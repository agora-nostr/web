const ct=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;function qt(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function Mt(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function ot(t,...e){if(!qt(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function de(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");Mt(t.outputLen),Mt(t.blockLen)}function vt(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function je(t,e){ot(t);const r=e.outputLen;if(t.length<r)throw new Error("digestInto() expects output buffer of length at least "+r)}function St(...t){for(let e=0;e<t.length;e++)t[e].fill(0)}function Lt(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function z(t,e){return t<<32-e|t>>>e}const he=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",ze=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function ft(t){if(ot(t),he)return t.toHex();let e="";for(let r=0;r<t.length;r++)e+=ze[t[r]];return e}const D={_0:48,_9:57,A:65,F:70,a:97,f:102};function ee(t){if(t>=D._0&&t<=D._9)return t-D._0;if(t>=D.A&&t<=D.F)return t-(D.A-10);if(t>=D.a&&t<=D.f)return t-(D.a-10)}function At(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);if(he)return Uint8Array.fromHex(t);const e=t.length,r=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(r);for(let o=0,s=0;o<r;o++,s+=2){const i=ee(t.charCodeAt(s)),c=ee(t.charCodeAt(s+1));if(i===void 0||c===void 0){const f=t[s]+t[s+1];throw new Error('hex string expected, got non-hex character "'+f+'" at index '+s)}n[o]=i*16+c}return n}function ge(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}function Gt(t){return typeof t=="string"&&(t=ge(t)),ot(t),t}function Y(...t){let e=0;for(let n=0;n<t.length;n++){const o=t[n];ot(o),e+=o.length}const r=new Uint8Array(e);for(let n=0,o=0;n<t.length;n++){const s=t[n];r.set(s,o),o+=s.length}return r}class we{}function Ye(t){const e=n=>t().update(Gt(n)).digest(),r=t();return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=()=>t(),e}function Rt(t=32){if(ct&&typeof ct.getRandomValues=="function")return ct.getRandomValues(new Uint8Array(t));if(ct&&typeof ct.randomBytes=="function")return Uint8Array.from(ct.randomBytes(t));throw new Error("crypto.getRandomValues must be defined")}function De(t,e,r,n){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,r,n);const o=BigInt(32),s=BigInt(4294967295),i=Number(r>>o&s),c=Number(r&s),f=n?4:0,g=n?0:4;t.setUint32(e+f,i,n),t.setUint32(e+g,c,n)}function Ge(t,e,r){return t&e^~t&r}function Xe(t,e,r){return t&e^t&r^e&r}class Fe extends we{constructor(e,r,n,o){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=r,this.padOffset=n,this.isLE=o,this.buffer=new Uint8Array(e),this.view=Lt(this.buffer)}update(e){vt(this),e=Gt(e),ot(e);const{view:r,buffer:n,blockLen:o}=this,s=e.length;for(let i=0;i<s;){const c=Math.min(o-this.pos,s-i);if(c===o){const f=Lt(e);for(;o<=s-i;i+=o)this.process(f,i);continue}n.set(e.subarray(i,i+c),this.pos),this.pos+=c,i+=c,this.pos===o&&(this.process(r,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){vt(this),je(e,this),this.finished=!0;const{buffer:r,view:n,blockLen:o,isLE:s}=this;let{pos:i}=this;r[i++]=128,St(this.buffer.subarray(i)),this.padOffset>o-i&&(this.process(n,0),i=0);for(let b=i;b<o;b++)r[b]=0;De(n,o-8,BigInt(this.length*8),s),this.process(n,0);const c=Lt(e),f=this.outputLen;if(f%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const g=f/4,y=this.get();if(g>y.length)throw new Error("_sha2: outputLen bigger than state");for(let b=0;b<g;b++)c.setUint32(4*b,y[b],s)}digest(){const{buffer:e,outputLen:r}=this;this.digestInto(e);const n=e.slice(0,r);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:r,buffer:n,length:o,finished:s,destroyed:i,pos:c}=this;return e.destroyed=i,e.finished=s,e.length=o,e.pos=c,o%r&&e.buffer.set(n),e}clone(){return this._cloneInto()}}const P=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Pe=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),W=new Uint32Array(64);class We extends Fe{constructor(e=32){super(64,e,8,!1),this.A=P[0]|0,this.B=P[1]|0,this.C=P[2]|0,this.D=P[3]|0,this.E=P[4]|0,this.F=P[5]|0,this.G=P[6]|0,this.H=P[7]|0}get(){const{A:e,B:r,C:n,D:o,E:s,F:i,G:c,H:f}=this;return[e,r,n,o,s,i,c,f]}set(e,r,n,o,s,i,c,f){this.A=e|0,this.B=r|0,this.C=n|0,this.D=o|0,this.E=s|0,this.F=i|0,this.G=c|0,this.H=f|0}process(e,r){for(let b=0;b<16;b++,r+=4)W[b]=e.getUint32(r,!1);for(let b=16;b<64;b++){const a=W[b-15],l=W[b-2],p=z(a,7)^z(a,18)^a>>>3,B=z(l,17)^z(l,19)^l>>>10;W[b]=B+W[b-7]+p+W[b-16]|0}let{A:n,B:o,C:s,D:i,E:c,F:f,G:g,H:y}=this;for(let b=0;b<64;b++){const a=z(c,6)^z(c,11)^z(c,25),l=y+a+Ge(c,f,g)+Pe[b]+W[b]|0,B=(z(n,2)^z(n,13)^z(n,22))+Xe(n,o,s)|0;y=g,g=f,f=c,c=i+l|0,i=s,s=o,o=n,n=l+B|0}n=n+this.A|0,o=o+this.B|0,s=s+this.C|0,i=i+this.D|0,c=c+this.E|0,f=f+this.F|0,g=g+this.G|0,y=y+this.H|0,this.set(n,o,s,i,c,f,g,y)}roundClean(){St(W)}destroy(){this.set(0,0,0,0,0,0,0,0),St(this.buffer)}}const It=Ye(()=>new We);class ye extends we{constructor(e,r){super(),this.finished=!1,this.destroyed=!1,de(e);const n=Gt(r);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(n.length>o?e.create().update(n).digest():n);for(let i=0;i<s.length;i++)s[i]^=54;this.iHash.update(s),this.oHash=e.create();for(let i=0;i<s.length;i++)s[i]^=106;this.oHash.update(s),St(s)}update(e){return vt(this),this.iHash.update(e),this}digestInto(e){vt(this),ot(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:r,iHash:n,finished:o,destroyed:s,blockLen:i,outputLen:c}=this;return e=e,e.finished=o,e.destroyed=s,e.blockLen=i,e.outputLen=c,e.oHash=r._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const be=(t,e,r)=>new ye(t,e).update(r).digest();be.create=(t,e)=>new ye(t,e);const Xt=BigInt(0),$t=BigInt(1);function _t(t,e=""){if(typeof t!="boolean"){const r=e&&`"${e}"`;throw new Error(r+"expected boolean, got type="+typeof t)}return t}function tt(t,e,r=""){const n=qt(t),o=t?.length,s=e!==void 0;if(!n||s&&o!==e){const i=r&&`"${r}" `,c=s?` of length ${e}`:"",f=n?`length=${o}`:`type=${typeof t}`;throw new Error(i+"expected Uint8Array"+c+", got "+f)}return t}function xt(t){const e=t.toString(16);return e.length&1?"0"+e:e}function me(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?Xt:BigInt("0x"+t)}function dt(t){return me(ft(t))}function pe(t){return ot(t),me(ft(Uint8Array.from(t).reverse()))}function Ot(t,e){return At(t.toString(16).padStart(e*2,"0"))}function Ee(t,e){return Ot(t,e).reverse()}function V(t,e,r){let n;if(typeof e=="string")try{n=At(e)}catch(s){throw new Error(t+" must be hex string or Uint8Array, cause: "+s)}else if(qt(e))n=Uint8Array.from(e);else throw new Error(t+" must be hex string or Uint8Array");const o=n.length;if(typeof r=="number"&&o!==r)throw new Error(t+" of length "+r+" expected, got "+o);return n}const Zt=t=>typeof t=="bigint"&&Xt<=t;function jt(t,e,r){return Zt(t)&&Zt(e)&&Zt(r)&&e<=t&&t<r}function Qe(t,e,r,n){if(!jt(e,r,n))throw new Error("expected valid "+t+": "+r+" <= n < "+n+", got "+e)}function xe(t){let e;for(e=0;t>Xt;t>>=$t,e+=1);return e}const yt=t=>($t<<BigInt(t))-$t;function Je(t,e,r){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof r!="function")throw new Error("hmacFn must be a function");const n=l=>new Uint8Array(l),o=l=>Uint8Array.of(l);let s=n(t),i=n(t),c=0;const f=()=>{s.fill(1),i.fill(0),c=0},g=(...l)=>r(i,s,...l),y=(l=n(0))=>{i=g(o(0),l),s=g(),l.length!==0&&(i=g(o(1),l),s=g())},b=()=>{if(c++>=1e3)throw new Error("drbg: tried 1000 values");let l=0;const p=[];for(;l<e;){s=g();const B=s.slice();p.push(B),l+=s.length}return Y(...p)};return(l,p)=>{f(),y(l);let B;for(;!(B=p(b()));)y();return f(),B}}function Ft(t,e,r={}){if(!t||typeof t!="object")throw new Error("expected valid options object");function n(o,s,i){const c=t[o];if(i&&c===void 0)return;const f=typeof c;if(f!==s||c===null)throw new Error(`param "${o}" is invalid: expected ${s}, got ${f}`)}Object.entries(e).forEach(([o,s])=>n(o,s,!1)),Object.entries(r).forEach(([o,s])=>n(o,s,!0))}function ne(t){const e=new WeakMap;return(r,...n)=>{const o=e.get(r);if(o!==void 0)return o;const s=t(r,...n);return e.set(r,s),s}}const M=BigInt(0),K=BigInt(1),et=BigInt(2),Be=BigInt(3),ve=BigInt(4),Se=BigInt(5),tn=BigInt(7),Ae=BigInt(8),en=BigInt(9),Ie=BigInt(16);function j(t,e){const r=t%e;return r>=M?r:e+r}function $(t,e,r){let n=t;for(;e-- >M;)n*=n,n%=r;return n}function re(t,e){if(t===M)throw new Error("invert: expected non-zero number");if(e<=M)throw new Error("invert: expected positive modulus, got "+e);let r=j(t,e),n=e,o=M,s=K;for(;r!==M;){const c=n/r,f=n%r,g=o-s*c;n=r,r=f,o=s,s=g}if(n!==K)throw new Error("invert: does not exist");return j(o,e)}function Pt(t,e,r){if(!t.eql(t.sqr(e),r))throw new Error("Cannot find square root")}function _e(t,e){const r=(t.ORDER+K)/ve,n=t.pow(e,r);return Pt(t,n,e),n}function nn(t,e){const r=(t.ORDER-Se)/Ae,n=t.mul(e,et),o=t.pow(n,r),s=t.mul(e,o),i=t.mul(t.mul(s,et),o),c=t.mul(s,t.sub(i,t.ONE));return Pt(t,c,e),c}function rn(t){const e=bt(t),r=He(t),n=r(e,e.neg(e.ONE)),o=r(e,n),s=r(e,e.neg(n)),i=(t+tn)/Ie;return(c,f)=>{let g=c.pow(f,i),y=c.mul(g,n);const b=c.mul(g,o),a=c.mul(g,s),l=c.eql(c.sqr(y),f),p=c.eql(c.sqr(b),f);g=c.cmov(g,y,l),y=c.cmov(a,b,p);const B=c.eql(c.sqr(y),f),N=c.cmov(g,y,B);return Pt(c,N,f),N}}function He(t){if(t<Be)throw new Error("sqrt is not defined for small field");let e=t-K,r=0;for(;e%et===M;)e/=et,r++;let n=et;const o=bt(t);for(;oe(o,n)===1;)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(r===1)return _e;let s=o.pow(n,e);const i=(e+K)/et;return function(f,g){if(f.is0(g))return g;if(oe(f,g)!==1)throw new Error("Cannot find square root");let y=r,b=f.mul(f.ONE,s),a=f.pow(g,e),l=f.pow(g,i);for(;!f.eql(a,f.ONE);){if(f.is0(a))return f.ZERO;let p=1,B=f.sqr(a);for(;!f.eql(B,f.ONE);)if(p++,B=f.sqr(B),p===y)throw new Error("Cannot find square root");const N=K<<BigInt(y-p-1),O=f.pow(b,N);y=p,b=f.sqr(O),a=f.mul(a,b),l=f.mul(l,O)}return l}}function on(t){return t%ve===Be?_e:t%Ae===Se?nn:t%Ie===en?rn(t):He(t)}const sn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function cn(t){const e={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},r=sn.reduce((n,o)=>(n[o]="function",n),e);return Ft(t,r),t}function fn(t,e,r){if(r<M)throw new Error("invalid exponent, negatives unsupported");if(r===M)return t.ONE;if(r===K)return e;let n=t.ONE,o=e;for(;r>M;)r&K&&(n=t.mul(n,o)),o=t.sqr(o),r>>=K;return n}function Ne(t,e,r=!1){const n=new Array(e.length).fill(r?t.ZERO:void 0),o=e.reduce((i,c,f)=>t.is0(c)?i:(n[f]=i,t.mul(i,c)),t.ONE),s=t.inv(o);return e.reduceRight((i,c,f)=>t.is0(c)?i:(n[f]=t.mul(i,n[f]),t.mul(i,c)),s),n}function oe(t,e){const r=(t.ORDER-K)/et,n=t.pow(e,r),o=t.eql(n,t.ONE),s=t.eql(n,t.ZERO),i=t.eql(n,t.neg(t.ONE));if(!o&&!s&&!i)throw new Error("invalid Legendre symbol result");return o?1:s?0:-1}function Ue(t,e){e!==void 0&&Mt(e);const r=e!==void 0?e:t.toString(2).length,n=Math.ceil(r/8);return{nBitLength:r,nByteLength:n}}function bt(t,e,r=!1,n={}){if(t<=M)throw new Error("invalid field: expected ORDER > 0, got "+t);let o,s,i=!1,c;if(typeof e=="object"&&e!=null){if(n.sqrt||r)throw new Error("cannot specify opts in two arguments");const a=e;a.BITS&&(o=a.BITS),a.sqrt&&(s=a.sqrt),typeof a.isLE=="boolean"&&(r=a.isLE),typeof a.modFromBytes=="boolean"&&(i=a.modFromBytes),c=a.allowedLengths}else typeof e=="number"&&(o=e),n.sqrt&&(s=n.sqrt);const{nBitLength:f,nByteLength:g}=Ue(t,o);if(g>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let y;const b=Object.freeze({ORDER:t,isLE:r,BITS:f,BYTES:g,MASK:yt(f),ZERO:M,ONE:K,allowedLengths:c,create:a=>j(a,t),isValid:a=>{if(typeof a!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof a);return M<=a&&a<t},is0:a=>a===M,isValidNot0:a=>!b.is0(a)&&b.isValid(a),isOdd:a=>(a&K)===K,neg:a=>j(-a,t),eql:(a,l)=>a===l,sqr:a=>j(a*a,t),add:(a,l)=>j(a+l,t),sub:(a,l)=>j(a-l,t),mul:(a,l)=>j(a*l,t),pow:(a,l)=>fn(b,a,l),div:(a,l)=>j(a*re(l,t),t),sqrN:a=>a*a,addN:(a,l)=>a+l,subN:(a,l)=>a-l,mulN:(a,l)=>a*l,inv:a=>re(a,t),sqrt:s||(a=>(y||(y=on(t)),y(b,a))),toBytes:a=>r?Ee(a,g):Ot(a,g),fromBytes:(a,l=!0)=>{if(c){if(!c.includes(a.length)||a.length>g)throw new Error("Field.fromBytes: expected "+c+" bytes, got "+a.length);const B=new Uint8Array(g);B.set(a,r?0:B.length-a.length),a=B}if(a.length!==g)throw new Error("Field.fromBytes: expected "+g+" bytes, got "+a.length);let p=r?pe(a):dt(a);if(i&&(p=j(p,t)),!l&&!b.isValid(p))throw new Error("invalid field element: outside of range 0..ORDER");return p},invertBatch:a=>Ne(b,a),cmov:(a,l,p)=>p?l:a});return Object.freeze(b)}function qe(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function Re(t){const e=qe(t);return e+Math.ceil(e/2)}function Oe(t,e,r=!1){const n=t.length,o=qe(e),s=Re(e);if(n<16||n<s||n>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+n);const i=r?pe(t):dt(t),c=j(i,e-K)+K;return r?Ee(c,o):Ot(c,o)}const ut=BigInt(0),nt=BigInt(1);function Ht(t,e){const r=e.negate();return t?r:e}function Tt(t,e){const r=Ne(t.Fp,e.map(n=>n.Z));return e.map((n,o)=>t.fromAffine(n.toAffine(r[o])))}function Le(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+t)}function Vt(t,e){Le(t,e);const r=Math.ceil(e/t)+1,n=2**(t-1),o=2**t,s=yt(t),i=BigInt(t);return{windows:r,windowSize:n,mask:s,maxNumber:o,shiftBy:i}}function se(t,e,r){const{windowSize:n,mask:o,maxNumber:s,shiftBy:i}=r;let c=Number(t&o),f=t>>i;c>n&&(c-=s,f+=nt);const g=e*n,y=g+Math.abs(c)-1,b=c===0,a=c<0,l=e%2!==0;return{nextN:f,offset:y,isZero:b,isNeg:a,isNegF:l,offsetF:g}}function an(t,e){if(!Array.isArray(t))throw new Error("array expected");t.forEach((r,n)=>{if(!(r instanceof e))throw new Error("invalid point at index "+n)})}function un(t,e){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((r,n)=>{if(!e.isValid(r))throw new Error("invalid scalar at index "+n)})}const kt=new WeakMap,Ze=new WeakMap;function Kt(t){return Ze.get(t)||1}function ie(t){if(t!==ut)throw new Error("invalid wNAF")}class ln{constructor(e,r){this.BASE=e.BASE,this.ZERO=e.ZERO,this.Fn=e.Fn,this.bits=r}_unsafeLadder(e,r,n=this.ZERO){let o=e;for(;r>ut;)r&nt&&(n=n.add(o)),o=o.double(),r>>=nt;return n}precomputeWindow(e,r){const{windows:n,windowSize:o}=Vt(r,this.bits),s=[];let i=e,c=i;for(let f=0;f<n;f++){c=i,s.push(c);for(let g=1;g<o;g++)c=c.add(i),s.push(c);i=c.double()}return s}wNAF(e,r,n){if(!this.Fn.isValid(n))throw new Error("invalid scalar");let o=this.ZERO,s=this.BASE;const i=Vt(e,this.bits);for(let c=0;c<i.windows;c++){const{nextN:f,offset:g,isZero:y,isNeg:b,isNegF:a,offsetF:l}=se(n,c,i);n=f,y?s=s.add(Ht(a,r[l])):o=o.add(Ht(b,r[g]))}return ie(n),{p:o,f:s}}wNAFUnsafe(e,r,n,o=this.ZERO){const s=Vt(e,this.bits);for(let i=0;i<s.windows&&n!==ut;i++){const{nextN:c,offset:f,isZero:g,isNeg:y}=se(n,i,s);if(n=c,!g){const b=r[f];o=o.add(y?b.negate():b)}}return ie(n),o}getPrecomputes(e,r,n){let o=kt.get(r);return o||(o=this.precomputeWindow(r,e),e!==1&&(typeof n=="function"&&(o=n(o)),kt.set(r,o))),o}cached(e,r,n){const o=Kt(e);return this.wNAF(o,this.getPrecomputes(o,e,n),r)}unsafe(e,r,n,o){const s=Kt(e);return s===1?this._unsafeLadder(e,r,o):this.wNAFUnsafe(s,this.getPrecomputes(s,e,n),r,o)}createCache(e,r){Le(r,this.bits),Ze.set(e,r),kt.delete(e)}hasCache(e){return Kt(e)!==1}}function dn(t,e,r,n){let o=e,s=t.ZERO,i=t.ZERO;for(;r>ut||n>ut;)r&nt&&(s=s.add(o)),n&nt&&(i=i.add(o)),o=o.double(),r>>=nt,n>>=nt;return{p1:s,p2:i}}function hn(t,e,r,n){an(r,t),un(n,e);const o=r.length,s=n.length;if(o!==s)throw new Error("arrays of points and scalars must have equal length");const i=t.ZERO,c=xe(BigInt(o));let f=1;c>12?f=c-3:c>4?f=c-2:c>0&&(f=2);const g=yt(f),y=new Array(Number(g)+1).fill(i),b=Math.floor((e.BITS-1)/f)*f;let a=i;for(let l=b;l>=0;l-=f){y.fill(i);for(let B=0;B<s;B++){const N=n[B],O=Number(N>>BigInt(l)&g);y[O]=y[O].add(r[B])}let p=i;for(let B=y.length-1,N=i;B>0;B--)N=N.add(y[B]),p=p.add(N);if(a=a.add(p),l!==0)for(let B=0;B<f;B++)a=a.double()}return a}function ce(t,e,r){if(e){if(e.ORDER!==t)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return cn(e),e}else return bt(t,{isLE:r})}function gn(t,e,r={},n){if(n===void 0&&(n=t==="edwards"),!e||typeof e!="object")throw new Error(`expected valid ${t} CURVE object`);for(const f of["p","n","h"]){const g=e[f];if(!(typeof g=="bigint"&&g>ut))throw new Error(`CURVE.${f} must be positive bigint`)}const o=ce(e.p,r.Fp,n),s=ce(e.n,r.Fn,n),c=["Gx","Gy","a","b"];for(const f of c)if(!o.isValid(e[f]))throw new Error(`CURVE.${f} must be valid field element of CURVE.Fp`);return e=Object.freeze(Object.assign({},e)),{CURVE:e,Fp:o,Fn:s}}const fe=(t,e)=>(t+(t>=0?e:-e)/Te)/e;function wn(t,e,r){const[[n,o],[s,i]]=e,c=fe(i*t,r),f=fe(-o*t,r);let g=t-c*n-f*s,y=-c*o-f*i;const b=g<X,a=y<X;b&&(g=-g),a&&(y=-y);const l=yt(Math.ceil(xe(r)/2))+at;if(g<X||g>=l||y<X||y>=l)throw new Error("splitScalar (endomorphism): failed, k="+t);return{k1neg:b,k1:g,k2neg:a,k2:y}}function zt(t){if(!["compact","recovered","der"].includes(t))throw new Error('Signature format must be "compact", "recovered", or "der"');return t}function Ct(t,e){const r={};for(let n of Object.keys(e))r[n]=t[n]===void 0?e[n]:t[n];return _t(r.lowS,"lowS"),_t(r.prehash,"prehash"),r.format!==void 0&&zt(r.format),r}class yn extends Error{constructor(e=""){super(e)}}const G={Err:yn,_tlv:{encode:(t,e)=>{const{Err:r}=G;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(e.length&1)throw new r("tlv.encode: unpadded data");const n=e.length/2,o=xt(n);if(o.length/2&128)throw new r("tlv.encode: long form length too big");const s=n>127?xt(o.length/2|128):"";return xt(t)+s+o+e},decode(t,e){const{Err:r}=G;let n=0;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(e.length<2||e[n++]!==t)throw new r("tlv.decode: wrong tlv");const o=e[n++],s=!!(o&128);let i=0;if(!s)i=o;else{const f=o&127;if(!f)throw new r("tlv.decode(long): indefinite length not supported");if(f>4)throw new r("tlv.decode(long): byte length is too big");const g=e.subarray(n,n+f);if(g.length!==f)throw new r("tlv.decode: length bytes not complete");if(g[0]===0)throw new r("tlv.decode(long): zero leftmost byte");for(const y of g)i=i<<8|y;if(n+=f,i<128)throw new r("tlv.decode(long): not minimal encoding")}const c=e.subarray(n,n+i);if(c.length!==i)throw new r("tlv.decode: wrong value length");return{v:c,l:e.subarray(n+i)}}},_int:{encode(t){const{Err:e}=G;if(t<X)throw new e("integer: negative integers are not allowed");let r=xt(t);if(Number.parseInt(r[0],16)&8&&(r="00"+r),r.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return r},decode(t){const{Err:e}=G;if(t[0]&128)throw new e("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return dt(t)}},toSig(t){const{Err:e,_int:r,_tlv:n}=G,o=V("signature",t),{v:s,l:i}=n.decode(48,o);if(i.length)throw new e("invalid signature: left bytes after parsing");const{v:c,l:f}=n.decode(2,s),{v:g,l:y}=n.decode(2,f);if(y.length)throw new e("invalid signature: left bytes after parsing");return{r:r.decode(c),s:r.decode(g)}},hexFromSig(t){const{_tlv:e,_int:r}=G,n=e.encode(2,r.encode(t.r)),o=e.encode(2,r.encode(t.s)),s=n+o;return e.encode(48,s)}},X=BigInt(0),at=BigInt(1),Te=BigInt(2),Bt=BigInt(3),bn=BigInt(4);function rt(t,e){const{BYTES:r}=t;let n;if(typeof e=="bigint")n=e;else{let o=V("private key",e);try{n=t.fromBytes(o)}catch{throw new Error(`invalid private key: expected ui8a of size ${r}, got ${typeof e}`)}}if(!t.isValidNot0(n))throw new Error("invalid private key: out of range [1..N-1]");return n}function mn(t,e={}){const r=gn("weierstrass",t,e),{Fp:n,Fn:o}=r;let s=r.CURVE;const{h:i,n:c}=s;Ft(e,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:f}=e;if(f&&(!n.is0(s.a)||typeof f.beta!="bigint"||!Array.isArray(f.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const g=ke(n,o);function y(){if(!n.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function b(H,h,d){const{x:u,y:w}=h.toAffine(),m=n.toBytes(u);if(_t(d,"isCompressed"),d){y();const v=!n.isOdd(w);return Y(Ve(v),m)}else return Y(Uint8Array.of(4),m,n.toBytes(w))}function a(H){tt(H,void 0,"Point");const{publicKey:h,publicKeyUncompressed:d}=g,u=H.length,w=H[0],m=H.subarray(1);if(u===h&&(w===2||w===3)){const v=n.fromBytes(m);if(!n.isValid(v))throw new Error("bad point: is not on curve, wrong x");const x=B(v);let E;try{E=n.sqrt(x)}catch(Z){const U=Z instanceof Error?": "+Z.message:"";throw new Error("bad point: is not on curve, sqrt error"+U)}y();const S=n.isOdd(E);return(w&1)===1!==S&&(E=n.neg(E)),{x:v,y:E}}else if(u===d&&w===4){const v=n.BYTES,x=n.fromBytes(m.subarray(0,v)),E=n.fromBytes(m.subarray(v,v*2));if(!N(x,E))throw new Error("bad point: is not on curve");return{x,y:E}}else throw new Error(`bad point: got length ${u}, expected compressed=${h} or uncompressed=${d}`)}const l=e.toBytes||b,p=e.fromBytes||a;function B(H){const h=n.sqr(H),d=n.mul(h,H);return n.add(n.add(d,n.mul(H,s.a)),s.b)}function N(H,h){const d=n.sqr(h),u=B(H);return n.eql(d,u)}if(!N(s.Gx,s.Gy))throw new Error("bad curve params: generator point");const O=n.mul(n.pow(s.a,Bt),bn),gt=n.mul(n.sqr(s.b),BigInt(27));if(n.is0(n.add(O,gt)))throw new Error("bad curve params: a or b");function L(H,h,d=!1){if(!n.isValid(h)||d&&n.is0(h))throw new Error(`bad point coordinate ${H}`);return h}function Q(H){if(!(H instanceof I))throw new Error("ProjectivePoint expected")}function F(H){if(!f||!f.basises)throw new Error("no endo");return wn(H,f.basises,o.ORDER)}const st=ne((H,h)=>{const{X:d,Y:u,Z:w}=H;if(n.eql(w,n.ONE))return{x:d,y:u};const m=H.is0();h==null&&(h=m?n.ONE:n.inv(w));const v=n.mul(d,h),x=n.mul(u,h),E=n.mul(w,h);if(m)return{x:n.ZERO,y:n.ZERO};if(!n.eql(E,n.ONE))throw new Error("invZ was invalid");return{x:v,y:x}}),mt=ne(H=>{if(H.is0()){if(e.allowInfinityPoint&&!n.is0(H.Y))return;throw new Error("bad point: ZERO")}const{x:h,y:d}=H.toAffine();if(!n.isValid(h)||!n.isValid(d))throw new Error("bad point: x or y not field elements");if(!N(h,d))throw new Error("bad point: equation left != right");if(!H.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function it(H,h,d,u,w){return d=new I(n.mul(d.X,H),d.Y,d.Z),h=Ht(u,h),d=Ht(w,d),h.add(d)}class I{constructor(h,d,u){this.X=L("x",h),this.Y=L("y",d,!0),this.Z=L("z",u),Object.freeze(this)}static CURVE(){return s}static fromAffine(h){const{x:d,y:u}=h||{};if(!h||!n.isValid(d)||!n.isValid(u))throw new Error("invalid affine point");if(h instanceof I)throw new Error("projective point not allowed");return n.is0(d)&&n.is0(u)?I.ZERO:new I(d,u,n.ONE)}static fromBytes(h){const d=I.fromAffine(p(tt(h,void 0,"point")));return d.assertValidity(),d}static fromHex(h){return I.fromBytes(V("pointHex",h))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(h=8,d=!0){return J.createCache(this,h),d||this.multiply(Bt),this}assertValidity(){mt(this)}hasEvenY(){const{y:h}=this.toAffine();if(!n.isOdd)throw new Error("Field doesn't support isOdd");return!n.isOdd(h)}equals(h){Q(h);const{X:d,Y:u,Z:w}=this,{X:m,Y:v,Z:x}=h,E=n.eql(n.mul(d,x),n.mul(m,w)),S=n.eql(n.mul(u,x),n.mul(v,w));return E&&S}negate(){return new I(this.X,n.neg(this.Y),this.Z)}double(){const{a:h,b:d}=s,u=n.mul(d,Bt),{X:w,Y:m,Z:v}=this;let x=n.ZERO,E=n.ZERO,S=n.ZERO,A=n.mul(w,w),Z=n.mul(m,m),U=n.mul(v,v),_=n.mul(w,m);return _=n.add(_,_),S=n.mul(w,v),S=n.add(S,S),x=n.mul(h,S),E=n.mul(u,U),E=n.add(x,E),x=n.sub(Z,E),E=n.add(Z,E),E=n.mul(x,E),x=n.mul(_,x),S=n.mul(u,S),U=n.mul(h,U),_=n.sub(A,U),_=n.mul(h,_),_=n.add(_,S),S=n.add(A,A),A=n.add(S,A),A=n.add(A,U),A=n.mul(A,_),E=n.add(E,A),U=n.mul(m,v),U=n.add(U,U),A=n.mul(U,_),x=n.sub(x,A),S=n.mul(U,Z),S=n.add(S,S),S=n.add(S,S),new I(x,E,S)}add(h){Q(h);const{X:d,Y:u,Z:w}=this,{X:m,Y:v,Z:x}=h;let E=n.ZERO,S=n.ZERO,A=n.ZERO;const Z=s.a,U=n.mul(s.b,Bt);let _=n.mul(d,m),q=n.mul(u,v),T=n.mul(w,x),C=n.add(d,u),R=n.add(m,v);C=n.mul(C,R),R=n.add(_,q),C=n.sub(C,R),R=n.add(d,w);let k=n.add(m,x);return R=n.mul(R,k),k=n.add(_,T),R=n.sub(R,k),k=n.add(u,w),E=n.add(v,x),k=n.mul(k,E),E=n.add(q,T),k=n.sub(k,E),A=n.mul(Z,R),E=n.mul(U,T),A=n.add(E,A),E=n.sub(q,A),A=n.add(q,A),S=n.mul(E,A),q=n.add(_,_),q=n.add(q,_),T=n.mul(Z,T),R=n.mul(U,R),q=n.add(q,T),T=n.sub(_,T),T=n.mul(Z,T),R=n.add(R,T),_=n.mul(q,R),S=n.add(S,_),_=n.mul(k,R),E=n.mul(C,E),E=n.sub(E,_),_=n.mul(C,q),A=n.mul(k,A),A=n.add(A,_),new I(E,S,A)}subtract(h){return this.add(h.negate())}is0(){return this.equals(I.ZERO)}multiply(h){const{endo:d}=e;if(!o.isValidNot0(h))throw new Error("invalid scalar: out of range");let u,w;const m=v=>J.cached(this,v,x=>Tt(I,x));if(d){const{k1neg:v,k1:x,k2neg:E,k2:S}=F(h),{p:A,f:Z}=m(x),{p:U,f:_}=m(S);w=Z.add(_),u=it(d.beta,A,U,v,E)}else{const{p:v,f:x}=m(h);u=v,w=x}return Tt(I,[u,w])[0]}multiplyUnsafe(h){const{endo:d}=e,u=this;if(!o.isValid(h))throw new Error("invalid scalar: out of range");if(h===X||u.is0())return I.ZERO;if(h===at)return u;if(J.hasCache(this))return this.multiply(h);if(d){const{k1neg:w,k1:m,k2neg:v,k2:x}=F(h),{p1:E,p2:S}=dn(I,u,m,x);return it(d.beta,E,S,w,v)}else return J.unsafe(u,h)}multiplyAndAddUnsafe(h,d,u){const w=this.multiplyUnsafe(d).add(h.multiplyUnsafe(u));return w.is0()?void 0:w}toAffine(h){return st(this,h)}isTorsionFree(){const{isTorsionFree:h}=e;return i===at?!0:h?h(I,this):J.unsafe(this,c).is0()}clearCofactor(){const{clearCofactor:h}=e;return i===at?this:h?h(I,this):this.multiplyUnsafe(i)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}toBytes(h=!0){return _t(h,"isCompressed"),this.assertValidity(),l(I,this,h)}toHex(h=!0){return ft(this.toBytes(h))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(h=!0){return this.toBytes(h)}_setWindowSize(h){this.precompute(h)}static normalizeZ(h){return Tt(I,h)}static msm(h,d){return hn(I,o,h,d)}static fromPrivateKey(h){return I.BASE.multiply(rt(o,h))}}I.BASE=new I(s.Gx,s.Gy,n.ONE),I.ZERO=new I(n.ZERO,n.ONE,n.ZERO),I.Fp=n,I.Fn=o;const pt=o.BITS,J=new ln(I,e.endo?Math.ceil(pt/2):pt);return I.BASE.precompute(8),I}function Ve(t){return Uint8Array.of(t?2:3)}function ke(t,e){return{secretKey:e.BYTES,publicKey:1+t.BYTES,publicKeyUncompressed:1+2*t.BYTES,publicKeyHasPrefix:!0,signature:2*e.BYTES}}function pn(t,e={}){const{Fn:r}=t,n=e.randomBytes||Rt,o=Object.assign(ke(t.Fp,r),{seed:Re(r.ORDER)});function s(l){try{return!!rt(r,l)}catch{return!1}}function i(l,p){const{publicKey:B,publicKeyUncompressed:N}=o;try{const O=l.length;return p===!0&&O!==B||p===!1&&O!==N?!1:!!t.fromBytes(l)}catch{return!1}}function c(l=n(o.seed)){return Oe(tt(l,o.seed,"seed"),r.ORDER)}function f(l,p=!0){return t.BASE.multiply(rt(r,l)).toBytes(p)}function g(l){const p=c(l);return{secretKey:p,publicKey:f(p)}}function y(l){if(typeof l=="bigint")return!1;if(l instanceof t)return!0;const{secretKey:p,publicKey:B,publicKeyUncompressed:N}=o;if(r.allowedLengths||p===B)return;const O=V("key",l).length;return O===B||O===N}function b(l,p,B=!0){if(y(l)===!0)throw new Error("first arg must be private key");if(y(p)===!1)throw new Error("second arg must be public key");const N=rt(r,l);return t.fromHex(p).multiply(N).toBytes(B)}return Object.freeze({getPublicKey:f,getSharedSecret:b,keygen:g,Point:t,utils:{isValidSecretKey:s,isValidPublicKey:i,randomSecretKey:c,isValidPrivateKey:s,randomPrivateKey:c,normPrivateKeyToScalar:l=>rt(r,l),precompute(l=8,p=t.BASE){return p.precompute(l,!1)}},lengths:o})}function En(t,e,r={}){de(e),Ft(r,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const n=r.randomBytes||Rt,o=r.hmac||((d,...u)=>be(e,d,Y(...u))),{Fp:s,Fn:i}=t,{ORDER:c,BITS:f}=i,{keygen:g,getPublicKey:y,getSharedSecret:b,utils:a,lengths:l}=pn(t,r),p={prehash:!1,lowS:typeof r.lowS=="boolean"?r.lowS:!1,format:void 0,extraEntropy:!1},B="compact";function N(d){const u=c>>at;return d>u}function O(d,u){if(!i.isValidNot0(u))throw new Error(`invalid signature ${d}: out of range 1..Point.Fn.ORDER`);return u}function gt(d,u){zt(u);const w=l.signature,m=u==="compact"?w:u==="recovered"?w+1:void 0;return tt(d,m,`${u} signature`)}class L{constructor(u,w,m){this.r=O("r",u),this.s=O("s",w),m!=null&&(this.recovery=m),Object.freeze(this)}static fromBytes(u,w=B){gt(u,w);let m;if(w==="der"){const{r:S,s:A}=G.toSig(tt(u));return new L(S,A)}w==="recovered"&&(m=u[0],w="compact",u=u.subarray(1));const v=i.BYTES,x=u.subarray(0,v),E=u.subarray(v,v*2);return new L(i.fromBytes(x),i.fromBytes(E),m)}static fromHex(u,w){return this.fromBytes(At(u),w)}addRecoveryBit(u){return new L(this.r,this.s,u)}recoverPublicKey(u){const w=s.ORDER,{r:m,s:v,recovery:x}=this;if(x==null||![0,1,2,3].includes(x))throw new Error("recovery id invalid");if(c*Te<w&&x>1)throw new Error("recovery id is ambiguous for h>1 curve");const S=x===2||x===3?m+c:m;if(!s.isValid(S))throw new Error("recovery id 2 or 3 invalid");const A=s.toBytes(S),Z=t.fromBytes(Y(Ve((x&1)===0),A)),U=i.inv(S),_=F(V("msgHash",u)),q=i.create(-_*U),T=i.create(v*U),C=t.BASE.multiplyUnsafe(q).add(Z.multiplyUnsafe(T));if(C.is0())throw new Error("point at infinify");return C.assertValidity(),C}hasHighS(){return N(this.s)}toBytes(u=B){if(zt(u),u==="der")return At(G.hexFromSig(this));const w=i.toBytes(this.r),m=i.toBytes(this.s);if(u==="recovered"){if(this.recovery==null)throw new Error("recovery bit must be present");return Y(Uint8Array.of(this.recovery),w,m)}return Y(w,m)}toHex(u){return ft(this.toBytes(u))}assertValidity(){}static fromCompact(u){return L.fromBytes(V("sig",u),"compact")}static fromDER(u){return L.fromBytes(V("sig",u),"der")}normalizeS(){return this.hasHighS()?new L(this.r,i.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return ft(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return ft(this.toBytes("compact"))}}const Q=r.bits2int||function(u){if(u.length>8192)throw new Error("input is too large");const w=dt(u),m=u.length*8-f;return m>0?w>>BigInt(m):w},F=r.bits2int_modN||function(u){return i.create(Q(u))},st=yt(f);function mt(d){return Qe("num < 2^"+f,d,X,st),i.toBytes(d)}function it(d,u){return tt(d,void 0,"message"),u?tt(e(d),void 0,"prehashed message"):d}function I(d,u,w){if(["recovered","canonical"].some(q=>q in w))throw new Error("sign() legacy options not supported");const{lowS:m,prehash:v,extraEntropy:x}=Ct(w,p);d=it(d,v);const E=F(d),S=rt(i,u),A=[mt(S),mt(E)];if(x!=null&&x!==!1){const q=x===!0?n(l.secretKey):x;A.push(V("extraEntropy",q))}const Z=Y(...A),U=E;function _(q){const T=Q(q);if(!i.isValidNot0(T))return;const C=i.inv(T),R=t.BASE.multiply(T).toAffine(),k=i.create(R.x);if(k===X)return;const Et=i.create(C*i.create(U+k*S));if(Et===X)return;let Jt=(R.x===k?0:2)|Number(R.y&at),te=Et;return m&&N(Et)&&(te=i.neg(Et),Jt^=1),new L(k,te,Jt)}return{seed:Z,k2sig:_}}function pt(d,u,w={}){d=V("message",d);const{seed:m,k2sig:v}=I(d,u,w);return Je(e.outputLen,i.BYTES,o)(m,v)}function J(d){let u;const w=typeof d=="string"||qt(d),m=!w&&d!==null&&typeof d=="object"&&typeof d.r=="bigint"&&typeof d.s=="bigint";if(!w&&!m)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(m)u=new L(d.r,d.s);else if(w){try{u=L.fromBytes(V("sig",d),"der")}catch(v){if(!(v instanceof G.Err))throw v}if(!u)try{u=L.fromBytes(V("sig",d),"compact")}catch{return!1}}return u||!1}function H(d,u,w,m={}){const{lowS:v,prehash:x,format:E}=Ct(m,p);if(w=V("publicKey",w),u=it(V("message",u),x),"strict"in m)throw new Error("options.strict was renamed to lowS");const S=E===void 0?J(d):L.fromBytes(V("sig",d),E);if(S===!1)return!1;try{const A=t.fromBytes(w);if(v&&S.hasHighS())return!1;const{r:Z,s:U}=S,_=F(u),q=i.inv(U),T=i.create(_*q),C=i.create(Z*q),R=t.BASE.multiplyUnsafe(T).add(A.multiplyUnsafe(C));return R.is0()?!1:i.create(R.x)===Z}catch{return!1}}function h(d,u,w={}){const{prehash:m}=Ct(w,p);return u=it(u,m),L.fromBytes(d,"recovered").recoverPublicKey(u).toBytes()}return Object.freeze({keygen:g,getPublicKey:y,getSharedSecret:b,utils:a,lengths:l,Point:t,sign:pt,verify:H,recoverPublicKey:h,Signature:L,hash:e})}function xn(t){const e={a:t.a,b:t.b,p:t.Fp.ORDER,n:t.n,h:t.h,Gx:t.Gx,Gy:t.Gy},r=t.Fp;let n=t.allowedPrivateKeyLengths?Array.from(new Set(t.allowedPrivateKeyLengths.map(i=>Math.ceil(i/2)))):void 0;const o=bt(e.n,{BITS:t.nBitLength,allowedLengths:n,modFromBytes:t.wrapPrivateKey}),s={Fp:r,Fn:o,allowInfinityPoint:t.allowInfinityPoint,endo:t.endo,isTorsionFree:t.isTorsionFree,clearCofactor:t.clearCofactor,fromBytes:t.fromBytes,toBytes:t.toBytes};return{CURVE:e,curveOpts:s}}function Bn(t){const{CURVE:e,curveOpts:r}=xn(t),n={hmac:t.hmac,randomBytes:t.randomBytes,lowS:t.lowS,bits2int:t.bits2int,bits2int_modN:t.bits2int_modN};return{CURVE:e,curveOpts:r,hash:t.hash,ecdsaOpts:n}}function vn(t,e){const r=e.Point;return Object.assign({},e,{ProjectivePoint:r,CURVE:Object.assign({},t,Ue(r.Fn.ORDER,r.Fn.BITS))})}function Sn(t){const{CURVE:e,curveOpts:r,hash:n,ecdsaOpts:o}=Bn(t),s=mn(e,r),i=En(s,n,o);return vn(t,i)}function An(t,e){const r=n=>Sn({...t,hash:n});return{...r(e),create:r}}const lt={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},In={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},_n=BigInt(0),ae=BigInt(1),Yt=BigInt(2);function Hn(t){const e=lt.p,r=BigInt(3),n=BigInt(6),o=BigInt(11),s=BigInt(22),i=BigInt(23),c=BigInt(44),f=BigInt(88),g=t*t*t%e,y=g*g*t%e,b=$(y,r,e)*y%e,a=$(b,r,e)*y%e,l=$(a,Yt,e)*g%e,p=$(l,o,e)*l%e,B=$(p,s,e)*p%e,N=$(B,c,e)*B%e,O=$(N,f,e)*N%e,gt=$(O,c,e)*B%e,L=$(gt,r,e)*y%e,Q=$(L,i,e)*p%e,F=$(Q,n,e)*g%e,st=$(F,Yt,e);if(!Nt.eql(Nt.sqr(st),t))throw new Error("Cannot find square root");return st}const Nt=bt(lt.p,{sqrt:Hn}),Ke=An({...lt,Fp:Nt,lowS:!0,endo:In},It),ue={};function Ut(t,...e){let r=ue[t];if(r===void 0){const n=It(ge(t));r=Y(n,n),ue[t]=r}return It(Y(r,...e))}const Wt=t=>t.toBytes(!0).slice(1),ht=Ke.Point,Qt=t=>t%Yt===_n;function Dt(t){const{Fn:e,BASE:r}=ht,n=rt(e,t),o=r.multiply(n);return{scalar:Qt(o.y)?n:e.neg(n),bytes:Wt(o)}}function Ce(t){const e=Nt;if(!e.isValidNot0(t))throw new Error("invalid x: Fail if x â‰¥ p");const r=e.create(t*t),n=e.create(r*t+BigInt(7));let o=e.sqrt(n);Qt(o)||(o=e.neg(o));const s=ht.fromAffine({x:t,y:o});return s.assertValidity(),s}const wt=dt;function Me(...t){return ht.Fn.create(wt(Ut("BIP0340/challenge",...t)))}function le(t){return Dt(t).bytes}function Nn(t,e,r=Rt(32)){const{Fn:n}=ht,o=V("message",t),{bytes:s,scalar:i}=Dt(e),c=V("auxRand",r,32),f=n.toBytes(i^wt(Ut("BIP0340/aux",c))),g=Ut("BIP0340/nonce",f,s,o),{bytes:y,scalar:b}=Dt(g),a=Me(y,s,o),l=new Uint8Array(64);if(l.set(y,0),l.set(n.toBytes(n.create(b+a*i)),32),!$e(l,o,s))throw new Error("sign: Invalid signature produced");return l}function $e(t,e,r){const{Fn:n,BASE:o}=ht,s=V("signature",t,64),i=V("message",e),c=V("publicKey",r,32);try{const f=Ce(wt(c)),g=wt(s.subarray(0,32));if(!jt(g,ae,lt.p))return!1;const y=wt(s.subarray(32,64));if(!jt(y,ae,lt.n))return!1;const b=Me(n.toBytes(g),Wt(f),i),a=o.multiplyUnsafe(y).add(f.multiplyUnsafe(n.neg(b))),{x:l,y:p}=a.toAffine();return!(a.is0()||!Qt(p)||l!==g)}catch{return!1}}const Un=(()=>{const r=(o=Rt(48))=>Oe(o,lt.n);Ke.utils.randomSecretKey;function n(o){const s=r(o);return{secretKey:s,publicKey:le(s)}}return{keygen:n,getPublicKey:le,sign:Nn,verify:$e,Point:ht,utils:{randomSecretKey:r,randomPrivateKey:r,taggedHash:Ut,lift_x:Ce,pointToBytes:Wt,numberToBytesBE:Ot,bytesToNumberBE:dt,mod:j},lengths:{secretKey:32,publicKey:32,publicKeyHasPrefix:!1,signature:64,seed:48}}})(),qn=It;globalThis.onmessage=t=>{const{serialized:e,id:r,sig:n,pubkey:o}=t.data;queueMicrotask(()=>{const s=qn(new TextEncoder().encode(e)),i=new Uint8Array(r.match(/.{1,2}/g).map(c=>parseInt(c,16)));if(!Rn(s,i)){postMessage([r,!1]);return}try{const c=Un.verify(n,s,o);postMessage([r,c])}catch(c){console.error("Signature verification error:",c),postMessage([r,!1])}})};function Rn(t,e){if(t.length!==e.length)return!1;for(let r=0;r<t.length;r++)if(t[r]!==e[r])return!1;return!0}
