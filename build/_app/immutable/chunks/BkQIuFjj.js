import{b as S,K as B,g as D,s as U}from"./Bq750rDx.js";import{t as $,u as H,v as A,w as E,x as y,h as N,N as M,f as L,y as G,z as q,n as w}from"./CdRP5_sk.js";var x={exports:{}},K;function J(){return K||(K=1,(function(e){var t=Object.prototype.hasOwnProperty,s="~";function n(){}Object.create&&(n.prototype=Object.create(null),new n().__proto__||(s=!1));function i(u,a,o){this.fn=u,this.context=a,this.once=o||!1}function c(u,a,o,l,f){if(typeof o!="function")throw new TypeError("The listener must be a function");var p=new i(o,l||u,f),h=s?s+a:a;return u._events[h]?u._events[h].fn?u._events[h]=[u._events[h],p]:u._events[h].push(p):(u._events[h]=p,u._eventsCount++),u}function C(u,a){--u._eventsCount===0?u._events=new n:delete u._events[a]}function d(){this._events=new n,this._eventsCount=0}d.prototype.eventNames=function(){var a=[],o,l;if(this._eventsCount===0)return a;for(l in o=this._events)t.call(o,l)&&a.push(s?l.slice(1):l);return Object.getOwnPropertySymbols?a.concat(Object.getOwnPropertySymbols(o)):a},d.prototype.listeners=function(a){var o=s?s+a:a,l=this._events[o];if(!l)return[];if(l.fn)return[l.fn];for(var f=0,p=l.length,h=new Array(p);f<p;f++)h[f]=l[f].fn;return h},d.prototype.listenerCount=function(a){var o=s?s+a:a,l=this._events[o];return l?l.fn?1:l.length:0},d.prototype.emit=function(a,o,l,f,p,h){var m=s?s+a:a;if(!this._events[m])return!1;var r=this._events[m],v=arguments.length,b,g;if(r.fn){switch(r.once&&this.removeListener(a,r.fn,void 0,!0),v){case 1:return r.fn.call(r.context),!0;case 2:return r.fn.call(r.context,o),!0;case 3:return r.fn.call(r.context,o,l),!0;case 4:return r.fn.call(r.context,o,l,f),!0;case 5:return r.fn.call(r.context,o,l,f,p),!0;case 6:return r.fn.call(r.context,o,l,f,p,h),!0}for(g=1,b=new Array(v-1);g<v;g++)b[g-1]=arguments[g];r.fn.apply(r.context,b)}else{var j=r.length,_;for(g=0;g<j;g++)switch(r[g].once&&this.removeListener(a,r[g].fn,void 0,!0),v){case 1:r[g].fn.call(r[g].context);break;case 2:r[g].fn.call(r[g].context,o);break;case 3:r[g].fn.call(r[g].context,o,l);break;case 4:r[g].fn.call(r[g].context,o,l,f);break;default:if(!b)for(_=1,b=new Array(v-1);_<v;_++)b[_-1]=arguments[_];r[g].fn.apply(r[g].context,b)}}return!0},d.prototype.on=function(a,o,l){return c(this,a,o,l,!1)},d.prototype.once=function(a,o,l){return c(this,a,o,l,!0)},d.prototype.removeListener=function(a,o,l,f){var p=s?s+a:a;if(!this._events[p])return this;if(!o)return C(this,p),this;var h=this._events[p];if(h.fn)h.fn===o&&(!f||h.once)&&(!l||h.context===l)&&C(this,p);else{for(var m=0,r=[],v=h.length;m<v;m++)(h[m].fn!==o||f&&!h[m].once||l&&h[m].context!==l)&&r.push(h[m]);r.length?this._events[p]=r.length===1?r[0]:r:C(this,p)}return this},d.prototype.removeAllListeners=function(a){var o;return a?(o=s?s+a:a,this._events[o]&&C(this,o)):(this._events=new n,this._eventsCount=0),this},d.prototype.off=d.prototype.removeListener,d.prototype.addListener=d.prototype.on,d.prefixed=s,d.EventEmitter=d,e.exports=d})(x)),x.exports}var W=J();const O=$(W);var k=Symbol("verified"),Q=e=>e instanceof Object;function V(e){if(!Q(e)||typeof e.kind!="number"||typeof e.content!="string"||typeof e.created_at!="number"||typeof e.pubkey!="string"||!e.pubkey.match(/^[a-f0-9]{64}$/)||!Array.isArray(e.tags))return!1;for(let t=0;t<e.tags.length;t++){let s=e.tags[t];if(!Array.isArray(s))return!1;for(let n=0;n<s.length;n++)if(typeof s[n]!="string")return!1}return!0}new TextDecoder("utf-8");var X=new TextEncoder,Y=class{generateSecretKey(){return E.utils.randomPrivateKey()}getPublicKey(e){return A(E.getPublicKey(e))}finalizeEvent(e,t){const s=e;return s.pubkey=A(E.getPublicKey(t)),s.id=I(s),s.sig=A(E.sign(I(s),t)),s[k]=!0,s}verifyEvent(e){if(typeof e[k]=="boolean")return e[k];const t=I(e);if(t!==e.id)return e[k]=!1,!1;try{const s=E.verify(e.sig,t,e.pubkey);return e[k]=s,s}catch{return e[k]=!1,!1}}};function Z(e){if(!V(e))throw new Error("can't serialize event with wrong or missing properties");return JSON.stringify([0,e.pubkey,e.created_at,e.kind,e.tags,e.content])}function I(e){let t=H(X.encode(Z(e)));return A(t)}var R=new Y;R.generateSecretKey;R.getPublicKey;R.finalizeEvent;R.verifyEvent;var P={namespace:"messages",version:1,collections:{messages:{primaryKey:"id",indexes:["conversationId","timestamp","sender","recipient"],compoundIndexes:[["conversationId","timestamp"],["recipient","read"]],schema:{id:"string",content:"string",sender:"string",recipient:"string?",timestamp:"number",protocol:"string",read:"boolean",rumor:"object?",conversationId:"string"}},conversations:{primaryKey:"id",indexes:["lastMessageAt"],compoundIndexes:[["participants"]],schema:{id:"string",participants:"string[]",name:"string?",avatar:"string?",lastMessageAt:"number?",unreadCount:"number",protocol:"string",metadata:"object?"}},mlsGroups:{primaryKey:"id",indexes:["createdAt"],schema:{id:"string",groupId:"string",epoch:"number",members:"string[]",createdAt:"number",updatedAt:"number",treeHash:"string",confirmedTranscriptHash:"string",interimTranscriptHash:"string",groupContext:"string"}},dmRelays:{primaryKey:"pubkey",indexes:["updatedAt"],schema:{pubkey:"string",relays:"string[]",updatedAt:"number"}}},migrations:{1:async e=>{await e.createCollection("messages",P.collections.messages),await e.createCollection("conversations",P.collections.conversations),await e.createCollection("mlsGroups",P.collections.mlsGroups),await e.createCollection("dmRelays",P.collections.dmRelays)}}},T=class extends O{id;participants;protocol;messages=[];storage;nip17;myPubkey;constructor(e,t,s,n,i,c){super(),this.id=e,this.participants=t,this.protocol=s,this.storage=n,this.myPubkey=i,this.nip17=c}async sendMessage(e){if(this.protocol==="nip17"&&this.nip17){const t=this.participants.find(s=>s.pubkey!==this.myPubkey);if(!t)throw new Error("No recipient found in conversation");try{const n={id:(await this.nip17.sendMessage(t,e)).id||"",content:e,sender:new y({pubkey:this.myPubkey}),recipient:t,timestamp:Math.floor(Date.now()/1e3),protocol:"nip17",read:!0,conversationId:this.id};return await this.storage.saveMessage(n),this.messages.push(n),this.emit("message",n),n}catch(s){const n={type:"send-failed",message:`Failed to send message: ${s}`,error:s};throw this.emit("error",n),s}}else throw new Error(`Protocol ${this.protocol} not supported yet`)}async getMessages(e){return this.messages.length===0&&(this.messages=await this.storage.getMessages(this.id,e)),e&&this.messages.length>e?this.messages.slice(-e):[...this.messages]}async markAsRead(){const e=this.messages.filter(t=>!t.read);if(e.length>0){const t=e.map(s=>s.id);await this.storage.markAsRead(t),e.forEach(s=>s.read=!0)}}getUnreadCount(){return this.messages.filter(e=>!e.read&&e.sender.pubkey!==this.myPubkey).length}getOtherParticipant(){return this.participants.find(e=>e.pubkey!==this.myPubkey)}getLastMessage(){return this.messages[this.messages.length-1]}async _handleIncomingMessage(e){this.messages.find(s=>s.id===e.id)||(this.messages.push(e),this.messages.sort((s,n)=>s.timestamp-n.timestamp),await this.storage.saveMessage(e),this.emit("message",e))}_handleStateChange(e){this.emit("state-change",e)}_handleError(e){this.emit("error",e)}destroy(){this.removeAllListeners(),this.messages=[]}},ee=class{constructor(e,t){this.ndk=e,this.signer=t}async sendMessage(e,t){const s=await this.signer.user(),n=new L(this.ndk);n.kind=M.PrivateDirectMessage,n.content=t,n.created_at=Math.floor(Date.now()/1e3),n.pubkey=s.pubkey,n.tags=[["p",e.pubkey]];const i=await G(n,e,this.signer),c=await this.getRecipientDMRelays(e),C=await this.getUserDMRelays(s),d=[...new Set([...c,...C])];if(d.length>0){const u=N.fromRelayUrls(d,this.ndk);await i.publish(u)}else await i.publish();return i}async unwrapMessage(e){try{const t=await q(e,void 0,this.signer);return t.kind!==M.PrivateDirectMessage?null:t.rawEvent()}catch(t){return console.error("Failed to unwrap message:",t),null}}rumorToMessage(e,t){e.id||(e.id=I(e));const s=e.pubkey===t,n=s?e.tags.find(c=>c[0]==="p")?.[1]||"":e.pubkey,i=[t,n].sort().join(":");return{id:e.id,content:e.content||"",sender:new y({pubkey:e.pubkey}),recipient:s?new y({pubkey:n}):new y({pubkey:t}),timestamp:e.created_at||Math.floor(Date.now()/1e3),protocol:"nip17",read:s,rumor:e,conversationId:i}}async getRecipientDMRelays(e){try{const t=await this.ndk.fetchEvent({kinds:[M.DirectMessageReceiveRelayList],authors:[e.pubkey]});if(t){const n=t.getMatchingTags("relay").map(i=>i[1]);if(n.length>0)return n}const s=await this.ndk.fetchEvent({kinds:[10002],authors:[e.pubkey]});if(s){const n=s.getMatchingTags("r").map(i=>i[1]);if(n.length>0)return n.slice(0,3)}return[]}catch(t){return console.error("Failed to fetch recipient relays:",t),[]}}async getUserDMRelays(e){try{const t=await this.ndk.fetchEvent({kinds:[M.DirectMessageReceiveRelayList],authors:[e.pubkey]});if(t){const n=t.getMatchingTags("relay").map(i=>i[1]);if(n.length>0)return n}const s=await this.ndk.fetchEvent({kinds:[10002],authors:[e.pubkey]});if(s){const n=s.getMatchingTags("r").map(i=>i[1]);if(n.length>0)return n.slice(0,3)}return[]}catch(t){return console.error("Failed to fetch user relays:",t),[]}}async publishDMRelayList(e){const t=new L(this.ndk);return t.kind=M.DirectMessageReceiveRelayList,t.tags=e.map(s=>["relay",s]),t.created_at=Math.floor(Date.now()/1e3),await t.sign(this.signer),await t.publish(),t}},F=class{constructor(e,t){this.cache=e,this.myPubkey=t}messagesCollection;conversationsCollection;initialized=!1;async ensureInitialized(){this.initialized||(this.cache.registerModule&&await this.cache.registerModule(P),this.cache.getModuleCollection&&(this.messagesCollection=await this.cache.getModuleCollection("messages","messages"),this.conversationsCollection=await this.cache.getModuleCollection("messages","conversations")),this.initialized=!0)}async saveMessage(e){if(await this.ensureInitialized(),!this.messagesCollection)return;const t={id:e.id,content:e.content,sender:e.sender.pubkey,recipient:e.recipient?.pubkey,timestamp:e.timestamp,protocol:e.protocol,read:e.read,rumor:e.rumor,conversationId:e.conversationId};await this.messagesCollection.save(t),await this.updateConversationForMessage(e)}async updateConversationForMessage(e){if(!this.conversationsCollection)return;const t=await this.conversationsCollection.get(e.conversationId);if(t)t.lastMessageAt=e.timestamp,!e.read&&e.sender.pubkey!==this.myPubkey&&t.unreadCount++,await this.conversationsCollection.save(t);else{const s=[e.sender.pubkey];e.recipient&&s.push(e.recipient.pubkey);const n={id:e.conversationId,participants:[...new Set(s)],lastMessageAt:e.timestamp,unreadCount:!e.read&&e.sender.pubkey!==this.myPubkey?1:0,protocol:e.protocol};await this.conversationsCollection.save(n)}}async getMessages(e,t){if(await this.ensureInitialized(),!this.messagesCollection)return[];const s=await this.messagesCollection.findBy("conversationId",e);s.sort((i,c)=>i.timestamp-c.timestamp);let n=s;return t&&n.length>t&&(n=n.slice(-t)),n.map(i=>({id:i.id,content:i.content,sender:new y({pubkey:i.sender}),recipient:i.recipient?new y({pubkey:i.recipient}):void 0,timestamp:i.timestamp,protocol:i.protocol,read:i.read,rumor:i.rumor,conversationId:i.conversationId}))}async markAsRead(e){if(await this.ensureInitialized(),!(!this.messagesCollection||!this.conversationsCollection))for(const t of e){const s=await this.messagesCollection.get(t);if(s&&!s.read){s.read=!0,await this.messagesCollection.save(s);const n=await this.conversationsCollection.get(s.conversationId);n&&n.unreadCount>0&&(n.unreadCount--,await this.conversationsCollection.save(n))}}}async getConversations(e){if(await this.ensureInitialized(),!this.conversationsCollection)return[];const s=(await this.conversationsCollection.all()).filter(n=>n.participants.includes(e));return s.sort((n,i)=>(i.lastMessageAt||0)-(n.lastMessageAt||0)),s.map(n=>({id:n.id,participants:n.participants,name:n.name,avatar:n.avatar,lastMessageAt:n.lastMessageAt,unreadCount:n.unreadCount}))}async saveConversation(e){if(await this.ensureInitialized(),!this.conversationsCollection)return;const t={id:e.id,participants:e.participants,name:e.name,avatar:e.avatar,lastMessageAt:e.lastMessageAt,unreadCount:e.unreadCount,protocol:"nip17"};await this.conversationsCollection.save(t)}async deleteMessage(e){if(await this.ensureInitialized(),!this.messagesCollection)return;const t=await this.messagesCollection.get(e);if(t){if(!t.read&&this.conversationsCollection){const s=await this.conversationsCollection.get(t.conversationId);s&&s.unreadCount>0&&(s.unreadCount--,await this.conversationsCollection.save(s))}await this.messagesCollection.delete(e)}}async clear(){await this.ensureInitialized(),this.messagesCollection&&await this.messagesCollection.clear(),this.conversationsCollection&&await this.conversationsCollection.clear()}},z=class{messages=new Map;conversations=new Map;messagesByConversation=new Map;async saveMessage(e){this.messages.set(e.id,e),this.messagesByConversation.has(e.conversationId)||this.messagesByConversation.set(e.conversationId,new Set),this.messagesByConversation.get(e.conversationId).add(e.id);const t=this.conversations.get(e.conversationId);t&&(t.lastMessageAt=e.timestamp,e.read||t.unreadCount++)}async getMessages(e,t){const s=this.messagesByConversation.get(e);if(!s)return[];const n=[];for(const i of s){const c=this.messages.get(i);c&&n.push(c)}return n.sort((i,c)=>i.timestamp-c.timestamp),t&&n.length>t?n.slice(-t):n}async markAsRead(e){for(const t of e){const s=this.messages.get(t);if(s){const n=!s.read;if(s.read=!0,n){const i=this.conversations.get(s.conversationId);i&&i.unreadCount>0&&i.unreadCount--}}}}async getConversations(e){const t=[];for(const s of this.conversations.values())s.participants.includes(e)&&t.push({...s});return t.sort((s,n)=>(n.lastMessageAt||0)-(s.lastMessageAt||0)),t}async saveConversation(e){this.conversations.set(e.id,{...e})}async deleteMessage(e){const t=this.messages.get(e);if(t){const s=this.messagesByConversation.get(t.conversationId);if(s&&s.delete(e),!t.read){const n=this.conversations.get(t.conversationId);n&&n.unreadCount>0&&n.unreadCount--}this.messages.delete(e)}}async clear(){this.messages.clear(),this.conversations.clear(),this.messagesByConversation.clear()}async getMessage(e){return this.messages.get(e)}async hasMessage(e){return this.messages.has(e)}},te=class extends O{ndk;storage;nip17;conversations=new Map;subscription;myPubkey;started=!1;constructor(e,t){if(super(),this.ndk=e,!e.signer)throw new Error("NDK must have a signer configured");this.storage=t?.storage||new z,this.nip17=new ee(e,e.signer),t?.autoStart&&this.start().catch(console.error)}async start(){if(this.started)return;if(!this.ndk.signer)throw new Error("NDK signer not configured");const e=await this.ndk.signer.user();this.myPubkey=e.pubkey,this.storage instanceof z&&this.ndk.cacheAdapter?.registerModule&&(this.storage=new F(this.ndk.cacheAdapter,this.myPubkey)),await this.loadConversations(),await this.subscribeToMessages(),this.started=!0}stop(){this.subscription&&(this.subscription.stop(),this.subscription=void 0),this.started=!1}async sendMessage(e,t){return this.myPubkey||await this.start(),(await this.getConversation(e)).sendMessage(t)}async getConversation(e){this.myPubkey||await this.start();const t=[this.myPubkey,e.pubkey].sort().join(":");let s=this.conversations.get(t);if(s)return s;s=new T(t,[new y({pubkey:this.myPubkey}),e],"nip17",this.storage,this.myPubkey,this.nip17);const n={id:t,participants:[this.myPubkey,e.pubkey],protocol:"nip17",unreadCount:0};return await this.storage.saveConversation(n),this.conversations.set(t,s),s.on("message",i=>{this.emit("message",i)}),s.on("error",i=>{this.emit("error",i)}),s}async getConversations(){return this.myPubkey||await this.start(),await this.loadConversations(),Array.from(this.conversations.values())}async publishDMRelays(e){return this.nip17.publishDMRelayList(e)}async loadConversations(){if(!this.myPubkey)return;const e=await this.storage.getConversations(this.myPubkey);for(const t of e){if(this.conversations.has(t.id))continue;const s=t.participants.map(c=>new y({pubkey:c})),n=new T(t.id,s,t.protocol,this.storage,this.myPubkey,this.nip17),i=await this.storage.getMessages(t.id);for(const c of i)c.sender=new y({pubkey:c.sender.pubkey}),c.recipient&&(c.recipient=new y({pubkey:c.recipient.pubkey})),await n._handleIncomingMessage(c);this.conversations.set(t.id,n),n.on("message",c=>{this.emit("message",c)}),n.on("error",c=>{this.emit("error",c)})}}async subscribeToMessages(){if(!this.myPubkey||!this.ndk.signer)return;const e=await this.ndk.signer.user(),t=await this.nip17.getUserDMRelays(e),s={closeOnEose:!1};if(t.length>0){const n=N.fromRelayUrls(t,this.ndk);s.relaySet=n}this.subscription=this.ndk.subscribe({kinds:[M.GiftWrap],"#p":[this.myPubkey]},{...s,onEvent:async n=>{await this.handleIncomingMessage(n)},onEose:()=>{console.log("Messages subscription active")}})}async handleIncomingMessage(e){if(!(!this.myPubkey||!this.ndk.signer))try{const t=await this.nip17.unwrapMessage(e);if(!t)return;const s=this.nip17.rumorToMessage(t,this.myPubkey),n=s.sender.pubkey===this.myPubkey?s.recipient?.pubkey:s.sender.pubkey;if(!n)return;const i=new y({pubkey:n}),c=await this.getConversation(i);await c._handleIncomingMessage(s),this.emit("message",s),c.getMessages.length===1&&this.emit("conversation-created",c)}catch(t){const s={type:"decryption-failed",message:`Failed to decrypt message: ${t}`,error:t};this.emit("error",s)}}destroy(){this.stop(),this.conversations.forEach(e=>e.destroy()),this.conversations.clear(),this.removeAllListeners()}};class se{messenger=null;#e=S(B([]));get _conversations(){return D(this.#e)}set _conversations(t){U(this.#e,t,!0)}#t=S(0);get _totalUnreadCount(){return D(this.#t)}set _totalUnreadCount(t){U(this.#t,t,!0)}isStarted=!1;async ensureStarted(){if(!this.isStarted&&w.$currentUser){this.isStarted=!0;const t=new F(w.cacheAdapter,w.$currentUser.pubkey);this.messenger=new te({ndk:w,storage:t}),this.messenger.on("message",s=>{this.refreshConversations()}),this.messenger.on("error",s=>{console.error("Messenger error:",s)}),await this.messenger.start(),await this.refreshConversations()}}async refreshConversations(){if(this.messenger)try{this._conversations=await this.messenger.getConversations(),this._totalUnreadCount=this._conversations.reduce((t,s)=>t+s.getUnreadCount(),0)}catch(t){console.error("Failed to refresh conversations:",t)}}async stop(){this.messenger&&(this.messenger.destroy(),this.messenger=null,this.isStarted=!1,this._conversations=[],this._totalUnreadCount=0)}async getConversation(t){if(await this.ensureStarted(),!this.messenger)return null;const s=w.getUser({npub:t});return await this.messenger.getConversation(s)}async sendMessage(t,s){if(await this.ensureStarted(),!this.messenger)return null;const n=w.getUser({npub:t}),i=await this.messenger.sendMessage(n,s);return await this.refreshConversations(),i}async markConversationAsRead(t){const s=this._conversations.find(n=>n.id===t);s&&(await s.markAsRead(),this._totalUnreadCount=this._conversations.reduce((n,i)=>n+i.getUnreadCount(),0))}get conversations(){return w.$currentUser&&this.ensureStarted(),[...this._conversations].sort((t,s)=>{const n=t.getLastMessage()?.timestamp||0;return(s.getLastMessage()?.timestamp||0)-n})}get totalUnreadCount(){return w.$currentUser&&this.ensureStarted(),this._totalUnreadCount}getMessenger(){return this.messenger}}const re=new se;export{re as m};
