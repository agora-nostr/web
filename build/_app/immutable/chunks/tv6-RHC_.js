import{_ as __vitePreload}from"./PPVm8Dsz.js";import{x as proxy,u as user_effect,g as get,a as user_derived,I as untrack,b as state,s as set,A as hasContext,B as getContext}from"./AsQG98fS.js";import{S as SvelteMap}from"./D2z4-Wxa.js";var define_process_env_default={},__create=Object.create,__getProtoOf=Object.getPrototypeOf,__defProp$2=Object.defineProperty,__getOwnPropNames$1=Object.getOwnPropertyNames,__hasOwnProp$1=Object.prototype.hasOwnProperty,__toESM=(n,t,r)=>{r=n!=null?__create(__getProtoOf(n)):{};const s=__defProp$2(r,"default",{value:n,enumerable:!0});for(let o of __getOwnPropNames$1(n))__hasOwnProp$1.call(s,o)||__defProp$2(s,o,{get:()=>n[o],enumerable:!0});return s},__commonJS=(n,t)=>()=>(t||n((t={exports:{}}).exports,t),t.exports),__export$1=(n,t)=>{for(var r in t)__defProp$2(n,r,{get:t[r],enumerable:!0,configurable:!0,set:s=>t[r]=()=>s})},require_types=__commonJS(n=>{Object.defineProperty(n,"__esModule",{value:!0})}),require_utils=__commonJS(n=>{Object.defineProperty(n,"__esModule",{value:!0}),n._fast_remove_single=void 0;function t(r,s){s!==-1&&(s===0?r.shift():s===r.length-1?r.length=r.length-1:r.splice(s,1))}n._fast_remove_single=t}),require_bake_collection=__commonJS((exports,module)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.bakeCollectionVariadic=exports.bakeCollectionAwait=exports.bakeCollection=exports.BAKED_EMPTY_FUNC=void 0,exports.BAKED_EMPTY_FUNC=function(){};var FORLOOP_FALLBACK=1500;function generateArgsDefCode(n){var t="";if(n===0)return t;for(var r=0;r<n-1;++r)t+="arg"+String(r)+", ";return t+="arg"+String(n-1),t}function generateBodyPartsCode(n,t){for(var r="",s="",o=0;o<t;++o)r+="var f".concat(o," = collection[").concat(o,`];
`),s+="f".concat(o,"(").concat(n,`)
`);return{funcDefCode:r,funcCallCode:s}}function generateBodyPartsVariadicCode(n){for(var t="",r="",s=0;s<n;++s)t+="var f".concat(s," = collection[").concat(s,`];
`),r+="f".concat(s,`.apply(undefined, arguments)
`);return{funcDefCode:t,funcCallCode:r}}function bakeCollection(collection,fixedArgsNum){if(collection.length===0)return exports.BAKED_EMPTY_FUNC;if(collection.length===1)return collection[0];var funcFactoryCode;if(collection.length<FORLOOP_FALLBACK){var argsDefCode=generateArgsDefCode(fixedArgsNum),_a=generateBodyPartsCode(argsDefCode,collection.length),funcDefCode=_a.funcDefCode,funcCallCode=_a.funcCallCode;funcFactoryCode=`(function(collection) {
            `.concat(funcDefCode,`
            collection = undefined;
            return (function(`).concat(argsDefCode,`) {
                `).concat(funcCallCode,`
            });
        })`)}else{var argsDefCode=generateArgsDefCode(fixedArgsNum);collection.length%10===0?funcFactoryCode=`(function(collection) {
                return (function(`.concat(argsDefCode,`) {
                    for (var i = 0; i < collection.length; i += 10) {
                        collection[i](`).concat(argsDefCode,`);
                        collection[i+1](`).concat(argsDefCode,`);
                        collection[i+2](`).concat(argsDefCode,`);
                        collection[i+3](`).concat(argsDefCode,`);
                        collection[i+4](`).concat(argsDefCode,`);
                        collection[i+5](`).concat(argsDefCode,`);
                        collection[i+6](`).concat(argsDefCode,`);
                        collection[i+7](`).concat(argsDefCode,`);
                        collection[i+8](`).concat(argsDefCode,`);
                        collection[i+9](`).concat(argsDefCode,`);
                    }
                });
            })`):collection.length%4===0?funcFactoryCode=`(function(collection) {
                return (function(`.concat(argsDefCode,`) {
                    for (var i = 0; i < collection.length; i += 4) {
                        collection[i](`).concat(argsDefCode,`);
                        collection[i+1](`).concat(argsDefCode,`);
                        collection[i+2](`).concat(argsDefCode,`);
                        collection[i+3](`).concat(argsDefCode,`);
                    }
                });
            })`):collection.length%3===0?funcFactoryCode=`(function(collection) {
                return (function(`.concat(argsDefCode,`) {
                    for (var i = 0; i < collection.length; i += 3) {
                        collection[i](`).concat(argsDefCode,`);
                        collection[i+1](`).concat(argsDefCode,`);
                        collection[i+2](`).concat(argsDefCode,`);
                    }
                });
            })`):funcFactoryCode=`(function(collection) {
                return (function(`.concat(argsDefCode,`) {
                    for (var i = 0; i < collection.length; ++i) {
                        collection[i](`).concat(argsDefCode,`);
                    }
                });
            })`)}{var funcFactory=eval(funcFactoryCode);return funcFactory(collection)}}exports.bakeCollection=bakeCollection;function bakeCollectionAwait(collection,fixedArgsNum){if(collection.length===0)return exports.BAKED_EMPTY_FUNC;if(collection.length===1)return collection[0];var funcFactoryCode;if(collection.length<FORLOOP_FALLBACK){var argsDefCode=generateArgsDefCode(fixedArgsNum),_a=generateBodyPartsCode(argsDefCode,collection.length),funcDefCode=_a.funcDefCode,funcCallCode=_a.funcCallCode;funcFactoryCode=`(function(collection) {
            `.concat(funcDefCode,`
            collection = undefined;
            return (function(`).concat(argsDefCode,`) {
                return Promise.all([ `).concat(funcCallCode,` ]);
            });
        })`)}else{var argsDefCode=generateArgsDefCode(fixedArgsNum);funcFactoryCode=`(function(collection) {
            return (function(`.concat(argsDefCode,`) {
                var promises = Array(collection.length);
                for (var i = 0; i < collection.length; ++i) {
                    promises[i] = collection[i](`).concat(argsDefCode,`);
                }
                return Promise.all(promises);
            });
        })`)}{var funcFactory=eval(funcFactoryCode);return funcFactory(collection)}}exports.bakeCollectionAwait=bakeCollectionAwait;function bakeCollectionVariadic(collection){if(collection.length===0)return exports.BAKED_EMPTY_FUNC;if(collection.length===1)return collection[0];var funcFactoryCode;if(collection.length<FORLOOP_FALLBACK){var _a=generateBodyPartsVariadicCode(collection.length),funcDefCode=_a.funcDefCode,funcCallCode=_a.funcCallCode;funcFactoryCode=`(function(collection) {
            `.concat(funcDefCode,`
            collection = undefined;
            return (function() {
                `).concat(funcCallCode,`
            });
        })`)}else funcFactoryCode=`(function(collection) {
            return (function() {
                for (var i = 0; i < collection.length; ++i) {
                    collection[i].apply(undefined, arguments);
                }
            });
        })`;{var funcFactory=eval(funcFactoryCode);return funcFactory(collection)}}exports.bakeCollectionVariadic=bakeCollectionVariadic}),require_task_collection=__commonJS(n=>{var t=n&&n.__spreadArray||function(ze,se,ne){if(ne||arguments.length===2)for(var X=0,$e=se.length,Ve;X<$e;X++)(Ve||!(X in se))&&(Ve||(Ve=Array.prototype.slice.call(se,0,X)),Ve[X]=se[X]);return ze.concat(Ve||Array.prototype.slice.call(se))};Object.defineProperty(n,"__esModule",{value:!0}),n.TaskCollection=void 0;var r=require_utils(),s=require_bake_collection();function o(ze,se){var ne=this.length;if(ne>1)if(se){var X;(X=this._tasks).push.apply(X,arguments),this.length+=arguments.length}else this._tasks.push(ze),this.length++;else if(se){if(ne===1){var $e=Array(1+arguments.length);$e.push($e),$e.push.apply($e,arguments),this._tasks=$e}else{var $e=Array(arguments.length);$e.push.apply($e,arguments),this._tasks=$e}this.length+=arguments.length}else ne===1?this._tasks=[this._tasks,ze]:this._tasks=ze,this.length++}function a(ze,se){var ne=this.length;if(ne>1)if(se){var X;(X=this._tasks).push.apply(X,arguments),this.length+=arguments.length}else this._tasks.push(ze),this.length++;else if(se){if(ne===1){var $e=Array(1+arguments.length);$e.push($e),$e.push.apply($e,arguments),this._tasks=$e}else{var $e=Array(arguments.length);$e.push.apply($e,arguments),this._tasks=$e}this.length+=arguments.length}else ne===1?this._tasks=[this._tasks,ze]:this._tasks=ze,this.length++;this.firstEmitBuildStrategy?this.call=_:this.rebuild()}function c(ze){this.length!==0&&(this.length===1?this._tasks===ze&&(this.length=0):((0,r._fast_remove_single)(this._tasks,this._tasks.lastIndexOf(ze)),this._tasks.length===1?(this._tasks=this._tasks[0],this.length=1):this.length=this._tasks.length))}function f(ze){if(this.length!==0){if(this.length===1)if(this._tasks===ze&&(this.length=0),this.firstEmitBuildStrategy){this.call=s.BAKED_EMPTY_FUNC;return}else{this.rebuild();return}else(0,r._fast_remove_single)(this._tasks,this._tasks.lastIndexOf(ze)),this._tasks.length===1?(this._tasks=this._tasks[0],this.length=1):this.length=this._tasks.length;this.firstEmitBuildStrategy?this.call=_:this.rebuild()}}function g(ze){for(var se,ne=[],X=1;X<arguments.length;X++)ne[X-1]=arguments[X];this.length===0?(this._tasks=ne,this.length=1):this.length===1?(ne.unshift(this._tasks),this._tasks=ne,this.length=this._tasks.length):((se=this._tasks).splice.apply(se,t([ze,0],ne,!1)),this.length=this._tasks.length)}function m(ze){for(var se,ne=[],X=1;X<arguments.length;X++)ne[X-1]=arguments[X];this.length===0?(this._tasks=ne,this.length=1):this.length===1?(ne.unshift(this._tasks),this._tasks=ne,this.length=this._tasks.length):((se=this._tasks).splice.apply(se,t([ze,0],ne,!1)),this.length=this._tasks.length),this.firstEmitBuildStrategy?this.call=_:this.rebuild()}function b(){this.length===0?this.call=s.BAKED_EMPTY_FUNC:this.length===1?this.call=this._tasks:this.call=(0,s.bakeCollection)(this._tasks,this.argsNum)}function k(){this.length===0?this.call=s.BAKED_EMPTY_FUNC:this.length===1?this.call=this._tasks:this.call=(0,s.bakeCollectionAwait)(this._tasks,this.argsNum)}function _(){this.rebuild(),this.call.apply(void 0,arguments)}var A=(function(){function ze(se,ne,X,$e){ne===void 0&&(ne=!0),X===void 0&&(X=null),$e===void 0&&($e=!1),this.awaitTasks=$e,this.call=s.BAKED_EMPTY_FUNC,this.argsNum=se,this.firstEmitBuildStrategy=!0,$e?this.rebuild=k.bind(this):this.rebuild=b.bind(this),this.setAutoRebuild(ne),X?typeof X=="function"?(this._tasks=X,this.length=1):(this._tasks=X,this.length=X.length):(this._tasks=null,this.length=0),ne&&this.rebuild()}return ze})();n.TaskCollection=A;function B(){this._tasks=null,this.length=0,this.call=s.BAKED_EMPTY_FUNC}function L(){this._tasks=null,this.length=0,this.call=s.BAKED_EMPTY_FUNC}function Z(ze){this.argsNum<ze&&(this.argsNum=ze,this.firstEmitBuildStrategy?this.call=_:this.rebuild())}function ve(ze){ze?(this.push=a.bind(this),this.insert=m.bind(this),this.removeLast=f.bind(this)):(this.push=o.bind(this),this.insert=g.bind(this),this.removeLast=c.bind(this))}function We(){return this.length===0?[]:this.length===1?[this._tasks]:this._tasks}function re(ze){ze.length===0?(this.length=0,this.call=s.BAKED_EMPTY_FUNC):ze.length===1?(this.length=1,this.call=ze[0],this._tasks=ze[0]):(this.length=ze.length,this._tasks=ze,this.firstEmitBuildStrategy?this.call=_:this.rebuild())}A.prototype.fastClear=B,A.prototype.clear=L,A.prototype.growArgsNum=Z,A.prototype.setAutoRebuild=ve,A.prototype.tasksAsArray=We,A.prototype.setTasks=re}),require_task_collection2=__commonJS(n=>{var t=n&&n.__createBinding||(Object.create?function(s,o,a,c){c===void 0&&(c=a);var f=Object.getOwnPropertyDescriptor(o,a);(!f||("get"in f?!o.__esModule:f.writable||f.configurable))&&(f={enumerable:!0,get:function(){return o[a]}}),Object.defineProperty(s,c,f)}:function(s,o,a,c){c===void 0&&(c=a),s[c]=o[a]}),r=n&&n.__exportStar||function(s,o){for(var a in s)a!=="default"&&!Object.prototype.hasOwnProperty.call(o,a)&&t(o,s,a)};Object.defineProperty(n,"__esModule",{value:!0}),r(require_task_collection(),n)}),require_utils2=__commonJS(n=>{Object.defineProperty(n,"__esModule",{value:!0}),n.nullObj=void 0;function t(){var r={};return r.__proto__=null,r}n.nullObj=t}),require_ee=__commonJS(n=>{var t=n&&n.__spreadArray||function(ne,X,$e){if($e||arguments.length===2)for(var Ve=0,Ze=X.length,He;Ve<Ze;Ve++)(He||!(Ve in X))&&(He||(He=Array.prototype.slice.call(X,0,Ve)),He[Ve]=X[Ve]);return ne.concat(He||Array.prototype.slice.call(X))};Object.defineProperty(n,"__esModule",{value:!0}),n.EventEmitter=void 0;var r=require_task_collection2(),s=require_utils(),o=require_utils2();function a(ne,X,$e,Ve,Ze,He){var Le=this.events[ne];if(Le){if(Le.length===0)return!1;if(Le.argsNum<6)Le.call(X,$e,Ve,Ze,He);else{for(var Q=new Array(Le.argsNum),oe=0,Y=Q.length;oe<Y;++oe)Q[oe]=arguments[oe+1];Le.call.apply(void 0,Q)}return!0}return!1}function c(ne,X,$e,Ve,Ze,He){var Le=this.events[ne],Q;if(Le!==void 0){if(Le.length===0)return!1;if(Le.argsNum<6)Le.call(X,$e,Ve,Ze,He);else{Q=new Array(Le.argsNum);for(var oe=0,Y=Q.length;oe<Y;++oe)Q[oe]=arguments[oe+1];Le.call.apply(void 0,Q)}}var Ce=this.onceEvents[ne];if(Ce){if(typeof Ce=="function")if(this.onceEvents[ne]=void 0,arguments.length<6)Ce(X,$e,Ve,Ze,He);else{if(Q===void 0){Q=new Array(arguments.length-1);for(var oe=0,Y=Q.length;oe<Y;++oe)Q[oe]=arguments[oe+1]}Ce.apply(void 0,Q)}else{var je=Ce;if(this.onceEvents[ne]=void 0,arguments.length<6)for(var oe=0;oe<je.length;++oe)je[oe](X,$e,Ve,Ze,He);else{if(Q===void 0){Q=new Array(arguments.length-1);for(var oe=0,Y=Q.length;oe<Y;++oe)Q[oe]=arguments[oe+1]}for(var oe=0;oe<je.length;++oe)je[oe].apply(void 0,Q)}}return!0}return Le!==void 0}var f=(function(){function ne(){this.events=(0,o.nullObj)(),this.onceEvents=(0,o.nullObj)(),this._symbolKeys=new Set,this.maxListeners=1/0}return Object.defineProperty(ne.prototype,"_eventsCount",{get:function(){return this.eventNames().length},enumerable:!1,configurable:!0}),ne})();n.EventEmitter=f;function g(ne,X){switch(this.emit===a&&(this.emit=c),typeof this.onceEvents[ne]){case"undefined":this.onceEvents[ne]=X,typeof ne=="symbol"&&this._symbolKeys.add(ne);break;case"function":this.onceEvents[ne]=[this.onceEvents[ne],X];break;case"object":this.onceEvents[ne].push(X)}return this}function m(ne,X,$e){if($e===void 0&&($e=X.length),typeof X!="function")throw new TypeError("The listener must be a function");var Ve=this.events[ne];return Ve?(Ve.push(X),Ve.growArgsNum($e),this.maxListeners!==1/0&&this.maxListeners<=Ve.length&&console.warn('Maximum event listeners for "'.concat(String(ne),'" event!'))):(this.events[ne]=new r.TaskCollection($e,!0,X,!1),typeof ne=="symbol"&&this._symbolKeys.add(ne)),this}function b(ne,X){var $e=this.events[ne];$e&&$e.removeLast(X);var Ve=this.onceEvents[ne];return Ve&&(typeof Ve=="function"?this.onceEvents[ne]=void 0:typeof Ve=="object"&&(Ve.length===1&&Ve[0]===X?this.onceEvents[ne]=void 0:(0,s._fast_remove_single)(Ve,Ve.lastIndexOf(X)))),this}function k(ne,X,$e,Ve){$e===void 0&&($e=this),Ve===void 0&&(Ve=X.length),this.boundFuncs||(this.boundFuncs=new Map);var Ze=X.bind($e);return this.boundFuncs.set(X,Ze),this.addListener(ne,Ze,Ve)}function _(ne,X){var $e,Ve,Ze=($e=this.boundFuncs)===null||$e===void 0?void 0:$e.get(X);return(Ve=this.boundFuncs)===null||Ve===void 0||Ve.delete(X),this.removeListener(ne,Ze)}function A(ne){return this.events[ne]&&!!this.events[ne].length}function B(ne,X,$e){if($e===void 0&&($e=X.length),typeof X!="function")throw new TypeError("The listener must be a function");var Ve=this.events[ne];return!Ve||!(Ve instanceof r.TaskCollection)?(Ve=this.events[ne]=new r.TaskCollection($e,!0,X,!1),typeof ne=="symbol"&&this._symbolKeys.add(ne)):(Ve.insert(0,X),Ve.growArgsNum($e),this.maxListeners!==1/0&&this.maxListeners<=Ve.length&&console.warn('Maximum event listeners for "'.concat(String(ne),'" event!'))),this}function L(ne,X){this.emit===a&&(this.emit=c);var $e=this.onceEvents[ne];return $e?typeof $e!="object"?(this.onceEvents[ne]=[X,$e],typeof ne=="symbol"&&this._symbolKeys.add(ne)):($e.unshift(X),this.maxListeners!==1/0&&this.maxListeners<=$e.length&&console.warn('Maximum event listeners for "'.concat(String(ne),'" once event!'))):(this.onceEvents[ne]=[X],typeof ne=="symbol"&&this._symbolKeys.add(ne)),this}function Z(ne){return ne===void 0?(this.events=(0,o.nullObj)(),this.onceEvents=(0,o.nullObj)(),this._symbolKeys=new Set):(this.events[ne]=void 0,this.onceEvents[ne]=void 0,typeof ne=="symbol"&&this._symbolKeys.delete(ne)),this}function ve(ne){return this.maxListeners=ne,this}function We(){return this.maxListeners}function re(ne){return this.emit===a?this.events[ne]?this.events[ne].tasksAsArray().slice():[]:this.events[ne]&&this.onceEvents[ne]?t(t([],this.events[ne].tasksAsArray(),!0),typeof this.onceEvents[ne]=="function"?[this.onceEvents[ne]]:this.onceEvents[ne],!0):this.events[ne]?this.events[ne].tasksAsArray():this.onceEvents[ne]?typeof this.onceEvents[ne]=="function"?[this.onceEvents[ne]]:this.onceEvents[ne]:[]}function ze(){var ne=this;if(this.emit===a){var X=Object.keys(this.events);return t(t([],X,!0),Array.from(this._symbolKeys),!0).filter(function(Ve){return Ve in ne.events&&ne.events[Ve]&&ne.events[Ve].length})}else{var X=Object.keys(this.events).filter(function(Ze){return ne.events[Ze]&&ne.events[Ze].length}),$e=Object.keys(this.onceEvents).filter(function(Ze){return ne.onceEvents[Ze]&&ne.onceEvents[Ze].length});return t(t(t([],X,!0),$e,!0),Array.from(this._symbolKeys).filter(function(Ze){return Ze in ne.events&&ne.events[Ze]&&ne.events[Ze].length||Ze in ne.onceEvents&&ne.onceEvents[Ze]&&ne.onceEvents[Ze].length}),!0)}}function se(ne){return this.emit===a?this.events[ne]&&this.events[ne].length||0:(this.events[ne]&&this.events[ne].length||0)+(this.onceEvents[ne]&&this.onceEvents[ne].length||0)}f.prototype.emit=a,f.prototype.on=m,f.prototype.once=g,f.prototype.addListener=m,f.prototype.removeListener=b,f.prototype.addListenerBound=k,f.prototype.removeListenerBound=_,f.prototype.hasListeners=A,f.prototype.prependListener=B,f.prototype.prependOnceListener=L,f.prototype.off=b,f.prototype.removeAllListeners=Z,f.prototype.setMaxListeners=ve,f.prototype.getMaxListeners=We,f.prototype.listeners=re,f.prototype.eventNames=ze,f.prototype.listenerCount=se}),require_lib=__commonJS(n=>{var t=n&&n.__createBinding||(Object.create?function(s,o,a,c){c===void 0&&(c=a);var f=Object.getOwnPropertyDescriptor(o,a);(!f||("get"in f?!o.__esModule:f.writable||f.configurable))&&(f={enumerable:!0,get:function(){return o[a]}}),Object.defineProperty(s,c,f)}:function(s,o,a,c){c===void 0&&(c=a),s[c]=o[a]}),r=n&&n.__exportStar||function(s,o){for(var a in s)a!=="default"&&!Object.prototype.hasOwnProperty.call(o,a)&&t(o,s,a)};Object.defineProperty(n,"__esModule",{value:!0}),r(require_types(),n),r(require_ee(),n)}),require_ms=__commonJS((n,t)=>{var r=1e3,s=r*60,o=s*60,a=o*24,c=a*7,f=a*365.25;t.exports=function(_,A){A=A||{};var B=typeof _;if(B==="string"&&_.length>0)return g(_);if(B==="number"&&isFinite(_))return A.long?b(_):m(_);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(_))};function g(_){if(_=String(_),!(_.length>100)){var A=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(_);if(A){var B=parseFloat(A[1]),L=(A[2]||"ms").toLowerCase();switch(L){case"years":case"year":case"yrs":case"yr":case"y":return B*f;case"weeks":case"week":case"w":return B*c;case"days":case"day":case"d":return B*a;case"hours":case"hour":case"hrs":case"hr":case"h":return B*o;case"minutes":case"minute":case"mins":case"min":case"m":return B*s;case"seconds":case"second":case"secs":case"sec":case"s":return B*r;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return B;default:return}}}}function m(_){var A=Math.abs(_);return A>=a?Math.round(_/a)+"d":A>=o?Math.round(_/o)+"h":A>=s?Math.round(_/s)+"m":A>=r?Math.round(_/r)+"s":_+"ms"}function b(_){var A=Math.abs(_);return A>=a?k(_,A,a,"day"):A>=o?k(_,A,o,"hour"):A>=s?k(_,A,s,"minute"):A>=r?k(_,A,r,"second"):_+" ms"}function k(_,A,B,L){var Z=A>=B*1.5;return Math.round(_/B)+" "+L+(Z?"s":"")}}),require_common=__commonJS((n,t)=>{function r(s){a.debug=a,a.default=a,a.coerce=k,a.disable=m,a.enable=f,a.enabled=b,a.humanize=require_ms(),a.destroy=_,Object.keys(s).forEach(A=>{a[A]=s[A]}),a.names=[],a.skips=[],a.formatters={};function o(A){let B=0;for(let L=0;L<A.length;L++)B=(B<<5)-B+A.charCodeAt(L),B|=0;return a.colors[Math.abs(B)%a.colors.length]}a.selectColor=o;function a(A){let B,L=null,Z,ve;function We(...re){if(!We.enabled)return;const ze=We,se=Number(new Date),ne=se-(B||se);ze.diff=ne,ze.prev=B,ze.curr=se,B=se,re[0]=a.coerce(re[0]),typeof re[0]!="string"&&re.unshift("%O");let X=0;re[0]=re[0].replace(/%([a-zA-Z%])/g,(Ve,Ze)=>{if(Ve==="%%")return"%";X++;const He=a.formatters[Ze];if(typeof He=="function"){const Le=re[X];Ve=He.call(ze,Le),re.splice(X,1),X--}return Ve}),a.formatArgs.call(ze,re),(ze.log||a.log).apply(ze,re)}return We.namespace=A,We.useColors=a.useColors(),We.color=a.selectColor(A),We.extend=c,We.destroy=a.destroy,Object.defineProperty(We,"enabled",{enumerable:!0,configurable:!1,get:()=>L!==null?L:(Z!==a.namespaces&&(Z=a.namespaces,ve=a.enabled(A)),ve),set:re=>{L=re}}),typeof a.init=="function"&&a.init(We),We}function c(A,B){const L=a(this.namespace+(typeof B>"u"?":":B)+A);return L.log=this.log,L}function f(A){a.save(A),a.namespaces=A,a.names=[],a.skips=[];const B=(typeof A=="string"?A:"").trim().replace(/\s+/g,",").split(",").filter(Boolean);for(const L of B)L[0]==="-"?a.skips.push(L.slice(1)):a.names.push(L)}function g(A,B){let L=0,Z=0,ve=-1,We=0;for(;L<A.length;)if(Z<B.length&&(B[Z]===A[L]||B[Z]==="*"))B[Z]==="*"?(ve=Z,We=L,Z++):(L++,Z++);else if(ve!==-1)Z=ve+1,We++,L=We;else return!1;for(;Z<B.length&&B[Z]==="*";)Z++;return Z===B.length}function m(){const A=[...a.names,...a.skips.map(B=>"-"+B)].join(",");return a.enable(""),A}function b(A){for(const B of a.skips)if(g(A,B))return!1;for(const B of a.names)if(g(A,B))return!0;return!1}function k(A){return A instanceof Error?A.stack||A.message:A}function _(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return a.enable(a.load()),a}t.exports=r}),require_browser=__commonJS((n,t)=>{n.formatArgs=s,n.save=o,n.load=a,n.useColors=r,n.storage=c(),n.destroy=(()=>{let g=!1;return()=>{g||(g=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),n.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function r(){if(typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs))return!0;if(typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))return!1;let g;return typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&(g=navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/))&&parseInt(g[1],10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}function s(g){if(g[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+g[0]+(this.useColors?"%c ":" ")+"+"+t.exports.humanize(this.diff),!this.useColors)return;const m="color: "+this.color;g.splice(1,0,m,"color: inherit");let b=0,k=0;g[0].replace(/%[a-zA-Z%]/g,_=>{_!=="%%"&&(b++,_==="%c"&&(k=b))}),g.splice(k,0,m)}n.log=console.debug||console.log||(()=>{});function o(g){try{g?n.storage.setItem("debug",g):n.storage.removeItem("debug")}catch{}}function a(){let g;try{g=n.storage.getItem("debug")||n.storage.getItem("DEBUG")}catch{}return!g&&typeof process<"u"&&"env"in process&&(g=define_process_env_default.DEBUG),g}function c(){try{return localStorage}catch{}}t.exports=require_common()(n);var{formatters:f}=t.exports;f.j=function(g){try{return JSON.stringify(g)}catch(m){return"[UnexpectedJSONParseError]: "+m.message}}}),require_LRUCacheNode=__commonJS(n=>{Object.defineProperty(n,"__esModule",{value:!0}),n.LRUCacheNode=void 0;class t{constructor(s,o,a){const{entryExpirationTimeInMS:c=null,next:f=null,prev:g=null,onEntryEvicted:m,onEntryMarkedAsMostRecentlyUsed:b,clone:k,cloneFn:_}=a??{};if(typeof c=="number"&&(c<=0||Number.isNaN(c)))throw new Error("entryExpirationTimeInMS must either be null (no expiry) or greater than 0");this.clone=k??!1,this.cloneFn=_??this.defaultClone,this.key=s,this.internalValue=this.clone?this.cloneFn(o):o,this.created=Date.now(),this.entryExpirationTimeInMS=c,this.next=f,this.prev=g,this.onEntryEvicted=m,this.onEntryMarkedAsMostRecentlyUsed=b}get value(){return this.clone?this.cloneFn(this.internalValue):this.internalValue}get isExpired(){return typeof this.entryExpirationTimeInMS=="number"&&Date.now()-this.created>this.entryExpirationTimeInMS}invokeOnEvicted(){if(this.onEntryEvicted){const{key:s,value:o,isExpired:a}=this;this.onEntryEvicted({key:s,value:o,isExpired:a})}}invokeOnEntryMarkedAsMostRecentlyUsed(){if(this.onEntryMarkedAsMostRecentlyUsed){const{key:s,value:o}=this;this.onEntryMarkedAsMostRecentlyUsed({key:s,value:o})}}defaultClone(s){return typeof s=="boolean"||typeof s=="string"||typeof s=="number"?s:JSON.parse(JSON.stringify(s))}}n.LRUCacheNode=t}),require_LRUCache=__commonJS(n=>{Object.defineProperty(n,"__esModule",{value:!0}),n.LRUCache=void 0;var t=require_LRUCacheNode();class r{constructor(o){this.lookupTable=new Map,this.head=null,this.tail=null;const{maxSize:a=25,entryExpirationTimeInMS:c=null,onEntryEvicted:f,onEntryMarkedAsMostRecentlyUsed:g,cloneFn:m,clone:b}=o??{};if(Number.isNaN(a)||a<=0)throw new Error("maxSize must be greater than 0.");if(typeof c=="number"&&(c<=0||Number.isNaN(c)))throw new Error("entryExpirationTimeInMS must either be null (no expiry) or greater than 0");this.maxSizeInternal=a,this.entryExpirationTimeInMS=c,this.onEntryEvicted=f,this.onEntryMarkedAsMostRecentlyUsed=g,this.clone=b,this.cloneFn=m}get size(){return this.cleanCache(),this.lookupTable.size}get remainingSize(){return this.maxSizeInternal-this.size}get newest(){return this.head?this.head.isExpired?(this.removeNodeFromListAndLookupTable(this.head),this.newest):this.mapNodeToEntry(this.head):null}get oldest(){return this.tail?this.tail.isExpired?(this.removeNodeFromListAndLookupTable(this.tail),this.oldest):this.mapNodeToEntry(this.tail):null}get maxSize(){return this.maxSizeInternal}set maxSize(o){if(Number.isNaN(o)||o<=0)throw new Error("maxSize must be greater than 0.");this.maxSizeInternal=o,this.enforceSizeLimit()}set(o,a,c){const f=this.lookupTable.get(o);f&&this.removeNodeFromListAndLookupTable(f);const g=new t.LRUCacheNode(o,a,{entryExpirationTimeInMS:this.entryExpirationTimeInMS,onEntryEvicted:this.onEntryEvicted,onEntryMarkedAsMostRecentlyUsed:this.onEntryMarkedAsMostRecentlyUsed,clone:this.clone,cloneFn:this.cloneFn,...c});return this.setNodeAsHead(g),this.lookupTable.set(o,g),this.enforceSizeLimit(),this}get(o){const a=this.lookupTable.get(o);return a?a.isExpired?(this.removeNodeFromListAndLookupTable(a),null):(this.setNodeAsHead(a),a.value):null}peek(o){const a=this.lookupTable.get(o);return a?a.isExpired?(this.removeNodeFromListAndLookupTable(a),null):a.value:null}delete(o){const a=this.lookupTable.get(o);return a?this.removeNodeFromListAndLookupTable(a):!1}has(o){const a=this.lookupTable.get(o);return a?a.isExpired?(this.removeNodeFromListAndLookupTable(a),!1):!0:!1}clear(){this.head=null,this.tail=null,this.lookupTable.clear()}find(o){let a=this.head;for(;a;){if(a.isExpired){const f=a.next;this.removeNodeFromListAndLookupTable(a),a=f;continue}const c=this.mapNodeToEntry(a);if(o(c))return this.setNodeAsHead(a),c;a=a.next}return null}forEach(o){let a=this.head,c=0;for(;a;){if(a.isExpired){const f=a.next;this.removeNodeFromListAndLookupTable(a),a=f;continue}o(a.value,a.key,c),a=a.next,c++}}*values(){let o=this.head;for(;o;){if(o.isExpired){const a=o.next;this.removeNodeFromListAndLookupTable(o),o=a;continue}yield o.value,o=o.next}}*keys(){let o=this.head;for(;o;){if(o.isExpired){const a=o.next;this.removeNodeFromListAndLookupTable(o),o=a;continue}yield o.key,o=o.next}}*entries(){let o=this.head;for(;o;){if(o.isExpired){const a=o.next;this.removeNodeFromListAndLookupTable(o),o=a;continue}yield this.mapNodeToEntry(o),o=o.next}}*[Symbol.iterator](){let o=this.head;for(;o;){if(o.isExpired){const a=o.next;this.removeNodeFromListAndLookupTable(o),o=a;continue}yield this.mapNodeToEntry(o),o=o.next}}enforceSizeLimit(){let o=this.tail;for(;o!==null&&this.size>this.maxSizeInternal;){const a=o.prev;this.removeNodeFromListAndLookupTable(o),o=a}}mapNodeToEntry({key:o,value:a}){return{key:o,value:a}}setNodeAsHead(o){this.removeNodeFromList(o),this.head?(o.next=this.head,this.head.prev=o,this.head=o):(this.head=o,this.tail=o),o.invokeOnEntryMarkedAsMostRecentlyUsed()}removeNodeFromList(o){o.prev!==null&&(o.prev.next=o.next),o.next!==null&&(o.next.prev=o.prev),this.head===o&&(this.head=o.next),this.tail===o&&(this.tail=o.prev),o.next=null,o.prev=null}removeNodeFromListAndLookupTable(o){return o.invokeOnEvicted(),this.removeNodeFromList(o),this.lookupTable.delete(o.key)}cleanCache(){if(!this.entryExpirationTimeInMS)return;const o=[];for(const a of this.lookupTable.values())a.isExpired&&o.push(a);o.forEach(a=>this.removeNodeFromListAndLookupTable(a))}}n.LRUCache=r}),require_dist=__commonJS(n=>{var t=n&&n.__createBinding||(Object.create?function(s,o,a,c){c===void 0&&(c=a);var f=Object.getOwnPropertyDescriptor(o,a);(!f||("get"in f?!o.__esModule:f.writable||f.configurable))&&(f={enumerable:!0,get:function(){return o[a]}}),Object.defineProperty(s,c,f)}:function(s,o,a,c){c===void 0&&(c=a),s[c]=o[a]}),r=n&&n.__exportStar||function(s,o){for(var a in s)a!=="default"&&!Object.prototype.hasOwnProperty.call(o,a)&&t(o,s,a)};Object.defineProperty(n,"__esModule",{value:!0}),r(require_LRUCache(),n)}),require_lib2=__commonJS(n=>{Object.defineProperty(n,"__esModule",{value:!0}),n.bytes=n.stringToBytes=n.str=n.bytesToString=n.hex=n.utf8=n.bech32m=n.bech32=n.base58check=n.base58xmr=n.base58xrp=n.base58flickr=n.base58=n.base64url=n.base64=n.base32crockford=n.base32hex=n.base32=n.base16=n.utils=n.assertNumber=void 0;function t(He){if(!Number.isSafeInteger(He))throw new Error(`Wrong integer: ${He}`)}n.assertNumber=t;function r(...He){const Le=(Y,Ce)=>je=>Y(Ce(je)),Q=Array.from(He).reverse().reduce((Y,Ce)=>Y?Le(Y,Ce.encode):Ce.encode,void 0),oe=He.reduce((Y,Ce)=>Y?Le(Y,Ce.decode):Ce.decode,void 0);return{encode:Q,decode:oe}}function s(He){return{encode:Le=>{if(!Array.isArray(Le)||Le.length&&typeof Le[0]!="number")throw new Error("alphabet.encode input should be an array of numbers");return Le.map(Q=>{if(t(Q),Q<0||Q>=He.length)throw new Error(`Digit index outside alphabet: ${Q} (alphabet: ${He.length})`);return He[Q]})},decode:Le=>{if(!Array.isArray(Le)||Le.length&&typeof Le[0]!="string")throw new Error("alphabet.decode input should be array of strings");return Le.map(Q=>{if(typeof Q!="string")throw new Error(`alphabet.decode: not string element=${Q}`);const oe=He.indexOf(Q);if(oe===-1)throw new Error(`Unknown letter: "${Q}". Allowed: ${He}`);return oe})}}}function o(He=""){if(typeof He!="string")throw new Error("join separator should be string");return{encode:Le=>{if(!Array.isArray(Le)||Le.length&&typeof Le[0]!="string")throw new Error("join.encode input should be array of strings");for(let Q of Le)if(typeof Q!="string")throw new Error(`join.encode: non-string input=${Q}`);return Le.join(He)},decode:Le=>{if(typeof Le!="string")throw new Error("join.decode input should be string");return Le.split(He)}}}function a(He,Le="="){if(t(He),typeof Le!="string")throw new Error("padding chr should be string");return{encode(Q){if(!Array.isArray(Q)||Q.length&&typeof Q[0]!="string")throw new Error("padding.encode input should be array of strings");for(let oe of Q)if(typeof oe!="string")throw new Error(`padding.encode: non-string input=${oe}`);for(;Q.length*He%8;)Q.push(Le);return Q},decode(Q){if(!Array.isArray(Q)||Q.length&&typeof Q[0]!="string")throw new Error("padding.encode input should be array of strings");for(let Y of Q)if(typeof Y!="string")throw new Error(`padding.decode: non-string input=${Y}`);let oe=Q.length;if(oe*He%8)throw new Error("Invalid padding: string should have whole number of bytes");for(;oe>0&&Q[oe-1]===Le;oe--)if(!((oe-1)*He%8))throw new Error("Invalid padding: string has too much padding");return Q.slice(0,oe)}}}function c(He){if(typeof He!="function")throw new Error("normalize fn should be function");return{encode:Le=>Le,decode:Le=>He(Le)}}function f(He,Le,Q){if(Le<2)throw new Error(`convertRadix: wrong from=${Le}, base cannot be less than 2`);if(Q<2)throw new Error(`convertRadix: wrong to=${Q}, base cannot be less than 2`);if(!Array.isArray(He))throw new Error("convertRadix: data should be array");if(!He.length)return[];let oe=0;const Y=[],Ce=Array.from(He);for(Ce.forEach(je=>{if(t(je),je<0||je>=Le)throw new Error(`Wrong integer: ${je}`)});;){let je=0,Je=!0;for(let Ge=oe;Ge<Ce.length;Ge++){const Xe=Ce[Ge],Qe=Le*je+Xe;if(!Number.isSafeInteger(Qe)||Le*je/Le!==je||Qe-Xe!==Le*je)throw new Error("convertRadix: carry overflow");if(je=Qe%Q,Ce[Ge]=Math.floor(Qe/Q),!Number.isSafeInteger(Ce[Ge])||Ce[Ge]*Q+je!==Qe)throw new Error("convertRadix: carry overflow");if(Je)Ce[Ge]?Je=!1:oe=Ge;else continue}if(Y.push(je),Je)break}for(let je=0;je<He.length-1&&He[je]===0;je++)Y.push(0);return Y.reverse()}var g=(He,Le)=>Le?g(Le,He%Le):He,m=(He,Le)=>He+(Le-g(He,Le));function b(He,Le,Q,oe){if(!Array.isArray(He))throw new Error("convertRadix2: data should be array");if(Le<=0||Le>32)throw new Error(`convertRadix2: wrong from=${Le}`);if(Q<=0||Q>32)throw new Error(`convertRadix2: wrong to=${Q}`);if(m(Le,Q)>32)throw new Error(`convertRadix2: carry overflow from=${Le} to=${Q} carryBits=${m(Le,Q)}`);let Y=0,Ce=0;const je=2**Q-1,Je=[];for(const Ge of He){if(t(Ge),Ge>=2**Le)throw new Error(`convertRadix2: invalid data word=${Ge} from=${Le}`);if(Y=Y<<Le|Ge,Ce+Le>32)throw new Error(`convertRadix2: carry overflow pos=${Ce} from=${Le}`);for(Ce+=Le;Ce>=Q;Ce-=Q)Je.push((Y>>Ce-Q&je)>>>0);Y&=2**Ce-1}if(Y=Y<<Q-Ce&je,!oe&&Ce>=Le)throw new Error("Excess padding");if(!oe&&Y)throw new Error(`Non-zero padding: ${Y}`);return oe&&Ce>0&&Je.push(Y>>>0),Je}function k(He){return t(He),{encode:Le=>{if(!(Le instanceof Uint8Array))throw new Error("radix.encode input should be Uint8Array");return f(Array.from(Le),2**8,He)},decode:Le=>{if(!Array.isArray(Le)||Le.length&&typeof Le[0]!="number")throw new Error("radix.decode input should be array of strings");return Uint8Array.from(f(Le,He,2**8))}}}function _(He,Le=!1){if(t(He),He<=0||He>32)throw new Error("radix2: bits should be in (0..32]");if(m(8,He)>32||m(He,8)>32)throw new Error("radix2: carry overflow");return{encode:Q=>{if(!(Q instanceof Uint8Array))throw new Error("radix2.encode input should be Uint8Array");return b(Array.from(Q),8,He,!Le)},decode:Q=>{if(!Array.isArray(Q)||Q.length&&typeof Q[0]!="number")throw new Error("radix2.decode input should be array of strings");return Uint8Array.from(b(Q,He,8,Le))}}}function A(He){if(typeof He!="function")throw new Error("unsafeWrapper fn should be function");return function(...Le){try{return He.apply(null,Le)}catch{}}}function B(He,Le){if(t(He),typeof Le!="function")throw new Error("checksum fn should be function");return{encode(Q){if(!(Q instanceof Uint8Array))throw new Error("checksum.encode: input should be Uint8Array");const oe=Le(Q).slice(0,He),Y=new Uint8Array(Q.length+He);return Y.set(Q),Y.set(oe,Q.length),Y},decode(Q){if(!(Q instanceof Uint8Array))throw new Error("checksum.decode: input should be Uint8Array");const oe=Q.slice(0,-He),Y=Le(oe).slice(0,He),Ce=Q.slice(-He);for(let je=0;je<He;je++)if(Y[je]!==Ce[je])throw new Error("Invalid checksum");return oe}}}n.utils={alphabet:s,chain:r,checksum:B,radix:k,radix2:_,join:o,padding:a},n.base16=r(_(4),s("0123456789ABCDEF"),o("")),n.base32=r(_(5),s("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),a(5),o("")),n.base32hex=r(_(5),s("0123456789ABCDEFGHIJKLMNOPQRSTUV"),a(5),o("")),n.base32crockford=r(_(5),s("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),o(""),c(He=>He.toUpperCase().replace(/O/g,"0").replace(/[IL]/g,"1"))),n.base64=r(_(6),s("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),a(6),o("")),n.base64url=r(_(6),s("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),a(6),o(""));var L=He=>r(k(58),s(He),o(""));n.base58=L("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),n.base58flickr=L("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"),n.base58xrp=L("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");var Z=[0,2,3,5,6,7,9,10,11];n.base58xmr={encode(He){let Le="";for(let Q=0;Q<He.length;Q+=8){const oe=He.subarray(Q,Q+8);Le+=n.base58.encode(oe).padStart(Z[oe.length],"1")}return Le},decode(He){let Le=[];for(let Q=0;Q<He.length;Q+=11){const oe=He.slice(Q,Q+11),Y=Z.indexOf(oe.length),Ce=n.base58.decode(oe);for(let je=0;je<Ce.length-Y;je++)if(Ce[je]!==0)throw new Error("base58xmr: wrong padding");Le=Le.concat(Array.from(Ce.slice(Ce.length-Y)))}return Uint8Array.from(Le)}};var ve=He=>r(B(4,Le=>He(He(Le))),n.base58);n.base58check=ve;var We=r(s("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),o("")),re=[996825010,642813549,513874426,1027748829,705979059];function ze(He){const Le=He>>25;let Q=(He&33554431)<<5;for(let oe=0;oe<re.length;oe++)(Le>>oe&1)===1&&(Q^=re[oe]);return Q}function se(He,Le,Q=1){const oe=He.length;let Y=1;for(let Ce=0;Ce<oe;Ce++){const je=He.charCodeAt(Ce);if(je<33||je>126)throw new Error(`Invalid prefix (${He})`);Y=ze(Y)^je>>5}Y=ze(Y);for(let Ce=0;Ce<oe;Ce++)Y=ze(Y)^He.charCodeAt(Ce)&31;for(let Ce of Le)Y=ze(Y)^Ce;for(let Ce=0;Ce<6;Ce++)Y=ze(Y);return Y^=Q,We.encode(b([Y%2**30],30,5,!1))}function ne(He){const Le=He==="bech32"?1:734539939,Q=_(5),oe=Q.decode,Y=Q.encode,Ce=A(oe);function je(Qe,rt,_t=90){if(typeof Qe!="string")throw new Error(`bech32.encode prefix should be string, not ${typeof Qe}`);if(!Array.isArray(rt)||rt.length&&typeof rt[0]!="number")throw new Error(`bech32.encode words should be array of numbers, not ${typeof rt}`);const ht=Qe.length+7+rt.length;if(_t!==!1&&ht>_t)throw new TypeError(`Length ${ht} exceeds limit ${_t}`);return Qe=Qe.toLowerCase(),`${Qe}1${We.encode(rt)}${se(Qe,rt,Le)}`}function Je(Qe,rt=90){if(typeof Qe!="string")throw new Error(`bech32.decode input should be string, not ${typeof Qe}`);if(Qe.length<8||rt!==!1&&Qe.length>rt)throw new TypeError(`Wrong string length: ${Qe.length} (${Qe}). Expected (8..${rt})`);const _t=Qe.toLowerCase();if(Qe!==_t&&Qe!==Qe.toUpperCase())throw new Error("String must be lowercase or uppercase");Qe=_t;const ht=Qe.lastIndexOf("1");if(ht===0||ht===-1)throw new Error('Letter "1" must be present between prefix and data only');const ot=Qe.slice(0,ht),xt=Qe.slice(ht+1);if(xt.length<6)throw new Error("Data must be at least 6 characters long");const St=We.decode(xt).slice(0,-6),Mt=se(ot,St,Le);if(!xt.endsWith(Mt))throw new Error(`Invalid checksum in ${Qe}: expected "${Mt}"`);return{prefix:ot,words:St}}const Ge=A(Je);function Xe(Qe){const{prefix:rt,words:_t}=Je(Qe,!1);return{prefix:rt,words:_t,bytes:oe(_t)}}return{encode:je,decode:Je,decodeToBytes:Xe,decodeUnsafe:Ge,fromWords:oe,fromWordsUnsafe:Ce,toWords:Y}}n.bech32=ne("bech32"),n.bech32m=ne("bech32m"),n.utf8={encode:He=>new TextDecoder().decode(He),decode:He=>new TextEncoder().encode(He)},n.hex=r(_(4),s("0123456789abcdef"),o(""),c(He=>{if(typeof He!="string"||He.length%2)throw new TypeError(`hex.decode: expected string, got ${typeof He} with length ${He.length}`);return He.toLowerCase()}));var X={utf8:n.utf8,hex:n.hex,base16:n.base16,base32:n.base32,base64:n.base64,base64url:n.base64url,base58:n.base58,base58xmr:n.base58xmr},$e=`Invalid encoding type. Available types: ${Object.keys(X).join(", ")}`,Ve=(He,Le)=>{if(typeof He!="string"||!X.hasOwnProperty(He))throw new TypeError($e);if(!(Le instanceof Uint8Array))throw new TypeError("bytesToString() expects Uint8Array");return X[He].encode(Le)};n.bytesToString=Ve,n.str=n.bytesToString;var Ze=(He,Le)=>{if(!X.hasOwnProperty(He))throw new TypeError($e);if(typeof Le!="string")throw new TypeError("stringToBytes() expects string");return X[He].decode(Le)};n.stringToBytes=Ze,n.bytes=n.stringToBytes}),require_bolt11=__commonJS((n,t)=>{var{bech32:r,hex:s,utf8:o}=require_lib2(),a={bech32:"bc",pubKeyHash:0,scriptHash:5,validWitnessVersions:[0]},c={bech32:"tb",pubKeyHash:111,scriptHash:196,validWitnessVersions:[0]},f={bech32:"tbs",pubKeyHash:111,scriptHash:196,validWitnessVersions:[0]},g={bech32:"bcrt",pubKeyHash:111,scriptHash:196,validWitnessVersions:[0]},m={bech32:"sb",pubKeyHash:63,scriptHash:123,validWitnessVersions:[0]},b=["option_data_loss_protect","initial_routing_sync","option_upfront_shutdown_script","gossip_queries","var_onion_optin","gossip_queries_ex","option_static_remotekey","payment_secret","basic_mpp","option_support_large_channel"],k={m:BigInt(1e3),u:BigInt(1e6),n:BigInt(1e9),p:BigInt(1e12)},_=BigInt("2100000000000000000"),A=BigInt(1e11),B={payment_hash:1,payment_secret:16,description:13,payee:19,description_hash:23,expiry:6,min_final_cltv_expiry:24,fallback_address:9,route_hint:3,feature_bits:5,metadata:27},L={};for(let X=0,$e=Object.keys(B);X<$e.length;X++){const Ve=$e[X],Ze=B[$e[X]].toString();L[Ze]=Ve}var Z={1:X=>s.encode(r.fromWordsUnsafe(X)),16:X=>s.encode(r.fromWordsUnsafe(X)),13:X=>o.encode(r.fromWordsUnsafe(X)),19:X=>s.encode(r.fromWordsUnsafe(X)),23:X=>s.encode(r.fromWordsUnsafe(X)),27:X=>s.encode(r.fromWordsUnsafe(X)),6:We,24:We,3:re,5:ze};function ve(X){return $e=>({tagCode:parseInt(X),words:r.encode("unknown",$e,Number.MAX_SAFE_INTEGER)})}function We(X){return X.reverse().reduce(($e,Ve,Ze)=>$e+Ve*Math.pow(32,Ze),0)}function re(X){const $e=[];let Ve,Ze,He,Le,Q,oe=r.fromWordsUnsafe(X);for(;oe.length>0;)Ve=s.encode(oe.slice(0,33)),Ze=s.encode(oe.slice(33,41)),He=parseInt(s.encode(oe.slice(41,45)),16),Le=parseInt(s.encode(oe.slice(45,49)),16),Q=parseInt(s.encode(oe.slice(49,51)),16),oe=oe.slice(51),$e.push({pubkey:Ve,short_channel_id:Ze,fee_base_msat:He,fee_proportional_millionths:Le,cltv_expiry_delta:Q});return $e}function ze(X){const $e=X.slice().reverse().map(He=>[!!(He&1),!!(He&2),!!(He&4),!!(He&8),!!(He&16)]).reduce((He,Le)=>He.concat(Le),[]);for(;$e.length<b.length*2;)$e.push(!1);const Ve={};b.forEach((He,Le)=>{let Q;$e[Le*2]?Q="required":$e[Le*2+1]?Q="supported":Q="unsupported",Ve[He]=Q});const Ze=$e.slice(b.length*2);return Ve.extra_bits={start_bit:b.length*2,bits:Ze,has_required:Ze.reduce((He,Le,Q)=>Q%2!==0?He||!1:He||Le,!1)},Ve}function se(X,$e){let Ve,Ze;if(X.slice(-1).match(/^[munp]$/))Ve=X.slice(-1),Ze=X.slice(0,-1);else{if(X.slice(-1).match(/^[^munp0-9]$/))throw new Error("Not a valid multiplier for the amount");Ze=X}if(!Ze.match(/^\d+$/))throw new Error("Not a valid human readable amount");const He=BigInt(Ze),Le=Ve?He*A/k[Ve]:He*A;if(Ve==="p"&&He%BigInt(10)!==BigInt(0)||Le>_)throw new Error("Amount is outside of valid range");return $e?Le.toString():Le}function ne(X,$e){if(typeof X!="string")throw new Error("Lightning Payment Request must be string");if(X.slice(0,2).toLowerCase()!=="ln")throw new Error("Not a proper lightning payment request");const Ve=[],Ze=r.decode(X,Number.MAX_SAFE_INTEGER);X=X.toLowerCase();const He=Ze.prefix;let Le=Ze.words,Q=X.slice(He.length+1),oe=Le.slice(-104);Le=Le.slice(0,-104);let Y=He.match(/^ln(\S+?)(\d*)([a-zA-Z]?)$/);if(Y&&!Y[2]&&(Y=He.match(/^ln(\S+)$/)),!Y)throw new Error("Not a proper lightning payment request");Ve.push({name:"lightning_network",letters:"ln"});const Ce=Y[1];let je;if($e){if($e.bech32===void 0||$e.pubKeyHash===void 0||$e.scriptHash===void 0||!Array.isArray($e.validWitnessVersions))throw new Error("Invalid network");je=$e}else switch(Ce){case a.bech32:je=a;break;case c.bech32:je=c;break;case f.bech32:je=f;break;case g.bech32:je=g;break;case m.bech32:je=m;break}if(!je||je.bech32!==Ce)throw new Error("Unknown coin bech32 prefix");Ve.push({name:"coin_network",letters:Ce,value:je});const Je=Y[2];let Ge;if(Je){const St=Y[3];Ge=se(Je+St,!0),Ve.push({name:"amount",letters:Y[2]+Y[3],value:Ge})}else Ge=null;Ve.push({name:"separator",letters:"1"});const Xe=We(Le.slice(0,7));Le=Le.slice(7),Ve.push({name:"timestamp",letters:Q.slice(0,7),value:Xe}),Q=Q.slice(7);let Qe,rt,_t,ht;for(;Le.length>0;){const St=Le[0].toString();Qe=L[St]||"unknown_tag",rt=Z[St]||ve(St),Le=Le.slice(1),_t=We(Le.slice(0,2)),Le=Le.slice(2),ht=Le.slice(0,_t),Le=Le.slice(_t),Ve.push({name:Qe,tag:Q[0],letters:Q.slice(0,3+_t),value:rt(ht)}),Q=Q.slice(3+_t)}Ve.push({name:"signature",letters:Q.slice(0,104),value:s.encode(r.fromWordsUnsafe(oe))}),Q=Q.slice(104),Ve.push({name:"checksum",letters:Q});let ot={paymentRequest:X,sections:Ve,get expiry(){let St=Ve.find(Mt=>Mt.name==="expiry");if(St)return xt("timestamp")+St.value},get route_hints(){return Ve.filter(St=>St.name==="route_hint").map(St=>St.value)}};for(let St in B)St!=="route_hint"&&Object.defineProperty(ot,St,{get(){return xt(St)}});return ot;function xt(St){let Mt=Ve.find(Bt=>Bt.name===St);return Mt?Mt.value:void 0}}t.exports={decode:ne,hrpToMillisat:se}}),exports_decoder={};__export$1(exports_decoder,{looksLikeBinaryFormat:()=>looksLikeBinaryFormat,decodeSingleEvent:()=>decodeSingleEvent,decodeEvents:()=>decodeEvents});function bytesToHex4(n){return Array.from(n).map(t=>t.toString(16).padStart(2,"0")).join("")}function decodeString(n){return new TextDecoder().decode(n)}function decodeEvent(n,t){const r=new DataView(n),s=new Uint8Array(n);let o=t;if(o+4>n.byteLength)throw new Error(`Buffer overflow: trying to read event size at offset ${o}, buffer length is ${n.byteLength}`);const a=r.getUint32(o,!0);o+=4;const c=t+a;if(c>n.byteLength)throw new Error(`Invalid event size: event claims to be ${a} bytes but only ${n.byteLength-t} bytes available`);const f=s.slice(o,o+32),g=bytesToHex4(f);o+=32;const m=s.slice(o,o+32),b=bytesToHex4(m);o+=32;const k=r.getUint32(o,!0);o+=4;const _=r.getUint16(o,!0);o+=2;const A=s.slice(o,o+64),B=bytesToHex4(A);o+=64;const L=r.getUint32(o,!0);o+=4;const Z=s.slice(o,o+L),ve=decodeString(Z);o+=L;const We=r.getUint16(o,!0);o+=2;const re=[];for(let X=0;X<We;X++){const $e=r.getUint8(o);o+=1;const Ve=[];for(let Ze=0;Ze<$e;Ze++){const He=r.getUint16(o,!0);o+=2;const Le=s.slice(o,o+He),Q=decodeString(Le);Ve.push(Q),o+=He}re.push(Ve)}let ze=null;const se=r.getUint8(o);if(o+=1,se===1){const X=r.getUint16(o,!0);o+=2;const $e=s.slice(o,o+X);ze=decodeString($e),o+=X}return{event:{id:g,pubkey:b,created_at:k,kind:_,sig:B,content:ve,tags:re,relay_url:ze},nextOffset:c}}function decodeEvents(n){if(n.byteLength===0)return[];if(n.byteLength<9)throw new Error(`Buffer too small: ${n.byteLength} bytes. Need at least 9 bytes for header.`);const t=new DataView(n);let r=0;const s=t.getUint32(r,!0);if(s!==MAGIC_NUMBER)throw new Error(`Invalid magic number. Expected ${MAGIC_NUMBER.toString(16)}, got ${s.toString(16)}`);r+=4;const o=t.getUint8(r);if(o!==SUPPORTED_VERSION)throw new Error(`Unsupported version ${o}. Only version ${SUPPORTED_VERSION} is supported`);r+=1;const a=t.getUint32(r,!0);r+=4;const c=[];for(let f=0;f<a;f++){const{event:g,nextOffset:m}=decodeEvent(n,r);c.push(g),r=m}return c}function decodeSingleEvent(n){const t=decodeEvents(n);if(t.length!==1)throw new Error(`Expected 1 event, got ${t.length}`);return t[0]}function looksLikeBinaryFormat(n){return n.byteLength<9?!1:new DataView(n).getUint32(0,!0)===MAGIC_NUMBER}var MAGIC_NUMBER=1313821524,SUPPORTED_VERSION=1;async function addDecryptedEvent(n,t){await this.ensureInitialized();const r=t.serialize(!0,!0);await this.postWorkerMessage({type:"addDecryptedEvent",payload:{wrapperId:n,serialized:r}})}async function addUnpublishedEvent(n,t,r=Date.now()){await this.ensureInitialized(),await this.postWorkerMessage({type:"addUnpublishedEvent",payload:{id:n.id,event:n.serialize(!0,!0),relays:JSON.stringify(t)}})}async function discardUnpublishedEvent(n){await this.ensureInitialized(),await this.postWorkerMessage({type:"discardUnpublishedEvent",payload:{id:n}})}async function fetchProfile(n){await this.ensureInitialized();const t=this.metadataCache?.getProfile(n);if(t)return t;const r=await this.postWorkerMessage({type:"fetchProfile",payload:{pubkey:n}});if(r&&r.profile)try{const o={...JSON.parse(r.profile),cachedAt:r.updated_at};return this.metadataCache?.setProfile(n,o),o}catch{return null}return null}async function getCacheStats(){return await this.ensureInitialized(),this.postWorkerMessage({type:"getCacheStats"})}var import_tseep=__toESM(require_lib()),import_debug=__toESM(require_browser()),import_debug2=__toESM(require_browser()),import_tseep2=__toESM(require_lib());__toESM(require_browser());function number$3(n){if(!Number.isSafeInteger(n)||n<0)throw new Error(`Wrong positive integer: ${n}`)}function bytes$4(n,...t){if(!(n instanceof Uint8Array))throw new Error("Expected Uint8Array");if(t.length>0&&!t.includes(n.length))throw new Error(`Expected Uint8Array of length ${t}, not of length=${n.length}`)}function hash$2(n){if(typeof n!="function"||typeof n.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");number$3(n.outputLen),number$3(n.blockLen)}function exists$3(n,t=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(t&&n.finished)throw new Error("Hash#digest() has already been called")}function output$3(n,t){bytes$4(n);const r=t.outputLen;if(n.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}var crypto$4=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var u8a$3=n=>n instanceof Uint8Array,createView$4=n=>new DataView(n.buffer,n.byteOffset,n.byteLength),rotr$3=(n,t)=>n<<32-t|n>>>t,isLE$3=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE$3)throw new Error("Non little-endian hardware is not supported");function utf8ToBytes$5(n){if(typeof n!="string")throw new Error(`utf8ToBytes expected string, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}function toBytes$4(n){if(typeof n=="string"&&(n=utf8ToBytes$5(n)),!u8a$3(n))throw new Error(`expected Uint8Array, got ${typeof n}`);return n}function concatBytes$4(...n){const t=new Uint8Array(n.reduce((s,o)=>s+o.length,0));let r=0;return n.forEach(s=>{if(!u8a$3(s))throw new Error("Uint8Array expected");t.set(s,r),r+=s.length}),t}let Hash$3=class{clone(){return this._cloneInto()}};function wrapConstructor$2(n){const t=s=>n().update(toBytes$4(s)).digest(),r=n();return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=()=>n(),t}function randomBytes$3(n=32){if(crypto$4&&typeof crypto$4.getRandomValues=="function")return crypto$4.getRandomValues(new Uint8Array(n));throw new Error("crypto.getRandomValues must be defined")}function setBigUint64$4(n,t,r,s){if(typeof n.setBigUint64=="function")return n.setBigUint64(t,r,s);const o=BigInt(32),a=BigInt(4294967295),c=Number(r>>o&a),f=Number(r&a),g=s?4:0,m=s?0:4;n.setUint32(t+g,c,s),n.setUint32(t+m,f,s)}let SHA2$2=class extends Hash$3{constructor(t,r,s,o){super(),this.blockLen=t,this.outputLen=r,this.padOffset=s,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=createView$4(this.buffer)}update(t){exists$3(this);const{view:r,buffer:s,blockLen:o}=this;t=toBytes$4(t);const a=t.length;for(let c=0;c<a;){const f=Math.min(o-this.pos,a-c);if(f===o){const g=createView$4(t);for(;o<=a-c;c+=o)this.process(g,c);continue}s.set(t.subarray(c,c+f),this.pos),this.pos+=f,c+=f,this.pos===o&&(this.process(r,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){exists$3(this),output$3(t,this),this.finished=!0;const{buffer:r,view:s,blockLen:o,isLE:a}=this;let{pos:c}=this;r[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>o-c&&(this.process(s,0),c=0);for(let k=c;k<o;k++)r[k]=0;setBigUint64$4(s,o-8,BigInt(this.length*8),a),this.process(s,0);const f=createView$4(t),g=this.outputLen;if(g%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const m=g/4,b=this.get();if(m>b.length)throw new Error("_sha2: outputLen bigger than state");for(let k=0;k<m;k++)f.setUint32(4*k,b[k],a)}digest(){const{buffer:t,outputLen:r}=this;this.digestInto(t);const s=t.slice(0,r);return this.destroy(),s}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:r,buffer:s,length:o,finished:a,destroyed:c,pos:f}=this;return t.length=o,t.pos=f,t.finished=a,t.destroyed=c,o%r&&t.buffer.set(s),t}};var Chi$3=(n,t,r)=>n&t^~n&r,Maj$3=(n,t,r)=>n&t^n&r^t&r,SHA256_K$3=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),IV$2=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W$3=new Uint32Array(64);let SHA256$3=class extends SHA2$2{constructor(){super(64,32,8,!1),this.A=IV$2[0]|0,this.B=IV$2[1]|0,this.C=IV$2[2]|0,this.D=IV$2[3]|0,this.E=IV$2[4]|0,this.F=IV$2[5]|0,this.G=IV$2[6]|0,this.H=IV$2[7]|0}get(){const{A:t,B:r,C:s,D:o,E:a,F:c,G:f,H:g}=this;return[t,r,s,o,a,c,f,g]}set(t,r,s,o,a,c,f,g){this.A=t|0,this.B=r|0,this.C=s|0,this.D=o|0,this.E=a|0,this.F=c|0,this.G=f|0,this.H=g|0}process(t,r){for(let k=0;k<16;k++,r+=4)SHA256_W$3[k]=t.getUint32(r,!1);for(let k=16;k<64;k++){const _=SHA256_W$3[k-15],A=SHA256_W$3[k-2],B=rotr$3(_,7)^rotr$3(_,18)^_>>>3,L=rotr$3(A,17)^rotr$3(A,19)^A>>>10;SHA256_W$3[k]=L+SHA256_W$3[k-7]+B+SHA256_W$3[k-16]|0}let{A:s,B:o,C:a,D:c,E:f,F:g,G:m,H:b}=this;for(let k=0;k<64;k++){const _=rotr$3(f,6)^rotr$3(f,11)^rotr$3(f,25),A=b+_+Chi$3(f,g,m)+SHA256_K$3[k]+SHA256_W$3[k]|0,L=(rotr$3(s,2)^rotr$3(s,13)^rotr$3(s,22))+Maj$3(s,o,a)|0;b=m,m=g,g=f,f=c+A|0,c=a,a=o,o=s,s=A+L|0}s=s+this.A|0,o=o+this.B|0,a=a+this.C|0,c=c+this.D|0,f=f+this.E|0,g=g+this.F|0,m=m+this.G|0,b=b+this.H|0,this.set(s,o,a,c,f,g,m,b)}roundClean(){SHA256_W$3.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var sha256$4=wrapConstructor$2(()=>new SHA256$3),exports_utils={};__export$1(exports_utils,{validateObject:()=>validateObject$1,utf8ToBytes:()=>utf8ToBytes2,numberToVarBytesBE:()=>numberToVarBytesBE$1,numberToHexUnpadded:()=>numberToHexUnpadded$2,numberToBytesLE:()=>numberToBytesLE$2,numberToBytesBE:()=>numberToBytesBE$2,hexToNumber:()=>hexToNumber$2,hexToBytes:()=>hexToBytes$4,equalBytes:()=>equalBytes$2,ensureBytes:()=>ensureBytes$2,createHmacDrbg:()=>createHmacDrbg$2,concatBytes:()=>concatBytes2,bytesToNumberLE:()=>bytesToNumberLE$2,bytesToNumberBE:()=>bytesToNumberBE$2,bytesToHex:()=>bytesToHex$4,bitSet:()=>bitSet$1,bitMask:()=>bitMask$2,bitLen:()=>bitLen$2,bitGet:()=>bitGet$1});var _0n$a=BigInt(0),_1n$a=BigInt(1),_2n$6=BigInt(2),u8a2=n=>n instanceof Uint8Array,hexes$3=Array.from({length:256},(n,t)=>t.toString(16).padStart(2,"0"));function bytesToHex$4(n){if(!u8a2(n))throw new Error("Uint8Array expected");let t="";for(let r=0;r<n.length;r++)t+=hexes$3[n[r]];return t}function numberToHexUnpadded$2(n){const t=n.toString(16);return t.length&1?`0${t}`:t}function hexToNumber$2(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return BigInt(n===""?"0":`0x${n}`)}function hexToBytes$4(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);const t=n.length;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(t/2);for(let s=0;s<r.length;s++){const o=s*2,a=n.slice(o,o+2),c=Number.parseInt(a,16);if(Number.isNaN(c)||c<0)throw new Error("Invalid byte sequence");r[s]=c}return r}function bytesToNumberBE$2(n){return hexToNumber$2(bytesToHex$4(n))}function bytesToNumberLE$2(n){if(!u8a2(n))throw new Error("Uint8Array expected");return hexToNumber$2(bytesToHex$4(Uint8Array.from(n).reverse()))}function numberToBytesBE$2(n,t){return hexToBytes$4(n.toString(16).padStart(t*2,"0"))}function numberToBytesLE$2(n,t){return numberToBytesBE$2(n,t).reverse()}function numberToVarBytesBE$1(n){return hexToBytes$4(numberToHexUnpadded$2(n))}function ensureBytes$2(n,t,r){let s;if(typeof t=="string")try{s=hexToBytes$4(t)}catch(a){throw new Error(`${n} must be valid hex string, got "${t}". Cause: ${a}`)}else if(u8a2(t))s=Uint8Array.from(t);else throw new Error(`${n} must be hex string or Uint8Array`);const o=s.length;if(typeof r=="number"&&o!==r)throw new Error(`${n} expected ${r} bytes, got ${o}`);return s}function concatBytes2(...n){const t=new Uint8Array(n.reduce((s,o)=>s+o.length,0));let r=0;return n.forEach(s=>{if(!u8a2(s))throw new Error("Uint8Array expected");t.set(s,r),r+=s.length}),t}function equalBytes$2(n,t){if(n.length!==t.length)return!1;for(let r=0;r<n.length;r++)if(n[r]!==t[r])return!1;return!0}function utf8ToBytes2(n){if(typeof n!="string")throw new Error(`utf8ToBytes expected string, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}function bitLen$2(n){let t;for(t=0;n>_0n$a;n>>=_1n$a,t+=1);return t}function bitGet$1(n,t){return n>>BigInt(t)&_1n$a}var bitSet$1=(n,t,r)=>n|(r?_1n$a:_0n$a)<<BigInt(t),bitMask$2=n=>(_2n$6<<BigInt(n-1))-_1n$a,u8n$1=n=>new Uint8Array(n),u8fr$1=n=>Uint8Array.from(n);function createHmacDrbg$2(n,t,r){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof r!="function")throw new Error("hmacFn must be a function");let s=u8n$1(n),o=u8n$1(n),a=0;const c=()=>{s.fill(1),o.fill(0),a=0},f=(...k)=>r(o,s,...k),g=(k=u8n$1())=>{o=f(u8fr$1([0]),k),s=f(),k.length!==0&&(o=f(u8fr$1([1]),k),s=f())},m=()=>{if(a++>=1e3)throw new Error("drbg: tried 1000 values");let k=0;const _=[];for(;k<t;){s=f();const A=s.slice();_.push(A),k+=s.length}return concatBytes2(..._)};return(k,_)=>{c(),g(k);let A;for(;!(A=_(m()));)g();return c(),A}}var validatorFns$1={bigint:n=>typeof n=="bigint",function:n=>typeof n=="function",boolean:n=>typeof n=="boolean",string:n=>typeof n=="string",stringOrUint8Array:n=>typeof n=="string"||n instanceof Uint8Array,isSafeInteger:n=>Number.isSafeInteger(n),array:n=>Array.isArray(n),field:(n,t)=>t.Fp.isValid(n),hash:n=>typeof n=="function"&&Number.isSafeInteger(n.outputLen)};function validateObject$1(n,t,r={}){const s=(o,a,c)=>{const f=validatorFns$1[a];if(typeof f!="function")throw new Error(`Invalid validator "${a}", expected function`);const g=n[o];if(!(c&&g===void 0)&&!f(g,n))throw new Error(`Invalid param ${String(o)}=${g} (${typeof g}), expected ${a}`)};for(const[o,a]of Object.entries(t))s(o,a,!1);for(const[o,a]of Object.entries(r))s(o,a,!0);return n}var _0n2=BigInt(0),_1n2=BigInt(1),_2n2=BigInt(2),_3n$4=BigInt(3),_4n$3=BigInt(4),_5n$2=BigInt(5),_8n$2=BigInt(8);BigInt(9);BigInt(16);function mod$2(n,t){const r=n%t;return r>=_0n2?r:t+r}function pow$1(n,t,r){if(r<=_0n2||t<_0n2)throw new Error("Expected power/modulo > 0");if(r===_1n2)return _0n2;let s=_1n2;for(;t>_0n2;)t&_1n2&&(s=s*n%r),n=n*n%r,t>>=_1n2;return s}function pow2$2(n,t,r){let s=n;for(;t-- >_0n2;)s*=s,s%=r;return s}function invert$2(n,t){if(n===_0n2||t<=_0n2)throw new Error(`invert: expected positive integers, got n=${n} mod=${t}`);let r=mod$2(n,t),s=t,o=_0n2,a=_1n2;for(;r!==_0n2;){const f=s/r,g=s%r,m=o-a*f;s=r,r=g,o=a,a=m}if(s!==_1n2)throw new Error("invert: does not exist");return mod$2(o,t)}function tonelliShanks$2(n){const t=(n-_1n2)/_2n2;let r,s,o;for(r=n-_1n2,s=0;r%_2n2===_0n2;r/=_2n2,s++);for(o=_2n2;o<n&&pow$1(o,t,n)!==n-_1n2;o++);if(s===1){const c=(n+_1n2)/_4n$3;return function(g,m){const b=g.pow(m,c);if(!g.eql(g.sqr(b),m))throw new Error("Cannot find square root");return b}}const a=(r+_1n2)/_2n2;return function(f,g){if(f.pow(g,t)===f.neg(f.ONE))throw new Error("Cannot find square root");let m=s,b=f.pow(f.mul(f.ONE,o),r),k=f.pow(g,a),_=f.pow(g,r);for(;!f.eql(_,f.ONE);){if(f.eql(_,f.ZERO))return f.ZERO;let A=1;for(let L=f.sqr(_);A<m&&!f.eql(L,f.ONE);A++)L=f.sqr(L);const B=f.pow(b,_1n2<<BigInt(m-A-1));b=f.sqr(B),k=f.mul(k,B),_=f.mul(_,b),m=A}return k}}function FpSqrt$2(n){if(n%_4n$3===_3n$4){const t=(n+_1n2)/_4n$3;return function(s,o){const a=s.pow(o,t);if(!s.eql(s.sqr(a),o))throw new Error("Cannot find square root");return a}}if(n%_8n$2===_5n$2){const t=(n-_5n$2)/_8n$2;return function(s,o){const a=s.mul(o,_2n2),c=s.pow(a,t),f=s.mul(o,c),g=s.mul(s.mul(f,_2n2),c),m=s.mul(f,s.sub(g,s.ONE));if(!s.eql(s.sqr(m),o))throw new Error("Cannot find square root");return m}}return tonelliShanks$2(n)}var FIELD_FIELDS$2=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function validateField$2(n){const t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},r=FIELD_FIELDS$2.reduce((s,o)=>(s[o]="function",s),t);return validateObject$1(n,r)}function FpPow$2(n,t,r){if(r<_0n2)throw new Error("Expected power > 0");if(r===_0n2)return n.ONE;if(r===_1n2)return t;let s=n.ONE,o=t;for(;r>_0n2;)r&_1n2&&(s=n.mul(s,o)),o=n.sqr(o),r>>=_1n2;return s}function FpInvertBatch$2(n,t){const r=new Array(t.length),s=t.reduce((a,c,f)=>n.is0(c)?a:(r[f]=a,n.mul(a,c)),n.ONE),o=n.inv(s);return t.reduceRight((a,c,f)=>n.is0(c)?a:(r[f]=n.mul(a,r[f]),n.mul(a,c)),o),r}function nLength$2(n,t){const r=t!==void 0?t:n.toString(2).length,s=Math.ceil(r/8);return{nBitLength:r,nByteLength:s}}function Field$2(n,t,r=!1,s={}){if(n<=_0n2)throw new Error(`Expected Field ORDER > 0, got ${n}`);const{nBitLength:o,nByteLength:a}=nLength$2(n,t);if(a>2048)throw new Error("Field lengths over 2048 bytes are not supported");const c=FpSqrt$2(n),f=Object.freeze({ORDER:n,BITS:o,BYTES:a,MASK:bitMask$2(o),ZERO:_0n2,ONE:_1n2,create:g=>mod$2(g,n),isValid:g=>{if(typeof g!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof g}`);return _0n2<=g&&g<n},is0:g=>g===_0n2,isOdd:g=>(g&_1n2)===_1n2,neg:g=>mod$2(-g,n),eql:(g,m)=>g===m,sqr:g=>mod$2(g*g,n),add:(g,m)=>mod$2(g+m,n),sub:(g,m)=>mod$2(g-m,n),mul:(g,m)=>mod$2(g*m,n),pow:(g,m)=>FpPow$2(f,g,m),div:(g,m)=>mod$2(g*invert$2(m,n),n),sqrN:g=>g*g,addN:(g,m)=>g+m,subN:(g,m)=>g-m,mulN:(g,m)=>g*m,inv:g=>invert$2(g,n),sqrt:s.sqrt||(g=>c(f,g)),invertBatch:g=>FpInvertBatch$2(f,g),cmov:(g,m,b)=>b?m:g,toBytes:g=>r?numberToBytesLE$2(g,a):numberToBytesBE$2(g,a),fromBytes:g=>{if(g.length!==a)throw new Error(`Fp.fromBytes: expected ${a}, got ${g.length}`);return r?bytesToNumberLE$2(g):bytesToNumberBE$2(g)}});return Object.freeze(f)}function getFieldBytesLength$2(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const t=n.toString(2).length;return Math.ceil(t/8)}function getMinHashLength$2(n){const t=getFieldBytesLength$2(n);return t+Math.ceil(t/2)}function mapHashToField$2(n,t,r=!1){const s=n.length,o=getFieldBytesLength$2(t),a=getMinHashLength$2(t);if(s<16||s<a||s>1024)throw new Error(`expected ${a}-1024 bytes of input, got ${s}`);const c=r?bytesToNumberBE$2(n):bytesToNumberLE$2(n),f=mod$2(c,t-_1n2)+_1n2;return r?numberToBytesLE$2(f,o):numberToBytesBE$2(f,o)}var _0n3=BigInt(0),_1n3=BigInt(1);function wNAF$2(n,t){const r=(o,a)=>{const c=a.negate();return o?c:a},s=o=>{const a=Math.ceil(t/o)+1,c=2**(o-1);return{windows:a,windowSize:c}};return{constTimeNegate:r,unsafeLadder(o,a){let c=n.ZERO,f=o;for(;a>_0n3;)a&_1n3&&(c=c.add(f)),f=f.double(),a>>=_1n3;return c},precomputeWindow(o,a){const{windows:c,windowSize:f}=s(a),g=[];let m=o,b=m;for(let k=0;k<c;k++){b=m,g.push(b);for(let _=1;_<f;_++)b=b.add(m),g.push(b);m=b.double()}return g},wNAF(o,a,c){const{windows:f,windowSize:g}=s(o);let m=n.ZERO,b=n.BASE;const k=BigInt(2**o-1),_=2**o,A=BigInt(o);for(let B=0;B<f;B++){const L=B*g;let Z=Number(c&k);c>>=A,Z>g&&(Z-=_,c+=_1n3);const ve=L,We=L+Math.abs(Z)-1,re=B%2!==0,ze=Z<0;Z===0?b=b.add(r(re,a[ve])):m=m.add(r(ze,a[We]))}return{p:m,f:b}},wNAFCached(o,a,c,f){const g=o._WINDOW_SIZE||1;let m=a.get(o);return m||(m=this.precomputeWindow(o,g),g!==1&&a.set(o,f(m))),this.wNAF(g,m,c)}}}function validateBasic$1(n){return validateField$2(n.Fp),validateObject$1(n,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...nLength$2(n.n,n.nBitLength),...n,p:n.Fp.ORDER})}function validatePointOpts$1(n){const t=validateBasic$1(n);validateObject$1(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:r,Fp:s,a:o}=t;if(r){if(!s.eql(o,s.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof r!="object"||typeof r.beta!="bigint"||typeof r.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...t})}var{bytesToNumberBE:b2n$1,hexToBytes:h2b$1}=exports_utils,DER$2={Err:class extends Error{constructor(t=""){super(t)}},_parseInt(n){const{Err:t}=DER$2;if(n.length<2||n[0]!==2)throw new t("Invalid signature integer tag");const r=n[1],s=n.subarray(2,r+2);if(!r||s.length!==r)throw new t("Invalid signature integer: wrong length");if(s[0]&128)throw new t("Invalid signature integer: negative");if(s[0]===0&&!(s[1]&128))throw new t("Invalid signature integer: unnecessary leading zero");return{d:b2n$1(s),l:n.subarray(r+2)}},toSig(n){const{Err:t}=DER$2,r=typeof n=="string"?h2b$1(n):n;if(!(r instanceof Uint8Array))throw new Error("ui8a expected");let s=r.length;if(s<2||r[0]!=48)throw new t("Invalid signature tag");if(r[1]!==s-2)throw new t("Invalid signature: incorrect length");const{d:o,l:a}=DER$2._parseInt(r.subarray(2)),{d:c,l:f}=DER$2._parseInt(a);if(f.length)throw new t("Invalid signature: left bytes after parsing");return{r:o,s:c}},hexFromSig(n){const t=m=>Number.parseInt(m[0],16)&8?"00"+m:m,r=m=>{const b=m.toString(16);return b.length&1?`0${b}`:b},s=t(r(n.s)),o=t(r(n.r)),a=s.length/2,c=o.length/2,f=r(a),g=r(c);return`30${r(c+a+4)}02${g}${o}02${f}${s}`}},_0n4=BigInt(0),_1n4=BigInt(1);BigInt(2);var _3n2=BigInt(3);BigInt(4);function weierstrassPoints$1(n){const t=validatePointOpts$1(n),{Fp:r}=t,s=t.toBytes||((B,L,Z)=>{const ve=L.toAffine();return concatBytes2(Uint8Array.from([4]),r.toBytes(ve.x),r.toBytes(ve.y))}),o=t.fromBytes||(B=>{const L=B.subarray(1),Z=r.fromBytes(L.subarray(0,r.BYTES)),ve=r.fromBytes(L.subarray(r.BYTES,2*r.BYTES));return{x:Z,y:ve}});function a(B){const{a:L,b:Z}=t,ve=r.sqr(B),We=r.mul(ve,B);return r.add(r.add(We,r.mul(B,L)),Z)}if(!r.eql(r.sqr(t.Gy),a(t.Gx)))throw new Error("bad generator point: equation left != right");function c(B){return typeof B=="bigint"&&_0n4<B&&B<t.n}function f(B){if(!c(B))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function g(B){const{allowedPrivateKeyLengths:L,nByteLength:Z,wrapPrivateKey:ve,n:We}=t;if(L&&typeof B!="bigint"){if(B instanceof Uint8Array&&(B=bytesToHex$4(B)),typeof B!="string"||!L.includes(B.length))throw new Error("Invalid key");B=B.padStart(Z*2,"0")}let re;try{re=typeof B=="bigint"?B:bytesToNumberBE$2(ensureBytes$2("private key",B,Z))}catch{throw new Error(`private key must be ${Z} bytes, hex or bigint, not ${typeof B}`)}return ve&&(re=mod$2(re,We)),f(re),re}const m=new Map;function b(B){if(!(B instanceof k))throw new Error("ProjectivePoint expected")}class k{constructor(L,Z,ve){if(this.px=L,this.py=Z,this.pz=ve,L==null||!r.isValid(L))throw new Error("x required");if(Z==null||!r.isValid(Z))throw new Error("y required");if(ve==null||!r.isValid(ve))throw new Error("z required")}static fromAffine(L){const{x:Z,y:ve}=L||{};if(!L||!r.isValid(Z)||!r.isValid(ve))throw new Error("invalid affine point");if(L instanceof k)throw new Error("projective point not allowed");const We=re=>r.eql(re,r.ZERO);return We(Z)&&We(ve)?k.ZERO:new k(Z,ve,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(L){const Z=r.invertBatch(L.map(ve=>ve.pz));return L.map((ve,We)=>ve.toAffine(Z[We])).map(k.fromAffine)}static fromHex(L){const Z=k.fromAffine(o(ensureBytes$2("pointHex",L)));return Z.assertValidity(),Z}static fromPrivateKey(L){return k.BASE.multiply(g(L))}_setWindowSize(L){this._WINDOW_SIZE=L,m.delete(this)}assertValidity(){if(this.is0()){if(t.allowInfinityPoint&&!r.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:L,y:Z}=this.toAffine();if(!r.isValid(L)||!r.isValid(Z))throw new Error("bad point: x or y not FE");const ve=r.sqr(Z),We=a(L);if(!r.eql(ve,We))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:L}=this.toAffine();if(r.isOdd)return!r.isOdd(L);throw new Error("Field doesn't support isOdd")}equals(L){b(L);const{px:Z,py:ve,pz:We}=this,{px:re,py:ze,pz:se}=L,ne=r.eql(r.mul(Z,se),r.mul(re,We)),X=r.eql(r.mul(ve,se),r.mul(ze,We));return ne&&X}negate(){return new k(this.px,r.neg(this.py),this.pz)}double(){const{a:L,b:Z}=t,ve=r.mul(Z,_3n2),{px:We,py:re,pz:ze}=this;let{ZERO:se,ZERO:ne,ZERO:X}=r,$e=r.mul(We,We),Ve=r.mul(re,re),Ze=r.mul(ze,ze),He=r.mul(We,re);return He=r.add(He,He),X=r.mul(We,ze),X=r.add(X,X),se=r.mul(L,X),ne=r.mul(ve,Ze),ne=r.add(se,ne),se=r.sub(Ve,ne),ne=r.add(Ve,ne),ne=r.mul(se,ne),se=r.mul(He,se),X=r.mul(ve,X),Ze=r.mul(L,Ze),He=r.sub($e,Ze),He=r.mul(L,He),He=r.add(He,X),X=r.add($e,$e),$e=r.add(X,$e),$e=r.add($e,Ze),$e=r.mul($e,He),ne=r.add(ne,$e),Ze=r.mul(re,ze),Ze=r.add(Ze,Ze),$e=r.mul(Ze,He),se=r.sub(se,$e),X=r.mul(Ze,Ve),X=r.add(X,X),X=r.add(X,X),new k(se,ne,X)}add(L){b(L);const{px:Z,py:ve,pz:We}=this,{px:re,py:ze,pz:se}=L;let{ZERO:ne,ZERO:X,ZERO:$e}=r;const Ve=t.a,Ze=r.mul(t.b,_3n2);let He=r.mul(Z,re),Le=r.mul(ve,ze),Q=r.mul(We,se),oe=r.add(Z,ve),Y=r.add(re,ze);oe=r.mul(oe,Y),Y=r.add(He,Le),oe=r.sub(oe,Y),Y=r.add(Z,We);let Ce=r.add(re,se);return Y=r.mul(Y,Ce),Ce=r.add(He,Q),Y=r.sub(Y,Ce),Ce=r.add(ve,We),ne=r.add(ze,se),Ce=r.mul(Ce,ne),ne=r.add(Le,Q),Ce=r.sub(Ce,ne),$e=r.mul(Ve,Y),ne=r.mul(Ze,Q),$e=r.add(ne,$e),ne=r.sub(Le,$e),$e=r.add(Le,$e),X=r.mul(ne,$e),Le=r.add(He,He),Le=r.add(Le,He),Q=r.mul(Ve,Q),Y=r.mul(Ze,Y),Le=r.add(Le,Q),Q=r.sub(He,Q),Q=r.mul(Ve,Q),Y=r.add(Y,Q),He=r.mul(Le,Y),X=r.add(X,He),He=r.mul(Ce,Y),ne=r.mul(oe,ne),ne=r.sub(ne,He),He=r.mul(oe,Le),$e=r.mul(Ce,$e),$e=r.add($e,He),new k(ne,X,$e)}subtract(L){return this.add(L.negate())}is0(){return this.equals(k.ZERO)}wNAF(L){return A.wNAFCached(this,m,L,Z=>{const ve=r.invertBatch(Z.map(We=>We.pz));return Z.map((We,re)=>We.toAffine(ve[re])).map(k.fromAffine)})}multiplyUnsafe(L){const Z=k.ZERO;if(L===_0n4)return Z;if(f(L),L===_1n4)return this;const{endo:ve}=t;if(!ve)return A.unsafeLadder(this,L);let{k1neg:We,k1:re,k2neg:ze,k2:se}=ve.splitScalar(L),ne=Z,X=Z,$e=this;for(;re>_0n4||se>_0n4;)re&_1n4&&(ne=ne.add($e)),se&_1n4&&(X=X.add($e)),$e=$e.double(),re>>=_1n4,se>>=_1n4;return We&&(ne=ne.negate()),ze&&(X=X.negate()),X=new k(r.mul(X.px,ve.beta),X.py,X.pz),ne.add(X)}multiply(L){f(L);let Z=L,ve,We;const{endo:re}=t;if(re){const{k1neg:ze,k1:se,k2neg:ne,k2:X}=re.splitScalar(Z);let{p:$e,f:Ve}=this.wNAF(se),{p:Ze,f:He}=this.wNAF(X);$e=A.constTimeNegate(ze,$e),Ze=A.constTimeNegate(ne,Ze),Ze=new k(r.mul(Ze.px,re.beta),Ze.py,Ze.pz),ve=$e.add(Ze),We=Ve.add(He)}else{const{p:ze,f:se}=this.wNAF(Z);ve=ze,We=se}return k.normalizeZ([ve,We])[0]}multiplyAndAddUnsafe(L,Z,ve){const We=k.BASE,re=(se,ne)=>ne===_0n4||ne===_1n4||!se.equals(We)?se.multiplyUnsafe(ne):se.multiply(ne),ze=re(this,Z).add(re(L,ve));return ze.is0()?void 0:ze}toAffine(L){const{px:Z,py:ve,pz:We}=this,re=this.is0();L==null&&(L=re?r.ONE:r.inv(We));const ze=r.mul(Z,L),se=r.mul(ve,L),ne=r.mul(We,L);if(re)return{x:r.ZERO,y:r.ZERO};if(!r.eql(ne,r.ONE))throw new Error("invZ was invalid");return{x:ze,y:se}}isTorsionFree(){const{h:L,isTorsionFree:Z}=t;if(L===_1n4)return!0;if(Z)return Z(k,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:L,clearCofactor:Z}=t;return L===_1n4?this:Z?Z(k,this):this.multiplyUnsafe(t.h)}toRawBytes(L=!0){return this.assertValidity(),s(k,this,L)}toHex(L=!0){return bytesToHex$4(this.toRawBytes(L))}}k.BASE=new k(t.Gx,t.Gy,r.ONE),k.ZERO=new k(r.ZERO,r.ONE,r.ZERO);const _=t.nBitLength,A=wNAF$2(k,t.endo?Math.ceil(_/2):_);return{CURVE:t,ProjectivePoint:k,normPrivateKeyToScalar:g,weierstrassEquation:a,isWithinCurveOrder:c}}function validateOpts$1(n){const t=validateBasic$1(n);return validateObject$1(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}function weierstrass$2(n){const t=validateOpts$1(n),{Fp:r,n:s}=t,o=r.BYTES+1,a=2*r.BYTES+1;function c(Y){return _0n4<Y&&Y<r.ORDER}function f(Y){return mod$2(Y,s)}function g(Y){return invert$2(Y,s)}const{ProjectivePoint:m,normPrivateKeyToScalar:b,weierstrassEquation:k,isWithinCurveOrder:_}=weierstrassPoints$1({...t,toBytes(Y,Ce,je){const Je=Ce.toAffine(),Ge=r.toBytes(Je.x),Xe=concatBytes2;return je?Xe(Uint8Array.from([Ce.hasEvenY()?2:3]),Ge):Xe(Uint8Array.from([4]),Ge,r.toBytes(Je.y))},fromBytes(Y){const Ce=Y.length,je=Y[0],Je=Y.subarray(1);if(Ce===o&&(je===2||je===3)){const Ge=bytesToNumberBE$2(Je);if(!c(Ge))throw new Error("Point is not on curve");const Xe=k(Ge);let Qe=r.sqrt(Xe);const rt=(Qe&_1n4)===_1n4;return(je&1)===1!==rt&&(Qe=r.neg(Qe)),{x:Ge,y:Qe}}else if(Ce===a&&je===4){const Ge=r.fromBytes(Je.subarray(0,r.BYTES)),Xe=r.fromBytes(Je.subarray(r.BYTES,2*r.BYTES));return{x:Ge,y:Xe}}else throw new Error(`Point of length ${Ce} was invalid. Expected ${o} compressed bytes or ${a} uncompressed bytes`)}}),A=Y=>bytesToHex$4(numberToBytesBE$2(Y,t.nByteLength));function B(Y){const Ce=s>>_1n4;return Y>Ce}function L(Y){return B(Y)?f(-Y):Y}const Z=(Y,Ce,je)=>bytesToNumberBE$2(Y.slice(Ce,je));class ve{constructor(Ce,je,Je){this.r=Ce,this.s=je,this.recovery=Je,this.assertValidity()}static fromCompact(Ce){const je=t.nByteLength;return Ce=ensureBytes$2("compactSignature",Ce,je*2),new ve(Z(Ce,0,je),Z(Ce,je,2*je))}static fromDER(Ce){const{r:je,s:Je}=DER$2.toSig(ensureBytes$2("DER",Ce));return new ve(je,Je)}assertValidity(){if(!_(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!_(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(Ce){return new ve(this.r,this.s,Ce)}recoverPublicKey(Ce){const{r:je,s:Je,recovery:Ge}=this,Xe=X(ensureBytes$2("msgHash",Ce));if(Ge==null||![0,1,2,3].includes(Ge))throw new Error("recovery id invalid");const Qe=Ge===2||Ge===3?je+t.n:je;if(Qe>=r.ORDER)throw new Error("recovery id 2 or 3 invalid");const rt=(Ge&1)===0?"02":"03",_t=m.fromHex(rt+A(Qe)),ht=g(Qe),ot=f(-Xe*ht),xt=f(Je*ht),St=m.BASE.multiplyAndAddUnsafe(_t,ot,xt);if(!St)throw new Error("point at infinify");return St.assertValidity(),St}hasHighS(){return B(this.s)}normalizeS(){return this.hasHighS()?new ve(this.r,f(-this.s),this.recovery):this}toDERRawBytes(){return hexToBytes$4(this.toDERHex())}toDERHex(){return DER$2.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return hexToBytes$4(this.toCompactHex())}toCompactHex(){return A(this.r)+A(this.s)}}const We={isValidPrivateKey(Y){try{return b(Y),!0}catch{return!1}},normPrivateKeyToScalar:b,randomPrivateKey:()=>{const Y=getMinHashLength$2(t.n);return mapHashToField$2(t.randomBytes(Y),t.n)},precompute(Y=8,Ce=m.BASE){return Ce._setWindowSize(Y),Ce.multiply(BigInt(3)),Ce}};function re(Y,Ce=!0){return m.fromPrivateKey(Y).toRawBytes(Ce)}function ze(Y){const Ce=Y instanceof Uint8Array,je=typeof Y=="string",Je=(Ce||je)&&Y.length;return Ce?Je===o||Je===a:je?Je===2*o||Je===2*a:Y instanceof m}function se(Y,Ce,je=!0){if(ze(Y))throw new Error("first arg must be private key");if(!ze(Ce))throw new Error("second arg must be public key");return m.fromHex(Ce).multiply(b(Y)).toRawBytes(je)}const ne=t.bits2int||function(Y){const Ce=bytesToNumberBE$2(Y),je=Y.length*8-t.nBitLength;return je>0?Ce>>BigInt(je):Ce},X=t.bits2int_modN||function(Y){return f(ne(Y))},$e=bitMask$2(t.nBitLength);function Ve(Y){if(typeof Y!="bigint")throw new Error("bigint expected");if(!(_0n4<=Y&&Y<$e))throw new Error(`bigint expected < 2^${t.nBitLength}`);return numberToBytesBE$2(Y,t.nByteLength)}function Ze(Y,Ce,je=He){if(["recovered","canonical"].some(Bt=>Bt in je))throw new Error("sign() legacy options not supported");const{hash:Je,randomBytes:Ge}=t;let{lowS:Xe,prehash:Qe,extraEntropy:rt}=je;Xe==null&&(Xe=!0),Y=ensureBytes$2("msgHash",Y),Qe&&(Y=ensureBytes$2("prehashed msgHash",Je(Y)));const _t=X(Y),ht=b(Ce),ot=[Ve(ht),Ve(_t)];if(rt!=null){const Bt=rt===!0?Ge(r.BYTES):rt;ot.push(ensureBytes$2("extraEntropy",Bt))}const xt=concatBytes2(...ot),St=_t;function Mt(Bt){const Ut=ne(Bt);if(!_(Ut))return;const Jt=g(Ut),Ft=m.BASE.multiply(Ut).toAffine(),Xt=f(Ft.x);if(Xt===_0n4)return;const rn=f(Jt*f(St+Xt*ht));if(rn===_0n4)return;let on=(Ft.x===Xt?0:2)|Number(Ft.y&_1n4),nn=rn;return Xe&&B(rn)&&(nn=L(rn),on^=1),new ve(Xt,nn,on)}return{seed:xt,k2sig:Mt}}const He={lowS:t.lowS,prehash:!1},Le={lowS:t.lowS,prehash:!1};function Q(Y,Ce,je=He){const{seed:Je,k2sig:Ge}=Ze(Y,Ce,je),Xe=t;return createHmacDrbg$2(Xe.hash.outputLen,Xe.nByteLength,Xe.hmac)(Je,Ge)}m.BASE._setWindowSize(8);function oe(Y,Ce,je,Je=Le){const Ge=Y;if(Ce=ensureBytes$2("msgHash",Ce),je=ensureBytes$2("publicKey",je),"strict"in Je)throw new Error("options.strict was renamed to lowS");const{lowS:Xe,prehash:Qe}=Je;let rt,_t;try{if(typeof Ge=="string"||Ge instanceof Uint8Array)try{rt=ve.fromDER(Ge)}catch(Ft){if(!(Ft instanceof DER$2.Err))throw Ft;rt=ve.fromCompact(Ge)}else if(typeof Ge=="object"&&typeof Ge.r=="bigint"&&typeof Ge.s=="bigint"){const{r:Ft,s:Xt}=Ge;rt=new ve(Ft,Xt)}else throw new Error("PARSE");_t=m.fromHex(je)}catch(Ft){if(Ft.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(Xe&&rt.hasHighS())return!1;Qe&&(Ce=t.hash(Ce));const{r:ht,s:ot}=rt,xt=X(Ce),St=g(ot),Mt=f(xt*St),Bt=f(ht*St),Ut=m.BASE.multiplyAndAddUnsafe(_t,Mt,Bt)?.toAffine();return Ut?f(Ut.x)===ht:!1}return{CURVE:t,getPublicKey:re,getSharedSecret:se,sign:Q,verify:oe,ProjectivePoint:m,Signature:ve,utils:We}}let HMAC$3=class extends Hash$3{constructor(t,r){super(),this.finished=!1,this.destroyed=!1,hash$2(t);const s=toBytes$4(r);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,a=new Uint8Array(o);a.set(s.length>o?t.create().update(s).digest():s);for(let c=0;c<a.length;c++)a[c]^=54;this.iHash.update(a),this.oHash=t.create();for(let c=0;c<a.length;c++)a[c]^=106;this.oHash.update(a),a.fill(0)}update(t){return exists$3(this),this.iHash.update(t),this}digestInto(t){exists$3(this),bytes$4(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:r,iHash:s,finished:o,destroyed:a,blockLen:c,outputLen:f}=this;return t=t,t.finished=o,t.destroyed=a,t.blockLen=c,t.outputLen=f,t.oHash=r._cloneInto(t.oHash),t.iHash=s._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}};var hmac$3=(n,t,r)=>new HMAC$3(n,t).update(r).digest();hmac$3.create=(n,t)=>new HMAC$3(n,t);function getHash$1(n){return{hash:n,hmac:(t,...r)=>hmac$3(n,t,concatBytes$4(...r)),randomBytes:randomBytes$3}}function createCurve$2(n,t){const r=s=>weierstrass$2({...n,...getHash$1(s)});return Object.freeze({...r(t),create:r})}var secp256k1P$1=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),secp256k1N$1=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),_1n5=BigInt(1),_2n4=BigInt(2),divNearest$2=(n,t)=>(n+t/_2n4)/t;function sqrtMod$2(n){const t=secp256k1P$1,r=BigInt(3),s=BigInt(6),o=BigInt(11),a=BigInt(22),c=BigInt(23),f=BigInt(44),g=BigInt(88),m=n*n*n%t,b=m*m*n%t,k=pow2$2(b,r,t)*b%t,_=pow2$2(k,r,t)*b%t,A=pow2$2(_,_2n4,t)*m%t,B=pow2$2(A,o,t)*A%t,L=pow2$2(B,a,t)*B%t,Z=pow2$2(L,f,t)*L%t,ve=pow2$2(Z,g,t)*Z%t,We=pow2$2(ve,f,t)*L%t,re=pow2$2(We,r,t)*b%t,ze=pow2$2(re,c,t)*B%t,se=pow2$2(ze,s,t)*m%t,ne=pow2$2(se,_2n4,t);if(!Fp$1.eql(Fp$1.sqr(ne),n))throw new Error("Cannot find square root");return ne}var Fp$1=Field$2(secp256k1P$1,void 0,void 0,{sqrt:sqrtMod$2}),secp256k1$2=createCurve$2({a:BigInt(0),b:BigInt(7),Fp:Fp$1,n:secp256k1N$1,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:n=>{const t=secp256k1N$1,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),s=-_1n5*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),a=r,c=BigInt("0x100000000000000000000000000000000"),f=divNearest$2(a*n,t),g=divNearest$2(-s*n,t);let m=mod$2(n-f*r-g*o,t),b=mod$2(-f*s-g*a,t);const k=m>c,_=b>c;if(k&&(m=t-m),_&&(b=t-b),m>c||b>c)throw new Error("splitScalar: Endomorphism failed, k="+n);return{k1neg:k,k1:m,k2neg:_,k2:b}}}},sha256$4),_0n5=BigInt(0),fe$2=n=>typeof n=="bigint"&&_0n5<n&&n<secp256k1P$1,ge$2=n=>typeof n=="bigint"&&_0n5<n&&n<secp256k1N$1,TAGGED_HASH_PREFIXES$2={};function taggedHash$2(n,...t){let r=TAGGED_HASH_PREFIXES$2[n];if(r===void 0){const s=sha256$4(Uint8Array.from(n,o=>o.charCodeAt(0)));r=concatBytes2(s,s),TAGGED_HASH_PREFIXES$2[n]=r}return sha256$4(concatBytes2(r,...t))}var pointToBytes$2=n=>n.toRawBytes(!0).slice(1),numTo32b$1=n=>numberToBytesBE$2(n,32),modP$1=n=>mod$2(n,secp256k1P$1),modN$1=n=>mod$2(n,secp256k1N$1),Point$2=secp256k1$2.ProjectivePoint,GmulAdd$1=(n,t,r)=>Point$2.BASE.multiplyAndAddUnsafe(n,t,r);function schnorrGetExtPubKey$2(n){let t=secp256k1$2.utils.normPrivateKeyToScalar(n),r=Point$2.fromPrivateKey(t);return{scalar:r.hasEvenY()?t:modN$1(-t),bytes:pointToBytes$2(r)}}function lift_x$2(n){if(!fe$2(n))throw new Error("bad x: need 0 < x < p");const t=modP$1(n*n),r=modP$1(t*n+BigInt(7));let s=sqrtMod$2(r);s%_2n4!==_0n5&&(s=modP$1(-s));const o=new Point$2(n,s,_1n5);return o.assertValidity(),o}function challenge$2(...n){return modN$1(bytesToNumberBE$2(taggedHash$2("BIP0340/challenge",...n)))}function schnorrGetPublicKey$2(n){return schnorrGetExtPubKey$2(n).bytes}function schnorrSign$2(n,t,r=randomBytes$3(32)){const s=ensureBytes$2("message",n),{bytes:o,scalar:a}=schnorrGetExtPubKey$2(t),c=ensureBytes$2("auxRand",r,32),f=numTo32b$1(a^bytesToNumberBE$2(taggedHash$2("BIP0340/aux",c))),g=taggedHash$2("BIP0340/nonce",f,o,s),m=modN$1(bytesToNumberBE$2(g));if(m===_0n5)throw new Error("sign failed: k is zero");const{bytes:b,scalar:k}=schnorrGetExtPubKey$2(m),_=challenge$2(b,o,s),A=new Uint8Array(64);if(A.set(b,0),A.set(numTo32b$1(modN$1(k+_*a)),32),!schnorrVerify$2(A,s,o))throw new Error("sign: Invalid signature produced");return A}function schnorrVerify$2(n,t,r){const s=ensureBytes$2("signature",n,64),o=ensureBytes$2("message",t),a=ensureBytes$2("publicKey",r,32);try{const c=lift_x$2(bytesToNumberBE$2(a)),f=bytesToNumberBE$2(s.subarray(0,32));if(!fe$2(f))return!1;const g=bytesToNumberBE$2(s.subarray(32,64));if(!ge$2(g))return!1;const m=challenge$2(numTo32b$1(f),pointToBytes$2(c),o),b=GmulAdd$1(c,g,modN$1(-m));return!(!b||!b.hasEvenY()||b.toAffine().x!==f)}catch{return!1}}var schnorr$2={getPublicKey:schnorrGetPublicKey$2,sign:schnorrSign$2,verify:schnorrVerify$2,utils:{randomPrivateKey:secp256k1$2.utils.randomPrivateKey,lift_x:lift_x$2,pointToBytes:pointToBytes$2,numberToBytesBE:numberToBytesBE$2,bytesToNumberBE:bytesToNumberBE$2,taggedHash:taggedHash$2,mod:mod$2}},crypto2=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var u8a3=n=>n instanceof Uint8Array,u32$2=n=>new Uint32Array(n.buffer,n.byteOffset,Math.floor(n.byteLength/4)),createView2=n=>new DataView(n.buffer,n.byteOffset,n.byteLength),rotr2=(n,t)=>n<<32-t|n>>>t,isLE2=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE2)throw new Error("Non little-endian hardware is not supported");var hexes2=Array.from({length:256},(n,t)=>t.toString(16).padStart(2,"0"));function bytesToHex2(n){if(!u8a3(n))throw new Error("Uint8Array expected");let t="";for(let r=0;r<n.length;r++)t+=hexes2[n[r]];return t}function hexToBytes2(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);const t=n.length;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(t/2);for(let s=0;s<r.length;s++){const o=s*2,a=n.slice(o,o+2),c=Number.parseInt(a,16);if(Number.isNaN(c)||c<0)throw new Error("Invalid byte sequence");r[s]=c}return r}function utf8ToBytes3(n){if(typeof n!="string")throw new Error(`utf8ToBytes expected string, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}function toBytes2(n){if(typeof n=="string"&&(n=utf8ToBytes3(n)),!u8a3(n))throw new Error(`expected Uint8Array, got ${typeof n}`);return n}function concatBytes3(...n){const t=new Uint8Array(n.reduce((s,o)=>s+o.length,0));let r=0;return n.forEach(s=>{if(!u8a3(s))throw new Error("Uint8Array expected");t.set(s,r),r+=s.length}),t}class Hash2{clone(){return this._cloneInto()}}var isPlainObject$1=n=>Object.prototype.toString.call(n)==="[object Object]"&&n.constructor===Object;function checkOpts$2(n,t){if(t!==void 0&&(typeof t!="object"||!isPlainObject$1(t)))throw new Error("Options should be object or undefined");return Object.assign(n,t)}function wrapConstructor2(n){const t=s=>n().update(toBytes2(s)).digest(),r=n();return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=()=>n(),t}function randomBytes2(n=32){if(crypto2&&typeof crypto2.getRandomValues=="function")return crypto2.getRandomValues(new Uint8Array(n));throw new Error("crypto.getRandomValues must be defined")}function number2(n){if(!Number.isSafeInteger(n)||n<0)throw new Error(`Wrong positive integer: ${n}`)}function bool$2(n){if(typeof n!="boolean")throw new Error(`Expected boolean, not ${n}`)}function bytes2(n,...t){if(!(n instanceof Uint8Array))throw new Error("Expected Uint8Array");if(t.length>0&&!t.includes(n.length))throw new Error(`Expected Uint8Array of length ${t}, not of length=${n.length}`)}function hash2(n){if(typeof n!="function"||typeof n.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");number2(n.outputLen),number2(n.blockLen)}function exists2(n,t=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(t&&n.finished)throw new Error("Hash#digest() has already been called")}function output2(n,t){bytes2(n);const r=t.outputLen;if(n.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}var assert$1={number:number2,bool:bool$2,bytes:bytes2,hash:hash2,exists:exists2,output:output2},_assert_default=assert$1;function setBigUint642(n,t,r,s){if(typeof n.setBigUint64=="function")return n.setBigUint64(t,r,s);const o=BigInt(32),a=BigInt(4294967295),c=Number(r>>o&a),f=Number(r&a),g=s?4:0,m=s?0:4;n.setUint32(t+g,c,s),n.setUint32(t+m,f,s)}class SHA22 extends Hash2{constructor(t,r,s,o){super(),this.blockLen=t,this.outputLen=r,this.padOffset=s,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=createView2(this.buffer)}update(t){_assert_default.exists(this);const{view:r,buffer:s,blockLen:o}=this;t=toBytes2(t);const a=t.length;for(let c=0;c<a;){const f=Math.min(o-this.pos,a-c);if(f===o){const g=createView2(t);for(;o<=a-c;c+=o)this.process(g,c);continue}s.set(t.subarray(c,c+f),this.pos),this.pos+=f,c+=f,this.pos===o&&(this.process(r,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){_assert_default.exists(this),_assert_default.output(t,this),this.finished=!0;const{buffer:r,view:s,blockLen:o,isLE:a}=this;let{pos:c}=this;r[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>o-c&&(this.process(s,0),c=0);for(let k=c;k<o;k++)r[k]=0;setBigUint642(s,o-8,BigInt(this.length*8),a),this.process(s,0);const f=createView2(t),g=this.outputLen;if(g%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const m=g/4,b=this.get();if(m>b.length)throw new Error("_sha2: outputLen bigger than state");for(let k=0;k<m;k++)f.setUint32(4*k,b[k],a)}digest(){const{buffer:t,outputLen:r}=this;this.digestInto(t);const s=t.slice(0,r);return this.destroy(),s}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:r,buffer:s,length:o,finished:a,destroyed:c,pos:f}=this;return t.length=o,t.pos=f,t.finished=a,t.destroyed=c,o%r&&t.buffer.set(s),t}}var Chi2=(n,t,r)=>n&t^~n&r,Maj2=(n,t,r)=>n&t^n&r^t&r,SHA256_K2=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),IV2=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W2=new Uint32Array(64);class SHA2562 extends SHA22{constructor(){super(64,32,8,!1),this.A=IV2[0]|0,this.B=IV2[1]|0,this.C=IV2[2]|0,this.D=IV2[3]|0,this.E=IV2[4]|0,this.F=IV2[5]|0,this.G=IV2[6]|0,this.H=IV2[7]|0}get(){const{A:t,B:r,C:s,D:o,E:a,F:c,G:f,H:g}=this;return[t,r,s,o,a,c,f,g]}set(t,r,s,o,a,c,f,g){this.A=t|0,this.B=r|0,this.C=s|0,this.D=o|0,this.E=a|0,this.F=c|0,this.G=f|0,this.H=g|0}process(t,r){for(let k=0;k<16;k++,r+=4)SHA256_W2[k]=t.getUint32(r,!1);for(let k=16;k<64;k++){const _=SHA256_W2[k-15],A=SHA256_W2[k-2],B=rotr2(_,7)^rotr2(_,18)^_>>>3,L=rotr2(A,17)^rotr2(A,19)^A>>>10;SHA256_W2[k]=L+SHA256_W2[k-7]+B+SHA256_W2[k-16]|0}let{A:s,B:o,C:a,D:c,E:f,F:g,G:m,H:b}=this;for(let k=0;k<64;k++){const _=rotr2(f,6)^rotr2(f,11)^rotr2(f,25),A=b+_+Chi2(f,g,m)+SHA256_K2[k]+SHA256_W2[k]|0,L=(rotr2(s,2)^rotr2(s,13)^rotr2(s,22))+Maj2(s,o,a)|0;b=m,m=g,g=f,f=c+A|0,c=a,a=o,o=s,s=A+L|0}s=s+this.A|0,o=o+this.B|0,a=a+this.C|0,c=c+this.D|0,f=f+this.E|0,g=g+this.F|0,m=m+this.G|0,b=b+this.H|0,this.set(s,o,a,c,f,g,m,b)}roundClean(){SHA256_W2.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}let SHA224$1=class extends SHA2562{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}};var sha2562=wrapConstructor2(()=>new SHA2562);wrapConstructor2(()=>new SHA224$1);function assertNumber$2(n){if(!Number.isSafeInteger(n))throw new Error(`Wrong integer: ${n}`)}function chain$3(...n){const t=(o,a)=>c=>o(a(c)),r=Array.from(n).reverse().reduce((o,a)=>o?t(o,a.encode):a.encode,void 0),s=n.reduce((o,a)=>o?t(o,a.decode):a.decode,void 0);return{encode:r,decode:s}}function alphabet$3(n){return{encode:t=>{if(!Array.isArray(t)||t.length&&typeof t[0]!="number")throw new Error("alphabet.encode input should be an array of numbers");return t.map(r=>{if(assertNumber$2(r),r<0||r>=n.length)throw new Error(`Digit index outside alphabet: ${r} (alphabet: ${n.length})`);return n[r]})},decode:t=>{if(!Array.isArray(t)||t.length&&typeof t[0]!="string")throw new Error("alphabet.decode input should be array of strings");return t.map(r=>{if(typeof r!="string")throw new Error(`alphabet.decode: not string element=${r}`);const s=n.indexOf(r);if(s===-1)throw new Error(`Unknown letter: "${r}". Allowed: ${n}`);return s})}}}function join$3(n=""){if(typeof n!="string")throw new Error("join separator should be string");return{encode:t=>{if(!Array.isArray(t)||t.length&&typeof t[0]!="string")throw new Error("join.encode input should be array of strings");for(let r of t)if(typeof r!="string")throw new Error(`join.encode: non-string input=${r}`);return t.join(n)},decode:t=>{if(typeof t!="string")throw new Error("join.decode input should be string");return t.split(n)}}}function padding$2(n,t="="){if(assertNumber$2(n),typeof t!="string")throw new Error("padding chr should be string");return{encode(r){if(!Array.isArray(r)||r.length&&typeof r[0]!="string")throw new Error("padding.encode input should be array of strings");for(let s of r)if(typeof s!="string")throw new Error(`padding.encode: non-string input=${s}`);for(;r.length*n%8;)r.push(t);return r},decode(r){if(!Array.isArray(r)||r.length&&typeof r[0]!="string")throw new Error("padding.encode input should be array of strings");for(let o of r)if(typeof o!="string")throw new Error(`padding.decode: non-string input=${o}`);let s=r.length;if(s*n%8)throw new Error("Invalid padding: string should have whole number of bytes");for(;s>0&&r[s-1]===t;s--)if(!((s-1)*n%8))throw new Error("Invalid padding: string has too much padding");return r.slice(0,s)}}}function normalize$3(n){if(typeof n!="function")throw new Error("normalize fn should be function");return{encode:t=>t,decode:t=>n(t)}}function convertRadix$3(n,t,r){if(t<2)throw new Error(`convertRadix: wrong from=${t}, base cannot be less than 2`);if(r<2)throw new Error(`convertRadix: wrong to=${r}, base cannot be less than 2`);if(!Array.isArray(n))throw new Error("convertRadix: data should be array");if(!n.length)return[];let s=0;const o=[],a=Array.from(n);for(a.forEach(c=>{if(assertNumber$2(c),c<0||c>=t)throw new Error(`Wrong integer: ${c}`)});;){let c=0,f=!0;for(let g=s;g<a.length;g++){const m=a[g],b=t*c+m;if(!Number.isSafeInteger(b)||t*c/t!==c||b-m!==t*c)throw new Error("convertRadix: carry overflow");if(c=b%r,a[g]=Math.floor(b/r),!Number.isSafeInteger(a[g])||a[g]*r+c!==b)throw new Error("convertRadix: carry overflow");if(f)a[g]?f=!1:s=g;else continue}if(o.push(c),f)break}for(let c=0;c<n.length-1&&n[c]===0;c++)o.push(0);return o.reverse()}var gcd$3=(n,t)=>t?gcd$3(t,n%t):n,radix2carry$3=(n,t)=>n+(t-gcd$3(n,t));function convertRadix2$3(n,t,r,s){if(!Array.isArray(n))throw new Error("convertRadix2: data should be array");if(t<=0||t>32)throw new Error(`convertRadix2: wrong from=${t}`);if(r<=0||r>32)throw new Error(`convertRadix2: wrong to=${r}`);if(radix2carry$3(t,r)>32)throw new Error(`convertRadix2: carry overflow from=${t} to=${r} carryBits=${radix2carry$3(t,r)}`);let o=0,a=0;const c=2**r-1,f=[];for(const g of n){if(assertNumber$2(g),g>=2**t)throw new Error(`convertRadix2: invalid data word=${g} from=${t}`);if(o=o<<t|g,a+t>32)throw new Error(`convertRadix2: carry overflow pos=${a} from=${t}`);for(a+=t;a>=r;a-=r)f.push((o>>a-r&c)>>>0);o&=2**a-1}if(o=o<<r-a&c,!s&&a>=t)throw new Error("Excess padding");if(!s&&o)throw new Error(`Non-zero padding: ${o}`);return s&&a>0&&f.push(o>>>0),f}function radix$3(n){return assertNumber$2(n),{encode:t=>{if(!(t instanceof Uint8Array))throw new Error("radix.encode input should be Uint8Array");return convertRadix$3(Array.from(t),2**8,n)},decode:t=>{if(!Array.isArray(t)||t.length&&typeof t[0]!="number")throw new Error("radix.decode input should be array of strings");return Uint8Array.from(convertRadix$3(t,n,2**8))}}}function radix2$3(n,t=!1){if(assertNumber$2(n),n<=0||n>32)throw new Error("radix2: bits should be in (0..32]");if(radix2carry$3(8,n)>32||radix2carry$3(n,8)>32)throw new Error("radix2: carry overflow");return{encode:r=>{if(!(r instanceof Uint8Array))throw new Error("radix2.encode input should be Uint8Array");return convertRadix2$3(Array.from(r),8,n,!t)},decode:r=>{if(!Array.isArray(r)||r.length&&typeof r[0]!="number")throw new Error("radix2.decode input should be array of strings");return Uint8Array.from(convertRadix2$3(r,n,8,t))}}}function unsafeWrapper$3(n){if(typeof n!="function")throw new Error("unsafeWrapper fn should be function");return function(...t){try{return n.apply(null,t)}catch{}}}var base16$2=chain$3(radix2$3(4),alphabet$3("0123456789ABCDEF"),join$3("")),base32$2=chain$3(radix2$3(5),alphabet$3("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),padding$2(5),join$3(""));chain$3(radix2$3(5),alphabet$3("0123456789ABCDEFGHIJKLMNOPQRSTUV"),padding$2(5),join$3(""));chain$3(radix2$3(5),alphabet$3("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),join$3(""),normalize$3(n=>n.toUpperCase().replace(/O/g,"0").replace(/[IL]/g,"1")));var base64$2=chain$3(radix2$3(6),alphabet$3("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),padding$2(6),join$3("")),base64url$2=chain$3(radix2$3(6),alphabet$3("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),padding$2(6),join$3("")),genBase58$3=n=>chain$3(radix$3(58),alphabet$3(n),join$3("")),base58$3=genBase58$3("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");genBase58$3("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");genBase58$3("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");var XMR_BLOCK_LEN$2=[0,2,3,5,6,7,9,10,11],base58xmr$2={encode(n){let t="";for(let r=0;r<n.length;r+=8){const s=n.subarray(r,r+8);t+=base58$3.encode(s).padStart(XMR_BLOCK_LEN$2[s.length],"1")}return t},decode(n){let t=[];for(let r=0;r<n.length;r+=11){const s=n.slice(r,r+11),o=XMR_BLOCK_LEN$2.indexOf(s.length),a=base58$3.decode(s);for(let c=0;c<a.length-o;c++)if(a[c]!==0)throw new Error("base58xmr: wrong padding");t=t.concat(Array.from(a.slice(a.length-o)))}return Uint8Array.from(t)}},BECH_ALPHABET$3=chain$3(alphabet$3("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),join$3("")),POLYMOD_GENERATORS$3=[996825010,642813549,513874426,1027748829,705979059];function bech32Polymod$3(n){const t=n>>25;let r=(n&33554431)<<5;for(let s=0;s<POLYMOD_GENERATORS$3.length;s++)(t>>s&1)===1&&(r^=POLYMOD_GENERATORS$3[s]);return r}function bechChecksum$3(n,t,r=1){const s=n.length;let o=1;for(let a=0;a<s;a++){const c=n.charCodeAt(a);if(c<33||c>126)throw new Error(`Invalid prefix (${n})`);o=bech32Polymod$3(o)^c>>5}o=bech32Polymod$3(o);for(let a=0;a<s;a++)o=bech32Polymod$3(o)^n.charCodeAt(a)&31;for(let a of t)o=bech32Polymod$3(o)^a;for(let a=0;a<6;a++)o=bech32Polymod$3(o);return o^=r,BECH_ALPHABET$3.encode(convertRadix2$3([o%2**30],30,5,!1))}function genBech32$3(n){const t=n==="bech32"?1:734539939,r=radix2$3(5),s=r.decode,o=r.encode,a=unsafeWrapper$3(s);function c(b,k,_=90){if(typeof b!="string")throw new Error(`bech32.encode prefix should be string, not ${typeof b}`);if(!Array.isArray(k)||k.length&&typeof k[0]!="number")throw new Error(`bech32.encode words should be array of numbers, not ${typeof k}`);const A=b.length+7+k.length;if(_!==!1&&A>_)throw new TypeError(`Length ${A} exceeds limit ${_}`);return b=b.toLowerCase(),`${b}1${BECH_ALPHABET$3.encode(k)}${bechChecksum$3(b,k,t)}`}function f(b,k=90){if(typeof b!="string")throw new Error(`bech32.decode input should be string, not ${typeof b}`);if(b.length<8||k!==!1&&b.length>k)throw new TypeError(`Wrong string length: ${b.length} (${b}). Expected (8..${k})`);const _=b.toLowerCase();if(b!==_&&b!==b.toUpperCase())throw new Error("String must be lowercase or uppercase");b=_;const A=b.lastIndexOf("1");if(A===0||A===-1)throw new Error('Letter "1" must be present between prefix and data only');const B=b.slice(0,A),L=b.slice(A+1);if(L.length<6)throw new Error("Data must be at least 6 characters long");const Z=BECH_ALPHABET$3.decode(L).slice(0,-6),ve=bechChecksum$3(B,Z,t);if(!L.endsWith(ve))throw new Error(`Invalid checksum in ${b}: expected "${ve}"`);return{prefix:B,words:Z}}const g=unsafeWrapper$3(f);function m(b){const{prefix:k,words:_}=f(b,!1);return{prefix:k,words:_,bytes:s(_)}}return{encode:c,decode:f,decodeToBytes:m,decodeUnsafe:g,fromWords:s,fromWordsUnsafe:a,toWords:o}}var bech32$3=genBech32$3("bech32");genBech32$3("bech32m");var utf8$2={encode:n=>new TextDecoder().decode(n),decode:n=>new TextEncoder().encode(n)},hex$2=chain$3(radix2$3(4),alphabet$3("0123456789abcdef"),join$3(""),normalize$3(n=>{if(typeof n!="string"||n.length%2)throw new TypeError(`hex.decode: expected string, got ${typeof n} with length ${n.length}`);return n.toLowerCase()})),CODERS$2={utf8:utf8$2,hex:hex$2,base16:base16$2,base32:base32$2,base64:base64$2,base64url:base64url$2,base58:base58$3,base58xmr:base58xmr$2};`${Object.keys(CODERS$2).join(", ")}`;function number3(n){if(!Number.isSafeInteger(n)||n<0)throw new Error(`positive integer expected, not ${n}`)}function bool2(n){if(typeof n!="boolean")throw new Error(`boolean expected, not ${n}`)}function isBytes$3(n){return n instanceof Uint8Array||n!=null&&typeof n=="object"&&n.constructor.name==="Uint8Array"}function bytes3(n,...t){if(!isBytes$3(n))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(n.length))throw new Error(`Uint8Array expected of length ${t}, not of length=${n.length}`)}function exists3(n,t=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(t&&n.finished)throw new Error("Hash#digest() has already been called")}function output3(n,t){bytes3(n);const r=t.outputLen;if(n.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}var u8=n=>new Uint8Array(n.buffer,n.byteOffset,n.byteLength),u322=n=>new Uint32Array(n.buffer,n.byteOffset,Math.floor(n.byteLength/4)),createView3=n=>new DataView(n.buffer,n.byteOffset,n.byteLength),isLE3=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE3)throw new Error("Non little-endian hardware is not supported");function utf8ToBytes4(n){if(typeof n!="string")throw new Error(`string expected, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}function toBytes3(n){if(typeof n=="string")n=utf8ToBytes4(n);else if(isBytes$3(n))n=n.slice();else throw new Error(`Uint8Array expected, got ${typeof n}`);return n}function checkOpts2(n,t){if(t==null||typeof t!="object")throw new Error("options must be defined");return Object.assign(n,t)}function equalBytes2(n,t){if(n.length!==t.length)return!1;let r=0;for(let s=0;s<n.length;s++)r|=n[s]^t[s];return r===0}var wrapCipher$1=(n,t)=>(Object.assign(t,n),t);function setBigUint643(n,t,r,s){if(typeof n.setBigUint64=="function")return n.setBigUint64(t,r,s);const o=BigInt(32),a=BigInt(4294967295),c=Number(r>>o&a),f=Number(r&a),g=s?4:0,m=s?0:4;n.setUint32(t+g,c,s),n.setUint32(t+m,f,s)}var BLOCK_SIZE$1=16,ZEROS16$1=new Uint8Array(16),ZEROS32$1=u322(ZEROS16$1),POLY$1=225,mul2$1=(n,t,r,s)=>{const o=s&1;return{s3:r<<31|s>>>1,s2:t<<31|r>>>1,s1:n<<31|t>>>1,s0:n>>>1^POLY$1<<24&-(o&1)}},swapLE=n=>(n>>>0&255)<<24|(n>>>8&255)<<16|(n>>>16&255)<<8|n>>>24&255|0;function _toGHASHKey(n){n.reverse();const t=n[15]&1;let r=0;for(let s=0;s<n.length;s++){const o=n[s];n[s]=o>>>1|r,r=(o&1)<<7}return n[0]^=-t&225,n}var estimateWindow=n=>n>64*1024?8:n>1024?4:2;class GHASH{constructor(t,r){this.blockLen=BLOCK_SIZE$1,this.outputLen=BLOCK_SIZE$1,this.s0=0,this.s1=0,this.s2=0,this.s3=0,this.finished=!1,t=toBytes3(t),bytes3(t,16);const s=createView3(t);let o=s.getUint32(0,!1),a=s.getUint32(4,!1),c=s.getUint32(8,!1),f=s.getUint32(12,!1);const g=[];for(let B=0;B<128;B++)g.push({s0:swapLE(o),s1:swapLE(a),s2:swapLE(c),s3:swapLE(f)}),{s0:o,s1:a,s2:c,s3:f}=mul2$1(o,a,c,f);const m=estimateWindow(r||1024);if(![1,2,4,8].includes(m))throw new Error(`ghash: wrong window size=${m}, should be 2, 4 or 8`);this.W=m;const k=128/m,_=this.windowSize=2**m,A=[];for(let B=0;B<k;B++)for(let L=0;L<_;L++){let Z=0,ve=0,We=0,re=0;for(let ze=0;ze<m;ze++){if(!(L>>>m-ze-1&1))continue;const{s0:ne,s1:X,s2:$e,s3:Ve}=g[m*B+ze];Z^=ne,ve^=X,We^=$e,re^=Ve}A.push({s0:Z,s1:ve,s2:We,s3:re})}this.t=A}_updateBlock(t,r,s,o){t^=this.s0,r^=this.s1,s^=this.s2,o^=this.s3;const{W:a,t:c,windowSize:f}=this;let g=0,m=0,b=0,k=0;const _=(1<<a)-1;let A=0;for(const B of[t,r,s,o])for(let L=0;L<4;L++){const Z=B>>>8*L&255;for(let ve=8/a-1;ve>=0;ve--){const We=Z>>>a*ve&_,{s0:re,s1:ze,s2:se,s3:ne}=c[A*f+We];g^=re,m^=ze,b^=se,k^=ne,A+=1}}this.s0=g,this.s1=m,this.s2=b,this.s3=k}update(t){t=toBytes3(t),exists3(this);const r=u322(t),s=Math.floor(t.length/BLOCK_SIZE$1),o=t.length%BLOCK_SIZE$1;for(let a=0;a<s;a++)this._updateBlock(r[a*4+0],r[a*4+1],r[a*4+2],r[a*4+3]);return o&&(ZEROS16$1.set(t.subarray(s*BLOCK_SIZE$1)),this._updateBlock(ZEROS32$1[0],ZEROS32$1[1],ZEROS32$1[2],ZEROS32$1[3]),ZEROS32$1.fill(0)),this}destroy(){const{t}=this;for(const r of t)r.s0=0,r.s1=0,r.s2=0,r.s3=0}digestInto(t){exists3(this),output3(t,this),this.finished=!0;const{s0:r,s1:s,s2:o,s3:a}=this,c=u322(t);return c[0]=r,c[1]=s,c[2]=o,c[3]=a,t}digest(){const t=new Uint8Array(BLOCK_SIZE$1);return this.digestInto(t),this.destroy(),t}}class Polyval extends GHASH{constructor(t,r){t=toBytes3(t);const s=_toGHASHKey(t.slice());super(s,r),s.fill(0)}update(t){t=toBytes3(t),exists3(this);const r=u322(t),s=t.length%BLOCK_SIZE$1,o=Math.floor(t.length/BLOCK_SIZE$1);for(let a=0;a<o;a++)this._updateBlock(swapLE(r[a*4+3]),swapLE(r[a*4+2]),swapLE(r[a*4+1]),swapLE(r[a*4+0]));return s&&(ZEROS16$1.set(t.subarray(o*BLOCK_SIZE$1)),this._updateBlock(swapLE(ZEROS32$1[3]),swapLE(ZEROS32$1[2]),swapLE(ZEROS32$1[1]),swapLE(ZEROS32$1[0])),ZEROS32$1.fill(0)),this}digestInto(t){exists3(this),output3(t,this),this.finished=!0;const{s0:r,s1:s,s2:o,s3:a}=this,c=u322(t);return c[0]=r,c[1]=s,c[2]=o,c[3]=a,t.reverse()}}function wrapConstructorWithKey$1(n){const t=(s,o)=>n(o,s.length).update(toBytes3(s)).digest(),r=n(new Uint8Array(16),0);return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=(s,o)=>n(s,o),t}var ghash=wrapConstructorWithKey$1((n,t)=>new GHASH(n,t)),polyval=wrapConstructorWithKey$1((n,t)=>new Polyval(n,t)),BLOCK_SIZE2=16,BLOCK_SIZE32=4,EMPTY_BLOCK=new Uint8Array(BLOCK_SIZE2),POLY2=283;function mul22(n){return n<<1^POLY2&-(n>>7)}function mul$1(n,t){let r=0;for(;t>0;t>>=1)r^=n&-(t&1),n=mul22(n);return r}var sbox$1=(()=>{let n=new Uint8Array(256);for(let r=0,s=1;r<256;r++,s^=mul22(s))n[r]=s;const t=new Uint8Array(256);t[0]=99;for(let r=0;r<255;r++){let s=n[255-r];s|=s<<8,t[n[r]]=(s^s>>4^s>>5^s>>6^s>>7^99)&255}return t})(),invSbox$1=sbox$1.map((n,t)=>sbox$1.indexOf(t)),rotr32_8$1=n=>n<<24|n>>>8,rotl32_8$1=n=>n<<8|n>>>24;function genTtable$1(n,t){if(n.length!==256)throw new Error("Wrong sbox length");const r=new Uint32Array(256).map((m,b)=>t(n[b])),s=r.map(rotl32_8$1),o=s.map(rotl32_8$1),a=o.map(rotl32_8$1),c=new Uint32Array(256*256),f=new Uint32Array(256*256),g=new Uint16Array(256*256);for(let m=0;m<256;m++)for(let b=0;b<256;b++){const k=m*256+b;c[k]=r[m]^s[b],f[k]=o[m]^a[b],g[k]=n[m]<<8|n[b]}return{sbox:n,sbox2:g,T0:r,T1:s,T2:o,T3:a,T01:c,T23:f}}var tableEncoding$1=genTtable$1(sbox$1,n=>mul$1(n,3)<<24|n<<16|n<<8|mul$1(n,2)),tableDecoding$1=genTtable$1(invSbox$1,n=>mul$1(n,11)<<24|mul$1(n,13)<<16|mul$1(n,9)<<8|mul$1(n,14)),xPowers$1=(()=>{const n=new Uint8Array(16);for(let t=0,r=1;t<16;t++,r=mul22(r))n[t]=r;return n})();function expandKeyLE$1(n){bytes3(n);const t=n.length;if(![16,24,32].includes(t))throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${t}`);const{sbox2:r}=tableEncoding$1,s=u322(n),o=s.length,a=f=>applySbox$1(r,f,f,f,f),c=new Uint32Array(t+28);c.set(s);for(let f=o;f<c.length;f++){let g=c[f-1];f%o===0?g=a(rotr32_8$1(g))^xPowers$1[f/o-1]:o>6&&f%o===4&&(g=a(g)),c[f]=c[f-o]^g}return c}function expandKeyDecLE$1(n){const t=expandKeyLE$1(n),r=t.slice(),s=t.length,{sbox2:o}=tableEncoding$1,{T0:a,T1:c,T2:f,T3:g}=tableDecoding$1;for(let m=0;m<s;m+=4)for(let b=0;b<4;b++)r[m+b]=t[s-m-4+b];t.fill(0);for(let m=4;m<s-4;m++){const b=r[m],k=applySbox$1(o,b,b,b,b);r[m]=a[k&255]^c[k>>>8&255]^f[k>>>16&255]^g[k>>>24]}return r}function apply0123$1(n,t,r,s,o,a){return n[r<<8&65280|s>>>8&255]^t[o>>>8&65280|a>>>24&255]}function applySbox$1(n,t,r,s,o){return n[t&255|r&65280]|n[s>>>16&255|o>>>16&65280]<<16}function encrypt$4(n,t,r,s,o){const{sbox2:a,T01:c,T23:f}=tableEncoding$1;let g=0;t^=n[g++],r^=n[g++],s^=n[g++],o^=n[g++];const m=n.length/4-2;for(let B=0;B<m;B++){const L=n[g++]^apply0123$1(c,f,t,r,s,o),Z=n[g++]^apply0123$1(c,f,r,s,o,t),ve=n[g++]^apply0123$1(c,f,s,o,t,r),We=n[g++]^apply0123$1(c,f,o,t,r,s);t=L,r=Z,s=ve,o=We}const b=n[g++]^applySbox$1(a,t,r,s,o),k=n[g++]^applySbox$1(a,r,s,o,t),_=n[g++]^applySbox$1(a,s,o,t,r),A=n[g++]^applySbox$1(a,o,t,r,s);return{s0:b,s1:k,s2:_,s3:A}}function decrypt$4(n,t,r,s,o){const{sbox2:a,T01:c,T23:f}=tableDecoding$1;let g=0;t^=n[g++],r^=n[g++],s^=n[g++],o^=n[g++];const m=n.length/4-2;for(let B=0;B<m;B++){const L=n[g++]^apply0123$1(c,f,t,o,s,r),Z=n[g++]^apply0123$1(c,f,r,t,o,s),ve=n[g++]^apply0123$1(c,f,s,r,t,o),We=n[g++]^apply0123$1(c,f,o,s,r,t);t=L,r=Z,s=ve,o=We}const b=n[g++]^applySbox$1(a,t,o,s,r),k=n[g++]^applySbox$1(a,r,t,o,s),_=n[g++]^applySbox$1(a,s,r,t,o),A=n[g++]^applySbox$1(a,o,s,r,t);return{s0:b,s1:k,s2:_,s3:A}}function getDst$1(n,t){if(!t)return new Uint8Array(n);if(bytes3(t),t.length<n)throw new Error(`aes: wrong destination length, expected at least ${n}, got: ${t.length}`);return t}function ctrCounter(n,t,r,s){bytes3(t,BLOCK_SIZE2),bytes3(r);const o=r.length;s=getDst$1(o,s);const a=t,c=u322(a);let{s0:f,s1:g,s2:m,s3:b}=encrypt$4(n,c[0],c[1],c[2],c[3]);const k=u322(r),_=u322(s);for(let B=0;B+4<=k.length;B+=4){_[B+0]=k[B+0]^f,_[B+1]=k[B+1]^g,_[B+2]=k[B+2]^m,_[B+3]=k[B+3]^b;let L=1;for(let Z=a.length-1;Z>=0;Z--)L=L+(a[Z]&255)|0,a[Z]=L&255,L>>>=8;({s0:f,s1:g,s2:m,s3:b}=encrypt$4(n,c[0],c[1],c[2],c[3]))}const A=BLOCK_SIZE2*Math.floor(k.length/BLOCK_SIZE32);if(A<o){const B=new Uint32Array([f,g,m,b]),L=u8(B);for(let Z=A,ve=0;Z<o;Z++,ve++)s[Z]=r[Z]^L[ve]}return s}function ctr32(n,t,r,s,o){bytes3(r,BLOCK_SIZE2),bytes3(s),o=getDst$1(s.length,o);const a=r,c=u322(a),f=createView3(a),g=u322(s),m=u322(o),b=t?0:12,k=s.length;let _=f.getUint32(b,t),{s0:A,s1:B,s2:L,s3:Z}=encrypt$4(n,c[0],c[1],c[2],c[3]);for(let We=0;We+4<=g.length;We+=4)m[We+0]=g[We+0]^A,m[We+1]=g[We+1]^B,m[We+2]=g[We+2]^L,m[We+3]=g[We+3]^Z,_=_+1>>>0,f.setUint32(b,_,t),{s0:A,s1:B,s2:L,s3:Z}=encrypt$4(n,c[0],c[1],c[2],c[3]);const ve=BLOCK_SIZE2*Math.floor(g.length/BLOCK_SIZE32);if(ve<k){const We=new Uint32Array([A,B,L,Z]),re=u8(We);for(let ze=ve,se=0;ze<k;ze++,se++)o[ze]=s[ze]^re[se]}return o}wrapCipher$1({blockSize:16,nonceLength:16},function n(t,r){bytes3(t),bytes3(r,BLOCK_SIZE2);function s(o,a){const c=expandKeyLE$1(t),f=r.slice(),g=ctrCounter(c,f,o,a);return c.fill(0),f.fill(0),g}return{encrypt:(o,a)=>s(o,a),decrypt:(o,a)=>s(o,a)}});function validateBlockDecrypt$1(n){if(bytes3(n),n.length%BLOCK_SIZE2!==0)throw new Error(`aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size ${BLOCK_SIZE2}`)}function validateBlockEncrypt$1(n,t,r){let s=n.length;const o=s%BLOCK_SIZE2;if(!t&&o!==0)throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");const a=u322(n);if(t){let g=BLOCK_SIZE2-o;g||(g=BLOCK_SIZE2),s=s+g}const c=getDst$1(s,r),f=u322(c);return{b:a,o:f,out:c}}function validatePCKS$1(n,t){if(!t)return n;const r=n.length;if(!r)throw new Error("aes/pcks5: empty ciphertext not allowed");const s=n[r-1];if(s<=0||s>16)throw new Error(`aes/pcks5: wrong padding byte: ${s}`);const o=n.subarray(0,-s);for(let a=0;a<s;a++)if(n[r-a-1]!==s)throw new Error("aes/pcks5: wrong padding");return o}function padPCKS$1(n){const t=new Uint8Array(16),r=u322(t);t.set(n);const s=BLOCK_SIZE2-n.length;for(let o=BLOCK_SIZE2-s;o<BLOCK_SIZE2;o++)t[o]=s;return r}wrapCipher$1({blockSize:16},function n(t,r={}){bytes3(t);const s=!r.disablePadding;return{encrypt:(o,a)=>{bytes3(o);const{b:c,o:f,out:g}=validateBlockEncrypt$1(o,s,a),m=expandKeyLE$1(t);let b=0;for(;b+4<=c.length;){const{s0:k,s1:_,s2:A,s3:B}=encrypt$4(m,c[b+0],c[b+1],c[b+2],c[b+3]);f[b++]=k,f[b++]=_,f[b++]=A,f[b++]=B}if(s){const k=padPCKS$1(o.subarray(b*4)),{s0:_,s1:A,s2:B,s3:L}=encrypt$4(m,k[0],k[1],k[2],k[3]);f[b++]=_,f[b++]=A,f[b++]=B,f[b++]=L}return m.fill(0),g},decrypt:(o,a)=>{validateBlockDecrypt$1(o);const c=expandKeyDecLE$1(t),f=getDst$1(o.length,a),g=u322(o),m=u322(f);for(let b=0;b+4<=g.length;){const{s0:k,s1:_,s2:A,s3:B}=decrypt$4(c,g[b+0],g[b+1],g[b+2],g[b+3]);m[b++]=k,m[b++]=_,m[b++]=A,m[b++]=B}return c.fill(0),validatePCKS$1(f,s)}}});var cbc$1=wrapCipher$1({blockSize:16,nonceLength:16},function n(t,r,s={}){bytes3(t),bytes3(r,16);const o=!s.disablePadding;return{encrypt:(a,c)=>{const f=expandKeyLE$1(t),{b:g,o:m,out:b}=validateBlockEncrypt$1(a,o,c),k=u322(r);let _=k[0],A=k[1],B=k[2],L=k[3],Z=0;for(;Z+4<=g.length;)_^=g[Z+0],A^=g[Z+1],B^=g[Z+2],L^=g[Z+3],{s0:_,s1:A,s2:B,s3:L}=encrypt$4(f,_,A,B,L),m[Z++]=_,m[Z++]=A,m[Z++]=B,m[Z++]=L;if(o){const ve=padPCKS$1(a.subarray(Z*4));_^=ve[0],A^=ve[1],B^=ve[2],L^=ve[3],{s0:_,s1:A,s2:B,s3:L}=encrypt$4(f,_,A,B,L),m[Z++]=_,m[Z++]=A,m[Z++]=B,m[Z++]=L}return f.fill(0),b},decrypt:(a,c)=>{validateBlockDecrypt$1(a);const f=expandKeyDecLE$1(t),g=u322(r),m=getDst$1(a.length,c),b=u322(a),k=u322(m);let _=g[0],A=g[1],B=g[2],L=g[3];for(let Z=0;Z+4<=b.length;){const ve=_,We=A,re=B,ze=L;_=b[Z+0],A=b[Z+1],B=b[Z+2],L=b[Z+3];const{s0:se,s1:ne,s2:X,s3:$e}=decrypt$4(f,_,A,B,L);k[Z++]=se^ve,k[Z++]=ne^We,k[Z++]=X^re,k[Z++]=$e^ze}return f.fill(0),validatePCKS$1(m,o)}}});wrapCipher$1({blockSize:16,nonceLength:16},function n(t,r){bytes3(t),bytes3(r,16);function s(o,a,c){const f=expandKeyLE$1(t),g=o.length;c=getDst$1(g,c);const m=u322(o),b=u322(c),k=a?b:m,_=u322(r);let A=_[0],B=_[1],L=_[2],Z=_[3];for(let We=0;We+4<=m.length;){const{s0:re,s1:ze,s2:se,s3:ne}=encrypt$4(f,A,B,L,Z);b[We+0]=m[We+0]^re,b[We+1]=m[We+1]^ze,b[We+2]=m[We+2]^se,b[We+3]=m[We+3]^ne,A=k[We++],B=k[We++],L=k[We++],Z=k[We++]}const ve=BLOCK_SIZE2*Math.floor(m.length/BLOCK_SIZE32);if(ve<g){({s0:A,s1:B,s2:L,s3:Z}=encrypt$4(f,A,B,L,Z));const We=u8(new Uint32Array([A,B,L,Z]));for(let re=ve,ze=0;re<g;re++,ze++)c[re]=o[re]^We[ze];We.fill(0)}return f.fill(0),c}return{encrypt:(o,a)=>s(o,!0,a),decrypt:(o,a)=>s(o,!1,a)}});function computeTag$1(n,t,r,s,o){const a=n.create(r,s.length+(o?.length||0));o&&a.update(o),a.update(s);const c=new Uint8Array(16),f=createView3(c);return o&&setBigUint643(f,0,BigInt(o.length*8),t),setBigUint643(f,8,BigInt(s.length*8),t),a.update(c),a.digest()}wrapCipher$1({blockSize:16,nonceLength:12,tagLength:16},function n(t,r,s){if(bytes3(r),r.length===0)throw new Error("aes/gcm: empty nonce");const o=16;function a(f,g,m){const b=computeTag$1(ghash,!1,f,m,s);for(let k=0;k<g.length;k++)b[k]^=g[k];return b}function c(){const f=expandKeyLE$1(t),g=EMPTY_BLOCK.slice(),m=EMPTY_BLOCK.slice();if(ctr32(f,!1,m,m,g),r.length===12)m.set(r);else{const k=EMPTY_BLOCK.slice(),_=createView3(k);setBigUint643(_,8,BigInt(r.length*8),!1),ghash.create(g).update(r).update(k).digestInto(m)}const b=ctr32(f,!1,m,EMPTY_BLOCK);return{xk:f,authKey:g,counter:m,tagMask:b}}return{encrypt:f=>{bytes3(f);const{xk:g,authKey:m,counter:b,tagMask:k}=c(),_=new Uint8Array(f.length+o);ctr32(g,!1,b,f,_);const A=a(m,k,_.subarray(0,_.length-o));return _.set(A,f.length),g.fill(0),_},decrypt:f=>{if(bytes3(f),f.length<o)throw new Error(`aes/gcm: ciphertext less than tagLen (${o})`);const{xk:g,authKey:m,counter:b,tagMask:k}=c(),_=f.subarray(0,-o),A=f.subarray(-o),B=a(m,k,_);if(!equalBytes2(B,A))throw new Error("aes/gcm: invalid ghash tag");const L=ctr32(g,!1,b,_);return m.fill(0),k.fill(0),g.fill(0),L}}});var limit=(n,t,r)=>s=>{if(!Number.isSafeInteger(s)||t>s||s>r)throw new Error(`${n}: invalid value=${s}, must be [${t}..${r}]`)};wrapCipher$1({blockSize:16,nonceLength:12,tagLength:16},function n(t,r,s){const a=limit("AAD",0,68719476736),c=limit("plaintext",0,2**36),f=limit("nonce",12,12),g=limit("ciphertext",16,2**36+16);bytes3(r),f(r.length),s&&(bytes3(s),a(s.length));function m(){const _=t.length;if(_!==16&&_!==24&&_!==32)throw new Error(`key length must be 16, 24 or 32 bytes, got: ${_} bytes`);const A=expandKeyLE$1(t),B=new Uint8Array(_),L=new Uint8Array(16),Z=u322(r);let ve=0,We=Z[0],re=Z[1],ze=Z[2],se=0;for(const ne of[L,B].map(u322)){const X=u322(ne);for(let $e=0;$e<X.length;$e+=2){const{s0:Ve,s1:Ze}=encrypt$4(A,ve,We,re,ze);X[$e+0]=Ve,X[$e+1]=Ze,ve=++se}}return A.fill(0),{authKey:L,encKey:expandKeyLE$1(B)}}function b(_,A,B){const L=computeTag$1(polyval,!0,A,B,s);for(let se=0;se<12;se++)L[se]^=r[se];L[15]&=127;const Z=u322(L);let ve=Z[0],We=Z[1],re=Z[2],ze=Z[3];return{s0:ve,s1:We,s2:re,s3:ze}=encrypt$4(_,ve,We,re,ze),Z[0]=ve,Z[1]=We,Z[2]=re,Z[3]=ze,L}function k(_,A,B){let L=A.slice();return L[15]|=128,ctr32(_,!0,L,B)}return{encrypt:_=>{bytes3(_),c(_.length);const{encKey:A,authKey:B}=m(),L=b(A,B,_),Z=new Uint8Array(_.length+16);return Z.set(L,_.length),Z.set(k(A,L,_)),A.fill(0),B.fill(0),Z},decrypt:_=>{bytes3(_),g(_.length);const A=_.subarray(-16),{encKey:B,authKey:L}=m(),Z=k(B,A,_.subarray(0,-16)),ve=b(B,L,Z);if(B.fill(0),L.fill(0),!equalBytes2(A,ve))throw new Error("invalid polyval tag");return Z}}});var u8to16$1=(n,t)=>n[t++]&255|(n[t++]&255)<<8;let Poly1305$1=class{constructor(t){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,t=toBytes3(t),bytes3(t,32);const r=u8to16$1(t,0),s=u8to16$1(t,2),o=u8to16$1(t,4),a=u8to16$1(t,6),c=u8to16$1(t,8),f=u8to16$1(t,10),g=u8to16$1(t,12),m=u8to16$1(t,14);this.r[0]=r&8191,this.r[1]=(r>>>13|s<<3)&8191,this.r[2]=(s>>>10|o<<6)&7939,this.r[3]=(o>>>7|a<<9)&8191,this.r[4]=(a>>>4|c<<12)&255,this.r[5]=c>>>1&8190,this.r[6]=(c>>>14|f<<2)&8191,this.r[7]=(f>>>11|g<<5)&8065,this.r[8]=(g>>>8|m<<8)&8191,this.r[9]=m>>>5&127;for(let b=0;b<8;b++)this.pad[b]=u8to16$1(t,16+2*b)}process(t,r,s=!1){const o=s?0:2048,{h:a,r:c}=this,f=c[0],g=c[1],m=c[2],b=c[3],k=c[4],_=c[5],A=c[6],B=c[7],L=c[8],Z=c[9],ve=u8to16$1(t,r+0),We=u8to16$1(t,r+2),re=u8to16$1(t,r+4),ze=u8to16$1(t,r+6),se=u8to16$1(t,r+8),ne=u8to16$1(t,r+10),X=u8to16$1(t,r+12),$e=u8to16$1(t,r+14);let Ve=a[0]+(ve&8191),Ze=a[1]+((ve>>>13|We<<3)&8191),He=a[2]+((We>>>10|re<<6)&8191),Le=a[3]+((re>>>7|ze<<9)&8191),Q=a[4]+((ze>>>4|se<<12)&8191),oe=a[5]+(se>>>1&8191),Y=a[6]+((se>>>14|ne<<2)&8191),Ce=a[7]+((ne>>>11|X<<5)&8191),je=a[8]+((X>>>8|$e<<8)&8191),Je=a[9]+($e>>>5|o),Ge=0,Xe=Ge+Ve*f+Ze*(5*Z)+He*(5*L)+Le*(5*B)+Q*(5*A);Ge=Xe>>>13,Xe&=8191,Xe+=oe*(5*_)+Y*(5*k)+Ce*(5*b)+je*(5*m)+Je*(5*g),Ge+=Xe>>>13,Xe&=8191;let Qe=Ge+Ve*g+Ze*f+He*(5*Z)+Le*(5*L)+Q*(5*B);Ge=Qe>>>13,Qe&=8191,Qe+=oe*(5*A)+Y*(5*_)+Ce*(5*k)+je*(5*b)+Je*(5*m),Ge+=Qe>>>13,Qe&=8191;let rt=Ge+Ve*m+Ze*g+He*f+Le*(5*Z)+Q*(5*L);Ge=rt>>>13,rt&=8191,rt+=oe*(5*B)+Y*(5*A)+Ce*(5*_)+je*(5*k)+Je*(5*b),Ge+=rt>>>13,rt&=8191;let _t=Ge+Ve*b+Ze*m+He*g+Le*f+Q*(5*Z);Ge=_t>>>13,_t&=8191,_t+=oe*(5*L)+Y*(5*B)+Ce*(5*A)+je*(5*_)+Je*(5*k),Ge+=_t>>>13,_t&=8191;let ht=Ge+Ve*k+Ze*b+He*m+Le*g+Q*f;Ge=ht>>>13,ht&=8191,ht+=oe*(5*Z)+Y*(5*L)+Ce*(5*B)+je*(5*A)+Je*(5*_),Ge+=ht>>>13,ht&=8191;let ot=Ge+Ve*_+Ze*k+He*b+Le*m+Q*g;Ge=ot>>>13,ot&=8191,ot+=oe*f+Y*(5*Z)+Ce*(5*L)+je*(5*B)+Je*(5*A),Ge+=ot>>>13,ot&=8191;let xt=Ge+Ve*A+Ze*_+He*k+Le*b+Q*m;Ge=xt>>>13,xt&=8191,xt+=oe*g+Y*f+Ce*(5*Z)+je*(5*L)+Je*(5*B),Ge+=xt>>>13,xt&=8191;let St=Ge+Ve*B+Ze*A+He*_+Le*k+Q*b;Ge=St>>>13,St&=8191,St+=oe*m+Y*g+Ce*f+je*(5*Z)+Je*(5*L),Ge+=St>>>13,St&=8191;let Mt=Ge+Ve*L+Ze*B+He*A+Le*_+Q*k;Ge=Mt>>>13,Mt&=8191,Mt+=oe*b+Y*m+Ce*g+je*f+Je*(5*Z),Ge+=Mt>>>13,Mt&=8191;let Bt=Ge+Ve*Z+Ze*L+He*B+Le*A+Q*_;Ge=Bt>>>13,Bt&=8191,Bt+=oe*k+Y*b+Ce*m+je*g+Je*f,Ge+=Bt>>>13,Bt&=8191,Ge=(Ge<<2)+Ge|0,Ge=Ge+Xe|0,Xe=Ge&8191,Ge=Ge>>>13,Qe+=Ge,a[0]=Xe,a[1]=Qe,a[2]=rt,a[3]=_t,a[4]=ht,a[5]=ot,a[6]=xt,a[7]=St,a[8]=Mt,a[9]=Bt}finalize(){const{h:t,pad:r}=this,s=new Uint16Array(10);let o=t[1]>>>13;t[1]&=8191;for(let f=2;f<10;f++)t[f]+=o,o=t[f]>>>13,t[f]&=8191;t[0]+=o*5,o=t[0]>>>13,t[0]&=8191,t[1]+=o,o=t[1]>>>13,t[1]&=8191,t[2]+=o,s[0]=t[0]+5,o=s[0]>>>13,s[0]&=8191;for(let f=1;f<10;f++)s[f]=t[f]+o,o=s[f]>>>13,s[f]&=8191;s[9]-=8192;let a=(o^1)-1;for(let f=0;f<10;f++)s[f]&=a;a=~a;for(let f=0;f<10;f++)t[f]=t[f]&a|s[f];t[0]=(t[0]|t[1]<<13)&65535,t[1]=(t[1]>>>3|t[2]<<10)&65535,t[2]=(t[2]>>>6|t[3]<<7)&65535,t[3]=(t[3]>>>9|t[4]<<4)&65535,t[4]=(t[4]>>>12|t[5]<<1|t[6]<<14)&65535,t[5]=(t[6]>>>2|t[7]<<11)&65535,t[6]=(t[7]>>>5|t[8]<<8)&65535,t[7]=(t[8]>>>8|t[9]<<5)&65535;let c=t[0]+r[0];t[0]=c&65535;for(let f=1;f<8;f++)c=(t[f]+r[f]|0)+(c>>>16)|0,t[f]=c&65535}update(t){exists3(this);const{buffer:r,blockLen:s}=this;t=toBytes3(t);const o=t.length;for(let a=0;a<o;){const c=Math.min(s-this.pos,o-a);if(c===s){for(;s<=o-a;a+=s)this.process(t,a);continue}r.set(t.subarray(a,a+c),this.pos),this.pos+=c,a+=c,this.pos===s&&(this.process(r,0,!1),this.pos=0)}return this}destroy(){this.h.fill(0),this.r.fill(0),this.buffer.fill(0),this.pad.fill(0)}digestInto(t){exists3(this),output3(t,this),this.finished=!0;const{buffer:r,h:s}=this;let{pos:o}=this;if(o){for(r[o++]=1;o<16;o++)r[o]=0;this.process(r,0,!0)}this.finalize();let a=0;for(let c=0;c<8;c++)t[a++]=s[c]>>>0,t[a++]=s[c]>>>8;return t}digest(){const{buffer:t,outputLen:r}=this;this.digestInto(t);const s=t.slice(0,r);return this.destroy(),s}};function wrapConstructorWithKey2(n){const t=(s,o)=>n(o).update(toBytes3(s)).digest(),r=n(new Uint8Array(32));return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=s=>n(s),t}var poly1305$1=wrapConstructorWithKey2(n=>new Poly1305$1(n)),_utf8ToBytes$1=n=>Uint8Array.from(n.split("").map(t=>t.charCodeAt(0))),sigma16$1=_utf8ToBytes$1("expand 16-byte k"),sigma32$1=_utf8ToBytes$1("expand 32-byte k"),sigma16_32$1=u322(sigma16$1),sigma32_32$1=u322(sigma32$1);sigma32_32$1.slice();function rotl$3(n,t){return n<<t|n>>>32-t}function isAligned32$1(n){return n.byteOffset%4===0}var BLOCK_LEN$1=64,BLOCK_LEN32$1=16,MAX_COUNTER$1=2**32-1,U32_EMPTY$1=new Uint32Array;function runCipher$1(n,t,r,s,o,a,c,f){const g=o.length,m=new Uint8Array(BLOCK_LEN$1),b=u322(m),k=isAligned32$1(o)&&isAligned32$1(a),_=k?u322(o):U32_EMPTY$1,A=k?u322(a):U32_EMPTY$1;for(let B=0;B<g;c++){if(n(t,r,s,b,c,f),c>=MAX_COUNTER$1)throw new Error("arx: counter overflow");const L=Math.min(BLOCK_LEN$1,g-B);if(k&&L===BLOCK_LEN$1){const Z=B/4;if(B%4!==0)throw new Error("arx: invalid block position");for(let ve=0,We;ve<BLOCK_LEN32$1;ve++)We=Z+ve,A[We]=_[We]^b[ve];B+=BLOCK_LEN$1;continue}for(let Z=0,ve;Z<L;Z++)ve=B+Z,a[ve]=o[ve]^m[Z];B+=L}}function createCipher$1(n,t){const{allowShortKeys:r,extendNonceFn:s,counterLength:o,counterRight:a,rounds:c}=checkOpts2({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},t);if(typeof n!="function")throw new Error("core must be a function");return number3(o),number3(c),bool2(a),bool2(r),(f,g,m,b,k=0)=>{bytes3(f),bytes3(g),bytes3(m);const _=m.length;if(b||(b=new Uint8Array(_)),bytes3(b),number3(k),k<0||k>=MAX_COUNTER$1)throw new Error("arx: counter overflow");if(b.length<_)throw new Error(`arx: output (${b.length}) is shorter than data (${_})`);const A=[];let B=f.length,L,Z;if(B===32)L=f.slice(),A.push(L),Z=sigma32_32$1;else if(B===16&&r)L=new Uint8Array(32),L.set(f),L.set(f,16),Z=sigma16_32$1,A.push(L);else throw new Error(`arx: invalid 32-byte key, got length=${B}`);isAligned32$1(g)||(g=g.slice(),A.push(g));const ve=u322(L);if(s){if(g.length!==24)throw new Error("arx: extended nonce must be 24 bytes");s(Z,ve,u322(g.subarray(0,16)),ve),g=g.subarray(16)}const We=16-o;if(We!==g.length)throw new Error(`arx: nonce must be ${We} or 16 bytes`);if(We!==12){const ze=new Uint8Array(12);ze.set(g,a?0:12-g.length),g=ze,A.push(g)}const re=u322(g);for(runCipher$1(n,Z,ve,re,m,b,k,c);A.length>0;)A.pop().fill(0);return b}}function chachaCore$1(n,t,r,s,o,a=20){let c=n[0],f=n[1],g=n[2],m=n[3],b=t[0],k=t[1],_=t[2],A=t[3],B=t[4],L=t[5],Z=t[6],ve=t[7],We=o,re=r[0],ze=r[1],se=r[2],ne=c,X=f,$e=g,Ve=m,Ze=b,He=k,Le=_,Q=A,oe=B,Y=L,Ce=Z,je=ve,Je=We,Ge=re,Xe=ze,Qe=se;for(let _t=0;_t<a;_t+=2)ne=ne+Ze|0,Je=rotl$3(Je^ne,16),oe=oe+Je|0,Ze=rotl$3(Ze^oe,12),ne=ne+Ze|0,Je=rotl$3(Je^ne,8),oe=oe+Je|0,Ze=rotl$3(Ze^oe,7),X=X+He|0,Ge=rotl$3(Ge^X,16),Y=Y+Ge|0,He=rotl$3(He^Y,12),X=X+He|0,Ge=rotl$3(Ge^X,8),Y=Y+Ge|0,He=rotl$3(He^Y,7),$e=$e+Le|0,Xe=rotl$3(Xe^$e,16),Ce=Ce+Xe|0,Le=rotl$3(Le^Ce,12),$e=$e+Le|0,Xe=rotl$3(Xe^$e,8),Ce=Ce+Xe|0,Le=rotl$3(Le^Ce,7),Ve=Ve+Q|0,Qe=rotl$3(Qe^Ve,16),je=je+Qe|0,Q=rotl$3(Q^je,12),Ve=Ve+Q|0,Qe=rotl$3(Qe^Ve,8),je=je+Qe|0,Q=rotl$3(Q^je,7),ne=ne+He|0,Qe=rotl$3(Qe^ne,16),Ce=Ce+Qe|0,He=rotl$3(He^Ce,12),ne=ne+He|0,Qe=rotl$3(Qe^ne,8),Ce=Ce+Qe|0,He=rotl$3(He^Ce,7),X=X+Le|0,Je=rotl$3(Je^X,16),je=je+Je|0,Le=rotl$3(Le^je,12),X=X+Le|0,Je=rotl$3(Je^X,8),je=je+Je|0,Le=rotl$3(Le^je,7),$e=$e+Q|0,Ge=rotl$3(Ge^$e,16),oe=oe+Ge|0,Q=rotl$3(Q^oe,12),$e=$e+Q|0,Ge=rotl$3(Ge^$e,8),oe=oe+Ge|0,Q=rotl$3(Q^oe,7),Ve=Ve+Ze|0,Xe=rotl$3(Xe^Ve,16),Y=Y+Xe|0,Ze=rotl$3(Ze^Y,12),Ve=Ve+Ze|0,Xe=rotl$3(Xe^Ve,8),Y=Y+Xe|0,Ze=rotl$3(Ze^Y,7);let rt=0;s[rt++]=c+ne|0,s[rt++]=f+X|0,s[rt++]=g+$e|0,s[rt++]=m+Ve|0,s[rt++]=b+Ze|0,s[rt++]=k+He|0,s[rt++]=_+Le|0,s[rt++]=A+Q|0,s[rt++]=B+oe|0,s[rt++]=L+Y|0,s[rt++]=Z+Ce|0,s[rt++]=ve+je|0,s[rt++]=We+Je|0,s[rt++]=re+Ge|0,s[rt++]=ze+Xe|0,s[rt++]=se+Qe|0}function hchacha$1(n,t,r,s){let o=n[0],a=n[1],c=n[2],f=n[3],g=t[0],m=t[1],b=t[2],k=t[3],_=t[4],A=t[5],B=t[6],L=t[7],Z=r[0],ve=r[1],We=r[2],re=r[3];for(let se=0;se<20;se+=2)o=o+g|0,Z=rotl$3(Z^o,16),_=_+Z|0,g=rotl$3(g^_,12),o=o+g|0,Z=rotl$3(Z^o,8),_=_+Z|0,g=rotl$3(g^_,7),a=a+m|0,ve=rotl$3(ve^a,16),A=A+ve|0,m=rotl$3(m^A,12),a=a+m|0,ve=rotl$3(ve^a,8),A=A+ve|0,m=rotl$3(m^A,7),c=c+b|0,We=rotl$3(We^c,16),B=B+We|0,b=rotl$3(b^B,12),c=c+b|0,We=rotl$3(We^c,8),B=B+We|0,b=rotl$3(b^B,7),f=f+k|0,re=rotl$3(re^f,16),L=L+re|0,k=rotl$3(k^L,12),f=f+k|0,re=rotl$3(re^f,8),L=L+re|0,k=rotl$3(k^L,7),o=o+m|0,re=rotl$3(re^o,16),B=B+re|0,m=rotl$3(m^B,12),o=o+m|0,re=rotl$3(re^o,8),B=B+re|0,m=rotl$3(m^B,7),a=a+b|0,Z=rotl$3(Z^a,16),L=L+Z|0,b=rotl$3(b^L,12),a=a+b|0,Z=rotl$3(Z^a,8),L=L+Z|0,b=rotl$3(b^L,7),c=c+k|0,ve=rotl$3(ve^c,16),_=_+ve|0,k=rotl$3(k^_,12),c=c+k|0,ve=rotl$3(ve^c,8),_=_+ve|0,k=rotl$3(k^_,7),f=f+g|0,We=rotl$3(We^f,16),A=A+We|0,g=rotl$3(g^A,12),f=f+g|0,We=rotl$3(We^f,8),A=A+We|0,g=rotl$3(g^A,7);let ze=0;s[ze++]=o,s[ze++]=a,s[ze++]=c,s[ze++]=f,s[ze++]=Z,s[ze++]=ve,s[ze++]=We,s[ze++]=re}var chacha20$1=createCipher$1(chachaCore$1,{counterRight:!1,counterLength:4,allowShortKeys:!1}),xchacha20$1=createCipher$1(chachaCore$1,{counterRight:!1,counterLength:8,extendNonceFn:hchacha$1,allowShortKeys:!1}),ZEROS162=new Uint8Array(16),updatePadded$1=(n,t)=>{n.update(t);const r=t.length%16;r&&n.update(ZEROS162.subarray(r))},ZEROS322=new Uint8Array(32);function computeTag2(n,t,r,s,o){const a=n(t,r,ZEROS322),c=poly1305$1.create(a);o&&updatePadded$1(c,o),updatePadded$1(c,s);const f=new Uint8Array(16),g=createView3(f);setBigUint643(g,0,BigInt(o?o.length:0),!0),setBigUint643(g,8,BigInt(s.length),!0),c.update(f);const m=c.digest();return a.fill(0),m}var _poly1305_aead$1=n=>(t,r,s)=>(bytes3(t,32),bytes3(r),{encrypt:(a,c)=>{const f=a.length,g=f+16;c?bytes3(c,g):c=new Uint8Array(g),n(t,r,a,c,1);const m=computeTag2(n,t,r,c.subarray(0,-16),s);return c.set(m,f),c},decrypt:(a,c)=>{const f=a.length,g=f-16;if(f<16)throw new Error("encrypted data must be at least 16 bytes");c?bytes3(c,g):c=new Uint8Array(g);const m=a.subarray(0,-16),b=a.subarray(-16),k=computeTag2(n,t,r,m,s);if(!equalBytes2(b,k))throw new Error("invalid tag");return n(t,r,m,c,1),c}}),xchacha20poly1305$1=wrapCipher$1({blockSize:64,nonceLength:24,tagLength:16},_poly1305_aead$1(xchacha20$1));class HMAC2 extends Hash2{constructor(t,r){super(),this.finished=!1,this.destroyed=!1,_assert_default.hash(t);const s=toBytes2(r);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,a=new Uint8Array(o);a.set(s.length>o?t.create().update(s).digest():s);for(let c=0;c<a.length;c++)a[c]^=54;this.iHash.update(a),this.oHash=t.create();for(let c=0;c<a.length;c++)a[c]^=106;this.oHash.update(a),a.fill(0)}update(t){return _assert_default.exists(this),this.iHash.update(t),this}digestInto(t){_assert_default.exists(this),_assert_default.bytes(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:r,iHash:s,finished:o,destroyed:a,blockLen:c,outputLen:f}=this;return t=t,t.finished=o,t.destroyed=a,t.blockLen=c,t.outputLen=f,t.oHash=r._cloneInto(t.oHash),t.iHash=s._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var hmac2=(n,t,r)=>new HMAC2(n,t).update(r).digest();hmac2.create=(n,t)=>new HMAC2(n,t);function extract$1(n,t,r){return _assert_default.hash(n),hmac2(n,toBytes2(r),toBytes2(t))}var HKDF_COUNTER$1=new Uint8Array([0]),EMPTY_BUFFER$1=new Uint8Array;function expand$1(n,t,r,s=32){if(_assert_default.hash(n),_assert_default.number(s),s>255*n.outputLen)throw new Error("Length should be <= 255*HashLen");const o=Math.ceil(s/n.outputLen);r===void 0&&(r=EMPTY_BUFFER$1);const a=new Uint8Array(o*n.outputLen),c=hmac2.create(n,t),f=c._cloneInto(),g=new Uint8Array(c.outputLen);for(let m=0;m<o;m++)HKDF_COUNTER$1[0]=m+1,f.update(m===0?EMPTY_BUFFER$1:g).update(r).update(HKDF_COUNTER$1).digestInto(g),a.set(g,n.outputLen*m),c._cloneInto(f);return c.destroy(),f.destroy(),g.fill(0),HKDF_COUNTER$1.fill(0),a.slice(0,s)}var __defProp2=Object.defineProperty,__export2=(n,t)=>{for(var r in t)__defProp2(n,r,{get:t[r],enumerable:!0})},verifiedSymbol$1=Symbol("verified"),isRecord$1=n=>n instanceof Object;function validateEvent$1(n){if(!isRecord$1(n)||typeof n.kind!="number"||typeof n.content!="string"||typeof n.created_at!="number"||typeof n.pubkey!="string"||!n.pubkey.match(/^[a-f0-9]{64}$/)||!Array.isArray(n.tags))return!1;for(let t=0;t<n.tags.length;t++){let r=n.tags[t];if(!Array.isArray(r))return!1;for(let s=0;s<r.length;s++)if(typeof r[s]!="string")return!1}return!0}var utils_exports$1={};__export2(utils_exports$1,{Queue:()=>Queue$2,QueueNode:()=>QueueNode$1,binarySearch:()=>binarySearch$1,bytesToHex:()=>bytesToHex2,hexToBytes:()=>hexToBytes2,insertEventIntoAscendingList:()=>insertEventIntoAscendingList$1,insertEventIntoDescendingList:()=>insertEventIntoDescendingList$1,normalizeURL:()=>normalizeURL$1,utf8Decoder:()=>utf8Decoder$2,utf8Encoder:()=>utf8Encoder$2});var utf8Decoder$2=new TextDecoder("utf-8"),utf8Encoder$2=new TextEncoder;function normalizeURL$1(n){try{n.indexOf("://")===-1&&(n="wss://"+n);let t=new URL(n);return t.pathname=t.pathname.replace(/\/+/g,"/"),t.pathname.endsWith("/")&&(t.pathname=t.pathname.slice(0,-1)),(t.port==="80"&&t.protocol==="ws:"||t.port==="443"&&t.protocol==="wss:")&&(t.port=""),t.searchParams.sort(),t.hash="",t.toString()}catch{throw new Error(`Invalid URL: ${n}`)}}function insertEventIntoDescendingList$1(n,t){const[r,s]=binarySearch$1(n,o=>t.id===o.id?0:t.created_at===o.created_at?-1:o.created_at-t.created_at);return s||n.splice(r,0,t),n}function insertEventIntoAscendingList$1(n,t){const[r,s]=binarySearch$1(n,o=>t.id===o.id?0:t.created_at===o.created_at?-1:t.created_at-o.created_at);return s||n.splice(r,0,t),n}function binarySearch$1(n,t){let r=0,s=n.length-1;for(;r<=s;){const o=Math.floor((r+s)/2),a=t(n[o]);if(a===0)return[o,!0];a<0?s=o-1:r=o+1}return[r,!1]}var QueueNode$1=class{value;next=null;prev=null;constructor(t){this.value=t}},Queue$2=class{first;last;constructor(){this.first=null,this.last=null}enqueue(t){const r=new QueueNode$1(t);return this.last?this.last===this.first?(this.last=r,this.last.prev=this.first,this.first.next=r):(r.prev=this.last,this.last.next=r,this.last=r):(this.first=r,this.last=r),!0}dequeue(){if(!this.first)return null;if(this.first===this.last){const r=this.first;return this.first=null,this.last=null,r.value}const t=this.first;return this.first=t.next,this.first&&(this.first.prev=null),t.value}},JS$1=class{generateSecretKey(){return schnorr$2.utils.randomPrivateKey()}getPublicKey(t){return bytesToHex2(schnorr$2.getPublicKey(t))}finalizeEvent(t,r){const s=t;return s.pubkey=bytesToHex2(schnorr$2.getPublicKey(r)),s.id=getEventHash$2(s),s.sig=bytesToHex2(schnorr$2.sign(getEventHash$2(s),r)),s[verifiedSymbol$1]=!0,s}verifyEvent(t){if(typeof t[verifiedSymbol$1]=="boolean")return t[verifiedSymbol$1];const r=getEventHash$2(t);if(r!==t.id)return t[verifiedSymbol$1]=!1,!1;try{const s=schnorr$2.verify(t.sig,r,t.pubkey);return t[verifiedSymbol$1]=s,s}catch{return t[verifiedSymbol$1]=!1,!1}}};function serializeEvent$1(n){if(!validateEvent$1(n))throw new Error("can't serialize event with wrong or missing properties");return JSON.stringify([0,n.pubkey,n.created_at,n.kind,n.tags,n.content])}function getEventHash$2(n){let t=sha2562(utf8Encoder$2.encode(serializeEvent$1(n)));return bytesToHex2(t)}var i$2=new JS$1,generateSecretKey$1=i$2.generateSecretKey,getPublicKey$1=i$2.getPublicKey,finalizeEvent$1=i$2.finalizeEvent,verifyEvent$1=i$2.verifyEvent,kinds_exports$1={};__export2(kinds_exports$1,{Application:()=>Application$1,BadgeAward:()=>BadgeAward$1,BadgeDefinition:()=>BadgeDefinition$1,BlockedRelaysList:()=>BlockedRelaysList$1,BookmarkList:()=>BookmarkList$1,Bookmarksets:()=>Bookmarksets$1,Calendar:()=>Calendar$1,CalendarEventRSVP:()=>CalendarEventRSVP$1,ChannelCreation:()=>ChannelCreation$1,ChannelHideMessage:()=>ChannelHideMessage$1,ChannelMessage:()=>ChannelMessage$1,ChannelMetadata:()=>ChannelMetadata$1,ChannelMuteUser:()=>ChannelMuteUser$1,ClassifiedListing:()=>ClassifiedListing$1,ClientAuth:()=>ClientAuth$1,CommunitiesList:()=>CommunitiesList$1,CommunityDefinition:()=>CommunityDefinition$1,CommunityPostApproval:()=>CommunityPostApproval$1,Contacts:()=>Contacts$1,CreateOrUpdateProduct:()=>CreateOrUpdateProduct$1,CreateOrUpdateStall:()=>CreateOrUpdateStall$1,Curationsets:()=>Curationsets$1,Date:()=>Date2$1,DirectMessageRelaysList:()=>DirectMessageRelaysList$1,DraftClassifiedListing:()=>DraftClassifiedListing$1,DraftLong:()=>DraftLong$1,Emojisets:()=>Emojisets$1,EncryptedDirectMessage:()=>EncryptedDirectMessage$1,EventDeletion:()=>EventDeletion$1,FileMetadata:()=>FileMetadata$1,FileServerPreference:()=>FileServerPreference$1,Followsets:()=>Followsets$1,GenericRepost:()=>GenericRepost$1,Genericlists:()=>Genericlists$1,GiftWrap:()=>GiftWrap$1,HTTPAuth:()=>HTTPAuth$1,Handlerinformation:()=>Handlerinformation$1,Handlerrecommendation:()=>Handlerrecommendation$1,Highlights:()=>Highlights$1,InterestsList:()=>InterestsList$1,Interestsets:()=>Interestsets$1,JobFeedback:()=>JobFeedback$1,JobRequest:()=>JobRequest$1,JobResult:()=>JobResult$1,Label:()=>Label$1,LightningPubRPC:()=>LightningPubRPC$1,LiveChatMessage:()=>LiveChatMessage$1,LiveEvent:()=>LiveEvent$1,LongFormArticle:()=>LongFormArticle$1,Metadata:()=>Metadata$1,Mutelist:()=>Mutelist$1,NWCWalletInfo:()=>NWCWalletInfo$1,NWCWalletRequest:()=>NWCWalletRequest$1,NWCWalletResponse:()=>NWCWalletResponse$1,NostrConnect:()=>NostrConnect$1,OpenTimestamps:()=>OpenTimestamps$1,Pinlist:()=>Pinlist$1,PrivateDirectMessage:()=>PrivateDirectMessage$1,ProblemTracker:()=>ProblemTracker$1,ProfileBadges:()=>ProfileBadges$1,PublicChatsList:()=>PublicChatsList$1,Reaction:()=>Reaction$1,RecommendRelay:()=>RecommendRelay$1,RelayList:()=>RelayList$1,Relaysets:()=>Relaysets$1,Report:()=>Report$1,Reporting:()=>Reporting$1,Repost:()=>Repost$1,Seal:()=>Seal$1,SearchRelaysList:()=>SearchRelaysList$1,ShortTextNote:()=>ShortTextNote$1,Time:()=>Time$1,UserEmojiList:()=>UserEmojiList$1,UserStatuses:()=>UserStatuses$1,Zap:()=>Zap$1,ZapGoal:()=>ZapGoal$1,ZapRequest:()=>ZapRequest$1,classifyKind:()=>classifyKind$1,isAddressableKind:()=>isAddressableKind$1,isEphemeralKind:()=>isEphemeralKind$1,isKind:()=>isKind$1,isRegularKind:()=>isRegularKind$1,isReplaceableKind:()=>isReplaceableKind$1});function isRegularKind$1(n){return 1e3<=n&&n<1e4||[1,2,4,5,6,7,8,16,40,41,42,43,44].includes(n)}function isReplaceableKind$1(n){return[0,3].includes(n)||1e4<=n&&n<2e4}function isEphemeralKind$1(n){return 2e4<=n&&n<3e4}function isAddressableKind$1(n){return 3e4<=n&&n<4e4}function classifyKind$1(n){return isRegularKind$1(n)?"regular":isReplaceableKind$1(n)?"replaceable":isEphemeralKind$1(n)?"ephemeral":isAddressableKind$1(n)?"parameterized":"unknown"}function isKind$1(n,t){const r=t instanceof Array?t:[t];return validateEvent$1(n)&&r.includes(n.kind)||!1}var Metadata$1=0,ShortTextNote$1=1,RecommendRelay$1=2,Contacts$1=3,EncryptedDirectMessage$1=4,EventDeletion$1=5,Repost$1=6,Reaction$1=7,BadgeAward$1=8,Seal$1=13,PrivateDirectMessage$1=14,GenericRepost$1=16,ChannelCreation$1=40,ChannelMetadata$1=41,ChannelMessage$1=42,ChannelHideMessage$1=43,ChannelMuteUser$1=44,OpenTimestamps$1=1040,GiftWrap$1=1059,FileMetadata$1=1063,LiveChatMessage$1=1311,ProblemTracker$1=1971,Report$1=1984,Reporting$1=1984,Label$1=1985,CommunityPostApproval$1=4550,JobRequest$1=5999,JobResult$1=6999,JobFeedback$1=7e3,ZapGoal$1=9041,ZapRequest$1=9734,Zap$1=9735,Highlights$1=9802,Mutelist$1=1e4,Pinlist$1=10001,RelayList$1=10002,BookmarkList$1=10003,CommunitiesList$1=10004,PublicChatsList$1=10005,BlockedRelaysList$1=10006,SearchRelaysList$1=10007,InterestsList$1=10015,UserEmojiList$1=10030,DirectMessageRelaysList$1=10050,FileServerPreference$1=10096,NWCWalletInfo$1=13194,LightningPubRPC$1=21e3,ClientAuth$1=22242,NWCWalletRequest$1=23194,NWCWalletResponse$1=23195,NostrConnect$1=24133,HTTPAuth$1=27235,Followsets$1=3e4,Genericlists$1=30001,Relaysets$1=30002,Bookmarksets$1=30003,Curationsets$1=30004,ProfileBadges$1=30008,BadgeDefinition$1=30009,Interestsets$1=30015,CreateOrUpdateStall$1=30017,CreateOrUpdateProduct$1=30018,LongFormArticle$1=30023,DraftLong$1=30024,Emojisets$1=30030,Application$1=30078,LiveEvent$1=30311,UserStatuses$1=30315,ClassifiedListing$1=30402,DraftClassifiedListing$1=30403,Date2$1=31922,Time$1=31923,Calendar$1=31924,CalendarEventRSVP$1=31925,Handlerrecommendation$1=31989,Handlerinformation$1=31990,CommunityDefinition$1=34550;function matchFilter$1(n,t){if(n.ids&&n.ids.indexOf(t.id)===-1||n.kinds&&n.kinds.indexOf(t.kind)===-1||n.authors&&n.authors.indexOf(t.pubkey)===-1)return!1;for(let r in n)if(r[0]==="#"){let s=r.slice(1),o=n[`#${s}`];if(o&&!t.tags.find(([a,c])=>a===r.slice(1)&&o.indexOf(c)!==-1))return!1}return!(n.since&&t.created_at<n.since||n.until&&t.created_at>n.until)}function matchFilters$1(n,t){for(let r=0;r<n.length;r++)if(matchFilter$1(n[r],t))return!0;return!1}var fakejson_exports$1={};__export2(fakejson_exports$1,{getHex64:()=>getHex64$1,getInt:()=>getInt$1,getSubscriptionId:()=>getSubscriptionId$1,matchEventId:()=>matchEventId$1,matchEventKind:()=>matchEventKind$1,matchEventPubkey:()=>matchEventPubkey$1});function getHex64$1(n,t){let r=t.length+3,s=n.indexOf(`"${t}":`)+r,o=n.slice(s).indexOf('"')+s+1;return n.slice(o,o+64)}function getInt$1(n,t){let r=t.length,s=n.indexOf(`"${t}":`)+r+3,o=n.slice(s),a=Math.min(o.indexOf(","),o.indexOf("}"));return parseInt(o.slice(0,a),10)}function getSubscriptionId$1(n){let t=n.slice(0,22).indexOf('"EVENT"');if(t===-1)return null;let r=n.slice(t+7+1).indexOf('"');if(r===-1)return null;let s=t+7+1+r,o=n.slice(s+1,80).indexOf('"');if(o===-1)return null;let a=s+1+o;return n.slice(s+1,a)}function matchEventId$1(n,t){return t===getHex64$1(n,"id")}function matchEventPubkey$1(n,t){return t===getHex64$1(n,"pubkey")}function matchEventKind$1(n,t){return t===getInt$1(n,"kind")}var nip42_exports$1={};__export2(nip42_exports$1,{makeAuthEvent:()=>makeAuthEvent$1});function makeAuthEvent$1(n,t){return{kind:ClientAuth$1,created_at:Math.floor(Date.now()/1e3),tags:[["relay",n],["challenge",t]],content:""}}var _WebSocket$1;try{_WebSocket$1=WebSocket}catch{}var _WebSocket2$1;try{_WebSocket2$1=WebSocket}catch{}var nip19_exports$2={};__export2(nip19_exports$2,{BECH32_REGEX:()=>BECH32_REGEX$3,Bech32MaxSize:()=>Bech32MaxSize$3,NostrTypeGuard:()=>NostrTypeGuard$2,decode:()=>decode$2,decodeNostrURI:()=>decodeNostrURI$2,encodeBytes:()=>encodeBytes$3,naddrEncode:()=>naddrEncode$2,neventEncode:()=>neventEncode$2,noteEncode:()=>noteEncode$2,nprofileEncode:()=>nprofileEncode$2,npubEncode:()=>npubEncode$2,nsecEncode:()=>nsecEncode$2});var NostrTypeGuard$2={isNProfile:n=>/^nprofile1[a-z\d]+$/.test(n||""),isNEvent:n=>/^nevent1[a-z\d]+$/.test(n||""),isNAddr:n=>/^naddr1[a-z\d]+$/.test(n||""),isNSec:n=>/^nsec1[a-z\d]{58}$/.test(n||""),isNPub:n=>/^npub1[a-z\d]{58}$/.test(n||""),isNote:n=>/^note1[a-z\d]+$/.test(n||""),isNcryptsec:n=>/^ncryptsec1[a-z\d]+$/.test(n||"")},Bech32MaxSize$3=5e3,BECH32_REGEX$3=/[\x21-\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;function integerToUint8Array$2(n){const t=new Uint8Array(4);return t[0]=n>>24&255,t[1]=n>>16&255,t[2]=n>>8&255,t[3]=n&255,t}function decodeNostrURI$2(n){try{return n.startsWith("nostr:")&&(n=n.substring(6)),decode$2(n)}catch{return{type:"invalid",data:null}}}function decode$2(n){let{prefix:t,words:r}=bech32$3.decode(n,Bech32MaxSize$3),s=new Uint8Array(bech32$3.fromWords(r));switch(t){case"nprofile":{let o=parseTLV$2(s);if(!o[0]?.[0])throw new Error("missing TLV 0 for nprofile");if(o[0][0].length!==32)throw new Error("TLV 0 should be 32 bytes");return{type:"nprofile",data:{pubkey:bytesToHex2(o[0][0]),relays:o[1]?o[1].map(a=>utf8Decoder$2.decode(a)):[]}}}case"nevent":{let o=parseTLV$2(s);if(!o[0]?.[0])throw new Error("missing TLV 0 for nevent");if(o[0][0].length!==32)throw new Error("TLV 0 should be 32 bytes");if(o[2]&&o[2][0].length!==32)throw new Error("TLV 2 should be 32 bytes");if(o[3]&&o[3][0].length!==4)throw new Error("TLV 3 should be 4 bytes");return{type:"nevent",data:{id:bytesToHex2(o[0][0]),relays:o[1]?o[1].map(a=>utf8Decoder$2.decode(a)):[],author:o[2]?.[0]?bytesToHex2(o[2][0]):void 0,kind:o[3]?.[0]?parseInt(bytesToHex2(o[3][0]),16):void 0}}}case"naddr":{let o=parseTLV$2(s);if(!o[0]?.[0])throw new Error("missing TLV 0 for naddr");if(!o[2]?.[0])throw new Error("missing TLV 2 for naddr");if(o[2][0].length!==32)throw new Error("TLV 2 should be 32 bytes");if(!o[3]?.[0])throw new Error("missing TLV 3 for naddr");if(o[3][0].length!==4)throw new Error("TLV 3 should be 4 bytes");return{type:"naddr",data:{identifier:utf8Decoder$2.decode(o[0][0]),pubkey:bytesToHex2(o[2][0]),kind:parseInt(bytesToHex2(o[3][0]),16),relays:o[1]?o[1].map(a=>utf8Decoder$2.decode(a)):[]}}}case"nsec":return{type:t,data:s};case"npub":case"note":return{type:t,data:bytesToHex2(s)};default:throw new Error(`unknown prefix ${t}`)}}function parseTLV$2(n){let t={},r=n;for(;r.length>0;){let s=r[0],o=r[1],a=r.slice(2,2+o);if(r=r.slice(2+o),a.length<o)throw new Error(`not enough data to read on TLV ${s}`);t[s]=t[s]||[],t[s].push(a)}return t}function nsecEncode$2(n){return encodeBytes$3("nsec",n)}function npubEncode$2(n){return encodeBytes$3("npub",hexToBytes2(n))}function noteEncode$2(n){return encodeBytes$3("note",hexToBytes2(n))}function encodeBech32$3(n,t){let r=bech32$3.toWords(t);return bech32$3.encode(n,r,Bech32MaxSize$3)}function encodeBytes$3(n,t){return encodeBech32$3(n,t)}function nprofileEncode$2(n){let t=encodeTLV$2({0:[hexToBytes2(n.pubkey)],1:(n.relays||[]).map(r=>utf8Encoder$2.encode(r))});return encodeBech32$3("nprofile",t)}function neventEncode$2(n){let t;n.kind!==void 0&&(t=integerToUint8Array$2(n.kind));let r=encodeTLV$2({0:[hexToBytes2(n.id)],1:(n.relays||[]).map(s=>utf8Encoder$2.encode(s)),2:n.author?[hexToBytes2(n.author)]:[],3:t?[new Uint8Array(t)]:[]});return encodeBech32$3("nevent",r)}function naddrEncode$2(n){let t=new ArrayBuffer(4);new DataView(t).setUint32(0,n.kind,!1);let r=encodeTLV$2({0:[utf8Encoder$2.encode(n.identifier)],1:(n.relays||[]).map(s=>utf8Encoder$2.encode(s)),2:[hexToBytes2(n.pubkey)],3:[new Uint8Array(t)]});return encodeBech32$3("naddr",r)}function encodeTLV$2(n){let t=[];return Object.entries(n).reverse().forEach(([r,s])=>{s.forEach(o=>{let a=new Uint8Array(o.length+2);a.set([parseInt(r)],0),a.set([o.length],1),a.set(o,2),t.push(a)})}),concatBytes3(...t)}var nip04_exports$1={};__export2(nip04_exports$1,{decrypt:()=>decrypt2$1,encrypt:()=>encrypt2$1});function encrypt2$1(n,t,r){const s=n instanceof Uint8Array?bytesToHex2(n):n,o=secp256k1$2.getSharedSecret(s,"02"+t),a=getNormalizedX$1(o);let c=Uint8Array.from(randomBytes2(16)),f=utf8Encoder$2.encode(r),g=cbc$1(a,c).encrypt(f),m=base64$2.encode(new Uint8Array(g)),b=base64$2.encode(new Uint8Array(c.buffer));return`${m}?iv=${b}`}function decrypt2$1(n,t,r){const s=n instanceof Uint8Array?bytesToHex2(n):n;let[o,a]=r.split("?iv="),c=secp256k1$2.getSharedSecret(s,"02"+t),f=getNormalizedX$1(c),g=base64$2.decode(a),m=base64$2.decode(o),b=cbc$1(f,g).decrypt(m);return utf8Decoder$2.decode(b)}function getNormalizedX$1(n){return n.slice(1,33)}var nip05_exports$1={};__export2(nip05_exports$1,{NIP05_REGEX:()=>NIP05_REGEX$2,isNip05:()=>isNip05$1,isValid:()=>isValid$1,queryProfile:()=>queryProfile$1,searchDomain:()=>searchDomain$1,useFetchImplementation:()=>useFetchImplementation$1});var NIP05_REGEX$2=/^(?:([\w.+-]+)@)?([\w_-]+(\.[\w_-]+)+)$/,isNip05$1=n=>NIP05_REGEX$2.test(n||""),_fetch$1;try{_fetch$1=fetch}catch(n){}function useFetchImplementation$1(n){_fetch$1=n}async function searchDomain$1(n,t=""){try{const r=`https://${n}/.well-known/nostr.json?name=${t}`,s=await _fetch$1(r,{redirect:"manual"});if(s.status!==200)throw Error("Wrong response code");return(await s.json()).names}catch{return{}}}async function queryProfile$1(n){const t=n.match(NIP05_REGEX$2);if(!t)return null;const[,r="_",s]=t;try{const o=`https://${s}/.well-known/nostr.json?name=${r}`,a=await _fetch$1(o,{redirect:"manual"});if(a.status!==200)throw Error("Wrong response code");const c=await a.json(),f=c.names[r];return f?{pubkey:f,relays:c.relays?.[f]}:null}catch{return null}}async function isValid$1(n,t){const r=await queryProfile$1(t);return r?r.pubkey===n:!1}var nip10_exports$1={};__export2(nip10_exports$1,{parse:()=>parse$1});function parse$1(n){const t={reply:void 0,root:void 0,mentions:[],profiles:[],quotes:[]};let r,s;for(let o=n.tags.length-1;o>=0;o--){const a=n.tags[o];if(a[0]==="e"&&a[1]){const[c,f,g,m,b]=a,k={id:f,relays:g?[g]:[],author:b};if(m==="root"){t.root=k;continue}if(m==="reply"){t.reply=k;continue}if(m==="mention"){t.mentions.push(k);continue}r?s=k:r=k,t.mentions.push(k);continue}if(a[0]==="q"&&a[1]){const[c,f,g]=a;t.quotes.push({id:f,relays:g?[g]:[]})}if(a[0]==="p"&&a[1]){t.profiles.push({pubkey:a[1],relays:a[2]?[a[2]]:[]});continue}}return t.root||(t.root=s||r||t.reply),t.reply||(t.reply=r||t.root),[t.reply,t.root].forEach(o=>{if(!o)return;let a=t.mentions.indexOf(o);if(a!==-1&&t.mentions.splice(a,1),o.author){let c=t.profiles.find(f=>f.pubkey===o.author);c&&c.relays&&(o.relays||(o.relays=[]),c.relays.forEach(f=>{o.relays?.indexOf(f)===-1&&o.relays.push(f)}),c.relays=o.relays)}}),t.mentions.forEach(o=>{if(o.author){let a=t.profiles.find(c=>c.pubkey===o.author);a&&a.relays&&(o.relays||(o.relays=[]),a.relays.forEach(c=>{o.relays.indexOf(c)===-1&&o.relays.push(c)}),a.relays=o.relays)}}),t}var nip11_exports$1={};__export2(nip11_exports$1,{fetchRelayInformation:()=>fetchRelayInformation$2,useFetchImplementation:()=>useFetchImplementation2$1});var _fetch2$1;try{_fetch2$1=fetch}catch{}function useFetchImplementation2$1(n){_fetch2$1=n}async function fetchRelayInformation$2(n){return await(await fetch(n.replace("ws://","http://").replace("wss://","https://"),{headers:{Accept:"application/nostr+json"}})).json()}var nip13_exports$1={};__export2(nip13_exports$1,{fastEventHash:()=>fastEventHash$1,getPow:()=>getPow$1,minePow:()=>minePow$1});function getPow$1(n){let t=0;for(let r=0;r<64;r+=8){const s=parseInt(n.substring(r,r+8),16);if(s===0)t+=32;else{t+=Math.clz32(s);break}}return t}function minePow$1(n,t){let r=0;const s=n,o=["nonce",r.toString(),t.toString()];for(s.tags.push(o);;){const a=Math.floor(new Date().getTime()/1e3);if(a!==s.created_at&&(r=0,s.created_at=a),o[1]=(++r).toString(),s.id=fastEventHash$1(s),getPow$1(s.id)>=t)break}return s}function fastEventHash$1(n){return bytesToHex2(sha2562(utf8Encoder$2.encode(JSON.stringify([0,n.pubkey,n.created_at,n.kind,n.tags,n.content]))))}var nip17_exports$1={};__export2(nip17_exports$1,{unwrapEvent:()=>unwrapEvent2$1,unwrapManyEvents:()=>unwrapManyEvents2$1,wrapEvent:()=>wrapEvent2$1,wrapManyEvents:()=>wrapManyEvents2$1});var nip59_exports$1={};__export2(nip59_exports$1,{createRumor:()=>createRumor$1,createSeal:()=>createSeal$1,createWrap:()=>createWrap$1,unwrapEvent:()=>unwrapEvent$1,unwrapManyEvents:()=>unwrapManyEvents$1,wrapEvent:()=>wrapEvent$2,wrapManyEvents:()=>wrapManyEvents$1});var nip44_exports$1={};__export2(nip44_exports$1,{decrypt:()=>decrypt22,encrypt:()=>encrypt22,getConversationKey:()=>getConversationKey$1,v2:()=>v2$1});var minPlaintextSize$1=1,maxPlaintextSize$1=65535;function getConversationKey$1(n,t){const r=secp256k1$2.getSharedSecret(n,"02"+t).subarray(1,33);return extract$1(sha2562,r,"nip44-v2")}function getMessageKeys$1(n,t){const r=expand$1(sha2562,n,t,76);return{chacha_key:r.subarray(0,32),chacha_nonce:r.subarray(32,44),hmac_key:r.subarray(44,76)}}function calcPaddedLen$1(n){if(!Number.isSafeInteger(n)||n<1)throw new Error("expected positive integer");if(n<=32)return 32;const t=1<<Math.floor(Math.log2(n-1))+1,r=t<=256?32:t/8;return r*(Math.floor((n-1)/r)+1)}function writeU16BE$1(n){if(!Number.isSafeInteger(n)||n<minPlaintextSize$1||n>maxPlaintextSize$1)throw new Error("invalid plaintext size: must be between 1 and 65535 bytes");const t=new Uint8Array(2);return new DataView(t.buffer).setUint16(0,n,!1),t}function pad$1(n){const t=utf8Encoder$2.encode(n),r=t.length,s=writeU16BE$1(r),o=new Uint8Array(calcPaddedLen$1(r)-r);return concatBytes3(s,t,o)}function unpad$1(n){const t=new DataView(n.buffer).getUint16(0),r=n.subarray(2,2+t);if(t<minPlaintextSize$1||t>maxPlaintextSize$1||r.length!==t||n.length!==2+calcPaddedLen$1(t))throw new Error("invalid padding");return utf8Decoder$2.decode(r)}function hmacAad$1(n,t,r){if(r.length!==32)throw new Error("AAD associated data must be 32 bytes");const s=concatBytes3(r,t);return hmac2(sha2562,n,s)}function decodePayload$1(n){if(typeof n!="string")throw new Error("payload must be a valid string");const t=n.length;if(t<132||t>87472)throw new Error("invalid payload length: "+t);if(n[0]==="#")throw new Error("unknown encryption version");let r;try{r=base64$2.decode(n)}catch(a){throw new Error("invalid base64: "+a.message)}const s=r.length;if(s<99||s>65603)throw new Error("invalid data length: "+s);const o=r[0];if(o!==2)throw new Error("unknown encryption version "+o);return{nonce:r.subarray(1,33),ciphertext:r.subarray(33,-32),mac:r.subarray(-32)}}function encrypt22(n,t,r=randomBytes2(32)){const{chacha_key:s,chacha_nonce:o,hmac_key:a}=getMessageKeys$1(t,r),c=pad$1(n),f=chacha20$1(s,o,c),g=hmacAad$1(a,f,r);return base64$2.encode(concatBytes3(new Uint8Array([2]),r,f,g))}function decrypt22(n,t){const{nonce:r,ciphertext:s,mac:o}=decodePayload$1(n),{chacha_key:a,chacha_nonce:c,hmac_key:f}=getMessageKeys$1(t,r),g=hmacAad$1(f,s,r);if(!equalBytes2(g,o))throw new Error("invalid MAC");const m=chacha20$1(a,c,s);return unpad$1(m)}var v2$1={utils:{getConversationKey:getConversationKey$1,calcPaddedLen:calcPaddedLen$1},encrypt:encrypt22,decrypt:decrypt22},TWO_DAYS$1=2880*60,now$1=()=>Math.round(Date.now()/1e3),randomNow$1=()=>Math.round(now$1()-Math.random()*TWO_DAYS$1),nip44ConversationKey$1=(n,t)=>getConversationKey$1(n,t),nip44Encrypt$1=(n,t,r)=>encrypt22(JSON.stringify(n),nip44ConversationKey$1(t,r)),nip44Decrypt$1=(n,t)=>JSON.parse(decrypt22(n.content,nip44ConversationKey$1(t,n.pubkey)));function createRumor$1(n,t){const r={created_at:now$1(),content:"",tags:[],...n,pubkey:getPublicKey$1(t)};return r.id=getEventHash$2(r),r}function createSeal$1(n,t,r){return finalizeEvent$1({kind:Seal$1,content:nip44Encrypt$1(n,t,r),created_at:randomNow$1(),tags:[]},t)}function createWrap$1(n,t){const r=generateSecretKey$1();return finalizeEvent$1({kind:GiftWrap$1,content:nip44Encrypt$1(n,r,t),created_at:randomNow$1(),tags:[["p",t]]},r)}function wrapEvent$2(n,t,r){const s=createRumor$1(n,t),o=createSeal$1(s,t,r);return createWrap$1(o,r)}function wrapManyEvents$1(n,t,r){if(!r||r.length===0)throw new Error("At least one recipient is required.");const s=getPublicKey$1(t),o=[wrapEvent$2(n,t,s)];return r.forEach(a=>{o.push(wrapEvent$2(n,t,a))}),o}function unwrapEvent$1(n,t){const r=nip44Decrypt$1(n,t);return nip44Decrypt$1(r,t)}function unwrapManyEvents$1(n,t){let r=[];return n.forEach(s=>{r.push(unwrapEvent$1(s,t))}),r.sort((s,o)=>s.created_at-o.created_at),r}function createEvent$1(n,t,r,s){const o={created_at:Math.ceil(Date.now()/1e3),kind:PrivateDirectMessage$1,tags:[],content:t};return(Array.isArray(n)?n:[n]).forEach(({publicKey:c,relayUrl:f})=>{o.tags.push(f?["p",c,f]:["p",c])}),s&&o.tags.push(["e",s.eventId,s.relayUrl||"","reply"]),r&&o.tags.push(["subject",r]),o}function wrapEvent2$1(n,t,r,s,o){const a=createEvent$1(t,r,s,o);return wrapEvent$2(a,n,t.publicKey)}function wrapManyEvents2$1(n,t,r,s,o){if(!t||t.length===0)throw new Error("At least one recipient is required.");return[{publicKey:getPublicKey$1(n)},...t].map(c=>wrapEvent2$1(n,c,r,s,o))}var unwrapEvent2$1=unwrapEvent$1,unwrapManyEvents2$1=unwrapManyEvents$1,nip18_exports$1={};__export2(nip18_exports$1,{finishRepostEvent:()=>finishRepostEvent$1,getRepostedEvent:()=>getRepostedEvent$1,getRepostedEventPointer:()=>getRepostedEventPointer$1});function finishRepostEvent$1(n,t,r,s){let o;const a=[...n.tags??[],["e",t.id,r],["p",t.pubkey]];return t.kind===ShortTextNote$1?o=Repost$1:(o=GenericRepost$1,a.push(["k",String(t.kind)])),finalizeEvent$1({kind:o,tags:a,content:n.content===""||t.tags?.find(c=>c[0]==="-")?"":JSON.stringify(t),created_at:n.created_at},s)}function getRepostedEventPointer$1(n){if(![Repost$1,GenericRepost$1].includes(n.kind))return;let t,r;for(let s=n.tags.length-1;s>=0&&(t===void 0||r===void 0);s--){const o=n.tags[s];o.length>=2&&(o[0]==="e"&&t===void 0?t=o:o[0]==="p"&&r===void 0&&(r=o))}if(t!==void 0)return{id:t[1],relays:[t[2],r?.[2]].filter(s=>typeof s=="string"),author:r?.[1]}}function getRepostedEvent$1(n,{skipVerification:t}={}){const r=getRepostedEventPointer$1(n);if(r===void 0||n.content==="")return;let s;try{s=JSON.parse(n.content)}catch{return}if(s.id===r.id&&!(!t&&!verifyEvent$1(s)))return s}var nip21_exports$1={};__export2(nip21_exports$1,{NOSTR_URI_REGEX:()=>NOSTR_URI_REGEX$1,parse:()=>parse2$1,test:()=>test$1});var NOSTR_URI_REGEX$1=new RegExp(`nostr:(${BECH32_REGEX$3.source})`);function test$1(n){return typeof n=="string"&&new RegExp(`^${NOSTR_URI_REGEX$1.source}$`).test(n)}function parse2$1(n){const t=n.match(new RegExp(`^${NOSTR_URI_REGEX$1.source}$`));if(!t)throw new Error(`Invalid Nostr URI: ${n}`);return{uri:t[0],value:t[1],decoded:decode$2(t[1])}}var nip25_exports$1={};__export2(nip25_exports$1,{finishReactionEvent:()=>finishReactionEvent$1,getReactedEventPointer:()=>getReactedEventPointer$1});function finishReactionEvent$1(n,t,r){const s=t.tags.filter(o=>o.length>=2&&(o[0]==="e"||o[0]==="p"));return finalizeEvent$1({...n,kind:Reaction$1,tags:[...n.tags??[],...s,["e",t.id],["p",t.pubkey]],content:n.content??"+"},r)}function getReactedEventPointer$1(n){if(n.kind!==Reaction$1)return;let t,r;for(let s=n.tags.length-1;s>=0&&(t===void 0||r===void 0);s--){const o=n.tags[s];o.length>=2&&(o[0]==="e"&&t===void 0?t=o:o[0]==="p"&&r===void 0&&(r=o))}if(!(t===void 0||r===void 0))return{id:t[1],relays:[t[2],r[2]].filter(s=>s!==void 0),author:r[1]}}var nip27_exports$1={};__export2(nip27_exports$1,{parse:()=>parse3$1});var noCharacter$1=/\W/m,noURLCharacter$1=/\W |\W$|$|,| /m;function*parse3$1(n){const t=n.length;let r=0,s=0;for(;s<t;){let o=n.indexOf(":",s);if(o===-1)break;if(n.substring(o-5,o)==="nostr"){const a=n.substring(o+60).match(noCharacter$1),c=a?o+60+a.index:t;try{let f,{data:g,type:m}=decode$2(n.substring(o+1,c));switch(m){case"npub":f={pubkey:g};break;case"nsec":case"note":s=c+1;continue;default:f=g}r!==o-5&&(yield{type:"text",text:n.substring(r,o-5)}),yield{type:"reference",pointer:f},s=c,r=s;continue}catch{s=o+1;continue}}else if(n.substring(o-5,o)==="https"||n.substring(o-4,o)==="http"){const a=n.substring(o+4).match(noURLCharacter$1),c=a?o+4+a.index:t,f=n[o-1]==="s"?5:4;try{let g=new URL(n.substring(o-f,c));if(g.hostname.indexOf(".")===-1)throw new Error("invalid url");if(r!==o-f&&(yield{type:"text",text:n.substring(r,o-f)}),/\.(png|jpe?g|gif|webp)$/i.test(g.pathname)){yield{type:"image",url:g.toString()},s=c,r=s;continue}if(/\.(mp4|avi|webm|mkv)$/i.test(g.pathname)){yield{type:"video",url:g.toString()},s=c,r=s;continue}if(/\.(mp3|aac|ogg|opus)$/i.test(g.pathname)){yield{type:"audio",url:g.toString()},s=c,r=s;continue}yield{type:"url",url:g.toString()},s=c,r=s;continue}catch{s=c+1;continue}}else if(n.substring(o-3,o)==="wss"||n.substring(o-2,o)==="ws"){const a=n.substring(o+4).match(noURLCharacter$1),c=a?o+4+a.index:t,f=n[o-1]==="s"?3:2;try{let g=new URL(n.substring(o-f,c));if(g.hostname.indexOf(".")===-1)throw new Error("invalid ws url");r!==o-f&&(yield{type:"text",text:n.substring(r,o-f)}),yield{type:"relay",url:g.toString()},s=c,r=s;continue}catch{s=c+1;continue}}else{s=o+1;continue}}r!==t&&(yield{type:"text",text:n.substring(r)})}var nip28_exports$1={};__export2(nip28_exports$1,{channelCreateEvent:()=>channelCreateEvent$1,channelHideMessageEvent:()=>channelHideMessageEvent$1,channelMessageEvent:()=>channelMessageEvent$1,channelMetadataEvent:()=>channelMetadataEvent$1,channelMuteUserEvent:()=>channelMuteUserEvent$1});var channelCreateEvent$1=(n,t)=>{let r;if(typeof n.content=="object")r=JSON.stringify(n.content);else if(typeof n.content=="string")r=n.content;else return;return finalizeEvent$1({kind:ChannelCreation$1,tags:[...n.tags??[]],content:r,created_at:n.created_at},t)},channelMetadataEvent$1=(n,t)=>{let r;if(typeof n.content=="object")r=JSON.stringify(n.content);else if(typeof n.content=="string")r=n.content;else return;return finalizeEvent$1({kind:ChannelMetadata$1,tags:[["e",n.channel_create_event_id],...n.tags??[]],content:r,created_at:n.created_at},t)},channelMessageEvent$1=(n,t)=>{const r=[["e",n.channel_create_event_id,n.relay_url,"root"]];return n.reply_to_channel_message_event_id&&r.push(["e",n.reply_to_channel_message_event_id,n.relay_url,"reply"]),finalizeEvent$1({kind:ChannelMessage$1,tags:[...r,...n.tags??[]],content:n.content,created_at:n.created_at},t)},channelHideMessageEvent$1=(n,t)=>{let r;if(typeof n.content=="object")r=JSON.stringify(n.content);else if(typeof n.content=="string")r=n.content;else return;return finalizeEvent$1({kind:ChannelHideMessage$1,tags:[["e",n.channel_message_event_id],...n.tags??[]],content:r,created_at:n.created_at},t)},channelMuteUserEvent$1=(n,t)=>{let r;if(typeof n.content=="object")r=JSON.stringify(n.content);else if(typeof n.content=="string")r=n.content;else return;return finalizeEvent$1({kind:ChannelMuteUser$1,tags:[["p",n.pubkey_to_mute],...n.tags??[]],content:r,created_at:n.created_at},t)},nip30_exports$1={};__export2(nip30_exports$1,{EMOJI_SHORTCODE_REGEX:()=>EMOJI_SHORTCODE_REGEX$1,matchAll:()=>matchAll$1,regex:()=>regex$1,replaceAll:()=>replaceAll$1});var EMOJI_SHORTCODE_REGEX$1=/:(\w+):/,regex$1=()=>new RegExp(`\\B${EMOJI_SHORTCODE_REGEX$1.source}\\B`,"g");function*matchAll$1(n){const t=n.matchAll(regex$1());for(const r of t)try{const[s,o]=r;yield{shortcode:s,name:o,start:r.index,end:r.index+s.length}}catch{}}function replaceAll$1(n,t){return n.replaceAll(regex$1(),(r,s)=>t({shortcode:r,name:s}))}var nip39_exports$1={};__export2(nip39_exports$1,{useFetchImplementation:()=>useFetchImplementation3$1,validateGithub:()=>validateGithub$1});var _fetch3$1;try{_fetch3$1=fetch}catch{}function useFetchImplementation3$1(n){_fetch3$1=n}async function validateGithub$1(n,t,r){try{return await(await _fetch3$1(`https://gist.github.com/${t}/${r}/raw`)).text()===`Verifying that I control the following Nostr public key: ${n}`}catch{return!1}}var nip47_exports$1={};__export2(nip47_exports$1,{makeNwcRequestEvent:()=>makeNwcRequestEvent$1,parseConnectionString:()=>parseConnectionString$1});function parseConnectionString$1(n){const{host:t,pathname:r,searchParams:s}=new URL(n),o=r||t,a=s.get("relay"),c=s.get("secret");if(!o||!a||!c)throw new Error("invalid connection string");return{pubkey:o,relay:a,secret:c}}async function makeNwcRequestEvent$1(n,t,r){const o=encrypt2$1(t,n,JSON.stringify({method:"pay_invoice",params:{invoice:r}})),a={kind:NWCWalletRequest$1,created_at:Math.round(Date.now()/1e3),content:o,tags:[["p",n]]};return finalizeEvent$1(a,t)}var nip54_exports$1={};__export2(nip54_exports$1,{normalizeIdentifier:()=>normalizeIdentifier$1});function normalizeIdentifier$1(n){return n=n.trim().toLowerCase(),n=n.normalize("NFKC"),Array.from(n).map(t=>new RegExp("\\p{Letter}","u").test(t)||new RegExp("\\p{Number}","u").test(t)?t:"-").join("")}var nip57_exports$1={};__export2(nip57_exports$1,{getSatoshisAmountFromBolt11:()=>getSatoshisAmountFromBolt11$1,getZapEndpoint:()=>getZapEndpoint$1,makeZapReceipt:()=>makeZapReceipt$1,makeZapRequest:()=>makeZapRequest$1,useFetchImplementation:()=>useFetchImplementation4$1,validateZapRequest:()=>validateZapRequest$1});var _fetch4$1;try{_fetch4$1=fetch}catch{}function useFetchImplementation4$1(n){_fetch4$1=n}async function getZapEndpoint$1(n){try{let t="",{lud06:r,lud16:s}=JSON.parse(n.content);if(s){let[c,f]=s.split("@");t=new URL(`/.well-known/lnurlp/${c}`,`https://${f}`).toString()}else if(r){let{words:c}=bech32$3.decode(r,1e3),f=bech32$3.fromWords(c);t=utf8Decoder$2.decode(f)}else return null;let a=await(await _fetch4$1(t)).json();if(a.allowsNostr&&a.nostrPubkey)return a.callback}catch{}return null}function makeZapRequest$1(n){let t={kind:9734,created_at:Math.round(Date.now()/1e3),content:n.comment||"",tags:[["p","pubkey"in n?n.pubkey:n.event.pubkey],["amount",n.amount.toString()],["relays",...n.relays]]};if("event"in n){if(t.tags.push(["e",n.event.id]),isReplaceableKind$1(n.event.kind)){const r=["a",`${n.event.kind}:${n.event.pubkey}:`];t.tags.push(r)}else if(isAddressableKind$1(n.event.kind)){let r=n.event.tags.find(([o,a])=>o==="d"&&a);if(!r)throw new Error("d tag not found or is empty");const s=["a",`${n.event.kind}:${n.event.pubkey}:${r[1]}`];t.tags.push(s)}t.tags.push(["k",n.event.kind.toString()])}return t}function validateZapRequest$1(n){let t;try{t=JSON.parse(n)}catch{return"Invalid zap request JSON."}if(!validateEvent$1(t))return"Zap request is not a valid Nostr event.";if(!verifyEvent$1(t))return"Invalid signature on zap request.";let r=t.tags.find(([a,c])=>a==="p"&&c);if(!r)return"Zap request doesn't have a 'p' tag.";if(!r[1].match(/^[a-f0-9]{64}$/))return"Zap request 'p' tag is not valid hex.";let s=t.tags.find(([a,c])=>a==="e"&&c);return s&&!s[1].match(/^[a-f0-9]{64}$/)?"Zap request 'e' tag is not valid hex.":t.tags.find(([a,c])=>a==="relays"&&c)?null:"Zap request doesn't have a 'relays' tag."}function makeZapReceipt$1({zapRequest:n,preimage:t,bolt11:r,paidAt:s}){let o=JSON.parse(n),a=o.tags.filter(([f])=>f==="e"||f==="p"||f==="a"),c={kind:9735,created_at:Math.round(s.getTime()/1e3),content:"",tags:[...a,["P",o.pubkey],["bolt11",r],["description",n]]};return t&&c.tags.push(["preimage",t]),c}function getSatoshisAmountFromBolt11$1(n){if(n.length<50)return 0;n=n.substring(0,50);const t=n.lastIndexOf("1");if(t===-1)return 0;const r=n.substring(0,t);if(!r.startsWith("lnbc"))return 0;const s=r.substring(4);if(s.length<1)return 0;const o=s[s.length-1],a=o.charCodeAt(0)-48,c=a>=0&&a<=9;let f=s.length-1;if(c&&f++,f<1)return 0;const g=parseInt(s.substring(0,f));switch(o){case"m":return g*1e5;case"u":return g*100;case"n":return g/10;case"p":return g/1e4;default:return g*1e8}}var nip98_exports$1={};__export2(nip98_exports$1,{getToken:()=>getToken$1,hashPayload:()=>hashPayload$1,unpackEventFromToken:()=>unpackEventFromToken$1,validateEvent:()=>validateEvent2$1,validateEventKind:()=>validateEventKind$1,validateEventMethodTag:()=>validateEventMethodTag$1,validateEventPayloadTag:()=>validateEventPayloadTag$1,validateEventTimestamp:()=>validateEventTimestamp$1,validateEventUrlTag:()=>validateEventUrlTag$1,validateToken:()=>validateToken$1});var _authorizationScheme$1="Nostr ";async function getToken$1(n,t,r,s=!1,o){const a={kind:HTTPAuth$1,tags:[["u",n],["method",t]],created_at:Math.round(new Date().getTime()/1e3),content:""};o&&a.tags.push(["payload",hashPayload$1(o)]);const c=await r(a);return(s?_authorizationScheme$1:"")+base64$2.encode(utf8Encoder$2.encode(JSON.stringify(c)))}async function validateToken$1(n,t,r){const s=await unpackEventFromToken$1(n).catch(a=>{throw a});return await validateEvent2$1(s,t,r).catch(a=>{throw a})}async function unpackEventFromToken$1(n){if(!n)throw new Error("Missing token");n=n.replace(_authorizationScheme$1,"");const t=utf8Decoder$2.decode(base64$2.decode(n));if(!t||t.length===0||!t.startsWith("{"))throw new Error("Invalid token");return JSON.parse(t)}function validateEventTimestamp$1(n){return n.created_at?Math.round(new Date().getTime()/1e3)-n.created_at<60:!1}function validateEventKind$1(n){return n.kind===HTTPAuth$1}function validateEventUrlTag$1(n,t){const r=n.tags.find(s=>s[0]==="u");return r?r.length>0&&r[1]===t:!1}function validateEventMethodTag$1(n,t){const r=n.tags.find(s=>s[0]==="method");return r?r.length>0&&r[1].toLowerCase()===t.toLowerCase():!1}function hashPayload$1(n){const t=sha2562(utf8Encoder$2.encode(JSON.stringify(n)));return bytesToHex2(t)}function validateEventPayloadTag$1(n,t){const r=n.tags.find(o=>o[0]==="payload");if(!r)return!1;const s=hashPayload$1(t);return r.length>0&&r[1]===s}async function validateEvent2$1(n,t,r,s){if(!verifyEvent$1(n))throw new Error("Invalid nostr event, signature invalid");if(!validateEventKind$1(n))throw new Error("Invalid nostr event, kind invalid");if(!validateEventTimestamp$1(n))throw new Error("Invalid nostr event, created_at timestamp invalid");if(!validateEventUrlTag$1(n,t))throw new Error("Invalid nostr event, url tag invalid");if(!validateEventMethodTag$1(n,r))throw new Error("Invalid nostr event, method tag invalid");if(s&&typeof s=="object"&&Object.keys(s).length>0&&!validateEventPayloadTag$1(n,s))throw new Error("Invalid nostr event, payload tag does not match request body hash");return!0}var crypto3=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;function isBytes2(n){return n instanceof Uint8Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint8Array"}function anumber$2(n){if(!Number.isSafeInteger(n)||n<0)throw new Error("positive integer expected, got "+n)}function abytes$1(n,...t){if(!isBytes2(n))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(n.length))throw new Error("Uint8Array expected of length "+t+", got length="+n.length)}function ahash$1(n){if(typeof n!="function"||typeof n.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");anumber$2(n.outputLen),anumber$2(n.blockLen)}function aexists$1(n,t=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(t&&n.finished)throw new Error("Hash#digest() has already been called")}function aoutput$1(n,t){abytes$1(n);const r=t.outputLen;if(n.length<r)throw new Error("digestInto() expects output buffer of length at least "+r)}function clean$1(...n){for(let t=0;t<n.length;t++)n[t].fill(0)}function createView4(n){return new DataView(n.buffer,n.byteOffset,n.byteLength)}function rotr3(n,t){return n<<32-t|n>>>t}var hasHexBuiltin$1=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",hexes3=Array.from({length:256},(n,t)=>t.toString(16).padStart(2,"0"));function bytesToHex3(n){if(abytes$1(n),hasHexBuiltin$1)return n.toHex();let t="";for(let r=0;r<n.length;r++)t+=hexes3[n[r]];return t}var asciis$1={_0:48,_9:57,A:65,F:70,a:97,f:102};function asciiToBase16$1(n){if(n>=asciis$1._0&&n<=asciis$1._9)return n-asciis$1._0;if(n>=asciis$1.A&&n<=asciis$1.F)return n-(asciis$1.A-10);if(n>=asciis$1.a&&n<=asciis$1.f)return n-(asciis$1.a-10)}function hexToBytes3(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);if(hasHexBuiltin$1)return Uint8Array.fromHex(n);const t=n.length,r=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const s=new Uint8Array(r);for(let o=0,a=0;o<r;o++,a+=2){const c=asciiToBase16$1(n.charCodeAt(a)),f=asciiToBase16$1(n.charCodeAt(a+1));if(c===void 0||f===void 0){const g=n[a]+n[a+1];throw new Error('hex string expected, got non-hex character "'+g+'" at index '+a)}s[o]=c*16+f}return s}function utf8ToBytes5(n){if(typeof n!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(n))}function toBytes4(n){return typeof n=="string"&&(n=utf8ToBytes5(n)),abytes$1(n),n}function concatBytes4(...n){let t=0;for(let s=0;s<n.length;s++){const o=n[s];abytes$1(o),t+=o.length}const r=new Uint8Array(t);for(let s=0,o=0;s<n.length;s++){const a=n[s];r.set(a,o),o+=a.length}return r}class Hash3{}function createHasher$1(n){const t=s=>n().update(toBytes4(s)).digest(),r=n();return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=()=>n(),t}function randomBytes3(n=32){if(crypto3&&typeof crypto3.getRandomValues=="function")return crypto3.getRandomValues(new Uint8Array(n));if(crypto3&&typeof crypto3.randomBytes=="function")return Uint8Array.from(crypto3.randomBytes(n));throw new Error("crypto.getRandomValues must be defined")}function setBigUint644(n,t,r,s){if(typeof n.setBigUint64=="function")return n.setBigUint64(t,r,s);const o=BigInt(32),a=BigInt(4294967295),c=Number(r>>o&a),f=Number(r&a),g=s?4:0,m=s?0:4;n.setUint32(t+g,c,s),n.setUint32(t+m,f,s)}function Chi3(n,t,r){return n&t^~n&r}function Maj3(n,t,r){return n&t^n&r^t&r}let HashMD$1=class extends Hash3{constructor(t,r,s,o){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=t,this.outputLen=r,this.padOffset=s,this.isLE=o,this.buffer=new Uint8Array(t),this.view=createView4(this.buffer)}update(t){aexists$1(this),t=toBytes4(t),abytes$1(t);const{view:r,buffer:s,blockLen:o}=this,a=t.length;for(let c=0;c<a;){const f=Math.min(o-this.pos,a-c);if(f===o){const g=createView4(t);for(;o<=a-c;c+=o)this.process(g,c);continue}s.set(t.subarray(c,c+f),this.pos),this.pos+=f,c+=f,this.pos===o&&(this.process(r,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){aexists$1(this),aoutput$1(t,this),this.finished=!0;const{buffer:r,view:s,blockLen:o,isLE:a}=this;let{pos:c}=this;r[c++]=128,clean$1(this.buffer.subarray(c)),this.padOffset>o-c&&(this.process(s,0),c=0);for(let k=c;k<o;k++)r[k]=0;setBigUint644(s,o-8,BigInt(this.length*8),a),this.process(s,0);const f=createView4(t),g=this.outputLen;if(g%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const m=g/4,b=this.get();if(m>b.length)throw new Error("_sha2: outputLen bigger than state");for(let k=0;k<m;k++)f.setUint32(4*k,b[k],a)}digest(){const{buffer:t,outputLen:r}=this;this.digestInto(t);const s=t.slice(0,r);return this.destroy(),s}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:r,buffer:s,length:o,finished:a,destroyed:c,pos:f}=this;return t.destroyed=c,t.finished=a,t.length=o,t.pos=f,o%r&&t.buffer.set(s),t}clone(){return this._cloneInto()}};var SHA256_IV$1=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_K3=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),SHA256_W3=new Uint32Array(64);class SHA2563 extends HashMD$1{constructor(t=32){super(64,t,8,!1),this.A=SHA256_IV$1[0]|0,this.B=SHA256_IV$1[1]|0,this.C=SHA256_IV$1[2]|0,this.D=SHA256_IV$1[3]|0,this.E=SHA256_IV$1[4]|0,this.F=SHA256_IV$1[5]|0,this.G=SHA256_IV$1[6]|0,this.H=SHA256_IV$1[7]|0}get(){const{A:t,B:r,C:s,D:o,E:a,F:c,G:f,H:g}=this;return[t,r,s,o,a,c,f,g]}set(t,r,s,o,a,c,f,g){this.A=t|0,this.B=r|0,this.C=s|0,this.D=o|0,this.E=a|0,this.F=c|0,this.G=f|0,this.H=g|0}process(t,r){for(let k=0;k<16;k++,r+=4)SHA256_W3[k]=t.getUint32(r,!1);for(let k=16;k<64;k++){const _=SHA256_W3[k-15],A=SHA256_W3[k-2],B=rotr3(_,7)^rotr3(_,18)^_>>>3,L=rotr3(A,17)^rotr3(A,19)^A>>>10;SHA256_W3[k]=L+SHA256_W3[k-7]+B+SHA256_W3[k-16]|0}let{A:s,B:o,C:a,D:c,E:f,F:g,G:m,H:b}=this;for(let k=0;k<64;k++){const _=rotr3(f,6)^rotr3(f,11)^rotr3(f,25),A=b+_+Chi3(f,g,m)+SHA256_K3[k]+SHA256_W3[k]|0,L=(rotr3(s,2)^rotr3(s,13)^rotr3(s,22))+Maj3(s,o,a)|0;b=m,m=g,g=f,f=c+A|0,c=a,a=o,o=s,s=A+L|0}s=s+this.A|0,o=o+this.B|0,a=a+this.C|0,c=c+this.D|0,f=f+this.E|0,g=g+this.F|0,m=m+this.G|0,b=b+this.H|0,this.set(s,o,a,c,f,g,m,b)}roundClean(){clean$1(SHA256_W3)}destroy(){this.set(0,0,0,0,0,0,0,0),clean$1(this.buffer)}}var sha2563=createHasher$1(()=>new SHA2563);class HMAC3 extends Hash3{constructor(t,r){super(),this.finished=!1,this.destroyed=!1,ahash$1(t);const s=toBytes4(r);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,a=new Uint8Array(o);a.set(s.length>o?t.create().update(s).digest():s);for(let c=0;c<a.length;c++)a[c]^=54;this.iHash.update(a),this.oHash=t.create();for(let c=0;c<a.length;c++)a[c]^=106;this.oHash.update(a),clean$1(a)}update(t){return aexists$1(this),this.iHash.update(t),this}digestInto(t){aexists$1(this),abytes$1(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:r,iHash:s,finished:o,destroyed:a,blockLen:c,outputLen:f}=this;return t=t,t.finished=o,t.destroyed=a,t.blockLen=c,t.outputLen=f,t.oHash=r._cloneInto(t.oHash),t.iHash=s._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var hmac3=(n,t,r)=>new HMAC3(n,t).update(r).digest();hmac3.create=(n,t)=>new HMAC3(n,t);var _0n6=BigInt(0),_1n6=BigInt(1);function _abool2$1(n,t=""){if(typeof n!="boolean"){const r=t&&`"${t}"`;throw new Error(r+"expected boolean, got type="+typeof n)}return n}function _abytes2$1(n,t,r=""){const s=isBytes2(n),o=n?.length,a=t!==void 0;if(!s||a&&o!==t){const c=r&&`"${r}" `,f=a?` of length ${t}`:"",g=s?`length=${o}`:`type=${typeof n}`;throw new Error(c+"expected Uint8Array"+f+", got "+g)}return n}function numberToHexUnpadded2(n){const t=n.toString(16);return t.length&1?"0"+t:t}function hexToNumber2(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return n===""?_0n6:BigInt("0x"+n)}function bytesToNumberBE2(n){return hexToNumber2(bytesToHex3(n))}function bytesToNumberLE2(n){return abytes$1(n),hexToNumber2(bytesToHex3(Uint8Array.from(n).reverse()))}function numberToBytesBE2(n,t){return hexToBytes3(n.toString(16).padStart(t*2,"0"))}function numberToBytesLE2(n,t){return numberToBytesBE2(n,t).reverse()}function ensureBytes2(n,t,r){let s;if(typeof t=="string")try{s=hexToBytes3(t)}catch(a){throw new Error(n+" must be hex string or Uint8Array, cause: "+a)}else if(isBytes2(t))s=Uint8Array.from(t);else throw new Error(n+" must be hex string or Uint8Array");const o=s.length;if(typeof r=="number"&&o!==r)throw new Error(n+" of length "+r+" expected, got "+o);return s}var isPosBig$1=n=>typeof n=="bigint"&&_0n6<=n;function inRange$1(n,t,r){return isPosBig$1(n)&&isPosBig$1(t)&&isPosBig$1(r)&&t<=n&&n<r}function aInRange$1(n,t,r,s){if(!inRange$1(t,r,s))throw new Error("expected valid "+n+": "+r+" <= n < "+s+", got "+t)}function bitLen2(n){let t;for(t=0;n>_0n6;n>>=_1n6,t+=1);return t}var bitMask2=n=>(_1n6<<BigInt(n))-_1n6;function createHmacDrbg2(n,t,r){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof r!="function")throw new Error("hmacFn must be a function");const s=A=>new Uint8Array(A),o=A=>Uint8Array.of(A);let a=s(n),c=s(n),f=0;const g=()=>{a.fill(1),c.fill(0),f=0},m=(...A)=>r(c,a,...A),b=(A=s(0))=>{c=m(o(0),A),a=m(),A.length!==0&&(c=m(o(1),A),a=m())},k=()=>{if(f++>=1e3)throw new Error("drbg: tried 1000 values");let A=0;const B=[];for(;A<t;){a=m();const L=a.slice();B.push(L),A+=a.length}return concatBytes4(...B)};return(A,B)=>{g(),b(A);let L;for(;!(L=B(k()));)b();return g(),L}}function _validateObject$1(n,t,r={}){if(!n||typeof n!="object")throw new Error("expected valid options object");function s(o,a,c){const f=n[o];if(c&&f===void 0)return;const g=typeof f;if(g!==a||f===null)throw new Error(`param "${o}" is invalid: expected ${a}, got ${g}`)}Object.entries(t).forEach(([o,a])=>s(o,a,!1)),Object.entries(r).forEach(([o,a])=>s(o,a,!0))}function memoized$1(n){const t=new WeakMap;return(r,...s)=>{const o=t.get(r);if(o!==void 0)return o;const a=n(r,...s);return t.set(r,a),a}}var _0n7=BigInt(0),_1n7=BigInt(1),_2n5=BigInt(2),_3n3=BigInt(3),_4n3=BigInt(4),_5n2=BigInt(5),_7n$1=BigInt(7),_8n2=BigInt(8),_9n2=BigInt(9),_16n2=BigInt(16);function mod2(n,t){const r=n%t;return r>=_0n7?r:t+r}function pow22(n,t,r){let s=n;for(;t-- >_0n7;)s*=s,s%=r;return s}function invert2(n,t){if(n===_0n7)throw new Error("invert: expected non-zero number");if(t<=_0n7)throw new Error("invert: expected positive modulus, got "+t);let r=mod2(n,t),s=t,o=_0n7,a=_1n7;for(;r!==_0n7;){const f=s/r,g=s%r,m=o-a*f;s=r,r=g,o=a,a=m}if(s!==_1n7)throw new Error("invert: does not exist");return mod2(o,t)}function assertIsSquare$1(n,t,r){if(!n.eql(n.sqr(t),r))throw new Error("Cannot find square root")}function sqrt3mod4$1(n,t){const r=(n.ORDER+_1n7)/_4n3,s=n.pow(t,r);return assertIsSquare$1(n,s,t),s}function sqrt5mod8$1(n,t){const r=(n.ORDER-_5n2)/_8n2,s=n.mul(t,_2n5),o=n.pow(s,r),a=n.mul(t,o),c=n.mul(n.mul(a,_2n5),o),f=n.mul(a,n.sub(c,n.ONE));return assertIsSquare$1(n,f,t),f}function sqrt9mod16$1(n){const t=Field2(n),r=tonelliShanks2(n),s=r(t,t.neg(t.ONE)),o=r(t,s),a=r(t,t.neg(s)),c=(n+_7n$1)/_16n2;return(f,g)=>{let m=f.pow(g,c),b=f.mul(m,s);const k=f.mul(m,o),_=f.mul(m,a),A=f.eql(f.sqr(b),g),B=f.eql(f.sqr(k),g);m=f.cmov(m,b,A),b=f.cmov(_,k,B);const L=f.eql(f.sqr(b),g),Z=f.cmov(m,b,L);return assertIsSquare$1(f,Z,g),Z}}function tonelliShanks2(n){if(n<_3n3)throw new Error("sqrt is not defined for small field");let t=n-_1n7,r=0;for(;t%_2n5===_0n7;)t/=_2n5,r++;let s=_2n5;const o=Field2(n);for(;FpLegendre$1(o,s)===1;)if(s++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(r===1)return sqrt3mod4$1;let a=o.pow(s,t);const c=(t+_1n7)/_2n5;return function(g,m){if(g.is0(m))return m;if(FpLegendre$1(g,m)!==1)throw new Error("Cannot find square root");let b=r,k=g.mul(g.ONE,a),_=g.pow(m,t),A=g.pow(m,c);for(;!g.eql(_,g.ONE);){if(g.is0(_))return g.ZERO;let B=1,L=g.sqr(_);for(;!g.eql(L,g.ONE);)if(B++,L=g.sqr(L),B===b)throw new Error("Cannot find square root");const Z=_1n7<<BigInt(b-B-1),ve=g.pow(k,Z);b=B,k=g.sqr(ve),_=g.mul(_,k),A=g.mul(A,ve)}return A}}function FpSqrt2(n){return n%_4n3===_3n3?sqrt3mod4$1:n%_8n2===_5n2?sqrt5mod8$1:n%_16n2===_9n2?sqrt9mod16$1(n):tonelliShanks2(n)}var FIELD_FIELDS2=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function validateField2(n){const t={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},r=FIELD_FIELDS2.reduce((s,o)=>(s[o]="function",s),t);return _validateObject$1(n,r),n}function FpPow2(n,t,r){if(r<_0n7)throw new Error("invalid exponent, negatives unsupported");if(r===_0n7)return n.ONE;if(r===_1n7)return t;let s=n.ONE,o=t;for(;r>_0n7;)r&_1n7&&(s=n.mul(s,o)),o=n.sqr(o),r>>=_1n7;return s}function FpInvertBatch2(n,t,r=!1){const s=new Array(t.length).fill(r?n.ZERO:void 0),o=t.reduce((c,f,g)=>n.is0(f)?c:(s[g]=c,n.mul(c,f)),n.ONE),a=n.inv(o);return t.reduceRight((c,f,g)=>n.is0(f)?c:(s[g]=n.mul(c,s[g]),n.mul(c,f)),a),s}function FpLegendre$1(n,t){const r=(n.ORDER-_1n7)/_2n5,s=n.pow(t,r),o=n.eql(s,n.ONE),a=n.eql(s,n.ZERO),c=n.eql(s,n.neg(n.ONE));if(!o&&!a&&!c)throw new Error("invalid Legendre symbol result");return o?1:a?0:-1}function nLength2(n,t){t!==void 0&&anumber$2(t);const r=t!==void 0?t:n.toString(2).length,s=Math.ceil(r/8);return{nBitLength:r,nByteLength:s}}function Field2(n,t,r=!1,s={}){if(n<=_0n7)throw new Error("invalid field: expected ORDER > 0, got "+n);let o,a,c=!1,f;if(typeof t=="object"&&t!=null){if(s.sqrt||r)throw new Error("cannot specify opts in two arguments");const _=t;_.BITS&&(o=_.BITS),_.sqrt&&(a=_.sqrt),typeof _.isLE=="boolean"&&(r=_.isLE),typeof _.modFromBytes=="boolean"&&(c=_.modFromBytes),f=_.allowedLengths}else typeof t=="number"&&(o=t),s.sqrt&&(a=s.sqrt);const{nBitLength:g,nByteLength:m}=nLength2(n,o);if(m>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let b;const k=Object.freeze({ORDER:n,isLE:r,BITS:g,BYTES:m,MASK:bitMask2(g),ZERO:_0n7,ONE:_1n7,allowedLengths:f,create:_=>mod2(_,n),isValid:_=>{if(typeof _!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof _);return _0n7<=_&&_<n},is0:_=>_===_0n7,isValidNot0:_=>!k.is0(_)&&k.isValid(_),isOdd:_=>(_&_1n7)===_1n7,neg:_=>mod2(-_,n),eql:(_,A)=>_===A,sqr:_=>mod2(_*_,n),add:(_,A)=>mod2(_+A,n),sub:(_,A)=>mod2(_-A,n),mul:(_,A)=>mod2(_*A,n),pow:(_,A)=>FpPow2(k,_,A),div:(_,A)=>mod2(_*invert2(A,n),n),sqrN:_=>_*_,addN:(_,A)=>_+A,subN:(_,A)=>_-A,mulN:(_,A)=>_*A,inv:_=>invert2(_,n),sqrt:a||(_=>(b||(b=FpSqrt2(n)),b(k,_))),toBytes:_=>r?numberToBytesLE2(_,m):numberToBytesBE2(_,m),fromBytes:(_,A=!0)=>{if(f){if(!f.includes(_.length)||_.length>m)throw new Error("Field.fromBytes: expected "+f+" bytes, got "+_.length);const L=new Uint8Array(m);L.set(_,r?0:L.length-_.length),_=L}if(_.length!==m)throw new Error("Field.fromBytes: expected "+m+" bytes, got "+_.length);let B=r?bytesToNumberLE2(_):bytesToNumberBE2(_);if(c&&(B=mod2(B,n)),!A&&!k.isValid(B))throw new Error("invalid field element: outside of range 0..ORDER");return B},invertBatch:_=>FpInvertBatch2(k,_),cmov:(_,A,B)=>B?A:_});return Object.freeze(k)}function getFieldBytesLength2(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const t=n.toString(2).length;return Math.ceil(t/8)}function getMinHashLength2(n){const t=getFieldBytesLength2(n);return t+Math.ceil(t/2)}function mapHashToField2(n,t,r=!1){const s=n.length,o=getFieldBytesLength2(t),a=getMinHashLength2(t);if(s<16||s<a||s>1024)throw new Error("expected "+a+"-1024 bytes of input, got "+s);const c=r?bytesToNumberLE2(n):bytesToNumberBE2(n),f=mod2(c,t-_1n7)+_1n7;return r?numberToBytesLE2(f,o):numberToBytesBE2(f,o)}var _0n8=BigInt(0),_1n8=BigInt(1);function negateCt$1(n,t){const r=t.negate();return n?r:t}function normalizeZ$1(n,t){const r=FpInvertBatch2(n.Fp,t.map(s=>s.Z));return t.map((s,o)=>n.fromAffine(s.toAffine(r[o])))}function validateW$1(n,t){if(!Number.isSafeInteger(n)||n<=0||n>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+n)}function calcWOpts$1(n,t){validateW$1(n,t);const r=Math.ceil(t/n)+1,s=2**(n-1),o=2**n,a=bitMask2(n),c=BigInt(n);return{windows:r,windowSize:s,mask:a,maxNumber:o,shiftBy:c}}function calcOffsets$1(n,t,r){const{windowSize:s,mask:o,maxNumber:a,shiftBy:c}=r;let f=Number(n&o),g=n>>c;f>s&&(f-=a,g+=_1n8);const m=t*s,b=m+Math.abs(f)-1,k=f===0,_=f<0,A=t%2!==0;return{nextN:g,offset:b,isZero:k,isNeg:_,isNegF:A,offsetF:m}}function validateMSMPoints$1(n,t){if(!Array.isArray(n))throw new Error("array expected");n.forEach((r,s)=>{if(!(r instanceof t))throw new Error("invalid point at index "+s)})}function validateMSMScalars$1(n,t){if(!Array.isArray(n))throw new Error("array of scalars expected");n.forEach((r,s)=>{if(!t.isValid(r))throw new Error("invalid scalar at index "+s)})}var pointPrecomputes$1=new WeakMap,pointWindowSizes$1=new WeakMap;function getW$1(n){return pointWindowSizes$1.get(n)||1}function assert0$1(n){if(n!==_0n8)throw new Error("invalid wNAF")}class wNAF2{constructor(t,r){this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=r}_unsafeLadder(t,r,s=this.ZERO){let o=t;for(;r>_0n8;)r&_1n8&&(s=s.add(o)),o=o.double(),r>>=_1n8;return s}precomputeWindow(t,r){const{windows:s,windowSize:o}=calcWOpts$1(r,this.bits),a=[];let c=t,f=c;for(let g=0;g<s;g++){f=c,a.push(f);for(let m=1;m<o;m++)f=f.add(c),a.push(f);c=f.double()}return a}wNAF(t,r,s){if(!this.Fn.isValid(s))throw new Error("invalid scalar");let o=this.ZERO,a=this.BASE;const c=calcWOpts$1(t,this.bits);for(let f=0;f<c.windows;f++){const{nextN:g,offset:m,isZero:b,isNeg:k,isNegF:_,offsetF:A}=calcOffsets$1(s,f,c);s=g,b?a=a.add(negateCt$1(_,r[A])):o=o.add(negateCt$1(k,r[m]))}return assert0$1(s),{p:o,f:a}}wNAFUnsafe(t,r,s,o=this.ZERO){const a=calcWOpts$1(t,this.bits);for(let c=0;c<a.windows&&s!==_0n8;c++){const{nextN:f,offset:g,isZero:m,isNeg:b}=calcOffsets$1(s,c,a);if(s=f,!m){const k=r[g];o=o.add(b?k.negate():k)}}return assert0$1(s),o}getPrecomputes(t,r,s){let o=pointPrecomputes$1.get(r);return o||(o=this.precomputeWindow(r,t),t!==1&&(typeof s=="function"&&(o=s(o)),pointPrecomputes$1.set(r,o))),o}cached(t,r,s){const o=getW$1(t);return this.wNAF(o,this.getPrecomputes(o,t,s),r)}unsafe(t,r,s,o){const a=getW$1(t);return a===1?this._unsafeLadder(t,r,o):this.wNAFUnsafe(a,this.getPrecomputes(a,t,s),r,o)}createCache(t,r){validateW$1(r,this.bits),pointWindowSizes$1.set(t,r),pointPrecomputes$1.delete(t)}hasCache(t){return getW$1(t)!==1}}function mulEndoUnsafe$1(n,t,r,s){let o=t,a=n.ZERO,c=n.ZERO;for(;r>_0n8||s>_0n8;)r&_1n8&&(a=a.add(o)),s&_1n8&&(c=c.add(o)),o=o.double(),r>>=_1n8,s>>=_1n8;return{p1:a,p2:c}}function pippenger$1(n,t,r,s){validateMSMPoints$1(r,n),validateMSMScalars$1(s,t);const o=r.length,a=s.length;if(o!==a)throw new Error("arrays of points and scalars must have equal length");const c=n.ZERO,f=bitLen2(BigInt(o));let g=1;f>12?g=f-3:f>4?g=f-2:f>0&&(g=2);const m=bitMask2(g),b=new Array(Number(m)+1).fill(c),k=Math.floor((t.BITS-1)/g)*g;let _=c;for(let A=k;A>=0;A-=g){b.fill(c);for(let L=0;L<a;L++){const Z=s[L],ve=Number(Z>>BigInt(A)&m);b[ve]=b[ve].add(r[L])}let B=c;for(let L=b.length-1,Z=c;L>0;L--)Z=Z.add(b[L]),B=B.add(Z);if(_=_.add(B),A!==0)for(let L=0;L<g;L++)_=_.double()}return _}function createField$1(n,t,r){if(t){if(t.ORDER!==n)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return validateField2(t),t}else return Field2(n,{isLE:r})}function _createCurveFields$1(n,t,r={},s){if(s===void 0&&(s=n==="edwards"),!t||typeof t!="object")throw new Error(`expected valid ${n} CURVE object`);for(const g of["p","n","h"]){const m=t[g];if(!(typeof m=="bigint"&&m>_0n8))throw new Error(`CURVE.${g} must be positive bigint`)}const o=createField$1(t.p,r.Fp,s),a=createField$1(t.n,r.Fn,s),f=["Gx","Gy","a","b"];for(const g of f)if(!o.isValid(t[g]))throw new Error(`CURVE.${g} must be valid field element of CURVE.Fp`);return t=Object.freeze(Object.assign({},t)),{CURVE:t,Fp:o,Fn:a}}var divNearest2=(n,t)=>(n+(n>=0?t:-t)/_2n6)/t;function _splitEndoScalar$1(n,t,r){const[[s,o],[a,c]]=t,f=divNearest2(c*n,r),g=divNearest2(-o*n,r);let m=n-f*s-g*a,b=-f*o-g*c;const k=m<_0n9,_=b<_0n9;k&&(m=-m),_&&(b=-b);const A=bitMask2(Math.ceil(bitLen2(r)/2))+_1n9;if(m<_0n9||m>=A||b<_0n9||b>=A)throw new Error("splitScalar (endomorphism): failed, k="+n);return{k1neg:k,k1:m,k2neg:_,k2:b}}function validateSigFormat$1(n){if(!["compact","recovered","der"].includes(n))throw new Error('Signature format must be "compact", "recovered", or "der"');return n}function validateSigOpts$1(n,t){const r={};for(let s of Object.keys(t))r[s]=n[s]===void 0?t[s]:n[s];return _abool2$1(r.lowS,"lowS"),_abool2$1(r.prehash,"prehash"),r.format!==void 0&&validateSigFormat$1(r.format),r}class DERErr2 extends Error{constructor(t=""){super(t)}}var DER2={Err:DERErr2,_tlv:{encode:(n,t)=>{const{Err:r}=DER2;if(n<0||n>256)throw new r("tlv.encode: wrong tag");if(t.length&1)throw new r("tlv.encode: unpadded data");const s=t.length/2,o=numberToHexUnpadded2(s);if(o.length/2&128)throw new r("tlv.encode: long form length too big");const a=s>127?numberToHexUnpadded2(o.length/2|128):"";return numberToHexUnpadded2(n)+a+o+t},decode(n,t){const{Err:r}=DER2;let s=0;if(n<0||n>256)throw new r("tlv.encode: wrong tag");if(t.length<2||t[s++]!==n)throw new r("tlv.decode: wrong tlv");const o=t[s++],a=!!(o&128);let c=0;if(!a)c=o;else{const g=o&127;if(!g)throw new r("tlv.decode(long): indefinite length not supported");if(g>4)throw new r("tlv.decode(long): byte length is too big");const m=t.subarray(s,s+g);if(m.length!==g)throw new r("tlv.decode: length bytes not complete");if(m[0]===0)throw new r("tlv.decode(long): zero leftmost byte");for(const b of m)c=c<<8|b;if(s+=g,c<128)throw new r("tlv.decode(long): not minimal encoding")}const f=t.subarray(s,s+c);if(f.length!==c)throw new r("tlv.decode: wrong value length");return{v:f,l:t.subarray(s+c)}}},_int:{encode(n){const{Err:t}=DER2;if(n<_0n9)throw new t("integer: negative integers are not allowed");let r=numberToHexUnpadded2(n);if(Number.parseInt(r[0],16)&8&&(r="00"+r),r.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return r},decode(n){const{Err:t}=DER2;if(n[0]&128)throw new t("invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return bytesToNumberBE2(n)}},toSig(n){const{Err:t,_int:r,_tlv:s}=DER2,o=ensureBytes2("signature",n),{v:a,l:c}=s.decode(48,o);if(c.length)throw new t("invalid signature: left bytes after parsing");const{v:f,l:g}=s.decode(2,a),{v:m,l:b}=s.decode(2,g);if(b.length)throw new t("invalid signature: left bytes after parsing");return{r:r.decode(f),s:r.decode(m)}},hexFromSig(n){const{_tlv:t,_int:r}=DER2,s=t.encode(2,r.encode(n.r)),o=t.encode(2,r.encode(n.s)),a=s+o;return t.encode(48,a)}},_0n9=BigInt(0),_1n9=BigInt(1),_2n6=BigInt(2),_3n4=BigInt(3),_4n4=BigInt(4);function _normFnElement$1(n,t){const{BYTES:r}=n;let s;if(typeof t=="bigint")s=t;else{let o=ensureBytes2("private key",t);try{s=n.fromBytes(o)}catch{throw new Error(`invalid private key: expected ui8a of size ${r}, got ${typeof t}`)}}if(!n.isValidNot0(s))throw new Error("invalid private key: out of range [1..N-1]");return s}function weierstrassN$1(n,t={}){const r=_createCurveFields$1("weierstrass",n,t),{Fp:s,Fn:o}=r;let a=r.CURVE;const{h:c,n:f}=a;_validateObject$1(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:g}=t;if(g&&(!s.is0(a.a)||typeof g.beta!="bigint"||!Array.isArray(g.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const m=getWLengths$1(s,o);function b(){if(!s.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function k(Le,Q,oe){const{x:Y,y:Ce}=Q.toAffine(),je=s.toBytes(Y);if(_abool2$1(oe,"isCompressed"),oe){b();const Je=!s.isOdd(Ce);return concatBytes4(pprefix$1(Je),je)}else return concatBytes4(Uint8Array.of(4),je,s.toBytes(Ce))}function _(Le){_abytes2$1(Le,void 0,"Point");const{publicKey:Q,publicKeyUncompressed:oe}=m,Y=Le.length,Ce=Le[0],je=Le.subarray(1);if(Y===Q&&(Ce===2||Ce===3)){const Je=s.fromBytes(je);if(!s.isValid(Je))throw new Error("bad point: is not on curve, wrong x");const Ge=L(Je);let Xe;try{Xe=s.sqrt(Ge)}catch(_t){const ht=_t instanceof Error?": "+_t.message:"";throw new Error("bad point: is not on curve, sqrt error"+ht)}b();const Qe=s.isOdd(Xe);return(Ce&1)===1!==Qe&&(Xe=s.neg(Xe)),{x:Je,y:Xe}}else if(Y===oe&&Ce===4){const Je=s.BYTES,Ge=s.fromBytes(je.subarray(0,Je)),Xe=s.fromBytes(je.subarray(Je,Je*2));if(!Z(Ge,Xe))throw new Error("bad point: is not on curve");return{x:Ge,y:Xe}}else throw new Error(`bad point: got length ${Y}, expected compressed=${Q} or uncompressed=${oe}`)}const A=t.toBytes||k,B=t.fromBytes||_;function L(Le){const Q=s.sqr(Le),oe=s.mul(Q,Le);return s.add(s.add(oe,s.mul(Le,a.a)),a.b)}function Z(Le,Q){const oe=s.sqr(Q),Y=L(Le);return s.eql(oe,Y)}if(!Z(a.Gx,a.Gy))throw new Error("bad curve params: generator point");const ve=s.mul(s.pow(a.a,_3n4),_4n4),We=s.mul(s.sqr(a.b),BigInt(27));if(s.is0(s.add(ve,We)))throw new Error("bad curve params: a or b");function re(Le,Q,oe=!1){if(!s.isValid(Q)||oe&&s.is0(Q))throw new Error(`bad point coordinate ${Le}`);return Q}function ze(Le){if(!(Le instanceof Ve))throw new Error("ProjectivePoint expected")}function se(Le){if(!g||!g.basises)throw new Error("no endo");return _splitEndoScalar$1(Le,g.basises,o.ORDER)}const ne=memoized$1((Le,Q)=>{const{X:oe,Y,Z:Ce}=Le;if(s.eql(Ce,s.ONE))return{x:oe,y:Y};const je=Le.is0();Q==null&&(Q=je?s.ONE:s.inv(Ce));const Je=s.mul(oe,Q),Ge=s.mul(Y,Q),Xe=s.mul(Ce,Q);if(je)return{x:s.ZERO,y:s.ZERO};if(!s.eql(Xe,s.ONE))throw new Error("invZ was invalid");return{x:Je,y:Ge}}),X=memoized$1(Le=>{if(Le.is0()){if(t.allowInfinityPoint&&!s.is0(Le.Y))return;throw new Error("bad point: ZERO")}const{x:Q,y:oe}=Le.toAffine();if(!s.isValid(Q)||!s.isValid(oe))throw new Error("bad point: x or y not field elements");if(!Z(Q,oe))throw new Error("bad point: equation left != right");if(!Le.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function $e(Le,Q,oe,Y,Ce){return oe=new Ve(s.mul(oe.X,Le),oe.Y,oe.Z),Q=negateCt$1(Y,Q),oe=negateCt$1(Ce,oe),Q.add(oe)}class Ve{constructor(Q,oe,Y){this.X=re("x",Q),this.Y=re("y",oe,!0),this.Z=re("z",Y),Object.freeze(this)}static CURVE(){return a}static fromAffine(Q){const{x:oe,y:Y}=Q||{};if(!Q||!s.isValid(oe)||!s.isValid(Y))throw new Error("invalid affine point");if(Q instanceof Ve)throw new Error("projective point not allowed");return s.is0(oe)&&s.is0(Y)?Ve.ZERO:new Ve(oe,Y,s.ONE)}static fromBytes(Q){const oe=Ve.fromAffine(B(_abytes2$1(Q,void 0,"point")));return oe.assertValidity(),oe}static fromHex(Q){return Ve.fromBytes(ensureBytes2("pointHex",Q))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(Q=8,oe=!0){return He.createCache(this,Q),oe||this.multiply(_3n4),this}assertValidity(){X(this)}hasEvenY(){const{y:Q}=this.toAffine();if(!s.isOdd)throw new Error("Field doesn't support isOdd");return!s.isOdd(Q)}equals(Q){ze(Q);const{X:oe,Y,Z:Ce}=this,{X:je,Y:Je,Z:Ge}=Q,Xe=s.eql(s.mul(oe,Ge),s.mul(je,Ce)),Qe=s.eql(s.mul(Y,Ge),s.mul(Je,Ce));return Xe&&Qe}negate(){return new Ve(this.X,s.neg(this.Y),this.Z)}double(){const{a:Q,b:oe}=a,Y=s.mul(oe,_3n4),{X:Ce,Y:je,Z:Je}=this;let{ZERO:Ge,ZERO:Xe,ZERO:Qe}=s,rt=s.mul(Ce,Ce),_t=s.mul(je,je),ht=s.mul(Je,Je),ot=s.mul(Ce,je);return ot=s.add(ot,ot),Qe=s.mul(Ce,Je),Qe=s.add(Qe,Qe),Ge=s.mul(Q,Qe),Xe=s.mul(Y,ht),Xe=s.add(Ge,Xe),Ge=s.sub(_t,Xe),Xe=s.add(_t,Xe),Xe=s.mul(Ge,Xe),Ge=s.mul(ot,Ge),Qe=s.mul(Y,Qe),ht=s.mul(Q,ht),ot=s.sub(rt,ht),ot=s.mul(Q,ot),ot=s.add(ot,Qe),Qe=s.add(rt,rt),rt=s.add(Qe,rt),rt=s.add(rt,ht),rt=s.mul(rt,ot),Xe=s.add(Xe,rt),ht=s.mul(je,Je),ht=s.add(ht,ht),rt=s.mul(ht,ot),Ge=s.sub(Ge,rt),Qe=s.mul(ht,_t),Qe=s.add(Qe,Qe),Qe=s.add(Qe,Qe),new Ve(Ge,Xe,Qe)}add(Q){ze(Q);const{X:oe,Y,Z:Ce}=this,{X:je,Y:Je,Z:Ge}=Q;let{ZERO:Xe,ZERO:Qe,ZERO:rt}=s;const _t=a.a,ht=s.mul(a.b,_3n4);let ot=s.mul(oe,je),xt=s.mul(Y,Je),St=s.mul(Ce,Ge),Mt=s.add(oe,Y),Bt=s.add(je,Je);Mt=s.mul(Mt,Bt),Bt=s.add(ot,xt),Mt=s.sub(Mt,Bt),Bt=s.add(oe,Ce);let Ut=s.add(je,Ge);return Bt=s.mul(Bt,Ut),Ut=s.add(ot,St),Bt=s.sub(Bt,Ut),Ut=s.add(Y,Ce),Xe=s.add(Je,Ge),Ut=s.mul(Ut,Xe),Xe=s.add(xt,St),Ut=s.sub(Ut,Xe),rt=s.mul(_t,Bt),Xe=s.mul(ht,St),rt=s.add(Xe,rt),Xe=s.sub(xt,rt),rt=s.add(xt,rt),Qe=s.mul(Xe,rt),xt=s.add(ot,ot),xt=s.add(xt,ot),St=s.mul(_t,St),Bt=s.mul(ht,Bt),xt=s.add(xt,St),St=s.sub(ot,St),St=s.mul(_t,St),Bt=s.add(Bt,St),ot=s.mul(xt,Bt),Qe=s.add(Qe,ot),ot=s.mul(Ut,Bt),Xe=s.mul(Mt,Xe),Xe=s.sub(Xe,ot),ot=s.mul(Mt,xt),rt=s.mul(Ut,rt),rt=s.add(rt,ot),new Ve(Xe,Qe,rt)}subtract(Q){return this.add(Q.negate())}is0(){return this.equals(Ve.ZERO)}multiply(Q){const{endo:oe}=t;if(!o.isValidNot0(Q))throw new Error("invalid scalar: out of range");let Y,Ce;const je=Je=>He.cached(this,Je,Ge=>normalizeZ$1(Ve,Ge));if(oe){const{k1neg:Je,k1:Ge,k2neg:Xe,k2:Qe}=se(Q),{p:rt,f:_t}=je(Ge),{p:ht,f:ot}=je(Qe);Ce=_t.add(ot),Y=$e(oe.beta,rt,ht,Je,Xe)}else{const{p:Je,f:Ge}=je(Q);Y=Je,Ce=Ge}return normalizeZ$1(Ve,[Y,Ce])[0]}multiplyUnsafe(Q){const{endo:oe}=t,Y=this;if(!o.isValid(Q))throw new Error("invalid scalar: out of range");if(Q===_0n9||Y.is0())return Ve.ZERO;if(Q===_1n9)return Y;if(He.hasCache(this))return this.multiply(Q);if(oe){const{k1neg:Ce,k1:je,k2neg:Je,k2:Ge}=se(Q),{p1:Xe,p2:Qe}=mulEndoUnsafe$1(Ve,Y,je,Ge);return $e(oe.beta,Xe,Qe,Ce,Je)}else return He.unsafe(Y,Q)}multiplyAndAddUnsafe(Q,oe,Y){const Ce=this.multiplyUnsafe(oe).add(Q.multiplyUnsafe(Y));return Ce.is0()?void 0:Ce}toAffine(Q){return ne(this,Q)}isTorsionFree(){const{isTorsionFree:Q}=t;return c===_1n9?!0:Q?Q(Ve,this):He.unsafe(this,f).is0()}clearCofactor(){const{clearCofactor:Q}=t;return c===_1n9?this:Q?Q(Ve,this):this.multiplyUnsafe(c)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}toBytes(Q=!0){return _abool2$1(Q,"isCompressed"),this.assertValidity(),A(Ve,this,Q)}toHex(Q=!0){return bytesToHex3(this.toBytes(Q))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(Q=!0){return this.toBytes(Q)}_setWindowSize(Q){this.precompute(Q)}static normalizeZ(Q){return normalizeZ$1(Ve,Q)}static msm(Q,oe){return pippenger$1(Ve,o,Q,oe)}static fromPrivateKey(Q){return Ve.BASE.multiply(_normFnElement$1(o,Q))}}Ve.BASE=new Ve(a.Gx,a.Gy,s.ONE),Ve.ZERO=new Ve(s.ZERO,s.ONE,s.ZERO),Ve.Fp=s,Ve.Fn=o;const Ze=o.BITS,He=new wNAF2(Ve,t.endo?Math.ceil(Ze/2):Ze);return Ve.BASE.precompute(8),Ve}function pprefix$1(n){return Uint8Array.of(n?2:3)}function getWLengths$1(n,t){return{secretKey:t.BYTES,publicKey:1+n.BYTES,publicKeyUncompressed:1+2*n.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function ecdh$1(n,t={}){const{Fn:r}=n,s=t.randomBytes||randomBytes3,o=Object.assign(getWLengths$1(n.Fp,r),{seed:getMinHashLength2(r.ORDER)});function a(A){try{return!!_normFnElement$1(r,A)}catch{return!1}}function c(A,B){const{publicKey:L,publicKeyUncompressed:Z}=o;try{const ve=A.length;return B===!0&&ve!==L||B===!1&&ve!==Z?!1:!!n.fromBytes(A)}catch{return!1}}function f(A=s(o.seed)){return mapHashToField2(_abytes2$1(A,o.seed,"seed"),r.ORDER)}function g(A,B=!0){return n.BASE.multiply(_normFnElement$1(r,A)).toBytes(B)}function m(A){const B=f(A);return{secretKey:B,publicKey:g(B)}}function b(A){if(typeof A=="bigint")return!1;if(A instanceof n)return!0;const{secretKey:B,publicKey:L,publicKeyUncompressed:Z}=o;if(r.allowedLengths||B===L)return;const ve=ensureBytes2("key",A).length;return ve===L||ve===Z}function k(A,B,L=!0){if(b(A)===!0)throw new Error("first arg must be private key");if(b(B)===!1)throw new Error("second arg must be public key");const Z=_normFnElement$1(r,A);return n.fromHex(B).multiply(Z).toBytes(L)}return Object.freeze({getPublicKey:g,getSharedSecret:k,keygen:m,Point:n,utils:{isValidSecretKey:a,isValidPublicKey:c,randomSecretKey:f,isValidPrivateKey:a,randomPrivateKey:f,normPrivateKeyToScalar:A=>_normFnElement$1(r,A),precompute(A=8,B=n.BASE){return B.precompute(A,!1)}},lengths:o})}function ecdsa$1(n,t,r={}){ahash$1(t),_validateObject$1(r,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const s=r.randomBytes||randomBytes3,o=r.hmac||((oe,...Y)=>hmac3(t,oe,concatBytes4(...Y))),{Fp:a,Fn:c}=n,{ORDER:f,BITS:g}=c,{keygen:m,getPublicKey:b,getSharedSecret:k,utils:_,lengths:A}=ecdh$1(n,r),B={prehash:!1,lowS:typeof r.lowS=="boolean"?r.lowS:!1,format:void 0,extraEntropy:!1},L="compact";function Z(oe){const Y=f>>_1n9;return oe>Y}function ve(oe,Y){if(!c.isValidNot0(Y))throw new Error(`invalid signature ${oe}: out of range 1..Point.Fn.ORDER`);return Y}function We(oe,Y){validateSigFormat$1(Y);const Ce=A.signature,je=Y==="compact"?Ce:Y==="recovered"?Ce+1:void 0;return _abytes2$1(oe,je,`${Y} signature`)}class re{constructor(Y,Ce,je){this.r=ve("r",Y),this.s=ve("s",Ce),je!=null&&(this.recovery=je),Object.freeze(this)}static fromBytes(Y,Ce=L){We(Y,Ce);let je;if(Ce==="der"){const{r:Qe,s:rt}=DER2.toSig(_abytes2$1(Y));return new re(Qe,rt)}Ce==="recovered"&&(je=Y[0],Ce="compact",Y=Y.subarray(1));const Je=c.BYTES,Ge=Y.subarray(0,Je),Xe=Y.subarray(Je,Je*2);return new re(c.fromBytes(Ge),c.fromBytes(Xe),je)}static fromHex(Y,Ce){return this.fromBytes(hexToBytes3(Y),Ce)}addRecoveryBit(Y){return new re(this.r,this.s,Y)}recoverPublicKey(Y){const Ce=a.ORDER,{r:je,s:Je,recovery:Ge}=this;if(Ge==null||![0,1,2,3].includes(Ge))throw new Error("recovery id invalid");if(f*_2n6<Ce&&Ge>1)throw new Error("recovery id is ambiguous for h>1 curve");const Qe=Ge===2||Ge===3?je+f:je;if(!a.isValid(Qe))throw new Error("recovery id 2 or 3 invalid");const rt=a.toBytes(Qe),_t=n.fromBytes(concatBytes4(pprefix$1((Ge&1)===0),rt)),ht=c.inv(Qe),ot=se(ensureBytes2("msgHash",Y)),xt=c.create(-ot*ht),St=c.create(Je*ht),Mt=n.BASE.multiplyUnsafe(xt).add(_t.multiplyUnsafe(St));if(Mt.is0())throw new Error("point at infinify");return Mt.assertValidity(),Mt}hasHighS(){return Z(this.s)}toBytes(Y=L){if(validateSigFormat$1(Y),Y==="der")return hexToBytes3(DER2.hexFromSig(this));const Ce=c.toBytes(this.r),je=c.toBytes(this.s);if(Y==="recovered"){if(this.recovery==null)throw new Error("recovery bit must be present");return concatBytes4(Uint8Array.of(this.recovery),Ce,je)}return concatBytes4(Ce,je)}toHex(Y){return bytesToHex3(this.toBytes(Y))}assertValidity(){}static fromCompact(Y){return re.fromBytes(ensureBytes2("sig",Y),"compact")}static fromDER(Y){return re.fromBytes(ensureBytes2("sig",Y),"der")}normalizeS(){return this.hasHighS()?new re(this.r,c.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return bytesToHex3(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return bytesToHex3(this.toBytes("compact"))}}const ze=r.bits2int||function(Y){if(Y.length>8192)throw new Error("input is too large");const Ce=bytesToNumberBE2(Y),je=Y.length*8-g;return je>0?Ce>>BigInt(je):Ce},se=r.bits2int_modN||function(Y){return c.create(ze(Y))},ne=bitMask2(g);function X(oe){return aInRange$1("num < 2^"+g,oe,_0n9,ne),c.toBytes(oe)}function $e(oe,Y){return _abytes2$1(oe,void 0,"message"),Y?_abytes2$1(t(oe),void 0,"prehashed message"):oe}function Ve(oe,Y,Ce){if(["recovered","canonical"].some(xt=>xt in Ce))throw new Error("sign() legacy options not supported");const{lowS:je,prehash:Je,extraEntropy:Ge}=validateSigOpts$1(Ce,B);oe=$e(oe,Je);const Xe=se(oe),Qe=_normFnElement$1(c,Y),rt=[X(Qe),X(Xe)];if(Ge!=null&&Ge!==!1){const xt=Ge===!0?s(A.secretKey):Ge;rt.push(ensureBytes2("extraEntropy",xt))}const _t=concatBytes4(...rt),ht=Xe;function ot(xt){const St=ze(xt);if(!c.isValidNot0(St))return;const Mt=c.inv(St),Bt=n.BASE.multiply(St).toAffine(),Ut=c.create(Bt.x);if(Ut===_0n9)return;const Jt=c.create(Mt*c.create(ht+Ut*Qe));if(Jt===_0n9)return;let Ft=(Bt.x===Ut?0:2)|Number(Bt.y&_1n9),Xt=Jt;return je&&Z(Jt)&&(Xt=c.neg(Jt),Ft^=1),new re(Ut,Xt,Ft)}return{seed:_t,k2sig:ot}}function Ze(oe,Y,Ce={}){oe=ensureBytes2("message",oe);const{seed:je,k2sig:Je}=Ve(oe,Y,Ce);return createHmacDrbg2(t.outputLen,c.BYTES,o)(je,Je)}function He(oe){let Y;const Ce=typeof oe=="string"||isBytes2(oe),je=!Ce&&oe!==null&&typeof oe=="object"&&typeof oe.r=="bigint"&&typeof oe.s=="bigint";if(!Ce&&!je)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(je)Y=new re(oe.r,oe.s);else if(Ce){try{Y=re.fromBytes(ensureBytes2("sig",oe),"der")}catch(Je){if(!(Je instanceof DER2.Err))throw Je}if(!Y)try{Y=re.fromBytes(ensureBytes2("sig",oe),"compact")}catch{return!1}}return Y||!1}function Le(oe,Y,Ce,je={}){const{lowS:Je,prehash:Ge,format:Xe}=validateSigOpts$1(je,B);if(Ce=ensureBytes2("publicKey",Ce),Y=$e(ensureBytes2("message",Y),Ge),"strict"in je)throw new Error("options.strict was renamed to lowS");const Qe=Xe===void 0?He(oe):re.fromBytes(ensureBytes2("sig",oe),Xe);if(Qe===!1)return!1;try{const rt=n.fromBytes(Ce);if(Je&&Qe.hasHighS())return!1;const{r:_t,s:ht}=Qe,ot=se(Y),xt=c.inv(ht),St=c.create(ot*xt),Mt=c.create(_t*xt),Bt=n.BASE.multiplyUnsafe(St).add(rt.multiplyUnsafe(Mt));return Bt.is0()?!1:c.create(Bt.x)===_t}catch{return!1}}function Q(oe,Y,Ce={}){const{prehash:je}=validateSigOpts$1(Ce,B);return Y=$e(Y,je),re.fromBytes(oe,"recovered").recoverPublicKey(Y).toBytes()}return Object.freeze({keygen:m,getPublicKey:b,getSharedSecret:k,utils:_,lengths:A,Point:n,sign:Ze,verify:Le,recoverPublicKey:Q,Signature:re,hash:t})}function _weierstrass_legacy_opts_to_new$1(n){const t={a:n.a,b:n.b,p:n.Fp.ORDER,n:n.n,h:n.h,Gx:n.Gx,Gy:n.Gy},r=n.Fp;let s=n.allowedPrivateKeyLengths?Array.from(new Set(n.allowedPrivateKeyLengths.map(c=>Math.ceil(c/2)))):void 0;const o=Field2(t.n,{BITS:n.nBitLength,allowedLengths:s,modFromBytes:n.wrapPrivateKey}),a={Fp:r,Fn:o,allowInfinityPoint:n.allowInfinityPoint,endo:n.endo,isTorsionFree:n.isTorsionFree,clearCofactor:n.clearCofactor,fromBytes:n.fromBytes,toBytes:n.toBytes};return{CURVE:t,curveOpts:a}}function _ecdsa_legacy_opts_to_new$1(n){const{CURVE:t,curveOpts:r}=_weierstrass_legacy_opts_to_new$1(n),s={hmac:n.hmac,randomBytes:n.randomBytes,lowS:n.lowS,bits2int:n.bits2int,bits2int_modN:n.bits2int_modN};return{CURVE:t,curveOpts:r,hash:n.hash,ecdsaOpts:s}}function _ecdsa_new_output_to_legacy$1(n,t){const r=t.Point;return Object.assign({},t,{ProjectivePoint:r,CURVE:Object.assign({},n,nLength2(r.Fn.ORDER,r.Fn.BITS))})}function weierstrass2(n){const{CURVE:t,curveOpts:r,hash:s,ecdsaOpts:o}=_ecdsa_legacy_opts_to_new$1(n),a=weierstrassN$1(t,r),c=ecdsa$1(a,s,o);return _ecdsa_new_output_to_legacy$1(n,c)}function createCurve2(n,t){const r=s=>weierstrass2({...n,hash:s});return{...r(t),create:r}}var secp256k1_CURVE$1={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},secp256k1_ENDO$1={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},_0n10=BigInt(0),_1n10=BigInt(1),_2n7=BigInt(2);function sqrtMod2(n){const t=secp256k1_CURVE$1.p,r=BigInt(3),s=BigInt(6),o=BigInt(11),a=BigInt(22),c=BigInt(23),f=BigInt(44),g=BigInt(88),m=n*n*n%t,b=m*m*n%t,k=pow22(b,r,t)*b%t,_=pow22(k,r,t)*b%t,A=pow22(_,_2n7,t)*m%t,B=pow22(A,o,t)*A%t,L=pow22(B,a,t)*B%t,Z=pow22(L,f,t)*L%t,ve=pow22(Z,g,t)*Z%t,We=pow22(ve,f,t)*L%t,re=pow22(We,r,t)*b%t,ze=pow22(re,c,t)*B%t,se=pow22(ze,s,t)*m%t,ne=pow22(se,_2n7,t);if(!Fpk1$1.eql(Fpk1$1.sqr(ne),n))throw new Error("Cannot find square root");return ne}var Fpk1$1=Field2(secp256k1_CURVE$1.p,{sqrt:sqrtMod2}),secp256k12=createCurve2({...secp256k1_CURVE$1,Fp:Fpk1$1,lowS:!0,endo:secp256k1_ENDO$1},sha2563),TAGGED_HASH_PREFIXES2={};function taggedHash2(n,...t){let r=TAGGED_HASH_PREFIXES2[n];if(r===void 0){const s=sha2563(utf8ToBytes5(n));r=concatBytes4(s,s),TAGGED_HASH_PREFIXES2[n]=r}return sha2563(concatBytes4(r,...t))}var pointToBytes2=n=>n.toBytes(!0).slice(1),Pointk1$1=secp256k12.Point,hasEven$1=n=>n%_2n7===_0n10;function schnorrGetExtPubKey2(n){const{Fn:t,BASE:r}=Pointk1$1,s=_normFnElement$1(t,n),o=r.multiply(s);return{scalar:hasEven$1(o.y)?s:t.neg(s),bytes:pointToBytes2(o)}}function lift_x2(n){const t=Fpk1$1;if(!t.isValidNot0(n))throw new Error("invalid x: Fail if x  p");const r=t.create(n*n),s=t.create(r*n+BigInt(7));let o=t.sqrt(s);hasEven$1(o)||(o=t.neg(o));const a=Pointk1$1.fromAffine({x:n,y:o});return a.assertValidity(),a}var num$1=bytesToNumberBE2;function challenge2(...n){return Pointk1$1.Fn.create(num$1(taggedHash2("BIP0340/challenge",...n)))}function schnorrGetPublicKey2(n){return schnorrGetExtPubKey2(n).bytes}function schnorrSign2(n,t,r=randomBytes3(32)){const{Fn:s}=Pointk1$1,o=ensureBytes2("message",n),{bytes:a,scalar:c}=schnorrGetExtPubKey2(t),f=ensureBytes2("auxRand",r,32),g=s.toBytes(c^num$1(taggedHash2("BIP0340/aux",f))),m=taggedHash2("BIP0340/nonce",g,a,o),{bytes:b,scalar:k}=schnorrGetExtPubKey2(m),_=challenge2(b,a,o),A=new Uint8Array(64);if(A.set(b,0),A.set(s.toBytes(s.create(k+_*c)),32),!schnorrVerify2(A,o,a))throw new Error("sign: Invalid signature produced");return A}function schnorrVerify2(n,t,r){const{Fn:s,BASE:o}=Pointk1$1,a=ensureBytes2("signature",n,64),c=ensureBytes2("message",t),f=ensureBytes2("publicKey",r,32);try{const g=lift_x2(num$1(f)),m=num$1(a.subarray(0,32));if(!inRange$1(m,_1n10,secp256k1_CURVE$1.p))return!1;const b=num$1(a.subarray(32,64));if(!inRange$1(b,_1n10,secp256k1_CURVE$1.n))return!1;const k=challenge2(s.toBytes(m),pointToBytes2(g),c),_=o.multiplyUnsafe(b).add(g.multiplyUnsafe(s.neg(k))),{x:A,y:B}=_.toAffine();return!(_.is0()||!hasEven$1(B)||A!==m)}catch{return!1}}var schnorr2=(()=>{const r=(o=randomBytes3(48))=>mapHashToField2(o,secp256k1_CURVE$1.n);secp256k12.utils.randomSecretKey;function s(o){const a=r(o);return{secretKey:a,publicKey:schnorrGetPublicKey2(a)}}return{keygen:s,getPublicKey:schnorrGetPublicKey2,sign:schnorrSign2,verify:schnorrVerify2,Point:Pointk1$1,utils:{randomSecretKey:r,randomPrivateKey:r,taggedHash:taggedHash2,lift_x:lift_x2,pointToBytes:pointToBytes2,numberToBytesBE:numberToBytesBE2,bytesToNumberBE:bytesToNumberBE2,mod:mod2},lengths:{secretKey:32,publicKey:32,publicKeyHasPrefix:!1,signature:64,seed:48}}})(),sha2564=sha2563,import_typescript_lru_cache=__toESM(require_dist()),import_tseep3=__toESM(require_lib()),exports_nip49={};__export$1(exports_nip49,{encrypt:()=>encrypt3,decrypt:()=>decrypt3});function pbkdf2Init$1(n,t,r,s){_assert_default.hash(n);const o=checkOpts$2({dkLen:32,asyncTick:10},s),{c:a,dkLen:c,asyncTick:f}=o;if(_assert_default.number(a),_assert_default.number(c),_assert_default.number(f),a<1)throw new Error("PBKDF2: iterations (c) should be >= 1");const g=toBytes2(t),m=toBytes2(r),b=new Uint8Array(c),k=hmac2.create(n,g),_=k._cloneInto().update(m);return{c:a,dkLen:c,asyncTick:f,DK:b,PRF:k,PRFSalt:_}}function pbkdf2Output$1(n,t,r,s,o){return n.destroy(),t.destroy(),s&&s.destroy(),o.fill(0),r}function pbkdf2$1(n,t,r,s){const{c:o,dkLen:a,DK:c,PRF:f,PRFSalt:g}=pbkdf2Init$1(n,t,r,s);let m;const b=new Uint8Array(4),k=createView2(b),_=new Uint8Array(f.outputLen);for(let A=1,B=0;B<a;A++,B+=f.outputLen){const L=c.subarray(B,B+f.outputLen);k.setInt32(0,A,!1),(m=g._cloneInto(m)).update(b).digestInto(_),L.set(_.subarray(0,L.length));for(let Z=1;Z<o;Z++){f._cloneInto(m).update(_).digestInto(_);for(let ve=0;ve<L.length;ve++)L[ve]^=_[ve]}}return pbkdf2Output$1(f,g,c,m,_)}var rotl2=(n,t)=>n<<t|n>>>32-t;function XorAndSalsa$1(n,t,r,s,o,a){let c=n[t++]^r[s++],f=n[t++]^r[s++],g=n[t++]^r[s++],m=n[t++]^r[s++],b=n[t++]^r[s++],k=n[t++]^r[s++],_=n[t++]^r[s++],A=n[t++]^r[s++],B=n[t++]^r[s++],L=n[t++]^r[s++],Z=n[t++]^r[s++],ve=n[t++]^r[s++],We=n[t++]^r[s++],re=n[t++]^r[s++],ze=n[t++]^r[s++],se=n[t++]^r[s++],ne=c,X=f,$e=g,Ve=m,Ze=b,He=k,Le=_,Q=A,oe=B,Y=L,Ce=Z,je=ve,Je=We,Ge=re,Xe=ze,Qe=se;for(let rt=0;rt<8;rt+=2)Ze^=rotl2(ne+Je|0,7),oe^=rotl2(Ze+ne|0,9),Je^=rotl2(oe+Ze|0,13),ne^=rotl2(Je+oe|0,18),Y^=rotl2(He+X|0,7),Ge^=rotl2(Y+He|0,9),X^=rotl2(Ge+Y|0,13),He^=rotl2(X+Ge|0,18),Xe^=rotl2(Ce+Le|0,7),$e^=rotl2(Xe+Ce|0,9),Le^=rotl2($e+Xe|0,13),Ce^=rotl2(Le+$e|0,18),Ve^=rotl2(Qe+je|0,7),Q^=rotl2(Ve+Qe|0,9),je^=rotl2(Q+Ve|0,13),Qe^=rotl2(je+Q|0,18),X^=rotl2(ne+Ve|0,7),$e^=rotl2(X+ne|0,9),Ve^=rotl2($e+X|0,13),ne^=rotl2(Ve+$e|0,18),Le^=rotl2(He+Ze|0,7),Q^=rotl2(Le+He|0,9),Ze^=rotl2(Q+Le|0,13),He^=rotl2(Ze+Q|0,18),je^=rotl2(Ce+Y|0,7),oe^=rotl2(je+Ce|0,9),Y^=rotl2(oe+je|0,13),Ce^=rotl2(Y+oe|0,18),Je^=rotl2(Qe+Xe|0,7),Ge^=rotl2(Je+Qe|0,9),Xe^=rotl2(Ge+Je|0,13),Qe^=rotl2(Xe+Ge|0,18);o[a++]=c+ne|0,o[a++]=f+X|0,o[a++]=g+$e|0,o[a++]=m+Ve|0,o[a++]=b+Ze|0,o[a++]=k+He|0,o[a++]=_+Le|0,o[a++]=A+Q|0,o[a++]=B+oe|0,o[a++]=L+Y|0,o[a++]=Z+Ce|0,o[a++]=ve+je|0,o[a++]=We+Je|0,o[a++]=re+Ge|0,o[a++]=ze+Xe|0,o[a++]=se+Qe|0}function BlockMix$1(n,t,r,s,o){let a=s+0,c=s+16*o;for(let f=0;f<16;f++)r[c+f]=n[t+(2*o-1)*16+f];for(let f=0;f<o;f++,a+=16,t+=16)XorAndSalsa$1(r,c,n,t,r,a),f>0&&(c+=16),XorAndSalsa$1(r,a,n,t+=16,r,c)}function scryptInit$1(n,t,r){const s=checkOpts$2({dkLen:32,asyncTick:10,maxmem:1073742848},r),{N:o,r:a,p:c,dkLen:f,asyncTick:g,maxmem:m,onProgress:b}=s;if(_assert_default.number(o),_assert_default.number(a),_assert_default.number(c),_assert_default.number(f),_assert_default.number(g),_assert_default.number(m),b!==void 0&&typeof b!="function")throw new Error("progressCb should be function");const k=128*a,_=k/4;if(o<=1||(o&o-1)!==0||o>=2**(k/8)||o>2**32)throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");if(c<0||c>(2**32-1)*32/k)throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");if(f<0||f>(2**32-1)*32)throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");const A=k*(o+c);if(A>m)throw new Error(`Scrypt: parameters too large, ${A} (128 * r * (N + p)) > ${m} (maxmem)`);const B=pbkdf2$1(sha2562,n,t,{c:1,dkLen:k*c}),L=u32$2(B),Z=u32$2(new Uint8Array(k*o)),ve=u32$2(new Uint8Array(k));let We=()=>{};if(b){const re=2*o*c,ze=Math.max(Math.floor(re/1e4),1);let se=0;We=()=>{se++,b&&(!(se%ze)||se===re)&&b(se/re)}}return{N:o,r:a,p:c,dkLen:f,blockSize32:_,V:Z,B32:L,B,tmp:ve,blockMixCb:We,asyncTick:g}}function scryptOutput$1(n,t,r,s,o){const a=pbkdf2$1(sha2562,n,r,{c:1,dkLen:t});return r.fill(0),s.fill(0),o.fill(0),a}function scrypt$1(n,t,r){const{N:s,r:o,p:a,dkLen:c,blockSize32:f,V:g,B32:m,B:b,tmp:k,blockMixCb:_}=scryptInit$1(n,t,r);for(let A=0;A<a;A++){const B=f*A;for(let L=0;L<f;L++)g[L]=m[B+L];for(let L=0,Z=0;L<s-1;L++)BlockMix$1(g,Z,g,Z+=f,o),_();BlockMix$1(g,(s-1)*f,m,B,o),_();for(let L=0;L<s;L++){const Z=m[B+f-16]%s;for(let ve=0;ve<f;ve++)k[ve]=m[B+ve]^g[Z*f+ve];BlockMix$1(k,0,m,B,o),_()}}return scryptOutput$1(n,c,b,g,k)}var Bech32MaxSize2=5e3;function encodeBech322(n,t){let r=bech32$3.toWords(t);return bech32$3.encode(n,r,Bech32MaxSize2)}function encodeBytes2(n,t){return encodeBech322(n,t)}function encrypt3(n,t,r=16,s=2){let o=randomBytes2(16),a=2**r,c=scrypt$1(t.normalize("NFKC"),o,{N:a,r:8,p:1,dkLen:32}),f=randomBytes2(24),g=Uint8Array.from([s]),b=xchacha20poly1305$1(c,f,g).encrypt(n),k=concatBytes3(Uint8Array.from([2]),Uint8Array.from([r]),o,f,g,b);return encodeBytes2("ncryptsec",k)}function decrypt3(n,t){let{prefix:r,words:s}=bech32$3.decode(n,Bech32MaxSize2);if(r!=="ncryptsec")throw new Error(`invalid prefix ${r}, expected 'ncryptsec'`);let o=new Uint8Array(bech32$3.fromWords(s)),a=o[0];if(a!==2)throw new Error(`invalid version ${a}, expected 0x02`);let f=2**o[1],g=o.slice(2,18),m=o.slice(18,42),b=o[42],k=Uint8Array.from([b]),_=o.slice(43),A=scrypt$1(t.normalize("NFKC"),g,{N:f,r:8,p:1,dkLen:32});return xchacha20poly1305$1(A,m,k).decrypt(_)}var import_tseep4=__toESM(require_lib()),import_debug4=__toESM(require_browser()),import_debug5=__toESM(require_browser()),import_debug6=__toESM(require_browser());__toESM(require_bolt11());var import_debug7=__toESM(require_browser()),import_tseep5=__toESM(require_lib()),import_tseep6=__toESM(require_lib()),import_typescript_lru_cache2=__toESM(require_dist()),import_typescript_lru_cache3=__toESM(require_dist()),import_debug8=__toESM(require_browser()),exports_nip19={};__export$1(exports_nip19,{nsecEncode:()=>nsecEncode2,npubEncode:()=>npubEncode2,nprofileEncode:()=>nprofileEncode2,noteEncode:()=>noteEncode2,neventEncode:()=>neventEncode2,naddrEncode:()=>naddrEncode2,encodeBytes:()=>encodeBytes3,decodeNostrURI:()=>decodeNostrURI2,decode:()=>decode2,NostrTypeGuard:()=>NostrTypeGuard2,Bech32MaxSize:()=>Bech32MaxSize3,BECH32_REGEX:()=>BECH32_REGEX2});var utf8Decoder2=new TextDecoder("utf-8"),utf8Encoder2=new TextEncoder,NostrTypeGuard2={isNProfile:n=>/^nprofile1[a-z\d]+$/.test(n||""),isNEvent:n=>/^nevent1[a-z\d]+$/.test(n||""),isNAddr:n=>/^naddr1[a-z\d]+$/.test(n||""),isNSec:n=>/^nsec1[a-z\d]{58}$/.test(n||""),isNPub:n=>/^npub1[a-z\d]{58}$/.test(n||""),isNote:n=>/^note1[a-z\d]+$/.test(n||""),isNcryptsec:n=>/^ncryptsec1[a-z\d]+$/.test(n||"")},Bech32MaxSize3=5e3,BECH32_REGEX2=/[\x21-\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;function integerToUint8Array2(n){const t=new Uint8Array(4);return t[0]=n>>24&255,t[1]=n>>16&255,t[2]=n>>8&255,t[3]=n&255,t}function decodeNostrURI2(n){try{return n.startsWith("nostr:")&&(n=n.substring(6)),decode2(n)}catch{return{type:"invalid",data:null}}}function decode2(n){let{prefix:t,words:r}=bech32$3.decode(n,Bech32MaxSize3),s=new Uint8Array(bech32$3.fromWords(r));switch(t){case"nprofile":{let o=parseTLV2(s);if(!o[0]?.[0])throw new Error("missing TLV 0 for nprofile");if(o[0][0].length!==32)throw new Error("TLV 0 should be 32 bytes");return{type:"nprofile",data:{pubkey:bytesToHex2(o[0][0]),relays:o[1]?o[1].map(a=>utf8Decoder2.decode(a)):[]}}}case"nevent":{let o=parseTLV2(s);if(!o[0]?.[0])throw new Error("missing TLV 0 for nevent");if(o[0][0].length!==32)throw new Error("TLV 0 should be 32 bytes");if(o[2]&&o[2][0].length!==32)throw new Error("TLV 2 should be 32 bytes");if(o[3]&&o[3][0].length!==4)throw new Error("TLV 3 should be 4 bytes");return{type:"nevent",data:{id:bytesToHex2(o[0][0]),relays:o[1]?o[1].map(a=>utf8Decoder2.decode(a)):[],author:o[2]?.[0]?bytesToHex2(o[2][0]):void 0,kind:o[3]?.[0]?parseInt(bytesToHex2(o[3][0]),16):void 0}}}case"naddr":{let o=parseTLV2(s);if(!o[0]?.[0])throw new Error("missing TLV 0 for naddr");if(!o[2]?.[0])throw new Error("missing TLV 2 for naddr");if(o[2][0].length!==32)throw new Error("TLV 2 should be 32 bytes");if(!o[3]?.[0])throw new Error("missing TLV 3 for naddr");if(o[3][0].length!==4)throw new Error("TLV 3 should be 4 bytes");return{type:"naddr",data:{identifier:utf8Decoder2.decode(o[0][0]),pubkey:bytesToHex2(o[2][0]),kind:parseInt(bytesToHex2(o[3][0]),16),relays:o[1]?o[1].map(a=>utf8Decoder2.decode(a)):[]}}}case"nsec":return{type:t,data:s};case"npub":case"note":return{type:t,data:bytesToHex2(s)};default:throw new Error(`unknown prefix ${t}`)}}function parseTLV2(n){let t={},r=n;for(;r.length>0;){let s=r[0],o=r[1],a=r.slice(2,2+o);if(r=r.slice(2+o),a.length<o)throw new Error(`not enough data to read on TLV ${s}`);t[s]=t[s]||[],t[s].push(a)}return t}function nsecEncode2(n){return encodeBytes3("nsec",n)}function npubEncode2(n){return encodeBytes3("npub",hexToBytes2(n))}function noteEncode2(n){return encodeBytes3("note",hexToBytes2(n))}function encodeBech323(n,t){let r=bech32$3.toWords(t);return bech32$3.encode(n,r,Bech32MaxSize3)}function encodeBytes3(n,t){return encodeBech323(n,t)}function nprofileEncode2(n){let t=encodeTLV2({0:[hexToBytes2(n.pubkey)],1:(n.relays||[]).map(r=>utf8Encoder2.encode(r))});return encodeBech323("nprofile",t)}function neventEncode2(n){let t;n.kind!==void 0&&(t=integerToUint8Array2(n.kind));let r=encodeTLV2({0:[hexToBytes2(n.id)],1:(n.relays||[]).map(s=>utf8Encoder2.encode(s)),2:n.author?[hexToBytes2(n.author)]:[],3:t?[new Uint8Array(t)]:[]});return encodeBech323("nevent",r)}function naddrEncode2(n){let t=new ArrayBuffer(4);new DataView(t).setUint32(0,n.kind,!1);let r=encodeTLV2({0:[utf8Encoder2.encode(n.identifier)],1:(n.relays||[]).map(s=>utf8Encoder2.encode(s)),2:[hexToBytes2(n.pubkey)],3:[new Uint8Array(t)]});return encodeBech323("naddr",r)}function encodeTLV2(n){let t=[];return Object.entries(n).reverse().forEach(([r,s])=>{s.forEach(o=>{let a=new Uint8Array(o.length+2);a.set([parseInt(r)],0),a.set([o.length],1),a.set(o,2),t.push(a)})}),concatBytes3(...t)}var import_debug9=__toESM(require_browser()),import_debug10=__toESM(require_browser()),import_tseep7=__toESM(require_lib()),import_tseep8=__toESM(require_lib()),import_debug11=__toESM(require_browser());__toESM(require_lib());var import_debug12=__toESM(require_browser()),__defProp3=Object.defineProperty,__getOwnPropDesc$1=Object.getOwnPropertyDescriptor,__getOwnPropNames2=Object.getOwnPropertyNames,__hasOwnProp2=Object.prototype.hasOwnProperty,__copyProps$1=(n,t,r,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of __getOwnPropNames2(t))!__hasOwnProp2.call(n,o)&&o!==r&&__defProp3(n,o,{get:()=>t[o],enumerable:!(s=__getOwnPropDesc$1(t,o))||s.enumerable});return n},__reExport$1=(n,t,r)=>(__copyProps$1(n,t,"default"),r);function getRelaysForSync$1(n,t,r="write"){if(!n.outboxTracker)return;const s=n.outboxTracker.data.get(t);if(s)return r==="write"?s.writeRelays:s.readRelays}async function getWriteRelaysFor$1(n,t,r="write"){if(n.outboxTracker)return n.outboxTracker.data.has(t)||await n.outboxTracker.trackUsers([t]),getRelaysForSync$1(n,t,r)}function getTopRelaysForAuthors$1(n,t){const r=new Map;return t.forEach(o=>{const a=getRelaysForSync$1(n,o);a&&a.forEach(c=>{const f=r.get(c)||0;r.set(c,f+1)})}),Array.from(r.entries()).sort((o,a)=>a[1]-o[1]).map(o=>o[0])}function getAllRelaysForAllPubkeys$1(n,t,r="read"){const s=new Map,o=new Set;return t.forEach(a=>{const c=getRelaysForSync$1(n,a,r);c&&c.size>0?(c.forEach(f=>{(s.get(f)||new Set).add(a)}),s.set(a,c)):o.add(a)}),{pubkeysToRelays:s,authorsMissingRelays:o}}function chooseRelayCombinationForPubkeys$1(n,t,r,{count:s,preferredRelays:o}={}){s??=2,o??=new Set;const a=n.pool,c=a.connectedRelays();c.forEach(_=>{o?.add(_.url)});const f=new Map,{pubkeysToRelays:g,authorsMissingRelays:m}=getAllRelaysForAllPubkeys$1(n,t,r),b=getTopRelaysForAuthors$1(n,t),k=(_,A)=>{const B=f.get(A)||[];B.push(_),f.set(A,B)};for(const[_,A]of g.entries()){let B=s;const L=new Set;for(const Z of c)A.has(Z.url)&&(k(_,Z.url),L.add(Z.url),B--);for(const Z of A)L.has(Z)||f.has(Z)&&(k(_,Z),L.add(Z),B--);if(!(B<=0))for(const Z of b){if(B<=0)break;L.has(Z)||A.has(Z)&&(k(_,Z),L.add(Z),B--)}}for(const _ of m)a.permanentAndConnectedRelays().forEach(A=>{const B=f.get(A.url)||[];B.push(_),f.set(A.url,B)});return f}function getRelaysForFilterWithAuthors$1(n,t,r=2){return chooseRelayCombinationForPubkeys$1(n,t,"write",{count:r})}function tryNormalizeRelayUrl$1(n){try{return normalizeRelayUrl$1(n)}catch{return}}function normalizeRelayUrl$1(n){let t=normalizeUrl$1(n,{stripAuthentication:!1,stripWWW:!1,stripHash:!0});return t.endsWith("/")||(t+="/"),t}function normalize2(n){const t=new Set;for(const r of n)try{t.add(normalizeRelayUrl$1(r))}catch{}return Array.from(t)}var DATA_URL_DEFAULT_MIME_TYPE$1="text/plain",DATA_URL_DEFAULT_CHARSET$1="us-ascii",testParameter$1=(n,t)=>t.some(r=>r instanceof RegExp?r.test(n):r===n),supportedProtocols$1=new Set(["https:","http:","file:"]),hasCustomProtocol$1=n=>{try{const{protocol:t}=new URL(n);return t.endsWith(":")&&!t.includes(".")&&!supportedProtocols$1.has(t)}catch{return!1}},normalizeDataURL$1=(n,{stripHash:t})=>{const r=/^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(n);if(!r)throw new Error(`Invalid URL: ${n}`);const s=r.groups?.type??"",o=r.groups?.data??"";let a=r.groups?.hash??"";const c=s.split(";");a=t?"":a;let f=!1;c[c.length-1]==="base64"&&(c.pop(),f=!0);const g=c.shift()?.toLowerCase()??"",b=[...c.map(k=>{let[_,A=""]=k.split("=").map(B=>B.trim());return _==="charset"&&(A=A.toLowerCase(),A===DATA_URL_DEFAULT_CHARSET$1)?"":`${_}${A?`=${A}`:""}`}).filter(Boolean)];return f&&b.push("base64"),(b.length>0||g&&g!==DATA_URL_DEFAULT_MIME_TYPE$1)&&b.unshift(g),`data:${b.join(";")},${f?o.trim():o}${a?`#${a}`:""}`};function normalizeUrl$1(n,t={}){if(t={defaultProtocol:"http",normalizeProtocol:!0,forceHttp:!1,forceHttps:!1,stripAuthentication:!0,stripHash:!1,stripTextFragment:!0,stripWWW:!0,removeQueryParameters:[/^utm_\w+/i],removeTrailingSlash:!0,removeSingleSlash:!0,removeDirectoryIndex:!1,removeExplicitPort:!1,sortQueryParameters:!0,...t},typeof t.defaultProtocol=="string"&&!t.defaultProtocol.endsWith(":")&&(t.defaultProtocol=`${t.defaultProtocol}:`),n=n.trim(),/^data:/i.test(n))return normalizeDataURL$1(n,t);if(hasCustomProtocol$1(n))return n;const r=n.startsWith("//");!r&&/^\.*\//.test(n)||(n=n.replace(/^(?!(?:\w+:)?\/\/)|^\/\//,t.defaultProtocol));const o=new URL(n);if(o.hostname=o.hostname.toLowerCase(),t.forceHttp&&t.forceHttps)throw new Error("The `forceHttp` and `forceHttps` options cannot be used together");if(t.forceHttp&&o.protocol==="https:"&&(o.protocol="http:"),t.forceHttps&&o.protocol==="http:"&&(o.protocol="https:"),t.stripAuthentication&&(o.username="",o.password=""),t.stripHash?o.hash="":t.stripTextFragment&&(o.hash=o.hash.replace(/#?:~:text.*?$/i,"")),o.pathname){const c=/\b[a-z][a-z\d+\-.]{1,50}:\/\//g;let f=0,g="";for(;;){const b=c.exec(o.pathname);if(!b)break;const k=b[0],_=b.index,A=o.pathname.slice(f,_);g+=A.replace(/\/{2,}/g,"/"),g+=k,f=_+k.length}const m=o.pathname.slice(f,o.pathname.length);g+=m.replace(/\/{2,}/g,"/"),o.pathname=g}if(o.pathname)try{o.pathname=decodeURI(o.pathname)}catch{}if(t.removeDirectoryIndex===!0&&(t.removeDirectoryIndex=[/^index\.[a-z]+$/]),Array.isArray(t.removeDirectoryIndex)&&t.removeDirectoryIndex.length>0){let c=o.pathname.split("/");const f=c[c.length-1];testParameter$1(f,t.removeDirectoryIndex)&&(c=c.slice(0,-1),o.pathname=`${c.slice(1).join("/")}/`)}if(o.hostname&&(o.hostname=o.hostname.replace(/\.$/,""),t.stripWWW&&/^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(o.hostname)&&(o.hostname=o.hostname.replace(/^www\./,""))),Array.isArray(t.removeQueryParameters))for(const c of[...o.searchParams.keys()])testParameter$1(c,t.removeQueryParameters)&&o.searchParams.delete(c);if(!Array.isArray(t.keepQueryParameters)&&t.removeQueryParameters===!0&&(o.search=""),Array.isArray(t.keepQueryParameters)&&t.keepQueryParameters.length>0)for(const c of[...o.searchParams.keys()])testParameter$1(c,t.keepQueryParameters)||o.searchParams.delete(c);if(t.sortQueryParameters){o.searchParams.sort();try{o.search=decodeURIComponent(o.search)}catch{}}t.removeTrailingSlash&&(o.pathname=o.pathname.replace(/\/$/,"")),t.removeExplicitPort&&o.port&&(o.port="");const a=n;return n=o.toString(),!t.removeSingleSlash&&o.pathname==="/"&&!a.endsWith("/")&&o.hash===""&&(n=n.replace(/\/$/,"")),(t.removeTrailingSlash||o.pathname==="/")&&o.hash===""&&t.removeSingleSlash&&(n=n.replace(/\/$/,"")),r&&!t.normalizeProtocol&&(n=n.replace(/^http:\/\//,"//")),t.stripProtocol&&(n=n.replace(/^(?:https?:)?\/\//,"")),n}var NDKRelayKeepalive$1=class{constructor(t=3e4,r){this.onSilenceDetected=r,this.timeout=t}lastActivity=Date.now();timer;timeout;isRunning=!1;recordActivity(){this.lastActivity=Date.now(),this.isRunning&&this.resetTimer()}start(){this.isRunning||(this.isRunning=!0,this.lastActivity=Date.now(),this.resetTimer())}stop(){this.isRunning=!1,this.timer&&(clearTimeout(this.timer),this.timer=void 0)}resetTimer(){this.timer&&clearTimeout(this.timer),this.timer=setTimeout(()=>{const t=Date.now()-this.lastActivity;if(t>=this.timeout)this.onSilenceDetected();else{const r=this.timeout-t;this.timer=setTimeout(()=>{this.onSilenceDetected()},r)}},this.timeout)}};async function probeRelayConnection$1(n){const t=`probe-${Math.random().toString(36).substring(7)}`;return new Promise(r=>{let s=!1;const o=setTimeout(()=>{s||(s=!0,n.send(["CLOSE",t]),r(!1))},5e3),a=()=>{s||(s=!0,clearTimeout(o),n.send(["CLOSE",t]),r(!0))};n.once("message",a),n.send(["REQ",t,{kinds:[99999],limit:0}])})}var MAX_RECONNECT_ATTEMPTS$1=5,FLAPPING_THRESHOLD_MS$1=1e3,NDKRelayConnectivity$1=class{ndkRelay;ws;_status;timeoutMs;connectedAt;_connectionStats={attempts:0,success:0,durations:[]};debug;netDebug;connectTimeout;reconnectTimeout;ndk;openSubs=new Map;openCountRequests=new Map;openEventPublishes=new Map;pendingAuthPublishes=new Map;serial=0;baseEoseTimeout=4400;keepalive;wsStateMonitor;sleepDetector;lastSleepCheck=Date.now();lastMessageSent=Date.now();wasIdle=!1;constructor(t,r){this.ndkRelay=t,this._status=1;const s=Math.floor(Math.random()*1e3);this.debug=this.ndkRelay.debug.extend(`connectivity${s}`),this.ndk=r,this.setupMonitoring()}setupMonitoring(){this.keepalive=new NDKRelayKeepalive$1(12e4,async()=>{this.debug("Relay silence detected, probing connection"),await probeRelayConnection$1({send:r=>this.send(JSON.stringify(r)),once:(r,s)=>{const o=a=>{try{const c=JSON.parse(a.data);(c[0]==="EOSE"||c[0]==="EVENT"||c[0]==="NOTICE")&&(s(),this.ws?.removeEventListener("message",o))}catch{}};this.ws?.addEventListener("message",o)}})||(this.debug("Probe failed, connection is stale"),this.handleStaleConnection())}),this.wsStateMonitor=setInterval(()=>{this._status===5&&(!this.ws||this.ws.readyState!==WebSocket.OPEN)&&(this.debug("WebSocket died silently, reconnecting"),this.handleStaleConnection())},5e3),this.sleepDetector=setInterval(()=>{const t=Date.now(),r=t-this.lastSleepCheck;r>15e3&&(this.debug(`Detected possible sleep/wake (${r}ms gap)`),this.handlePossibleWake()),this.lastSleepCheck=t},1e4)}handleStaleConnection(){this._status=1,this.wasIdle=!0,this.onDisconnect()}handlePossibleWake(){this.debug("System wake detected, checking all connections"),this.wasIdle=!0,this._status>=5&&(!this.ws||this.ws.readyState!==WebSocket.OPEN?this.handleStaleConnection():probeRelayConnection$1({send:t=>this.send(JSON.stringify(t)),once:(t,r)=>{const s=o=>{try{const a=JSON.parse(o.data);(a[0]==="EOSE"||a[0]==="EVENT"||a[0]==="NOTICE")&&(r(),this.ws?.removeEventListener("message",s))}catch{}};this.ws?.addEventListener("message",s)}}).then(t=>{t||this.handleStaleConnection()}))}resetReconnectionState(){this.wasIdle=!0,this.reconnectTimeout&&(clearTimeout(this.reconnectTimeout),this.reconnectTimeout=void 0)}async connect(t,r=!0){if(this.ws&&this.ws.readyState!==WebSocket.OPEN&&this.ws.readyState!==WebSocket.CONNECTING){this.debug("Cleaning up stale WebSocket connection");try{this.ws.close()}catch{}this.ws=void 0,this._status=1}if(this._status!==2&&this._status!==1||this.reconnectTimeout){this.debug("Relay requested to be connected but was in state %s or it had a reconnect timeout",this._status);return}this.reconnectTimeout&&(clearTimeout(this.reconnectTimeout),this.reconnectTimeout=void 0),this.connectTimeout&&(clearTimeout(this.connectTimeout),this.connectTimeout=void 0),t??=this.timeoutMs,!this.timeoutMs&&t&&(this.timeoutMs=t),this.timeoutMs&&(this.connectTimeout=setTimeout(()=>this.onConnectionError(r),this.timeoutMs));try{this.updateConnectionStats.attempt(),this._status===1?this._status=4:this._status=2,this.ws=new WebSocket(this.ndkRelay.url),this.ws.onopen=this.onConnect.bind(this),this.ws.onclose=this.onDisconnect.bind(this),this.ws.onmessage=this.onMessage.bind(this),this.ws.onerror=this.onError.bind(this)}catch(s){throw this.debug(`Failed to connect to ${this.ndkRelay.url}`,s),this._status=1,r?this.handleReconnection():this.ndkRelay.emit("delayed-connect",2880*60*1e3),s}}disconnect(){this._status=0,this.keepalive?.stop(),this.wsStateMonitor&&(clearInterval(this.wsStateMonitor),this.wsStateMonitor=void 0),this.sleepDetector&&(clearInterval(this.sleepDetector),this.sleepDetector=void 0);try{this.ws?.close()}catch(t){this.debug("Failed to disconnect",t),this._status=1}}onConnectionError(t){this.debug(`Error connecting to ${this.ndkRelay.url}`,this.timeoutMs),t&&!this.reconnectTimeout&&this.handleReconnection()}onConnect(){this.netDebug?.("connected",this.ndkRelay),this.reconnectTimeout&&(clearTimeout(this.reconnectTimeout),this.reconnectTimeout=void 0),this.connectTimeout&&(clearTimeout(this.connectTimeout),this.connectTimeout=void 0),this.updateConnectionStats.connected(),this._status=5,this.keepalive?.start(),this.wasIdle=!1,this.ndkRelay.emit("connect"),this.ndkRelay.emit("ready")}onDisconnect(){this.netDebug?.("disconnected",this.ndkRelay),this.updateConnectionStats.disconnected(),this.keepalive?.stop(),this.clearPendingPublishes(new Error(`Relay ${this.ndkRelay.url} disconnected`)),this._status===5&&this.handleReconnection(),this._status=1,this.ndkRelay.emit("disconnect")}onMessage(t){this.netDebug?.(t.data,this.ndkRelay,"recv"),this.keepalive?.recordActivity();try{const r=JSON.parse(t.data),[s,o,...a]=r,c=this.ndkRelay.getProtocolHandler(s);if(c){c(this.ndkRelay,r);return}switch(s){case"EVENT":{const f=this.openSubs.get(o),g=r[2];if(!f){this.debug(`Received event for unknown subscription ${o}`);return}f.onevent(g);return}case"COUNT":{const f=r[2],g=this.openCountRequests.get(o);g&&(g.resolve(f.count),this.openCountRequests.delete(o));return}case"EOSE":{const f=this.openSubs.get(o);if(!f)return;f.oneose(o);return}case"OK":{const f=r[2],g=r[3],m=this.openEventPublishes.get(o),b=m?.pop();if(!m||!b){this.debug("Received OK for unknown event publish",o);return}f?(b.resolve(g),this.pendingAuthPublishes.delete(o)):g&&(g.toLowerCase().includes("auth-required")||g.toLowerCase().includes("not authorized")||g.toLowerCase().includes("blocked: not authorized"))?this.pendingAuthPublishes.get(o)?(this.debug("Publish failed due to auth-required, will retry after auth",o),m.push(b),this.openEventPublishes.set(o,m)):b.reject(new Error(g)):(b.reject(new Error(g)),this.pendingAuthPublishes.delete(o)),m.length===0?this.openEventPublishes.delete(o):!f&&!(g?.toLowerCase().includes("auth-required")||g?.toLowerCase().includes("not authorized")||g?.toLowerCase().includes("blocked: not authorized"))&&this.openEventPublishes.set(o,m);return}case"CLOSED":{const f=this.openSubs.get(o);if(!f)return;f.onclosed(r[2]);return}case"NOTICE":this.onNotice(r[1]);return;case"AUTH":{this.onAuthRequested(r[1]);return}}}catch(r){this.debug(`Error parsing message from ${this.ndkRelay.url}: ${r.message}`,r?.stack);return}}async onAuthRequested(t){const r=this.ndkRelay.authPolicy??this.ndk?.relayAuthDefaultPolicy;if(this.debug("Relay requested authentication",{havePolicy:!!r}),this._status===7){this.debug("Already authenticating, ignoring");return}if(this._status=6,r){if(this._status>=5){this._status=7;let s;try{s=await r(this.ndkRelay,t)}catch(o){this.debug("Authentication policy threw an error",o),s=!1}if(this.debug("Authentication policy returned",!!s),s instanceof NDKEvent$1||s===!0){s instanceof NDKEvent$1&&await this.auth(s);const o=async()=>{if(this._status>=5&&this._status<8){const a=new NDKEvent$1(this.ndk);a.kind=22242,a.tags=[["relay",this.ndkRelay.url],["challenge",t]],await a.sign(),this.auth(a).then(()=>{this._status=8,this.ndkRelay.emit("authed"),this.debug("Authentication successful"),this.retryPendingAuthPublishes()}).catch(c=>{this._status=6,this.ndkRelay.emit("auth:failed",c),this.debug("Authentication failed",c),this.rejectPendingAuthPublishes(c)})}else this.debug("Authentication failed, it changed status, status is %d",this._status)};s===!0&&(this.ndk?.signer?o().catch(a=>{console.error("Error authenticating",a)}):(this.debug("No signer available for authentication localhost"),this.ndk?.once("signer:ready",o))),this._status=5,this.ndkRelay.emit("authed")}}}else this.ndkRelay.emit("auth",t)}onError(t){this.debug(`WebSocket error on ${this.ndkRelay.url}:`,t)}get status(){return this._status}isAvailable(){return this._status===5}isFlapping(){const t=this._connectionStats.durations;if(t.length%3!==0)return!1;const s=t.reduce((f,g)=>f+g,0)/t.length,o=t.map(f=>(f-s)**2).reduce((f,g)=>f+g,0)/t.length;return Math.sqrt(o)<FLAPPING_THRESHOLD_MS$1}async onNotice(t){this.ndkRelay.emit("notice",t)}handleReconnection(t=0){if(this.reconnectTimeout)return;if(this.isFlapping()){this.ndkRelay.emit("flapping",this._connectionStats),this._status=3;return}let r;if(this.wasIdle){const s=[0,1e3,2e3,5e3,1e4,3e4];r=s[Math.min(t,s.length-1)],this.debug(`Using aggressive reconnect after idle, attempt ${t}, delay ${r}ms`)}else this.connectedAt?r=Math.max(0,6e4-(Date.now()-this.connectedAt)):(r=Math.min(1e3*2**t,3e4),this.debug(`Using standard backoff, attempt ${t}, delay ${r}ms`));this.reconnectTimeout=setTimeout(()=>{this.reconnectTimeout=void 0,this._status=2,this.connect().catch(s=>{t<MAX_RECONNECT_ATTEMPTS$1?this.handleReconnection(t+1):(this.debug("Max reconnect attempts reached"),this.wasIdle=!1)})},r),this.ndkRelay.emit("delayed-connect",r),this.debug("Reconnecting in",r),this._connectionStats.nextReconnectAt=Date.now()+r}async send(t){Date.now()-this.lastMessageSent>12e4&&(this.wasIdle=!0),this._status>=5&&this.ws?.readyState===WebSocket.OPEN?(this.ws?.send(t),this.netDebug?.(t,this.ndkRelay,"send"),this.lastMessageSent=Date.now()):(this.debug(`Not connected to ${this.ndkRelay.url} (%d), not sending message ${t}`,this._status),this._status>=5&&this.ws?.readyState!==WebSocket.OPEN&&(this.debug(`Stale connection detected, WebSocket state: ${this.ws?.readyState}`),this.handleStaleConnection()))}async auth(t){const r=new Promise((s,o)=>{const a=this.openEventPublishes.get(t.id)??[];a.push({resolve:s,reject:o}),this.openEventPublishes.set(t.id,a)});return this.send(`["AUTH",${JSON.stringify(t.rawEvent())}]`),r}clearPendingPublishes(t){this.rejectPendingAuthPublishes(t);for(const[r,s]of this.openEventPublishes.entries()){for(;s.length>0;){const o=s.shift();o&&o.reject(t)}this.openEventPublishes.delete(r)}}retryPendingAuthPublishes(){if(this.pendingAuthPublishes.size!==0){this.debug(`Retrying ${this.pendingAuthPublishes.size} pending publishes after auth`);for(const[t,r]of this.pendingAuthPublishes.entries())this.debug(`Retrying publish for event ${t}`),this.send(`["EVENT",${JSON.stringify(r)}]`);this.pendingAuthPublishes.clear()}}rejectPendingAuthPublishes(t){if(this.pendingAuthPublishes.size!==0){this.debug(`Rejecting ${this.pendingAuthPublishes.size} pending publishes due to auth failure`);for(const[r]of this.pendingAuthPublishes.entries()){const s=this.openEventPublishes.get(r);if(s&&s.length>0){const o=s.pop();o&&o.reject(new Error(`Authentication failed: ${t.message}`)),s.length===0&&this.openEventPublishes.delete(r)}}this.pendingAuthPublishes.clear()}}async publish(t){const r=new Promise((s,o)=>{const a=this.openEventPublishes.get(t.id)??[];a.length>0&&console.warn(`Duplicate event publishing detected, you are publishing event ${t.id} twice`),a.push({resolve:s,reject:o}),this.openEventPublishes.set(t.id,a)});return this.pendingAuthPublishes.set(t.id,t),this.send(`["EVENT",${JSON.stringify(t)}]`),r}async count(t,r){this.serial++;const s=r?.id||`count:${this.serial}`,o=new Promise((a,c)=>{this.openCountRequests.set(s,{resolve:a,reject:c})});return this.send(`["COUNT","${s}",${JSON.stringify(t).substring(1)}`),o}close(t,r){this.send(`["CLOSE","${t}"]`);const s=this.openSubs.get(t);this.openSubs.delete(t),s&&s.onclose(r)}req(t){`${this.send(`["REQ","${t.subId}",${JSON.stringify(t.executeFilters).substring(1)}`)}`,this.openSubs.set(t.subId,t)}updateConnectionStats={connected:()=>{this._connectionStats.success++,this._connectionStats.connectedAt=Date.now()},disconnected:()=>{this._connectionStats.connectedAt&&(this._connectionStats.durations.push(Date.now()-this._connectionStats.connectedAt),this._connectionStats.durations.length>100&&this._connectionStats.durations.shift()),this._connectionStats.connectedAt=void 0},attempt:()=>{this._connectionStats.attempts++,this._connectionStats.connectedAt=Date.now()}};get connectionStats(){return this._connectionStats}get url(){return this.ndkRelay.url}get connected(){return this._status>=5&&this.ws?.readyState===WebSocket.OPEN}};async function fetchRelayInformation2(n){const t=n.replace(/^wss:\/\//,"https://").replace(/^ws:\/\//,"http://"),r=await fetch(t,{headers:{Accept:"application/nostr+json"}});if(!r.ok)throw new Error(`Failed to fetch relay information: ${r.status} ${r.statusText}`);return await r.json()}var NDKRelayPublisher$1=class{ndkRelay;debug;constructor(t){this.ndkRelay=t,this.debug=t.debug.extend("publisher")}async publish(t,r=2500){let s;const o=()=>new Promise((k,_)=>{try{this.publishEvent(t).then(A=>{this.ndkRelay.emit("published",t),t.emit("relay:published",this.ndkRelay),k(!0)}).catch(_)}catch(A){_(A)}}),a=new Promise((k,_)=>{s=setTimeout(()=>{s=void 0,_(new Error(`Timeout: ${r}ms`))},r)}),c=()=>{o().then(k=>f(k)).catch(k=>g(k))};let f,g;const m=k=>{throw this.ndkRelay.debug("Publish failed",k,t.id),this.ndkRelay.emit("publish:failed",t,k),t.emit("relay:publish:failed",this.ndkRelay,k),k},b=()=>{s&&clearTimeout(s),this.ndkRelay.removeListener("connect",c)};return this.ndkRelay.status>=5?Promise.race([o(),a]).catch(m).finally(b):(this.ndkRelay.status<=1?(console.warn("Relay is disconnected, trying to connect to publish an event",this.ndkRelay.url),this.ndkRelay.connect()):console.warn("Relay not connected, waiting for connection to publish an event",this.ndkRelay.url),Promise.race([new Promise((k,_)=>{f=k,g=_,this.ndkRelay.on("connect",c)}),a]).catch(m).finally(b))}async publishEvent(t){return this.ndkRelay.connectivity.publish(t.rawEvent())}};function filterFingerprint$1(n,t){const r=[];for(const o of n){const a=Object.entries(o||{}).map(([c,f])=>["since","until"].includes(c)?`${c}:${f}`:c).sort().join("-");r.push(a)}let s=t?"+":"";return s+=r.join("|"),s}function mergeFilters$1(n){const t=[],r={};return n.filter(s=>!!s.limit).forEach(s=>t.push(s)),n=n.filter(s=>!s.limit),n.length===0?t:(n.forEach(s=>{Object.entries(s).forEach(([o,a])=>{Array.isArray(a)?r[o]===void 0?r[o]=[...a]:r[o]=Array.from(new Set([...r[o],...a])):r[o]=a})}),[...t,r])}var MAX_ITEMS$1=3;function formatArray$1(n,t){const s=(t?n.slice(0,MAX_ITEMS$1).map(t):n.slice(0,MAX_ITEMS$1)).join(",");return n.length>MAX_ITEMS$1?`${s}+${n.length-MAX_ITEMS$1}`:s}function formatFilters$1(n){return n.map(t=>{const r=[];t.ids?.length&&r.push(`ids:[${formatArray$1(t.ids,s=>String(s).slice(0,8))}]`),t.kinds?.length&&r.push(`kinds:[${formatArray$1(t.kinds)}]`),t.authors?.length&&r.push(`authors:[${formatArray$1(t.authors,s=>String(s).slice(0,8))}]`),t.since&&r.push(`since:${t.since}`),t.until&&r.push(`until:${t.until}`),t.limit&&r.push(`limit:${t.limit}`),t.search&&r.push(`search:"${String(t.search).slice(0,20)}"`);for(const[s,o]of Object.entries(t))s.startsWith("#")&&Array.isArray(o)&&o.length>0&&r.push(`${s}:[${formatArray$1(o,a=>String(a).slice(0,8))}]`);return`{${r.join(" ")}}`}).join(", ")}var NDKRelaySubscription$1=class{fingerprint;items=new Map;topSubManager;debug;status=0;onClose;relay;eosed=!1;executionTimer;fireTime;delayType;executeFilters;id=Math.random().toString(36).substring(7);constructor(t,r,s){this.relay=t,this.topSubManager=s,this.debug=t.debug.extend(`sub[${this.id}]`),this.fingerprint=r||Math.random().toString(36).substring(7)}_subId;get subId(){return this._subId?this._subId:(this._subId=this.fingerprint.slice(0,15),this._subId)}subIdParts=new Set;addSubIdPart(t){this.subIdParts.add(t)}addItem(t,r){if(!this.items.has(t.internalId))switch(t.on("close",this.removeItem.bind(this,t)),this.items.set(t.internalId,{subscription:t,filters:r}),this.status!==3&&t.subId&&(!this._subId||this._subId.length<25)&&(this.status===0||this.status===1)&&this.addSubIdPart(t.subId),this.status){case 0:this.evaluateExecutionPlan(t);break;case 3:break;case 1:this.evaluateExecutionPlan(t);break;case 4:throw this.debug("Subscription is closed, cannot add new items",{filters:formatFilters$1(r),subId:t.subId,internalId:t.internalId}),new Error("Cannot add new items to a closed subscription")}}removeItem(t){if(this.items.delete(t.internalId),this.items.size===0){if(this.status===0||this.status===1){this.status=4,this.cleanup();return}if(!this.eosed)return;this.close(),this.cleanup()}}close(){if(this.status===4)return;const t=this.status;if(this.status=4,t===3)try{this.relay.close(this.subId)}catch(r){this.debug("Error closing subscription",r,this)}else this.debug("Subscription wanted to close but it wasn't running, this is probably ok",{subId:this.subId,prevStatus:t,sub:this});this.cleanup()}cleanup(){this.executionTimer&&clearTimeout(this.executionTimer),this.relay.off("ready",this.executeOnRelayReady),this.relay.off("authed",this.reExecuteAfterAuth),this.onClose&&this.onClose(this)}evaluateExecutionPlan(t){if(!t.isGroupable()){this.status=1,this.execute();return}if(t.filters.find(o=>!!o.limit)&&(this.executeFilters=this.compileFilters(),this.executeFilters.length>=10)){this.status=1,this.execute();return}const r=t.groupableDelay,s=t.groupableDelayType;if(!r)throw new Error("Cannot group a subscription without a delay");if(this.status===0)this.schedule(r,s);else{const o=this.delayType,a=this.fireTime-Date.now();if(o==="at-least"&&s==="at-least")a<r&&(this.executionTimer&&clearTimeout(this.executionTimer),this.schedule(r,s));else if(o==="at-least"&&s==="at-most")a>r&&(this.executionTimer&&clearTimeout(this.executionTimer),this.schedule(r,s));else if(o==="at-most"&&s==="at-most")a>r&&(this.executionTimer&&clearTimeout(this.executionTimer),this.schedule(r,s));else if(o==="at-most"&&s==="at-least")a>r&&(this.executionTimer&&clearTimeout(this.executionTimer),this.schedule(r,s));else throw new Error(`Unknown delay type combination ${o} ${s}`)}}schedule(t,r){this.status=1;const s=Date.now();this.fireTime=s+t,this.delayType=r;const o=setTimeout(()=>{this.execute()},t);r==="at-least"&&(this.executionTimer=o)}executeOnRelayReady=()=>{if(this.status===2){if(this.items.size===0){this.debug("No items to execute; this relay was probably too slow to respond and the caller gave up",{status:this.status,fingerprint:this.fingerprint,id:this.id,subId:this.subId}),this.cleanup();return}this.debug("Executing on relay ready",{status:this.status,fingerprint:this.fingerprint,itemsSize:this.items.size,filters:formatFilters$1(this.compileFilters())}),this.status=1,this.execute()}};finalizeSubId(){if(this.subIdParts.size>0){let r=Array.from(this.subIdParts).map(s=>s.substring(0,10)).join("-");r.length>20&&(r=r.substring(0,20)),this._subId=r}else this._subId=this.fingerprint.slice(0,15);this._subId+=`-${Math.random().toString(36).substring(2,7)}`}reExecuteAfterAuth=(()=>{const t=this.subId;this.debug("Re-executing after auth",this.items.size),this.eosed?this.relay.close(this.subId):this.debug("We are abandoning an opened subscription, once it EOSE's, the handler will close it",{oldSubId:t}),this._subId=void 0,this.status=1,this.execute(),this.debug("Re-executed after auth %s  %s",t,this.subId)}).bind(this);execute(){if(this.status===1){if(!this.relay.connected){this.status=2,this.debug("Waiting for relay to be ready",{status:this.status,id:this.subId,fingerprint:this.fingerprint,itemsSize:this.items.size}),this.relay.once("ready",this.executeOnRelayReady);return}this.relay.status<8&&this.relay.once("authed",this.reExecuteAfterAuth),this.status=3,this.finalizeSubId(),this.executeFilters=this.compileFilters(),this.relay.req(this)}}onstart(){}onevent(t){this.topSubManager.dispatchEvent(t,this.relay)}oneose(t){if(this.eosed=!0,t!==this.subId){this.debug("Received EOSE for an abandoned subscription",t,this.subId),this.relay.close(t);return}this.items.size===0&&this.close();for(const{subscription:r}of this.items.values())r.eoseReceived(this.relay),r.closeOnEose&&this.removeItem(r)}onclose(t){this.status=4}onclosed(t){if(t)for(const{subscription:r}of this.items.values())r.closedReceived(this.relay,t)}compileFilters(){const t=[],r=Array.from(this.items.values()).map(o=>o.filters);if(!r[0])return this.debug(" No filters to merge",{itemsSize:this.items.size}),[];const s=r[0].length;for(let o=0;o<s;o++){const a=r.map(f=>f[o]),c=mergeFilters$1(a);t.push(...c)}return t}},NDKRelaySubscriptionManager$1=class{relay;subscriptions;generalSubManager;constructor(t,r){this.relay=t,this.subscriptions=new Map,this.generalSubManager=r}addSubscription(t,r){let s;if(!t.isGroupable())s=this.createSubscription(t,r);else{const o=filterFingerprint$1(r,t.closeOnEose);o&&(s=(this.subscriptions.get(o)||[]).find(c=>c.status<3)),s??=this.createSubscription(t,r,o)}s.addItem(t,r)}createSubscription(t,r,s){const o=new NDKRelaySubscription$1(this.relay,s||null,this.generalSubManager);o.onClose=this.onRelaySubscriptionClose.bind(this);const a=this.subscriptions.get(o.fingerprint)??[];return this.subscriptions.set(o.fingerprint,[...a,o]),o}onRelaySubscriptionClose(t){let r=this.subscriptions.get(t.fingerprint)??[];r?r.length===1?this.subscriptions.delete(t.fingerprint):(r=r.filter(s=>s.id!==t.id),this.subscriptions.set(t.fingerprint,r)):console.warn("Unexpectedly did not find a subscription with fingerprint",t.fingerprint)}},NDKRelay$1=class kn extends import_tseep2.EventEmitter{url;scores;connectivity;subs;publisher;authPolicy;protocolHandlers=new Map;_relayInfo;lowestValidationRatio;targetValidationRatio;validationRatioFn;validatedEventCount=0;nonValidatedEventCount=0;trusted=!1;complaining=!1;debug;static defaultValidationRatioUpdateFn=(t,r,s)=>{if(t.lowestValidationRatio===void 0||t.targetValidationRatio===void 0)return 1;let o=t.validationRatio;if(t.validationRatio>t.targetValidationRatio){const a=r/100;o=Math.max(t.lowestValidationRatio,t.validationRatio-a)}return o<t.validationRatio?o:t.validationRatio};constructor(t,r,s){super(),this.url=normalizeRelayUrl$1(t),this.scores=new Map,this.debug=import_debug2.default(`ndk:relay:${t}`),this.connectivity=new NDKRelayConnectivity$1(this,s),this.connectivity.netDebug=s?.netDebug,this.req=this.connectivity.req.bind(this.connectivity),this.close=this.connectivity.close.bind(this.connectivity),this.subs=new NDKRelaySubscriptionManager$1(this,s.subManager),this.publisher=new NDKRelayPublisher$1(this),this.authPolicy=r,this.targetValidationRatio=s?.initialValidationRatio,this.lowestValidationRatio=s?.lowestValidationRatio,this.validationRatioFn=(s?.validationRatioFn??kn.defaultValidationRatioUpdateFn).bind(this),this.updateValidationRatio(),s||console.trace("relay created without ndk")}updateValidationRatio(){if(this.validationRatioFn&&this.validatedEventCount>0){const t=this.validationRatioFn(this,this.validatedEventCount,this.nonValidatedEventCount);this.targetValidationRatio=t}setTimeout(()=>{this.updateValidationRatio()},3e4)}get status(){return this.connectivity.status}get connectionStats(){return this.connectivity.connectionStats}async connect(t,r=!0){return this.connectivity.connect(t,r)}disconnect(){this.status!==1&&this.connectivity.disconnect()}subscribe(t,r){this.subs.addSubscription(t,r)}async publish(t,r=2500){return this.publisher.publish(t,r)}referenceTags(){return[["r",this.url]]}addValidatedEvent(){this.validatedEventCount++}addNonValidatedEvent(){this.nonValidatedEventCount++}get validationRatio(){return this.nonValidatedEventCount===0?1:this.validatedEventCount/(this.validatedEventCount+this.nonValidatedEventCount)}shouldValidateEvent(){return this.trusted?!1:this.targetValidationRatio===void 0||this.targetValidationRatio>=1?!0:Math.random()<this.targetValidationRatio}get connected(){return this.connectivity.connected}req;close;registerProtocolHandler(t,r){this.protocolHandlers.set(t,r)}unregisterProtocolHandler(t){this.protocolHandlers.delete(t)}getProtocolHandler(t){return this.protocolHandlers.get(t)}async fetchInfo(t=!1){const s=this.connectivity.ndk;if(!t&&s?.cacheAdapter?.getRelayStatus){const o=await s.cacheAdapter.getRelayStatus(this.url);if(o?.nip11&&Date.now()-o.nip11.fetchedAt<864e5)return this._relayInfo=o.nip11.data,o.nip11.data}return!t&&this._relayInfo?this._relayInfo:(this._relayInfo=await fetchRelayInformation2(this.url),s?.cacheAdapter?.updateRelayStatus&&await s.cacheAdapter.updateRelayStatus(this.url,{nip11:{data:this._relayInfo,fetchedAt:Date.now()}}),this._relayInfo)}get info(){return this._relayInfo}},NDKPublishError$1=class extends Error{errors;publishedToRelays;intendedRelaySet;constructor(t,r,s,o){super(t),this.errors=r,this.publishedToRelays=s,this.intendedRelaySet=o}get relayErrors(){const t=[];for(const[r,s]of this.errors)t.push(`${r.url}: ${s}`);return t.join(`
`)}},NDKRelaySet$1=class _n{relays;debug;ndk;pool;constructor(t,r,s){this.relays=t,this.ndk=r,this.pool=s??r.pool,this.debug=r.debug.extend("relayset")}addRelay(t){this.relays.add(t)}get relayUrls(){return Array.from(this.relays).map(t=>t.url)}static fromRelayUrls(t,r,s=!0,o){if(o=o??r.pool,!o)throw new Error("No pool provided");const a=new Set;for(const c of t){const f=o.relays.get(normalizeRelayUrl$1(c));if(f)f.status<5&&s&&f.connect(),a.add(f);else{const g=new NDKRelay$1(normalizeRelayUrl$1(c),r?.relayAuthDefaultPolicy,r);o.useTemporaryRelay(g,void 0,`requested from fromRelayUrls ${t}`),a.add(g)}}return new _n(new Set(a),r,o)}async publish(t,r,s=1){const o=new Set,a=new Map,c=t.isEphemeral();t.publishStatus="pending";const f=g=>{o.add(g)};t.on("relay:published",f);try{const g=Array.from(this.relays).map(m=>new Promise(b=>{const k=r?setTimeout(()=>{o.has(m)||(a.set(m,new Error(`Publish timeout after ${r}ms`)),b(!1))},r):null;m.publish(t,r).then(_=>{k&&clearTimeout(k),_?(o.add(m),b(!0)):b(!1)}).catch(_=>{k&&clearTimeout(k),c||a.set(m,_),b(!1)})}));if(await Promise.all(g),o.size<s){if(!c){const m=new NDKPublishError$1("Not enough relays received the event ("+o.size+" published, "+s+" required)",a,o,this);throw t.publishStatus="error",t.publishError=m,this.ndk?.emit("event:publish-failed",t,m,this.relayUrls),m}}else t.publishStatus="success",t.emit("published",{relaySet:this,publishedToRelays:o});return o}finally{t.off("relay:published",f)}}get size(){return this.relays.size}},d$5=import_debug.default("ndk:outbox:calculate");async function calculateRelaySetFromEvent$1(n,t,r){const s=new Set,o=await getWriteRelaysFor$1(n,t.pubkey);o&&o.forEach(f=>{const g=n.pool?.getRelay(f);g&&s.add(g)});let a=t.tags.filter(f=>["a","e"].includes(f[0])).map(f=>f[2]).filter(f=>f?.startsWith("wss://")).filter(f=>{try{return new URL(f),!0}catch{return!1}}).map(f=>normalizeRelayUrl$1(f));a=Array.from(new Set(a)).slice(0,5),a.forEach(f=>{const g=n.pool?.getRelay(f,!0,!0);g&&(d$5("Adding relay hint %s",f),s.add(g))});const c=t.getMatchingTags("p").map(f=>f[1]);return c.length<5?Array.from(chooseRelayCombinationForPubkeys$1(n,c,"read",{preferredRelays:new Set(o)}).keys()).forEach(g=>{const m=n.pool?.getRelay(g,!1,!0);m&&(d$5("Adding p-tagged relay %s",g),s.add(m))}):d$5("Too many p-tags to consider %d",c.length),n.pool?.permanentAndConnectedRelays().forEach(f=>s.add(f)),r&&s.size<r&&n.explicitRelayUrls?.filter(g=>!Array.from(s).some(m=>m.url===g)).slice(0,r-s.size)?.forEach(g=>{const m=n.pool?.getRelay(g,!1,!0);m&&(d$5("Adding explicit relay %s",g),s.add(m))}),new NDKRelaySet$1(s,n)}function calculateRelaySetsFromFilter$1(n,t,r,s){const o=new Map,a=new Set;if(t.forEach(c=>{c.authors&&c.authors.forEach(f=>a.add(f))}),a.size>0){const c=getRelaysForFilterWithAuthors$1(n,Array.from(a),s);for(const f of c.keys())o.set(f,[]);for(const f of t)if(f.authors)for(const[g,m]of c.entries()){const b=f.authors.filter(k=>m.includes(k));o.set(g,[...o.get(g),{...f,authors:b}])}else for(const g of c.keys())o.set(g,[...o.get(g),f])}else n.explicitRelayUrls&&n.explicitRelayUrls.forEach(c=>{o.set(c,t)});return o.size===0&&r.permanentAndConnectedRelays().slice(0,5).forEach(c=>{o.set(c.url,t)}),o}function calculateRelaySetsFromFilters$1(n,t,r,s){return calculateRelaySetsFromFilter$1(n,t,r,s)}function isValidHex64$1(n){if(typeof n!="string"||n.length!==64)return!1;for(let t=0;t<64;t++){const r=n.charCodeAt(t);if(!(r>=48&&r<=57||r>=97&&r<=102||r>=65&&r<=70))return!1}return!0}function isValidPubkey$1(n){return isValidHex64$1(n)}function isValidNip05$1(n){if(typeof n!="string")return!1;for(let t=0;t<n.length;t++)if(n.charCodeAt(t)===46)return!0;return!1}function mergeTags$1(n,t){const r=new Map,s=c=>c.join(","),o=(c,f)=>c.every((g,m)=>g===f[m]),a=c=>{for(const[f,g]of r)if(o(g,c)||o(c,g)){c.length>=g.length&&r.set(f,c);return}r.set(s(c),c)};return n.concat(t).forEach(a),Array.from(r.values())}var hashtagRegex$1=new RegExp(`(?<=\\s|^)(#[^\\s!@#$%^&*()=+./,[{\\]};:'"?><]+)`,"g");function generateHashtags$1(n){const t=n.match(hashtagRegex$1),r=new Set,s=new Set;if(t)for(const o of t)r.has(o.slice(1))||(s.add(o.slice(1)),r.add(o.slice(1)));return Array.from(s)}async function generateContentTags$1(n,t=[],r,s){if(r?.skipContentTagging)return{content:n,tags:t};const o=/(@|nostr:)(npub|nprofile|note|nevent|naddr)[a-zA-Z0-9]+/g,a=[],c=f=>{t.find(g=>["q",f[0]].includes(g[0])&&g[1]===f[1])||t.push(f)};if(n=n.replace(o,f=>{try{const g=f.split(/(@|nostr:)/)[2],{type:m,data:b}=nip19_exports$2.decode(g);let k;if(r?.filters){const _=!r.filters.includeTypes||r.filters.includeTypes.includes(m),A=r.filters.excludeTypes?.includes(m);if(!_||A)return f}switch(m){case"npub":r?.pTags!==!1&&(k=["p",b]);break;case"nprofile":r?.pTags!==!1&&(k=["p",b.pubkey]);break;case"note":a.push(new Promise(async _=>{const A=await maybeGetEventRelayUrl$1(g);c(["q",b,A]),_()}));break;case"nevent":a.push(new Promise(async _=>{const{id:A,author:B}=b;let{relays:L}=b;(!L||L.length===0)&&(L=[await maybeGetEventRelayUrl$1(g)]),c(["q",A,L[0]]),B&&r?.pTags!==!1&&r?.pTagOnQTags!==!1&&c(["p",B]),_()}));break;case"naddr":a.push(new Promise(async _=>{const A=[b.kind,b.pubkey,b.identifier].join(":");let B=b.relays??[];B.length===0&&(B=[await maybeGetEventRelayUrl$1(g)]),c(["q",A,B[0]]),r?.pTags!==!1&&r?.pTagOnQTags!==!1&&r?.pTagOnATags!==!1&&c(["p",b.pubkey]),_()}));break;default:return f}return k&&c(k),`nostr:${g}`}catch{return f}}),await Promise.all(a),!r?.filters?.excludeTypes?.includes("hashtag")){const f=generateHashtags$1(n).map(g=>["t",g]);t=mergeTags$1(t,f)}if(r?.pTags!==!1&&r?.copyPTagsFromTarget&&s){const f=s.getMatchingTags("p");for(const g of f)!g[1]||!isValidPubkey$1(g[1])||t.find(m=>m[0]==="p"&&m[1]===g[1])||t.push(g)}return{content:n,tags:t}}async function maybeGetEventRelayUrl$1(n){return""}async function encrypt4(n,t,r="nip44"){let s;if(!this.ndk)throw new Error("No NDK instance found!");let o=t;if(o||(this.ndk.assertSigner(),o=this.ndk.signer),!o)throw new Error("no NDK signer");const a=n||(()=>{const c=this.getMatchingTags("p");if(c.length!==1)throw new Error("No recipient could be determined and no explicit recipient was provided");return this.ndk.getUser({pubkey:c[0][1]})})();if(r==="nip44"&&await isEncryptionEnabled$1(o,"nip44")&&(s=await o.encrypt(a,this.content,"nip44")),(!s||r==="nip04")&&await isEncryptionEnabled$1(o,"nip04")&&(s=await o.encrypt(a,this.content,"nip04")),!s)throw new Error("Failed to encrypt event.");this.content=s}async function decrypt4(n,t,r){if(this.ndk?.cacheAdapter?.getDecryptedEvent){const f=await this.ndk.cacheAdapter.getDecryptedEvent(this.id);if(f){this.content=f.content;return}}let s;if(!this.ndk)throw new Error("No NDK instance found!");let o=t;if(o||(this.ndk.assertSigner(),o=this.ndk.signer),!o)throw new Error("no NDK signer");const a=n||this.author;if(!a)throw new Error("No sender provided and no author available");const c=r||(this.content.match(/\\?iv=/)?"nip04":"nip44");if((c==="nip04"||this.kind===4)&&await isEncryptionEnabled$1(o,"nip04")&&this.content.search("\\?iv=")&&(s=await o.decrypt(a,this.content,"nip04")),!s&&c==="nip44"&&await isEncryptionEnabled$1(o,"nip44")&&(s=await o.decrypt(a,this.content,"nip44")),!s)throw new Error("Failed to decrypt event.");this.content=s,this.ndk?.cacheAdapter?.addDecryptedEvent&&this.ndk.cacheAdapter.addDecryptedEvent(this.id,this)}async function isEncryptionEnabled$1(n,t){return n.encryptionEnabled?t?!!await n.encryptionEnabled(t):!0:!1}function eventHasETagMarkers$1(n){for(const t of n.tags)if(t[0]==="e"&&(t[3]??"").length>0)return!0;return!1}function getRootTag$1(n,t){t??=n.tagType();const r=n.tags.find(isTagRootTag$1);if(!r){if(eventHasETagMarkers$1(n))return;const s=n.getMatchingTags(t);if(s.length<3)return s[0]}return r}var nip22RootTags$1=new Set(["A","E","I"]),nip22ReplyTags$1=new Set(["a","e","i"]);function getReplyTag$1(n,t){if(n.kind===1111){let o;for(const a of n.tags)if(nip22RootTags$1.has(a[0]))o=a;else if(nip22ReplyTags$1.has(a[0])){o=a;break}return o}t??=n.tagType();let r=!1,s;for(const o of n.tags)if(o[0]===t){if((o[3]??"").length>0&&(r=!0),r&&o[3]==="reply")return o;r&&o[3]==="root"&&(s=o),r||(s=o)}return s}function isTagRootTag$1(n){return n[0]==="E"||n[3]==="root"}async function fetchTaggedEvent$1(n,t){if(!this.ndk)throw new Error("NDK instance not found");const r=this.getMatchingTags(n,t);if(r.length===0)return;const[s,o,a]=r[0],c=a!==""?this.ndk.pool.getRelay(a):void 0;return await this.ndk.fetchEvent(o,{},c)}async function fetchRootEvent$1(n){if(!this.ndk)throw new Error("NDK instance not found");const t=getRootTag$1(this);if(t)return this.ndk.fetchEventFromTag(t,this,n)}async function fetchReplyEvent$1(n){if(!this.ndk)throw new Error("NDK instance not found");const t=getReplyTag$1(this);if(t)return this.ndk.fetchEventFromTag(t,this,n)}function isReplaceable$1(){if(this.kind===void 0)throw new Error("Kind not set");return[0,3].includes(this.kind)||this.kind>=1e4&&this.kind<2e4||this.kind>=3e4&&this.kind<4e4}function isEphemeral$1(){if(this.kind===void 0)throw new Error("Kind not set");return this.kind>=2e4&&this.kind<3e4}function isParamReplaceable$1(){if(this.kind===void 0)throw new Error("Kind not set");return this.kind>=3e4&&this.kind<4e4}var DEFAULT_RELAY_COUNT$1=2;function encode$1(n=DEFAULT_RELAY_COUNT$1){let t=[];return this.onRelays.length>0?t=this.onRelays.map(r=>r.url):this.relay&&(t=[this.relay.url]),t.length>n&&(t=t.slice(0,n)),this.isParamReplaceable()?nip19_exports$2.naddrEncode({kind:this.kind,pubkey:this.pubkey,identifier:this.replaceableDTag(),relays:t}):t.length>0?nip19_exports$2.neventEncode({id:this.tagId(),relays:t,author:this.pubkey}):nip19_exports$2.noteEncode(this.tagId())}async function repost$1(n=!0,t){if(!t&&n){if(!this.ndk)throw new Error("No NDK instance found");this.ndk.assertSigner(),t=this.ndk.signer}const r=new NDKEvent$1(this.ndk,{kind:getKind$1(this)});return this.isProtected||(r.content=JSON.stringify(this.rawEvent())),r.tag(this),this.kind!==1&&r.tags.push(["k",`${this.kind}`]),t&&await r.sign(t),n&&await r.publish(),r}function getKind$1(n){return n.kind===1?6:16}function getEventDetails$1(n){return"inspect"in n&&typeof n.inspect=="string"?n.inspect:JSON.stringify(n)}function validateForSerialization$1(n){if(typeof n.kind!="number")throw new Error(`Can't serialize event with invalid properties: kind (must be number, got ${typeof n.kind}). Event: ${getEventDetails$1(n)}`);if(typeof n.content!="string")throw new Error(`Can't serialize event with invalid properties: content (must be string, got ${typeof n.content}). Event: ${getEventDetails$1(n)}`);if(typeof n.created_at!="number")throw new Error(`Can't serialize event with invalid properties: created_at (must be number, got ${typeof n.created_at}). Event: ${getEventDetails$1(n)}`);if(typeof n.pubkey!="string")throw new Error(`Can't serialize event with invalid properties: pubkey (must be string, got ${typeof n.pubkey}). Event: ${getEventDetails$1(n)}`);if(!Array.isArray(n.tags))throw new Error(`Can't serialize event with invalid properties: tags (must be array, got ${typeof n.tags}). Event: ${getEventDetails$1(n)}`);for(let t=0;t<n.tags.length;t++){const r=n.tags[t];if(!Array.isArray(r))throw new Error(`Can't serialize event with invalid properties: tags[${t}] (must be array, got ${typeof r}). Event: ${getEventDetails$1(n)}`);for(let s=0;s<r.length;s++)if(typeof r[s]!="string")throw new Error(`Can't serialize event with invalid properties: tags[${t}][${s}] (must be string, got ${typeof r[s]}). Event: ${getEventDetails$1(n)}`)}}function serialize$1(n=!1,t=!1){validateForSerialization$1(this);const r=[0,this.pubkey,this.created_at,this.kind,this.tags,this.content];return n&&r.push(this.sig),t&&r.push(this.id),JSON.stringify(r)}function deserialize$1(n){const t=JSON.parse(n),r={pubkey:t[1],created_at:t[2],kind:t[3],tags:t[4],content:t[5]};if(t.length>=7){const s=t[6],o=t[7];s&&s.length===128?(r.sig=s,o&&o.length===64&&(r.id=o)):s&&s.length===64&&(r.id=s,o&&o.length===128&&(r.sig=o))}return r}var worker$1,processingQueue$1={};function signatureVerificationInit$1(n){worker$1=n,worker$1.onmessage=t=>{if(!Array.isArray(t.data)||t.data.length!==2){console.error("[NDK]  Signature verification worker received incompatible message format.",`

 Expected format: [eventId, boolean]`,`
 Received:`,t.data,`

 This likely means:`,`
  1. You have a STALE worker.js file that needs updating`,`
  2. Version mismatch between @nostr-dev-kit/ndk and deployed worker`,`
  3. Wrong worker is being used for signature verification`,`

 Solution: Update your worker files:`,`
  cp node_modules/@nostr-dev-kit/ndk/dist/workers/sig-verification.js public/`,`
  cp node_modules/@nostr-dev-kit/cache-sqlite-wasm/dist/worker.js public/`,`

 Or use Vite/bundler imports instead of static files:`,`
  import SigWorker from "@nostr-dev-kit/ndk/workers/sig-verification?worker"`);return}const[r,s]=t.data,o=processingQueue$1[r];if(!o){console.error("No record found for event",r);return}delete processingQueue$1[r];for(const a of o.resolves)a(s)}}async function verifySignatureAsync$1(n,t,r){const s=n.ndk,o=Date.now();let a;return s.signatureVerificationFunction?a=await s.signatureVerificationFunction(n):a=await new Promise(c=>{const f=n.serialize();let g=!1;processingQueue$1[n.id]||(processingQueue$1[n.id]={event:n,resolves:[],relay:r},g=!0),processingQueue$1[n.id].resolves.push(c),g&&worker$1?.postMessage({serialized:f,id:n.id,sig:n.sig,pubkey:n.pubkey})}),s.signatureVerificationTimeMs+=Date.now()-o,a}var PUBKEY_REGEX$1=/^[a-f0-9]{64}$/;function validate$1(){if(typeof this.kind!="number"||typeof this.content!="string"||typeof this.created_at!="number"||typeof this.pubkey!="string"||!this.pubkey.match(PUBKEY_REGEX$1)||!Array.isArray(this.tags))return!1;for(let n=0;n<this.tags.length;n++){const t=this.tags[n];if(!Array.isArray(t))return!1;for(let r=0;r<t.length;r++)if(typeof t[r]=="object")return!1}return!0}var verifiedSignatures$1=new import_typescript_lru_cache.LRUCache({maxSize:1e3,entryExpirationTimeInMS:6e4});function verifySignature$1(n){if(typeof this.signatureVerified=="boolean")return this.signatureVerified;const t=verifiedSignatures$1.get(this.id);if(t!==null)return this.signatureVerified=!!t,this.signatureVerified;try{if(this.ndk?.asyncSigVerification){const r=this.relay;verifySignatureAsync$1(this,n,r).then(s=>{n&&(this.signatureVerified=s,s&&verifiedSignatures$1.set(this.id,this.sig)),s?r&&r.addValidatedEvent():(r?this.ndk?.reportInvalidSignature(this,r):this.ndk?.reportInvalidSignature(this),verifiedSignatures$1.set(this.id,!1))}).catch(s=>{console.error("signature verification error",this.id,s)})}else{const r=sha2564(new TextEncoder().encode(this.serialize())),s=schnorr2.verify(this.sig,r,this.pubkey);return s?verifiedSignatures$1.set(this.id,this.sig):verifiedSignatures$1.set(this.id,!1),this.signatureVerified=s,s}}catch{return this.signatureVerified=!1,!1}}function getEventHash2(){return getEventHashFromSerializedEvent$1(this.serialize())}function getEventHashFromSerializedEvent$1(n){const t=sha2564(new TextEncoder().encode(n));return bytesToHex3(t)}var skipClientTagOnKinds$1=new Set([0,4,1059,13,3,9734,5]),NDKEvent$1=class cn extends import_tseep.EventEmitter{ndk;created_at;content="";tags=[];kind;id="";sig;pubkey="";signatureVerified;_author=void 0;relay;get onRelays(){let t=[];return this.ndk?t=this.ndk.subManager.seenEvents.get(this.id)||[]:this.relay&&t.push(this.relay),t}publishStatus="success";publishError;constructor(t,r){super(),this.ndk=t,this.created_at=r?.created_at,this.content=r?.content||"",this.tags=r?.tags||[],this.id=r?.id||"",this.sig=r?.sig,this.pubkey=r?.pubkey||"",this.kind=r?.kind,r instanceof cn&&(this.relay&&(this.relay=r.relay,this.ndk?.subManager.seenEvent(r.id,this.relay)),this.publishStatus=r.publishStatus,this.publishError=r.publishError)}static deserialize(t,r){return new cn(t,deserialize$1(r))}rawEvent(){return{created_at:this.created_at,content:this.content,tags:this.tags,kind:this.kind,pubkey:this.pubkey,id:this.id,sig:this.sig}}set author(t){this.pubkey=t.pubkey,this._author=t,this._author.ndk??=this.ndk}get author(){if(this._author)return this._author;if(!this.ndk)throw new Error("No NDK instance found");const t=this.ndk.getUser({pubkey:this.pubkey});return this._author=t,t}tagExternal(t,r,s){const o=["i"],a=["k"];switch(r){case"url":{const c=new URL(t);c.hash="",o.push(c.toString()),a.push(`${c.protocol}//${c.host}`);break}case"hashtag":o.push(`#${t.toLowerCase()}`),a.push("#");break;case"geohash":o.push(`geo:${t.toLowerCase()}`),a.push("geo");break;case"isbn":o.push(`isbn:${t.replace(/-/g,"")}`),a.push("isbn");break;case"podcast:guid":o.push(`podcast:guid:${t}`),a.push("podcast:guid");break;case"podcast:item:guid":o.push(`podcast:item:guid:${t}`),a.push("podcast:item:guid");break;case"podcast:publisher:guid":o.push(`podcast:publisher:guid:${t}`),a.push("podcast:publisher:guid");break;case"isan":o.push(`isan:${t.split("-").slice(0,4).join("-")}`),a.push("isan");break;case"doi":o.push(`doi:${t.toLowerCase()}`),a.push("doi");break;default:throw new Error(`Unsupported NIP-73 entity type: ${r}`)}s&&o.push(s),this.tags.push(o),this.tags.push(a)}tag(t,r,s,o,a){let c=[];if(t.fetchProfile!==void 0){if(o??="p",o==="p"&&a?.pTags===!1)return;const g=[o,t.pubkey];r&&g.push("",r),c.push(g)}else if(t instanceof cn){const g=t;if(s??=g?.pubkey===this.pubkey,c=g.referenceTags(r,s,o,a),a?.pTags!==!1)for(const m of g.getMatchingTags("p"))!m[1]||!isValidPubkey$1(m[1])||m[1]!==this.pubkey&&(this.tags.find(b=>b[0]==="p"&&b[1]===m[1])||this.tags.push(["p",m[1]]))}else if(Array.isArray(t))c=[t];else throw new Error("Invalid argument",t);this.tags=mergeTags$1(this.tags,c)}async toNostrEvent(t,r){if(!t&&this.pubkey===""){const a=await this.ndk?.signer?.user();this.pubkey=a?.pubkey||""}this.created_at||(this.created_at=Math.floor(Date.now()/1e3));const{content:s,tags:o}=await this.generateTags(r);this.content=s||"",this.tags=o;try{this.id=this.getEventHash()}catch{}return this.rawEvent()}serialize=serialize$1.bind(this);getEventHash=getEventHash2.bind(this);validate=validate$1.bind(this);verifySignature=verifySignature$1.bind(this);isReplaceable=isReplaceable$1.bind(this);isEphemeral=isEphemeral$1.bind(this);isDvm=()=>this.kind&&this.kind>=5e3&&this.kind<=7e3;isParamReplaceable=isParamReplaceable$1.bind(this);encode=encode$1.bind(this);encrypt=encrypt4.bind(this);decrypt=decrypt4.bind(this);getMatchingTags(t,r){const s=this.tags.filter(o=>o[0]===t);return r===void 0?s:s.filter(o=>o[3]===r)}hasTag(t,r){return this.tags.some(s=>s[0]===t&&(!r||s[3]===r))}tagValue(t,r){const s=this.getMatchingTags(t,r);if(s.length!==0)return s[0][1]}get alt(){return this.tagValue("alt")}set alt(t){this.removeTag("alt"),t&&this.tags.push(["alt",t])}get dTag(){return this.tagValue("d")}set dTag(t){this.removeTag("d"),t&&this.tags.push(["d",t])}removeTag(t,r){const s=Array.isArray(t)?t:[t];this.tags=this.tags.filter(o=>{const a=s.includes(o[0]),c=r?o[3]===r:!0;return!(a&&c)})}replaceTag(t){this.removeTag(t[0]),this.tags.push(t)}async sign(t,r){this.ndk?.aiGuardrails?.event?.signing(this),t?this.author=await t.user():(this.ndk?.assertSigner(),t=this.ndk?.signer);const s=await this.toNostrEvent(void 0,r);return this.sig=await t.sign(s),this.sig}async publishReplaceable(t,r,s){return this.id="",this.created_at=Math.floor(Date.now()/1e3),this.sig="",this.publish(t,r,s)}async publish(t,r,s,o){if(s||(s=1),this.sig||await this.sign(void 0,o),!this.ndk)throw new Error("NDKEvent must be associated with an NDK instance to publish");if(this.ndk.aiGuardrails?.event?.publishing(this),(!t||t.size===0)&&(t=this.ndk.devWriteRelaySet||await calculateRelaySetFromEvent$1(this.ndk,this,s)),this.kind===5&&this.ndk.cacheAdapter?.deleteEventIds){const f=this.getMatchingTags("e").map(g=>g[1]);this.ndk.cacheAdapter.deleteEventIds(f)}const a=this.rawEvent();if(this.ndk.cacheAdapter?.addUnpublishedEvent&&shouldTrackUnpublishedEvent$1(this))try{this.ndk.cacheAdapter.addUnpublishedEvent(this,t.relayUrls)}catch(f){console.error("Error adding unpublished event to cache",f)}this.kind===5&&this.ndk.cacheAdapter?.deleteEventIds&&this.ndk.cacheAdapter.deleteEventIds(this.getMatchingTags("e").map(f=>f[1])),this.ndk.subManager.dispatchEvent(a,void 0,!0);const c=await t.publish(this,r,s);return c.forEach(f=>this.ndk?.subManager.seenEvent(this.id,f)),c}async generateTags(t){let r=[];const s=await generateContentTags$1(this.content,this.tags,t,this),o=s.content;if(r=s.tags,this.kind&&this.isParamReplaceable()&&!this.getMatchingTags("d")[0]){const c=this.tagValue("title");let g=[...Array(c?6:16)].map(()=>Math.random().toString(36)[2]).join("");c&&c.length>0&&(g=`${c.replace(/[^a-z0-9]+/gi,"-").replace(/^-|-$/g,"")}-${g}`),r.push(["d",g])}if(this.shouldAddClientTag){const a=["client",this.ndk?.clientName??""];this.ndk?.clientNip89&&a.push(this.ndk?.clientNip89),r.push(a)}else this.shouldStripClientTag&&(r=r.filter(a=>a[0]!=="client"));return{content:o||"",tags:r}}get shouldAddClientTag(){return!(!this.ndk?.clientName&&!this.ndk?.clientNip89||skipClientTagOnKinds$1.has(this.kind)||this.isEphemeral()||this.isReplaceable()&&!this.isParamReplaceable()||this.isDvm()||this.hasTag("client"))}get shouldStripClientTag(){return skipClientTagOnKinds$1.has(this.kind)}muted(){return this.ndk?.muteFilter&&this.ndk.muteFilter(this)?"muted":null}replaceableDTag(){if(this.kind&&this.kind>=3e4&&this.kind<=4e4){const t=this.getMatchingTags("d")[0];return t?t[1]:""}throw new Error("Event is not a parameterized replaceable event")}deduplicationKey(){return this.kind===0||this.kind===3||this.kind&&this.kind>=1e4&&this.kind<2e4?`${this.kind}:${this.pubkey}`:this.tagId()}tagId(){return this.isParamReplaceable()?this.tagAddress():this.id}tagAddress(){if(this.isParamReplaceable()){const t=this.dTag??"";return`${this.kind}:${this.pubkey}:${t}`}if(this.isReplaceable())return`${this.kind}:${this.pubkey}:`;throw new Error("Event is not a replaceable event")}tagType(){return this.isParamReplaceable()?"a":"e"}tagReference(t){let r;return this.isParamReplaceable()?r=["a",this.tagAddress()]:r=["e",this.tagId()],this.relay?r.push(this.relay.url):r.push(""),r.push(t??""),this.isParamReplaceable()||r.push(this.pubkey),r}referenceTags(t,r,s,o){let a=[];return this.isParamReplaceable()?a=[[s??"a",this.tagAddress()],[s??"e",this.id]]:a=[[s??"e",this.id]],a=a.map(c=>(c[0]==="e"||t?c.push(this.relay?.url??""):this.relay?.url&&c.push(this.relay?.url),c)),a.forEach(c=>{c[0]==="e"?(c.push(t??""),c.push(this.pubkey)):t&&c.push(t)}),a=[...a,...this.getMatchingTags("h")],!r&&o?.pTags!==!1&&a.push(...this.author.referenceTags()),a}filter(){return this.isParamReplaceable()?{"#a":[this.tagId()]}:{"#e":[this.tagId()]}}nip22Filter(){return this.isParamReplaceable()?{"#A":[this.tagId()]}:{"#E":[this.tagId()]}}async delete(t,r=!0){if(!this.ndk)throw new Error("No NDK instance found");this.ndk.assertSigner();const s=new cn(this.ndk,{kind:5,content:t||""});return s.tag(this,void 0,!0),s.tags.push(["k",this.kind?.toString()]),r&&(this.emit("deleted"),await s.publish()),s}set isProtected(t){this.removeTag("-"),t&&this.tags.push(["-"])}get isProtected(){return this.hasTag("-")}fetchTaggedEvent=fetchTaggedEvent$1.bind(this);fetchRootEvent=fetchRootEvent$1.bind(this);fetchReplyEvent=fetchReplyEvent$1.bind(this);repost=repost$1.bind(this);async react(t,r=!0){if(!this.ndk)throw new Error("No NDK instance found");this.ndk.assertSigner();const s=new cn(this.ndk,{kind:7,content:t});return s.tag(this),this.kind!==1&&s.tags.push(["k",`${this.kind}`]),r&&await s.publish(),s}get isValid(){return this.validate()}get inspect(){return JSON.stringify(this.rawEvent(),null,4)}dump(){console.debug(JSON.stringify(this.rawEvent(),null,4)),console.debug("Event on relays:",this.onRelays.map(t=>t.url).join(", "))}reply(t,r){const s=new cn(this.ndk);if(this.ndk?.aiGuardrails?.event?.creatingReply(s),this.kind===1&&!t)s.kind=1,this.hasTag("e")?s.tags=[...s.tags,...this.getMatchingTags("e"),...this.getMatchingTags("p"),...this.getMatchingTags("a"),...this.referenceTags("reply",!1,void 0,r)]:s.tag(this,"root",!1,void 0,r);else{s.kind=1111;const o=["A","E","I","P"],a=this.tags.filter(c=>o.includes(c[0]));if(a.length>0){const c=this.tagValue("K");s.tags.push(...a),c&&s.tags.push(["K",c]);let f;if(this.isParamReplaceable()){f=["a",this.tagAddress()];const g=this.relay?.url??"";g&&f.push(g)}else{f=["e",this.tagId()];const g=this.relay?.url??"";f.push(g),f.push(this.pubkey)}s.tags.push(f)}else{let c,f;const g=this.relay?.url??"";this.isParamReplaceable()?(c=["a",this.tagAddress(),g],f=["A",this.tagAddress(),g]):(c=["e",this.tagId(),g,this.pubkey],f=["E",this.tagId(),g,this.pubkey]),s.tags.push(c),s.tags.push(f),s.tags.push(["K",this.kind?.toString()]),r?.pTags!==!1&&r?.pTagOnATags!==!1&&s.tags.push(["P",this.pubkey])}s.tags.push(["k",this.kind?.toString()]),r?.pTags!==!1&&(s.tags.push(...this.getMatchingTags("p")),s.tags.push(["p",this.pubkey]))}return s}},untrackedUnpublishedEvents$1=new Set([24133,13194,23194,23195]);function shouldTrackUnpublishedEvent$1(n){return!untrackedUnpublishedEvents$1.has(n.kind)}var NDKPool$1=class extends import_tseep3.EventEmitter{_relays=new Map;status="idle";autoConnectRelays=new Set;debug;temporaryRelayTimers=new Map;flappingRelays=new Set;backoffTimes=new Map;ndk;disconnectionTimes=new Map;systemEventDetector;constructor(t,r,{debug:s,name:o}={}){super(),this.debug=s??r.debug.extend("pool"),o&&(this._name=o),this.ndk=r,this.relayUrls=t,this.ndk.pools&&this.ndk.pools.push(this)}get relays(){return this._relays}set relayUrls(t){this._relays.clear();for(const r of t){const s=new NDKRelay$1(r,void 0,this.ndk);s.connectivity.netDebug=this.ndk.netDebug,this.addRelay(s)}}_name="unnamed";get name(){return this._name}set name(t){this._name=t,this.debug=this.debug.extend(t)}useTemporaryRelay(t,r=3e4,s){const o=this.relays.has(t.url);o||(this.addRelay(t),this.debug("Adding temporary relay %s for filters %o",t.url,s));const a=this.temporaryRelayTimers.get(t.url);if(a&&clearTimeout(a),!o||a){const c=setTimeout(()=>{this.ndk.explicitRelayUrls?.includes(t.url)||this.removeRelay(t.url)},r);this.temporaryRelayTimers.set(t.url,c)}}addRelay(t,r=!0){const s=this.relays.has(t.url),o=t.url.includes("/npub1");let a=!0;const c=t.url;if(s)return;if(this.ndk.relayConnectionFilter&&!this.ndk.relayConnectionFilter(c)){this.debug(`Refusing to add relay ${c}: blocked by relayConnectionFilter`);return}if(o){this.debug(`Refusing to add relay ${c}: is a filter relay`);return}if(this.ndk.cacheAdapter?.getRelayStatus){const B=this.ndk.cacheAdapter.getRelayStatus(c),L=B instanceof Promise?void 0:B;if(L?.dontConnectBefore){if(L.dontConnectBefore>Date.now()){const Z=L.dontConnectBefore-Date.now();this.debug(`Refusing to add relay ${c}: delayed connect for ${Z}ms`),setTimeout(()=>{this.addRelay(t,r)},Z);return}a=!1}}const f=B=>this.emit("notice",t,B),g=()=>this.handleRelayConnect(c),m=()=>this.handleRelayReady(t),b=()=>{this.recordDisconnection(t),this.emit("relay:disconnect",t)},k=()=>this.handleFlapping(t),_=B=>this.emit("relay:auth",t,B),A=()=>this.emit("relay:authed",t);t.off("notice",f),t.off("connect",g),t.off("ready",m),t.off("disconnect",b),t.off("flapping",k),t.off("auth",_),t.off("authed",A),t.on("notice",f),t.on("connect",g),t.on("ready",m),t.on("disconnect",b),t.on("flapping",k),t.on("auth",_),t.on("authed",A),t.on("delayed-connect",B=>{this.ndk.cacheAdapter?.updateRelayStatus&&this.ndk.cacheAdapter.updateRelayStatus(t.url,{dontConnectBefore:Date.now()+B})}),this._relays.set(c,t),r&&this.autoConnectRelays.add(c),r&&this.status==="active"&&(this.emit("relay:connecting",t),t.connect(void 0,a).catch(B=>{this.debug(`Failed to connect to relay ${c}`,B)}))}removeRelay(t){const r=this.relays.get(t);if(r)return r.disconnect(),this.relays.delete(t),this.autoConnectRelays.delete(t),this.emit("relay:disconnect",r),!0;const s=this.temporaryRelayTimers.get(t);return s&&(clearTimeout(s),this.temporaryRelayTimers.delete(t)),!1}isRelayConnected(t){const r=normalizeRelayUrl$1(t),s=this.relays.get(r);return s?s.status===5:!1}getRelay(t,r=!0,s=!1,o){let a=this.relays.get(normalizeRelayUrl$1(t));return a||(a=new NDKRelay$1(t,void 0,this.ndk),a.connectivity.netDebug=this.ndk.netDebug,s?this.useTemporaryRelay(a,3e4,o):this.addRelay(a,r)),a}handleRelayConnect(t){const r=this.relays.get(t);if(!r){console.error("NDK BUG: relay not found in pool",{relayUrl:t});return}this.emit("relay:connect",r),this.stats().connected===this.relays.size&&this.emit("connect")}handleRelayReady(t){this.emit("relay:ready",t)}async connect(t){this.status="active",this.debug(`Connecting to ${this.relays.size} relays${t?`, timeout ${t}ms`:""}...`);const r=Array.from(this.autoConnectRelays.keys()).map(c=>this.relays.get(c)).filter(c=>!!c);for(const c of r)c.status!==5&&c.status!==4&&(this.emit("relay:connecting",c),c.connect().catch(f=>{this.debug(`Failed to connect to relay ${c.url}: ${f??"No reason specified"}`)}));const s=()=>r.every(c=>c.status===5),o=new Promise(c=>{if(s()){c();return}const f=[];for(const g of r){const m=()=>{if(s()){for(let b=0;b<r.length;b++)r[b].off("connect",f[b]);c()}};f.push(m),g.on("connect",m)}}),a=typeof t=="number"?new Promise(c=>setTimeout(c,t)):new Promise(()=>{});await Promise.race([o,a])}checkOnFlappingRelays(){const t=this.flappingRelays.size,r=this.relays.size;if(t/r>=.8)for(const s of this.flappingRelays)this.backoffTimes.set(s,0)}recordDisconnection(t){const r=Date.now();this.disconnectionTimes.set(t.url,r);for(const[s,o]of this.disconnectionTimes.entries())r-o>1e4&&this.disconnectionTimes.delete(s);this.checkForSystemWideDisconnection()}checkForSystemWideDisconnection(){const t=Date.now(),r=[];for(const s of this.disconnectionTimes.values())t-s<5e3&&r.push(s);r.length>this.relays.size/2&&this.relays.size>1&&(this.debug(`System-wide disconnection detected: ${r.length}/${this.relays.size} relays disconnected`),this.handleSystemWideReconnection())}handleSystemWideReconnection(){if(this.systemEventDetector){this.debug("System-wide reconnection already in progress, skipping");return}this.debug("Initiating system-wide reconnection with reset backoff"),this.systemEventDetector=setTimeout(()=>{this.systemEventDetector=void 0},1e4);for(const t of this.relays.values())t.connectivity&&(t.connectivity.resetReconnectionState(),t.status!==5&&t.status!==4&&t.connect().catch(r=>{this.debug(`Failed to reconnect relay ${t.url} after system event: ${r}`)}));this.disconnectionTimes.clear()}handleFlapping(t){this.debug(`Relay ${t.url} is flapping`);let r=this.backoffTimes.get(t.url)||5e3;r=r*2,this.backoffTimes.set(t.url,r),this.debug(`Backoff time for ${t.url} is ${r}ms`),setTimeout(()=>{this.debug(`Attempting to reconnect to ${t.url}`),this.emit("relay:connecting",t),t.connect(),this.checkOnFlappingRelays()},r),t.disconnect(),this.emit("flapping",t)}size(){return this.relays.size}stats(){const t={total:0,connected:0,disconnected:0,connecting:0};for(const r of this.relays.values())t.total++,r.status===5?t.connected++:r.status===1?t.disconnected++:r.status===4&&t.connecting++;return t}connectedRelays(){return Array.from(this.relays.values()).filter(t=>t.status>=5)}permanentAndConnectedRelays(){return Array.from(this.relays.values()).filter(t=>t.status>=5&&!this.temporaryRelayTimers.has(t.url))}urls(){return Array.from(this.relays.keys())}},NDKDVMJobFeedback$1=class Sn extends NDKEvent$1{static kind=7e3;static kinds=[7e3];constructor(t,r){super(t,r),this.kind??=7e3}static async from(t){const r=new Sn(t.ndk,t.rawEvent());return r.encrypted&&await r.dvmDecrypt(),r}get status(){return this.tagValue("status")}set status(t){this.removeTag("status"),t!==void 0&&this.tags.push(["status",t])}get encrypted(){return!!this.getMatchingTags("encrypted")[0]}async dvmDecrypt(){await this.decrypt();const t=JSON.parse(this.content);this.tags.push(...t)}},NDKCashuMintList$1=class Tn extends NDKEvent$1{static kind=10019;static kinds=[10019];_p2pk;constructor(t,r){super(t,r),this.kind??=10019}static from(t){return new Tn(t.ndk,t)}set relays(t){this.tags=this.tags.filter(r=>r[0]!=="relay");for(const r of t)this.tags.push(["relay",r])}get relays(){const t=[];for(const r of this.tags)r[0]==="relay"&&t.push(r[1]);return t}set mints(t){this.tags=this.tags.filter(r=>r[0]!=="mint");for(const r of t)this.tags.push(["mint",r])}get mints(){const t=[];for(const r of this.tags)r[0]==="mint"&&t.push(r[1]);return Array.from(new Set(t))}get p2pk(){return this._p2pk?this._p2pk:(this._p2pk=this.tagValue("pubkey")??this.pubkey,this._p2pk)}set p2pk(t){this._p2pk=t,this.removeTag("pubkey"),t&&this.tags.push(["pubkey",t])}get relaySet(){return NDKRelaySet$1.fromRelayUrls(this.relays,this.ndk)}},NDKArticle$1=class An extends NDKEvent$1{static kind=30023;static kinds=[30023];constructor(t,r){super(t,r),this.kind??=30023}static from(t){return new An(t.ndk,t)}get title(){return this.tagValue("title")}set title(t){this.removeTag("title"),t&&this.tags.push(["title",t])}get image(){return this.tagValue("image")}set image(t){this.removeTag("image"),t&&this.tags.push(["image",t])}get summary(){return this.tagValue("summary")}set summary(t){this.removeTag("summary"),t&&this.tags.push(["summary",t])}get published_at(){const t=this.tagValue("published_at");if(t){let r=Number.parseInt(t);return r>1e12&&(r=Math.floor(r/1e3)),r}}set published_at(t){this.removeTag("published_at"),t!==void 0&&this.tags.push(["published_at",t.toString()])}async generateTags(){return super.generateTags(),this.published_at||(this.published_at=this.created_at),super.generateTags()}get url(){return this.tagValue("url")}set url(t){t?this.tags.push(["url",t]):this.removeTag("url")}},NDKBlossomList$1=class xn extends NDKEvent$1{static kind=10063;static kinds=[10063];constructor(t,r){super(t,r),this.kind??=10063}static from(t){return new xn(t.ndk,t.rawEvent())}get servers(){return this.tags.filter(t=>t[0]==="server").map(t=>t[1])}set servers(t){this.tags=this.tags.filter(r=>r[0]!=="server");for(const r of t)this.tags.push(["server",r])}get default(){const t=this.servers;return t.length>0?t[0]:void 0}set default(t){if(!t)return;const s=this.servers.filter(o=>o!==t);this.servers=[t,...s]}addServer(t){if(!t)return;const r=this.servers;r.includes(t)||(this.servers=[...r,t])}removeServer(t){if(!t)return;const r=this.servers;this.servers=r.filter(s=>s!==t)}},NDKFedimintMint$1=class Rn extends NDKEvent$1{static kind=38173;static kinds=[38173];constructor(t,r){super(t,r),this.kind??=38173}static async from(t){return new Rn(t.ndk,t)}get identifier(){return this.tagValue("d")}set identifier(t){this.removeTag("d"),t&&this.tags.push(["d",t])}get inviteCodes(){return this.getMatchingTags("u").map(t=>t[1])}set inviteCodes(t){this.removeTag("u");for(const r of t)this.tags.push(["u",r])}get modules(){return this.getMatchingTags("modules").map(t=>t[1])}set modules(t){this.removeTag("modules");for(const r of t)this.tags.push(["modules",r])}get network(){return this.tagValue("n")}set network(t){this.removeTag("n"),t&&this.tags.push(["n",t])}get metadata(){if(this.content)try{return JSON.parse(this.content)}catch{return}}set metadata(t){t?this.content=JSON.stringify(t):this.content=""}},NDKCashuMintAnnouncement$1=class Nn extends NDKEvent$1{static kind=38172;static kinds=[38172];constructor(t,r){super(t,r),this.kind??=38172}static async from(t){return new Nn(t.ndk,t)}get identifier(){return this.tagValue("d")}set identifier(t){this.removeTag("d"),t&&this.tags.push(["d",t])}get url(){return this.tagValue("u")}set url(t){this.removeTag("u"),t&&this.tags.push(["u",t])}get nuts(){return this.getMatchingTags("nuts").map(t=>t[1])}set nuts(t){this.removeTag("nuts");for(const r of t)this.tags.push(["nuts",r])}get network(){return this.tagValue("n")}set network(t){this.removeTag("n"),t&&this.tags.push(["n",t])}get metadata(){if(this.content)try{return JSON.parse(this.content)}catch{return}}set metadata(t){t?this.content=JSON.stringify(t):this.content=""}},NDKMintRecommendation$1=class Cn extends NDKEvent$1{static kind=38e3;static kinds=[38e3];constructor(t,r){super(t,r),this.kind??=38e3}static async from(t){return new Cn(t.ndk,t)}get recommendedKind(){const t=this.tagValue("k");return t?Number(t):void 0}set recommendedKind(t){this.removeTag("k"),t&&this.tags.push(["k",t.toString()])}get identifier(){return this.tagValue("d")}set identifier(t){this.removeTag("d"),t&&this.tags.push(["d",t])}get urls(){return this.getMatchingTags("u").map(t=>t[1])}set urls(t){this.removeTag("u");for(const r of t)this.tags.push(["u",r])}get mintEventPointers(){return this.getMatchingTags("a").map(t=>({kind:Number(t[1].split(":")[0]),identifier:t[1].split(":")[2],relay:t[2]}))}addMintEventPointer(t,r,s,o){const a=["a",`${t}:${r}:${s}`];o&&a.push(o),this.tags.push(a)}get review(){return this.content}set review(t){this.content=t}},NDKClassified$1=class In extends NDKEvent$1{static kind=30402;static kinds=[30402];constructor(t,r){super(t,r),this.kind??=30402}static from(t){return new In(t.ndk,t)}get title(){return this.tagValue("title")}set title(t){this.removeTag("title"),t&&this.tags.push(["title",t])}get summary(){return this.tagValue("summary")}set summary(t){this.removeTag("summary"),t&&this.tags.push(["summary",t])}get published_at(){const t=this.tagValue("published_at");if(t)return Number.parseInt(t)}set published_at(t){this.removeTag("published_at"),t!==void 0&&this.tags.push(["published_at",t.toString()])}get location(){return this.tagValue("location")}set location(t){this.removeTag("location"),t&&this.tags.push(["location",t])}get price(){const t=this.tags.find(r=>r[0]==="price");if(t)return{amount:Number.parseFloat(t[1]),currency:t[2],frequency:t[3]}}set price(t){if(typeof t=="string"&&(t={amount:Number.parseFloat(t)}),t?.amount){const r=["price",t.amount.toString()];t.currency&&r.push(t.currency),t.frequency&&r.push(t.frequency),this.tags.push(r)}else this.removeTag("price")}async generateTags(){return super.generateTags(),this.published_at||(this.published_at=this.created_at),super.generateTags()}},NDKDraft$1=class Pn extends NDKEvent$1{_event;static kind=31234;static kinds=[31234,1234];counterparty;constructor(t,r){super(t,r),this.kind??=31234}static from(t){return new Pn(t.ndk,t)}set identifier(t){this.removeTag("d"),this.tags.push(["d",t])}get identifier(){return this.dTag}set event(t){t instanceof NDKEvent$1?this._event=t:this._event=new NDKEvent$1(void 0,t),this.prepareEvent()}set checkpoint(t){t?(this.tags.push(t.tagReference()),this.kind=1234):(this.removeTag("a"),this.kind=31234)}get isCheckpoint(){return this.kind===1234}get isProposal(){const t=this.tagValue("p");return!!t&&t!==this.pubkey}async getEvent(t){if(this._event)return this._event;if(t??=this.ndk?.signer,!t)throw new Error("No signer available");if(this.content&&this.content.length>0)try{const r=t.pubkey,o=[this.tagValue("p"),this.pubkey].filter(Boolean).find(f=>f!==r);let a;a=new NDKUser$1({pubkey:o??r}),await this.decrypt(a,t);const c=JSON.parse(this.content);return this._event=await wrapEvent3(new NDKEvent$1(this.ndk,c)),this._event}catch(r){console.error(r);return}else return null}prepareEvent(){if(!this._event)throw new Error("No event has been provided");this.removeTag("k"),this._event.kind&&this.tags.push(["k",this._event.kind.toString()]),this.content=JSON.stringify(this._event.rawEvent())}async save({signer:t,publish:r,relaySet:s}){if(t??=this.ndk?.signer,!t)throw new Error("No signer available");const o=this.counterparty||await t.user();if(await this.encrypt(o,t),this.counterparty){const a=this.counterparty.pubkey;this.removeTag("p"),this.tags.push(["p",a])}if(r!==!1)return this.publishReplaceable(s)}};function mapImetaTag$1(n){const t={};if(n.length===2){const s=n[1].split(" ");for(let o=0;o<s.length;o+=2){const a=s[o],c=s[o+1];a==="fallback"?(t.fallback||(t.fallback=[]),t.fallback.push(c)):t[a]=c}return t}const r=n.slice(1);for(const s of r){const o=s.split(" "),a=o[0],c=o.slice(1).join(" ");a==="fallback"?(t.fallback||(t.fallback=[]),t.fallback.push(c)):t[a]=c}return t}function imetaTagToTag$1(n){const t=["imeta"];for(const[r,s]of Object.entries(n))if(Array.isArray(s))for(const o of s)t.push(`${r} ${o}`);else s&&t.push(`${r} ${s}`);return t}var NDKFollowPack$1=class Bn extends NDKEvent$1{static kind=39089;static kinds=[39089,39092];constructor(t,r){super(t,r),this.kind??=39089}static from(t){return new Bn(t.ndk,t)}get title(){return this.tagValue("title")}set title(t){this.removeTag("title"),t&&this.tags.push(["title",t])}get image(){const t=this.tags.find(r=>r[0]==="imeta");if(t){const r=mapImetaTag$1(t);if(r.url)return r.url}return this.tagValue("image")}set image(t){this.tags=this.tags.filter(r=>r[0]!=="imeta"&&r[0]!=="image"),typeof t=="string"?t!==void 0&&this.tags.push(["image",t]):t&&typeof t=="object"&&(this.tags.push(imetaTagToTag$1(t)),t.url&&this.tags.push(["image",t.url]))}get pubkeys(){return Array.from(new Set(this.tags.filter(t=>t[0]==="p"&&t[1]&&isValidPubkey$1(t[1])).map(t=>t[1])))}set pubkeys(t){this.tags=this.tags.filter(r=>r[0]!=="p");for(const r of t)this.tags.push(["p",r])}get description(){return this.tagValue("description")}set description(t){this.removeTag("description"),t&&this.tags.push(["description",t])}},NDKHighlight$1=class Mn extends NDKEvent$1{_article;static kind=9802;static kinds=[9802];constructor(t,r){super(t,r),this.kind??=9802}static from(t){return new Mn(t.ndk,t)}get url(){return this.tagValue("r")}set context(t){t===void 0?this.tags=this.tags.filter(([r,s])=>r!=="context"):(this.tags=this.tags.filter(([r,s])=>r!=="context"),this.tags.push(["context",t]))}get context(){return this.tags.find(([t,r])=>t==="context")?.[1]??void 0}get article(){return this._article}set article(t){this._article=t,typeof t=="string"?this.tags.push(["r",t]):this.tag(t)}getArticleTag(){return this.getMatchingTags("a")[0]||this.getMatchingTags("e")[0]||this.getMatchingTags("r")[0]}async getArticle(){if(this._article!==void 0)return this._article;let t;const r=this.getArticleTag();if(r){switch(r[0]){case"a":{const[s,o,a]=r[1].split(":");t=nip19_exports$2.naddrEncode({kind:Number.parseInt(s),pubkey:o,identifier:a});break}case"e":t=nip19_exports$2.noteEncode(r[1]);break;case"r":this._article=r[1];break}if(t){let s=await this.ndk?.fetchEvent(t);s&&(s.kind===30023&&(s=NDKArticle$1.from(s)),this._article=s)}return this._article}}},NDKImage$1=class Dn extends NDKEvent$1{static kind=20;static kinds=[20];_imetas;constructor(t,r){super(t,r),this.kind??=20}static from(t){return new Dn(t.ndk,t.rawEvent())}get isValid(){return this.imetas.length>0}get imetas(){return this._imetas?this._imetas:(this._imetas=this.tags.filter(t=>t[0]==="imeta").map(mapImetaTag$1).filter(t=>!!t.url),this._imetas)}set imetas(t){this._imetas=t,this.tags=this.tags.filter(r=>r[0]!=="imeta"),this.tags.push(...t.map(imetaTagToTag$1))}},NDKList$1=class Un extends NDKEvent$1{_encryptedTags;static kind=30001;static kinds=[30001,10004,10050,10030,10015,10001,10002,10007,10006,10003,10012];encryptedTagsLength;constructor(t,r){super(t,r),this.kind??=30001}static from(t){return new Un(t.ndk,t)}get title(){const t=this.tagValue("title")||this.tagValue("name");return t||(this.kind===3?"Contacts":this.kind===1e4?"Mute":this.kind===10001?"Pinned Notes":this.kind===10002?"Relay Metadata":this.kind===10003?"Bookmarks":this.kind===10004?"Communities":this.kind===10005?"Public Chats":this.kind===10006?"Blocked Relays":this.kind===10007?"Search Relays":this.kind===10050?"Direct Message Receive Relays":this.kind===10012?"Relay Feeds":this.kind===10015?"Interests":this.kind===10030?"Emojis":this.tagValue("d"))}set title(t){this.removeTag(["title","name"]),t&&this.tags.push(["title",t])}get name(){return this.title}set name(t){this.title=t}get description(){return this.tagValue("description")}set description(t){this.removeTag("description"),t&&this.tags.push(["description",t])}get image(){return this.tagValue("image")}set image(t){this.removeTag("image"),t&&this.tags.push(["image",t])}isEncryptedTagsCacheValid(){return!!(this._encryptedTags&&this.encryptedTagsLength===this.content.length)}async encryptedTags(t=!0){if(t&&this.isEncryptedTagsCacheValid())return this._encryptedTags;if(!this.ndk)throw new Error("NDK instance not set");if(!this.ndk.signer)throw new Error("NDK signer not set");const r=await this.ndk.signer.user();try{if(this.content.length>0)try{const s=await this.ndk.signer.decrypt(r,this.content),o=JSON.parse(s);return o?.[0]?(this.encryptedTagsLength=this.content.length,this._encryptedTags=o):(this.encryptedTagsLength=this.content.length,this._encryptedTags=[])}catch{}}catch{}return[]}validateTag(t){return!0}getItems(t){return this.tags.filter(r=>r[0]===t)}get items(){return this.tags.filter(t=>!["d","L","l","title","name","description","published_at","summary","image","thumb","alt","expiration","subject","client"].includes(t[0]))}async addItem(t,r=void 0,s=!1,o="bottom"){if(!this.ndk)throw new Error("NDK instance not set");if(!this.ndk.signer)throw new Error("NDK signer not set");let a;if(t instanceof NDKEvent$1)a=[t.tagReference(r)];else if(t instanceof NDKUser$1)a=t.referenceTags();else if(t instanceof NDKRelay$1)a=t.referenceTags();else if(Array.isArray(t))a=[t];else throw new Error("Invalid object type");if(r&&a[0].push(r),s){const c=await this.ndk.signer.user(),f=await this.encryptedTags();o==="top"?f.unshift(...a):f.push(...a),this._encryptedTags=f,this.encryptedTagsLength=this.content.length,this.content=JSON.stringify(f),await this.encrypt(c)}else o==="top"?this.tags.unshift(...a):this.tags.push(...a);this.created_at=Math.floor(Date.now()/1e3),this.emit("change")}async removeItemByValue(t,r=!0){if(!this.ndk)throw new Error("NDK instance not set");if(!this.ndk.signer)throw new Error("NDK signer not set");const s=this.tags.findIndex(f=>f[1]===t);s>=0&&this.tags.splice(s,1);const o=await this.ndk.signer.user(),a=await this.encryptedTags(),c=a.findIndex(f=>f[1]===t);if(c>=0&&(a.splice(c,1),this._encryptedTags=a,this.encryptedTagsLength=this.content.length,this.content=JSON.stringify(a),await this.encrypt(o)),r)return this.publishReplaceable();this.created_at=Math.floor(Date.now()/1e3),this.emit("change")}async removeItem(t,r){if(!this.ndk)throw new Error("NDK instance not set");if(!this.ndk.signer)throw new Error("NDK signer not set");if(r){const s=await this.ndk.signer.user(),o=await this.encryptedTags();o.splice(t,1),this._encryptedTags=o,this.encryptedTagsLength=this.content.length,this.content=JSON.stringify(o),await this.encrypt(s)}else this.tags.splice(t,1);return this.created_at=Math.floor(Date.now()/1e3),this.emit("change"),this}has(t){return this.items.some(r=>r[1]===t)}filterForItems(){const t=new Set,r=new Map,s=[];for(const o of this.items)if(o[0]==="e"&&o[1])t.add(o[1]);else if(o[0]==="a"&&o[1]){const[a,c,f]=o[1].split(":");if(!a||!c)continue;const g=`${a}:${c}`,m=r.get(g)||[];m.push(f||""),r.set(g,m)}if(t.size>0&&s.push({ids:Array.from(t)}),r.size>0)for(const[o,a]of r.entries()){const[c,f]=o.split(":");s.push({kinds:[Number.parseInt(c)],authors:[f],"#d":a})}return s}},NDKAppHandlerEvent$1=class Ln extends NDKEvent$1{profile;static kind=31990;static kinds=[31990];constructor(t,r){super(t,r),this.kind??=31990}static from(t){const r=new Ln(t.ndk,t.rawEvent());return r.isValid?r:null}get isValid(){const t=new Map,r=o=>[o[0],o[2]].join(":").toLowerCase(),s=["web","android","ios"];for(const o of this.tags)if(s.includes(o[0])){const a=r(o);if(t.has(a)&&t.get(a)!==o[1].toLowerCase())return!1;t.set(a,o[1].toLowerCase())}return!0}async fetchProfile(){if(this.profile===void 0&&this.content.length>0)try{const t=JSON.parse(this.content);if(t?.name)return t;this.profile=null}catch{this.profile=null}return new Promise((t,r)=>{const s=this.author;s.fetchProfile().then(()=>{t(s.profile)}).catch(r)})}},SEVERITY_MAP$1={NO_PROOFS:"ERROR",INVALID_PROOF_COUNT:"ERROR",MULTIPLE_RECIPIENTS:"ERROR",NO_RECIPIENT:"ERROR",MULTIPLE_MINTS:"ERROR",NO_MINT:"ERROR",MULTIPLE_EVENT_TAGS:"ERROR",MALFORMED_PROOF_SECRET:"ERROR",MISSING_EVENT_TAG_IN_PROOF:"WARNING",MISMATCHED_EVENT_TAG_IN_PROOF:"WARNING",MISSING_SENDER_TAG_IN_PROOF:"WARNING",MISMATCHED_SENDER_TAG_IN_PROOF:"WARNING",NO_EVENT_TAG_IN_EVENT:"WARNING"},ERROR_MESSAGES$1={NO_PROOFS:"Nutzap must contain at least one proof",INVALID_PROOF_COUNT:"Invalid proof count",MULTIPLE_RECIPIENTS:"Nutzap must have exactly one recipient (p tag)",NO_RECIPIENT:"Nutzap must have a recipient (p tag)",MULTIPLE_MINTS:"Nutzap must specify exactly one mint (u tag)",NO_MINT:"Nutzap must specify a mint (u tag)",MULTIPLE_EVENT_TAGS:"Nutzap must have at most one event tag (e tag)",MALFORMED_PROOF_SECRET:"Proof secret is malformed and cannot be parsed",MISSING_EVENT_TAG_IN_PROOF:"Proof secret missing 'e' tag for replay protection",MISMATCHED_EVENT_TAG_IN_PROOF:"Proof secret 'e' tag does not match event being zapped",MISSING_SENDER_TAG_IN_PROOF:"Proof secret missing 'P' tag for sender verification",MISMATCHED_SENDER_TAG_IN_PROOF:"Proof secret 'P' tag does not match sender pubkey",NO_EVENT_TAG_IN_EVENT:"Nutzap event missing 'e' tag (recommended for replay protection)"};function createValidationIssue$1(n,t){return{code:n,severity:SEVERITY_MAP$1[n],message:ERROR_MESSAGES$1[n],proofIndex:t}}var NDKNutzap$1=class wn extends NDKEvent$1{debug;_proofs=[];static kind=9321;static kinds=[wn.kind];constructor(t,r){super(t,r),this.kind??=9321,this.debug=t?.debug.extend("nutzap")??import_debug4.default("ndk:nutzap"),this.alt||(this.alt="This is a nutzap");try{const s=this.getMatchingTags("proof");s.length?this._proofs=s.map(o=>JSON.parse(o[1])):this._proofs=JSON.parse(this.content)}catch{return}}static from(t){const r=new wn(t.ndk,t);if(!(!r._proofs||!r._proofs.length))return r}set comment(t){this.content=t??""}get comment(){const t=this.tagValue("comment");return t||this.content}set proofs(t){this._proofs=t,this.tags=this.tags.filter(r=>r[0]!=="proof");for(const r of t)this.tags.push(["proof",JSON.stringify(r)])}get proofs(){return this._proofs}get rawP2pk(){const t=this.proofs[0];try{const r=JSON.parse(t.secret);let s;if(typeof r=="string"?(s=JSON.parse(r),this.debug("stringified payload",t.secret)):typeof r=="object"&&(s=r),Array.isArray(s)&&s[0]==="P2PK"&&s.length>1&&typeof s[1]=="object"&&s[1]!==null||typeof s=="object"&&s!==null&&typeof s[1]?.data=="string")return s[1].data}catch(r){this.debug("error parsing p2pk pubkey",r,this.proofs[0])}}get p2pk(){const t=this.rawP2pk;if(t)return t.startsWith("02")?t.slice(2):t}get mint(){return this.tagValue("u")}set mint(t){this.replaceTag(["u",t])}get unit(){let t=this.tagValue("unit")??"sat";return t?.startsWith("msat")&&(t="sat"),t}set unit(t){if(this.removeTag("unit"),t?.startsWith("msat"))throw new Error("msat is not allowed, use sat denomination instead");t&&this.tag(["unit",t])}get amount(){return this.proofs.reduce((r,s)=>r+s.amount,0)}sender=this.author;set target(t){this.tags=this.tags.filter(r=>r[0]!=="p"),t instanceof NDKEvent$1&&this.tags.push(t.tagReference())}set recipientPubkey(t){this.removeTag("p"),this.tag(["p",t])}get recipientPubkey(){return this.tagValue("p")}get recipient(){const t=this.recipientPubkey;return this.ndk?this.ndk.getUser({pubkey:t}):new NDKUser$1({pubkey:t})}async toNostrEvent(){this.unit==="msat"&&(this.unit="sat"),this.removeTag("amount"),this.tags.push(["amount",this.amount.toString()]);const t=await super.toNostrEvent();return t.content=this.comment,t}get isValid(){return this.validateNIP61().valid}validateNIP61(){const t=[];let r=0,s=0,o=0;for(const g of this.tags)g[0]==="e"&&r++,g[0]==="p"&&s++,g[0]==="u"&&o++;this.proofs.length===0&&t.push(createValidationIssue$1("NO_PROOFS")),s===0?t.push(createValidationIssue$1("NO_RECIPIENT")):s>1&&t.push(createValidationIssue$1("MULTIPLE_RECIPIENTS")),o===0?t.push(createValidationIssue$1("NO_MINT")):o>1&&t.push(createValidationIssue$1("MULTIPLE_MINTS")),r>1&&t.push(createValidationIssue$1("MULTIPLE_EVENT_TAGS"));const a=this.tagValue("e"),c=this.pubkey;for(let g=0;g<this.proofs.length;g++){const m=this.proofs[g];try{const b=JSON.parse(m.secret),k=typeof b=="string"?JSON.parse(b):b;if(Array.isArray(k)&&k[0]==="P2PK"&&k[1]){const _=k[1].tags;if(a)if(!_)t.push(createValidationIssue$1("MISSING_EVENT_TAG_IN_PROOF",g));else{const A=_.find(B=>B[0]==="e");A?A[1]!==a&&t.push(createValidationIssue$1("MISMATCHED_EVENT_TAG_IN_PROOF",g)):t.push(createValidationIssue$1("MISSING_EVENT_TAG_IN_PROOF",g))}if(!_)t.push(createValidationIssue$1("MISSING_SENDER_TAG_IN_PROOF",g));else{const A=_.find(B=>B[0]==="P");A?A[1]!==c&&t.push(createValidationIssue$1("MISMATCHED_SENDER_TAG_IN_PROOF",g)):t.push(createValidationIssue$1("MISSING_SENDER_TAG_IN_PROOF",g))}}}catch{t.push(createValidationIssue$1("MALFORMED_PROOF_SECRET",g))}}return!a&&this.proofs.length>0&&t.push(createValidationIssue$1("NO_EVENT_TAG_IN_EVENT")),{valid:!t.some(g=>g.severity==="ERROR"),issues:t}}},NDKProject$1=class Fn extends NDKEvent$1{static kind=31933;static kinds=[31933];_signer;constructor(t,r){super(t,r),this.kind=31933}static from(t){return new Fn(t.ndk,t.rawEvent())}set repo(t){this.removeTag("repo"),t&&this.tags.push(["repo",t])}set hashtags(t){this.removeTag("hashtags"),t.filter(r=>r.length>0).length&&this.tags.push(["hashtags",...t])}get hashtags(){const t=this.tags.find(r=>r[0]==="hashtags");return t?t.slice(1):[]}get repo(){return this.tagValue("repo")}get title(){return this.tagValue("title")}set title(t){this.removeTag("title"),t&&this.tags.push(["title",t])}get picture(){return this.tagValue("picture")}set picture(t){this.removeTag("picture"),t&&this.tags.push(["picture",t])}set description(t){this.content=t}get description(){return this.content}get slug(){return this.dTag??"empty-dtag"}async getSigner(){if(this._signer)return this._signer;const t=this.tagValue("key");if(!t)this._signer=NDKPrivateKeySigner$1.generate(),await this.encryptAndSaveNsec();else{const r=await this.ndk?.signer?.decrypt(this.ndk.activeUser,t);if(!r)throw new Error("Failed to decrypt project key or missing signer context.");this._signer=new NDKPrivateKeySigner$1(r)}return this._signer}async getNsec(){return(await this.getSigner()).privateKey}async setNsec(t){this._signer=new NDKPrivateKeySigner$1(t),await this.encryptAndSaveNsec()}async encryptAndSaveNsec(){if(!this._signer)throw new Error("Signer is not set.");const t=this._signer.privateKey,r=await this.ndk?.signer?.encrypt(this.ndk.activeUser,t);r&&(this.removeTag("key"),this.tags.push(["key",r]))}},NDKProjectTemplate$1=class On extends NDKEvent$1{static kind=30717;static kinds=[30717];constructor(t,r){super(t,r),this.kind=30717}static from(t){return new On(t.ndk,t.rawEvent())}get templateId(){return this.dTag??""}set templateId(t){this.dTag=t}get name(){return this.tagValue("title")??""}set name(t){this.removeTag("title"),t&&this.tags.push(["title",t])}get description(){return this.tagValue("description")??""}set description(t){this.removeTag("description"),t&&this.tags.push(["description",t])}get repoUrl(){return this.tagValue("uri")??""}set repoUrl(t){this.removeTag("uri"),t&&this.tags.push(["uri",t])}get image(){return this.tagValue("image")}set image(t){this.removeTag("image"),t&&this.tags.push(["image",t])}get command(){return this.tagValue("command")}set command(t){this.removeTag("command"),t&&this.tags.push(["command",t])}get agentConfig(){const t=this.tagValue("agent");if(t)try{return JSON.parse(t)}catch{return}}set agentConfig(t){this.removeTag("agent"),t&&this.tags.push(["agent",JSON.stringify(t)])}get templateTags(){return this.getMatchingTags("t").map(t=>t[1]).filter(Boolean)}set templateTags(t){this.tags=this.tags.filter(r=>r[0]!=="t"),t.forEach(r=>{r&&this.tags.push(["t",r])})}},READ_MARKER$1="read",WRITE_MARKER$1="write",NDKRelayList$1=class Kn extends NDKEvent$1{static kind=10002;static kinds=[10002];constructor(t,r){super(t,r),this.kind??=10002}static from(t){return new Kn(t.ndk,t.rawEvent())}get readRelayUrls(){return this.tags.filter(t=>t[0]==="r"||t[0]==="relay").filter(t=>!t[2]||t[2]&&t[2]===READ_MARKER$1).map(t=>tryNormalizeRelayUrl$1(t[1])).filter(t=>!!t)}set readRelayUrls(t){for(const r of t)this.tags.push(["r",r,READ_MARKER$1])}get writeRelayUrls(){return this.tags.filter(t=>t[0]==="r"||t[0]==="relay").filter(t=>!t[2]||t[2]&&t[2]===WRITE_MARKER$1).map(t=>tryNormalizeRelayUrl$1(t[1])).filter(t=>!!t)}set writeRelayUrls(t){for(const r of t)this.tags.push(["r",r,WRITE_MARKER$1])}get bothRelayUrls(){return this.tags.filter(t=>t[0]==="r"||t[0]==="relay").filter(t=>!t[2]).map(t=>t[1])}set bothRelayUrls(t){for(const r of t)this.tags.push(["r",r])}get relays(){return this.tags.filter(t=>t[0]==="r"||t[0]==="relay").map(t=>t[1])}get relaySet(){if(!this.ndk)throw new Error("NDKRelayList has no NDK instance");return new NDKRelaySet$1(new Set(this.relays.map(t=>this.ndk?.pool.getRelay(t)).filter(t=>!!t)),this.ndk)}};function relayListFromKind3$1(n,t){try{const r=JSON.parse(t.content),s=new NDKRelayList$1(n),o=new Set,a=new Set;for(let[c,f]of Object.entries(r)){try{c=normalizeRelayUrl$1(c)}catch{continue}if(!f)o.add(c),a.add(c);else{const g=f;g.write&&a.add(c),g.read&&o.add(c)}}return s.readRelayUrls=Array.from(o),s.writeRelayUrls=Array.from(a),s}catch{}}var NDKRelayFeedList$1=class Hn extends NDKList$1{static kind=10012;static kinds=[10012];constructor(t,r){super(t,r),r?.kind||(this.kind=10012)}static from(t){return new Hn(t.ndk,t)}get relayUrls(){return this.getMatchingTags("relay").map(t=>t[1])}get relaySets(){return this.getMatchingTags("a").map(t=>t[1])}async addRelay(t,r,s=!1,o="bottom"){const a=["relay",t];r&&a.push(r),await this.addItem(a,void 0,s,o)}async addRelaySet(t,r,s=!1,o="bottom"){const a=["a",t];r&&a.push(r),await this.addItem(a,void 0,s,o)}async removeRelay(t,r=!0){await this.removeItemByValue(t,r)}async removeRelaySet(t,r=!0){await this.removeItemByValue(t,r)}},NDKRepost$1=class Vn extends NDKEvent$1{_repostedEvents;static kind=6;static kinds=[6,16];static from(t){return new Vn(t.ndk,t.rawEvent())}async repostedEvents(t,r){const s=[];if(!this.ndk)throw new Error("NDK instance not set");if(this._repostedEvents!==void 0)return this._repostedEvents;for(const o of this.repostedEventIds()){const a=filterForId$1(o),c=await this.ndk.fetchEvent(a,r);c&&s.push(t?t.from(c):c)}return s}repostedEventIds(){return this.tags.filter(t=>t[0]==="e"||t[0]==="a").map(t=>t[1])}};function filterForId$1(n){if(n.match(/:/)){const[t,r,s]=n.split(":");return{kinds:[Number.parseInt(t)],authors:[r],"#d":[s]}}return{ids:[n]}}var NDKSimpleGroupMemberList$1=class zn extends NDKEvent$1{relaySet;memberSet=new Set;static kind=39002;static kinds=[39002];constructor(t,r){super(t,r),this.kind??=39002,this.memberSet=new Set(this.members)}static from(t){return new zn(t.ndk,t)}get members(){return this.getMatchingTags("p").map(t=>t[1])}hasMember(t){return this.memberSet.has(t)}async publish(t,r,s){return t??=this.relaySet,super.publishReplaceable(t,r,s)}},NDKSimpleGroupMetadata$1=class qn extends NDKEvent$1{static kind=39e3;static kinds=[39e3];constructor(t,r){super(t,r),this.kind??=39e3}static from(t){return new qn(t.ndk,t)}get name(){return this.tagValue("name")}get picture(){return this.tagValue("picture")}get about(){return this.tagValue("about")}get scope(){if(this.getMatchingTags("public").length>0)return"public";if(this.getMatchingTags("public").length>0)return"private"}set scope(t){this.removeTag("public"),this.removeTag("private"),t==="public"?this.tags.push(["public",""]):t==="private"&&this.tags.push(["private",""])}get access(){if(this.getMatchingTags("open").length>0)return"open";if(this.getMatchingTags("closed").length>0)return"closed"}set access(t){this.removeTag("open"),this.removeTag("closed"),t==="open"?this.tags.push(["open",""]):t==="closed"&&this.tags.push(["closed",""])}};function strToPosition$1(n){const[t,r]=n.split(",").map(Number);return{x:t,y:r}}function strToDimension$1(n){const[t,r]=n.split("x").map(Number);return{width:t,height:r}}var NDKStorySticker$1=class Wn{static Text="text";static Pubkey="pubkey";static Event="event";static Prompt="prompt";static Countdown="countdown";type;value;position;dimension;properties;constructor(t){if(Array.isArray(t)){const r=t;if(r[0]!=="sticker"||r.length<5)throw new Error("Invalid sticker tag");this.type=r[1],this.value=r[2],this.position=strToPosition$1(r[3]),this.dimension=strToDimension$1(r[4]);const s={};for(let o=5;o<r.length;o++){const[a,...c]=r[o].split(" ");s[a]=c.join(" ")}Object.keys(s).length>0&&(this.properties=s)}else this.type=t,this.value=void 0,this.position={x:0,y:0},this.dimension={width:0,height:0}}static fromTag(t){try{return new Wn(t)}catch{return null}}get style(){return this.properties?.style}set style(t){t?this.properties={...this.properties,style:t}:delete this.properties?.style}get rotation(){return this.properties?.rot?Number.parseFloat(this.properties.rot):void 0}set rotation(t){t!==void 0?this.properties={...this.properties,rot:t.toString()}:delete this.properties?.rot}get isValid(){return this.hasValidDimensions()&&this.hasValidPosition()}hasValidDimensions=()=>typeof this.dimension.width=="number"&&typeof this.dimension.height=="number"&&!Number.isNaN(this.dimension.width)&&!Number.isNaN(this.dimension.height);hasValidPosition=()=>typeof this.position.x=="number"&&typeof this.position.y=="number"&&!Number.isNaN(this.position.x)&&!Number.isNaN(this.position.y);toTag(){if(!this.isValid){const s=[this.hasValidDimensions()?void 0:"dimensions is invalid",this.hasValidPosition()?void 0:"position is invalid"].filter(Boolean);throw new Error(`Invalid sticker: ${s.join(", ")}`)}let t;switch(this.type){case"event":t=this.value.tagId();break;case"pubkey":t=this.value.pubkey;break;default:t=this.value}const r=["sticker",this.type,t,coordinates$1(this.position),dimension$1(this.dimension)];if(this.properties)for(const[s,o]of Object.entries(this.properties))r.push(`${s} ${o}`);return r}},NDKStory$1=class jn extends NDKEvent$1{static kind=23;static kinds=[23];_imeta;_dimensions;constructor(t,r){if(super(t,r),this.kind??=23,r)for(const s of r.tags)switch(s[0]){case"imeta":this._imeta=mapImetaTag$1(s);break;case"dim":this.dimensions=strToDimension$1(s[1]);break}}static from(t){return new jn(t.ndk,t)}get isValid(){return!!this.imeta}get imeta(){return this._imeta}set imeta(t){this._imeta=t,this.tags=this.tags.filter(r=>r[0]!=="imeta"),t&&this.tags.push(imetaTagToTag$1(t))}get dimensions(){const t=this.tagValue("dim");if(t)return strToDimension$1(t)}set dimensions(t){this.removeTag("dim"),t&&this.tags.push(["dim",`${t.width}x${t.height}`])}get duration(){const t=this.tagValue("dur");if(t)return Number.parseInt(t)}set duration(t){this.removeTag("dur"),t!==void 0&&this.tags.push(["dur",t.toString()])}get stickers(){const t=[];for(const r of this.tags){if(r[0]!=="sticker"||r.length<5)continue;const s=NDKStorySticker$1.fromTag(r);s&&t.push(s)}return t}addSticker(t){let r;if(t instanceof NDKStorySticker$1)r=t;else{const s=["sticker",t.type,typeof t.value=="string"?t.value:"",coordinates$1(t.position),dimension$1(t.dimension)];if(t.properties)for(const[o,a]of Object.entries(t.properties))s.push(`${o} ${a}`);r=new NDKStorySticker$1(s),r.value=t.value}r.type==="pubkey"?this.tag(r.value):r.type==="event"&&this.tag(r.value),this.tags.push(r.toTag())}removeSticker(t){const r=this.stickers;if(t<0||t>=r.length)return;let s=0;for(let o=0;o<this.tags.length;o++)if(this.tags[o][0]==="sticker"){if(s===t){this.tags.splice(o,1);break}s++}}},coordinates$1=n=>`${n.x},${n.y}`,dimension$1=n=>`${n.width}x${n.height}`,NDKSubscriptionReceipt$1=class Gn extends NDKEvent$1{debug;static kind=7003;static kinds=[7003];constructor(t,r){super(t,r),this.kind??=7003,this.debug=t?.debug.extend("subscription-start")??import_debug5.default("ndk:subscription-start")}static from(t){return new Gn(t.ndk,t.rawEvent())}get recipient(){const t=this.getMatchingTags("p")?.[0];return t?new NDKUser$1({pubkey:t[1]}):void 0}set recipient(t){this.removeTag("p"),t&&this.tags.push(["p",t.pubkey])}get subscriber(){const t=this.getMatchingTags("P")?.[0];return t?new NDKUser$1({pubkey:t[1]}):void 0}set subscriber(t){this.removeTag("P"),t&&this.tags.push(["P",t.pubkey])}set subscriptionStart(t){this.debug(`before setting subscription start: ${this.rawEvent}`),this.removeTag("e"),this.tag(t,"subscription",!0),this.debug(`after setting subscription start: ${this.rawEvent}`)}get tierName(){return this.getMatchingTags("tier")?.[0]?.[1]}get isValid(){const t=this.validPeriod;if(!t||t.start>t.end)return!1;const r=this.getMatchingTags("p"),s=this.getMatchingTags("P");return!(r.length!==1||s.length!==1)}get validPeriod(){const t=this.getMatchingTags("valid")?.[0];if(t)try{return{start:new Date(Number.parseInt(t[1])*1e3),end:new Date(Number.parseInt(t[2])*1e3)}}catch{return}}set validPeriod(t){this.removeTag("valid"),t&&this.tags.push(["valid",Math.floor(t.start.getTime()/1e3).toString(),Math.floor(t.end.getTime()/1e3).toString()])}get startPeriod(){return this.validPeriod?.start}get endPeriod(){return this.validPeriod?.end}isActive(t){t??=new Date;const r=this.validPeriod;return!(!r||t<r.start||t>r.end)}},possibleIntervalFrequencies$1=["daily","weekly","monthly","quarterly","yearly"];function newAmount$1(n,t,r){return["amount",n.toString(),t,r]}function parseTagToSubscriptionAmount$1(n){const t=Number.parseInt(n[1]);if(Number.isNaN(t)||t===void 0||t===null||t<=0)return;const r=n[2];if(r===void 0||r==="")return;const s=n[3];if(s!==void 0&&possibleIntervalFrequencies$1.includes(s))return{amount:t,currency:r,term:s}}var NDKSubscriptionTier$1=class Zn extends NDKArticle$1{static kind=37001;static kinds=[37001];constructor(t,r){const s=r?.kind??37001;super(t,r),this.kind=s}static from(t){return new Zn(t.ndk,t)}get perks(){return this.getMatchingTags("perk").map(t=>t[1]).filter(t=>t!==void 0)}addPerk(t){this.tags.push(["perk",t])}get amounts(){return this.getMatchingTags("amount").map(t=>parseTagToSubscriptionAmount$1(t)).filter(t=>t!==void 0)}addAmount(t,r,s){this.tags.push(newAmount$1(t,r,s))}set relayUrl(t){this.tags.push(["r",t])}get relayUrls(){return this.getMatchingTags("r").map(t=>t[1]).filter(t=>t!==void 0)}get verifierPubkey(){return this.tagValue("p")}set verifierPubkey(t){this.removeTag("p"),t&&this.tags.push(["p",t])}get isValid(){return this.title!==void 0&&this.amounts.length>0}},NDKSubscriptionStart$1=class Yn extends NDKEvent$1{debug;static kind=7001;static kinds=[7001];constructor(t,r){super(t,r),this.kind??=7001,this.debug=t?.debug.extend("subscription-start")??import_debug6.default("ndk:subscription-start")}static from(t){return new Yn(t.ndk,t.rawEvent())}get recipient(){const t=this.getMatchingTags("p")?.[0];return t?new NDKUser$1({pubkey:t[1]}):void 0}set recipient(t){this.removeTag("p"),t&&this.tags.push(["p",t.pubkey])}get amount(){const t=this.getMatchingTags("amount")?.[0];if(t)return parseTagToSubscriptionAmount$1(t)}set amount(t){this.removeTag("amount"),t&&this.tags.push(newAmount$1(t.amount,t.currency,t.term))}get tierId(){const t=this.getMatchingTags("e")?.[0],r=this.getMatchingTags("a")?.[0];if(!(!t||!r))return t[1]??r[1]}set tier(t){this.removeTag("e"),this.removeTag("a"),this.removeTag("event"),t&&(this.tag(t),this.removeTag("p"),this.tags.push(["p",t.pubkey]),this.tags.push(["event",JSON.stringify(t.rawEvent())]))}async fetchTier(){const t=this.tagValue("event");if(t)try{const o=JSON.parse(t);return new NDKSubscriptionTier$1(this.ndk,o)}catch{this.debug("Failed to parse event tag")}const r=this.tierId;if(!r)return;const s=await this.ndk?.fetchEvent(r);if(s)return NDKSubscriptionTier$1.from(s)}get isValid(){return this.getMatchingTags("amount").length!==1?(this.debug("Invalid # of amount tag"),!1):this.amount?this.getMatchingTags("p").length!==1?(this.debug("Invalid # of p tag"),!1):this.recipient?!0:(this.debug("Invalid p tag"),!1):(this.debug("Invalid amount tag"),!1)}},NDKTask$1=class Jn extends NDKEvent$1{static kind=1934;static kinds=[1934];constructor(t,r){super(t,r),this.kind=1934}static from(t){return new Jn(t.ndk,t.rawEvent())}set title(t){this.removeTag("title"),t&&this.tags.push(["title",t])}get title(){return this.tagValue("title")}set project(t){this.removeTag("a"),this.tags.push(t.tagReference())}get projectSlug(){const t=this.getMatchingTags("a")[0];return t?t[1].split(/:/)?.[2]:void 0}},NDKThread$1=class Xn extends NDKEvent$1{static kind=11;static kinds=[11];constructor(t,r){super(t,r),this.kind??=11}static from(t){return new Xn(t.ndk,t)}get title(){return this.tagValue("title")}set title(t){this.removeTag("title"),t&&this.tags.push(["title",t])}},NDKVideo$1=class Qn extends NDKEvent$1{static kind=21;static kinds=[34235,34236,22,21];_imetas;static from(t){return new Qn(t.ndk,t.rawEvent())}get title(){return this.tagValue("title")}set title(t){this.removeTag("title"),t&&this.tags.push(["title",t])}get thumbnail(){let t;return this.imetas&&this.imetas.length>0&&(t=this.imetas[0].image?.[0]),t??this.tagValue("thumb")}get imetas(){return this._imetas?this._imetas:(this._imetas=this.tags.filter(t=>t[0]==="imeta").map(mapImetaTag$1),this._imetas)}set imetas(t){this._imetas=t,this.tags=this.tags.filter(r=>r[0]!=="imeta"),this.tags.push(...t.map(imetaTagToTag$1))}get url(){return this.imetas&&this.imetas.length>0?this.imetas[0].url:this.tagValue("url")}get published_at(){const t=this.tagValue("published_at");if(t)return Number.parseInt(t)}async generateTags(){if(super.generateTags(),!this.kind&&this.imetas?.[0]?.dim){const[t,r]=this.imetas[0].dim.split("x"),s=t&&r&&Number.parseInt(t)<Number.parseInt(r);this.duration&&this.duration<120&&s?this.kind=22:this.kind=21}return super.generateTags()}get duration(){const t=this.tagValue("duration");if(t)return Number.parseInt(t)}set duration(t){this.removeTag("duration"),t!==void 0&&this.tags.push(["duration",Math.floor(t).toString()])}},NDKWiki$1=class er extends NDKArticle$1{static kind=30818;static kinds=[30818];static from(t){return new er(t.ndk,t.rawEvent())}get isDefered(){return this.hasTag("a","defer")}get deferedId(){return this.tagValue("a","defer")}set defer(t){this.removeTag("a","defer"),this.tag(t,"defer")}},NDKWikiMergeRequest$1=class tr extends NDKEvent$1{static kind=818;static kinds=[818];static from(t){return new tr(t.ndk,t.rawEvent())}get targetId(){return this.tagValue("a")}set target(t){this.tags=this.tags.filter(r=>{if(r[0]==="a"||r[0]==="e"&&r[3]!=="source")return!0}),this.tag(t)}get sourceId(){return this.tagValue("e","source")}set source(t){this.removeTag("e","source"),this.tag(t,"source",!1,"e")}},registeredEventClasses$1=new Set;function wrapEvent3(n){const t=new Map,s=[...[NDKImage$1,NDKVideo$1,NDKCashuMintList$1,NDKArticle$1,NDKHighlight$1,NDKDraft$1,NDKWiki$1,NDKWikiMergeRequest$1,NDKNutzap$1,NDKProject$1,NDKTask$1,NDKProjectTemplate$1,NDKSimpleGroupMemberList$1,NDKSimpleGroupMetadata$1,NDKSubscriptionTier$1,NDKSubscriptionStart$1,NDKSubscriptionReceipt$1,NDKList$1,NDKRelayList$1,NDKRelayFeedList$1,NDKStory$1,NDKBlossomList$1,NDKFollowPack$1,NDKThread$1,NDKRepost$1,NDKClassified$1,NDKAppHandlerEvent$1,NDKDVMJobFeedback$1,NDKCashuMintAnnouncement$1,NDKFedimintMint$1,NDKMintRecommendation$1],...registeredEventClasses$1];for(const a of s)for(const c of a.kinds)t.set(c,a);const o=t.get(n.kind);return o?o.from(n):n}function checkMissingKind$1(n,t){(n.kind===void 0||n.kind===null)&&t("event-missing-kind",`Cannot sign event without 'kind'.

 Event data:
    content: ${n.content?`"${n.content.substring(0,50)}${n.content.length>50?"...":""}"`:"(empty)"}
    tags: ${n.tags.length} tag${n.tags.length!==1?"s":""}
    kind: ${n.kind} 

Set event.kind before signing.`,"Example: event.kind = 1; // for text note",!1)}function checkContentIsObject$1(n,t){if(typeof n.content=="object"){const r=JSON.stringify(n.content,null,2).substring(0,200);t("event-content-is-object",`Event content is an object. Content must be a string.

 Your content (${typeof n.content}):
${r}${JSON.stringify(n.content).length>200?"...":""}

 event.content = { ... }  // WRONG
 event.content = JSON.stringify({ ... })  // CORRECT`,"Use JSON.stringify() for structured data: event.content = JSON.stringify(data)",!1)}}function checkCreatedAtMilliseconds$1(n,t){if(n.created_at&&n.created_at>1e10){const r=Math.floor(n.created_at/1e3),s=new Date(n.created_at).toISOString();t("event-created-at-milliseconds",`Event created_at is in milliseconds, not seconds.

 Your value:
    created_at: ${n.created_at} 
    Interpreted as: ${s}
    Should be: ${r} 

Nostr timestamps MUST be in seconds since Unix epoch.`,"Use Math.floor(Date.now() / 1000) instead of Date.now()",!1)}}function checkInvalidPTags$1(n,t){n.getMatchingTags("p").forEach((s,o)=>{if(s[1]&&!/^[0-9a-f]{64}$/i.test(s[1])){const a=JSON.stringify(s);t("tag-invalid-p-tag",`p-tag[${o}] has invalid pubkey.

 Your tag:
   ${a}

 Invalid value: "${s[1]}"
    Length: ${s[1].length} (expected 64)
    Format: ${s[1].startsWith("npub")?"bech32 (npub)":"unknown"}

p-tags MUST contain 64-character hex pubkeys.`,s[1].startsWith("npub")?`Use ndkUser.pubkey instead of npub:
    event.tags.push(['p', ndkUser.pubkey])
    event.tags.push(['p', 'npub1...'])`:"p-tags must contain valid hex pubkeys (64 characters, 0-9a-f)",!1)}})}function checkInvalidETags$1(n,t){n.getMatchingTags("e").forEach((s,o)=>{if(s[1]&&!/^[0-9a-f]{64}$/i.test(s[1])){const a=JSON.stringify(s),c=s[1].startsWith("note")||s[1].startsWith("nevent");t("tag-invalid-e-tag",`e-tag[${o}] has invalid event ID.

 Your tag:
   ${a}

 Invalid value: "${s[1]}"
    Length: ${s[1].length} (expected 64)
    Format: ${c?"bech32 (note/nevent)":"unknown"}

e-tags MUST contain 64-character hex event IDs.`,c?`Use event.id instead of bech32:
    event.tags.push(['e', referencedEvent.id])
    event.tags.push(['e', 'note1...'])`:"e-tags must contain valid hex event IDs (64 characters, 0-9a-f)",!1)}})}function checkManualReplyMarkers$1(n,t,r){if(n.kind!==1||r.has(n))return;const s=n.tags.filter(o=>o[0]==="e"&&(o[3]==="reply"||o[3]==="root"));if(s.length>0){const o=s.map((a,c)=>`   ${c+1}. ${JSON.stringify(a)}`).join(`
`);t("event-manual-reply-markers",`Event has ${s.length} e-tag(s) with manual reply/root markers.

 Your tags with markers:
${o}

  Manual reply markers detected! This will cause incorrect threading.`,`Reply events MUST be created using .reply():

    CORRECT:
   const replyEvent = originalEvent.reply();
   replyEvent.content = 'good point!';
   await replyEvent.publish();

    WRONG:
   event.tags.push(['e', eventId, '', 'reply']);

NDK handles all reply threading automatically - never add reply/root markers manually.`)}}function checkHashtagsWithPrefix$1(n,t){n.getMatchingTags("t").forEach((s,o)=>{if(s[1]&&s[1].startsWith("#")){const a=JSON.stringify(s);t("tag-hashtag-with-prefix",`t-tag[${o}] contains hashtag with # prefix.

 Your tag:
   ${a}

 Invalid value: "${s[1]}"

Hashtag tags should NOT include the # symbol.`,`Remove the # prefix from hashtag tags:
    event.tags.push(['t', 'nostr'])
    event.tags.push(['t', '#nostr'])`,!1)}})}function checkReplaceableWithOldTimestamp$1(n,t){if(n.kind===void 0||n.kind===null||!n.created_at||!n.isReplaceable())return;const r=Math.floor(Date.now()/1e3),s=r-n.created_at;if(s>10){const a=Math.floor(s/60),c=a>0?`${a} minute${a!==1?"s":""}`:`${s} seconds`;t("event-replaceable-old-timestamp",`Publishing a replaceable event with an old created_at timestamp.

 Event details:
    kind: ${n.kind} (replaceable)
    created_at: ${n.created_at}
    age: ${c} old
    current time: ${r}

  This is wrong and will be rejected by relays.`,`For replaceable events, use publishReplaceable():

    CORRECT:
   await event.publishReplaceable();
   // Automatically updates created_at to now

    WRONG:
   await event.publish();
   // Uses old created_at`)}}function signing$1(n,t,r,s){checkMissingKind$1(n,t),checkContentIsObject$1(n,t),checkCreatedAtMilliseconds$1(n,t),checkInvalidPTags$1(n,t),checkInvalidETags$1(n,t),checkHashtagsWithPrefix$1(n,t),checkManualReplyMarkers$1(n,r,s)}function publishing$1(n,t){checkReplaceableWithOldTimestamp$1(n,t)}function isNip33Pattern$1(n){const t=Array.isArray(n)?n:[n];if(t.length!==1)return!1;const r=t[0];return r.kinds&&Array.isArray(r.kinds)&&r.kinds.length===1&&r.authors&&Array.isArray(r.authors)&&r.authors.length===1&&r["#d"]&&Array.isArray(r["#d"])&&r["#d"].length===1}function isReplaceableEventFilter$1(n){const t=Array.isArray(n)?n:[n];return t.length===0?!1:t.every(r=>!r.kinds||!Array.isArray(r.kinds)||r.kinds.length===0||!r.authors||!Array.isArray(r.authors)||r.authors.length===0?!1:r.kinds.every(o=>o===0||o===3||o>=1e4&&o<=19999))}function formatFilter$1(n){return JSON.stringify(n,null,2).split(`
`).map((r,s)=>s===0?r:`   ${r}`).join(`
`)}function fetchingEvents$1(n,t,r,s,o){if(o(),t?.cacheUsage==="ONLY_CACHE")return;const a=Array.isArray(n)?n:[n],c=a.map(formatFilter$1).join(`

   ---

   `);if(isNip33Pattern$1(n))a[0],r("fetch-events-usage",`For fetching a NIP-33 addressable event, use fetchEvent() with the naddr directly.

 Your filter:
   `+c+`

   BAD:  const decoded = nip19.decode(naddr);
           const events = await ndk.fetchEvents({
             kinds: [decoded.data.kind],
             authors: [decoded.data.pubkey],
             "#d": [decoded.data.identifier]
           });
           const event = Array.from(events)[0];

   GOOD: const event = await ndk.fetchEvent(naddr);
   GOOD: const event = await ndk.fetchEvent('naddr1...');

fetchEvent() handles naddr decoding automatically and returns the event directly.`);else{if(isReplaceableEventFilter$1(n))return;{if(!s())return;let f="";const g=a.some(k=>k.limit!==void 0),m=new Set(a.flatMap(k=>k.kinds||[])).size,b=new Set(a.flatMap(k=>k.authors||[])).size;if(g){const k=Math.max(...a.map(_=>_.limit||0));f+=`
    Limit: ${k} event${k!==1?"s":""}`}m>0&&(f+=`
    Kinds: ${m} type${m!==1?"s":""}`),b>0&&(f+=`
    Authors: ${b} author${b!==1?"s":""}`),r("fetch-events-usage",`fetchEvents() is a BLOCKING operation that waits for EOSE.
In most cases, you should use subscribe() instead.

 Your filter`+(a.length>1?"s":"")+`:
   `+c+(f?`

 Filter analysis:`+f:"")+`

   BAD:  const events = await ndk.fetchEvents(filter);
   GOOD: ndk.subscribe(filter, { onEvent: (e) => ... });

Only use fetchEvents() when you MUST block until data arrives.`,"For one-time queries, use fetchEvent() instead of fetchEvents() when expecting a single result.")}}}var GuardrailCheckId$1={NDK_NO_CACHE:"ndk-no-cache",FILTER_BECH32_IN_ARRAY:"filter-bech32-in-array",FILTER_INVALID_HEX:"filter-invalid-hex",FILTER_ONLY_LIMIT:"filter-only-limit",FILTER_EMPTY:"filter-empty",FILTER_SINCE_AFTER_UNTIL:"filter-since-after-until",FILTER_INVALID_A_TAG:"filter-invalid-a-tag",FILTER_HASHTAG_WITH_PREFIX:"filter-hashtag-with-prefix"};function checkCachePresence$1(n,t){t(GuardrailCheckId$1.NDK_NO_CACHE)&&setTimeout(()=>{if(!n.cacheAdapter){const o=`
 AI_GUARDRAILS WARNING: NDK initialized without a cache adapter. Apps perform significantly better with caching.

 ${typeof window<"u"?"Consider using @nostr-dev-kit/ndk-cache-dexie or @nostr-dev-kit/ndk-cache-sqlite-wasm":"Consider using @nostr-dev-kit/ndk-cache-redis or @nostr-dev-kit/ndk-cache-sqlite"}

 To disable this check:
   ndk.aiGuardrails.skip('${GuardrailCheckId$1.NDK_NO_CACHE}')
   or set: ndk.aiGuardrails = { skip: new Set(['${GuardrailCheckId$1.NDK_NO_CACHE}']) }`;console.warn(o)}},2500)}var AIGuardrails$1=class{enabled=!1;skipSet=new Set;extensions=new Map;_nextCallDisabled=null;_replyEvents=new WeakSet;_fetchEventsCount=0;_subscribeCount=0;constructor(t=!1){this.setMode(t)}register(t,r){this.extensions.has(t)&&console.warn(`AIGuardrails: Extension '${t}' already registered, overwriting`);const s={};for(const[o,a]of Object.entries(r))typeof a=="function"&&(s[o]=(...c)=>{this.enabled&&a(...c,this.shouldCheck.bind(this),this.error.bind(this),this.warn.bind(this))});this.extensions.set(t,s),this[t]=s}setMode(t){typeof t=="boolean"?(this.enabled=t,this.skipSet.clear()):t&&typeof t=="object"&&(this.enabled=!0,this.skipSet=t.skip||new Set)}isEnabled(){return this.enabled}shouldCheck(t){return!(!this.enabled||this.skipSet.has(t)||this._nextCallDisabled==="all"||this._nextCallDisabled&&this._nextCallDisabled.has(t))}skip(t){this.skipSet.add(t)}enable(t){this.skipSet.delete(t)}getSkipped(){return Array.from(this.skipSet)}captureAndClearNextCallDisabled(){const t=this._nextCallDisabled;return this._nextCallDisabled=null,t}incrementFetchEventsCount(){this._fetchEventsCount++}incrementSubscribeCount(){this._subscribeCount++}shouldWarnAboutFetchEventsRatio(){const t=this._fetchEventsCount+this._subscribeCount;return t<=6?!1:this._fetchEventsCount/t>.5}error(t,r,s,o=!0){if(!this.shouldCheck(t))return;const a=this.formatMessage(t,"ERROR",r,s,o);throw console.error(a),new Error(a)}warn(t,r,s){if(!this.shouldCheck(t))return;const o=this.formatMessage(t,"WARNING",r,s,!0);throw console.error(o),new Error(o)}formatMessage(t,r,s,o,a=!0){let c=`
 AI_GUARDRAILS ${r}: ${s}`;return o&&(c+=`

 ${o}`),a&&(c+=`

 To disable this check:
   ndk.guardrailOff('${t}').yourMethod()  // For one call`,c+=`
   ndk.aiGuardrails.skip('${t}')  // Permanently`,c+=`
   or set: ndk.aiGuardrails = { skip: new Set(['${t}']) }`),c}ndkInstantiated(t){this.enabled&&checkCachePresence$1(t,this.shouldCheck.bind(this))}ndk={fetchingEvents:(t,r)=>{this.enabled&&fetchingEvents$1(t,r,this.warn.bind(this),this.shouldWarnAboutFetchEventsRatio.bind(this),this.incrementFetchEventsCount.bind(this))}};event={signing:t=>{this.enabled&&signing$1(t,this.error.bind(this),this.warn.bind(this),this._replyEvents)},publishing:t=>{this.enabled&&publishing$1(t,this.warn.bind(this))},received:(t,r)=>{this.enabled},creatingReply:t=>{this.enabled&&this._replyEvents.add(t)}};subscription={created:(t,r)=>{this.enabled&&this.incrementSubscribeCount()}};relay={connected:t=>{this.enabled}}};function processFilters$1(n,t="validate",r,s){if(t==="ignore")return n;const o=[],a=n.map((c,f)=>(s?.aiGuardrails.isEnabled()&&runAIGuardrailsForFilter$1(c,f,s),processFilter$1(c,t,f,o,r)));if(t==="validate"&&o.length>0)throw new Error(`Invalid filter(s) detected:
${o.join(`
`)}`);return a}function processFilter$1(n,t,r,s,o){const a=t==="validate",c=a?n:{...n};if(n.ids){const f=[];n.ids.forEach((g,m)=>{g===void 0?a?s.push(`Filter[${r}].ids[${m}] is undefined`):o?.(`Fixed: Removed undefined value at ids[${m}]`):typeof g!="string"?a?s.push(`Filter[${r}].ids[${m}] is not a string (got ${typeof g})`):o?.(`Fixed: Removed non-string value at ids[${m}] (was ${typeof g})`):isValidHex64$1(g)?f.push(g):a?s.push(`Filter[${r}].ids[${m}] is not a valid 64-char hex string: "${g}"`):o?.(`Fixed: Removed invalid hex string at ids[${m}]`)}),a||(c.ids=f.length>0?f:void 0)}if(n.authors){const f=[];n.authors.forEach((g,m)=>{g===void 0?a?s.push(`Filter[${r}].authors[${m}] is undefined`):o?.(`Fixed: Removed undefined value at authors[${m}]`):typeof g!="string"?a?s.push(`Filter[${r}].authors[${m}] is not a string (got ${typeof g})`):o?.(`Fixed: Removed non-string value at authors[${m}] (was ${typeof g})`):isValidHex64$1(g)?f.push(g):a?s.push(`Filter[${r}].authors[${m}] is not a valid 64-char hex pubkey: "${g}"`):o?.(`Fixed: Removed invalid hex pubkey at authors[${m}]`)}),a||(c.authors=f.length>0?f:void 0)}if(n.kinds){const f=[];n.kinds.forEach((g,m)=>{g===void 0?a?s.push(`Filter[${r}].kinds[${m}] is undefined`):o?.(`Fixed: Removed undefined value at kinds[${m}]`):typeof g!="number"?a?s.push(`Filter[${r}].kinds[${m}] is not a number (got ${typeof g})`):o?.(`Fixed: Removed non-number value at kinds[${m}] (was ${typeof g})`):Number.isInteger(g)?g<0||g>65535?a?s.push(`Filter[${r}].kinds[${m}] is out of valid range (0-65535): ${g}`):o?.(`Fixed: Removed out-of-range kind at kinds[${m}]: ${g}`):f.push(g):a?s.push(`Filter[${r}].kinds[${m}] is not an integer: ${g}`):o?.(`Fixed: Removed non-integer value at kinds[${m}]: ${g}`)}),a||(c.kinds=f.length>0?f:void 0)}for(const f in n)if(f.startsWith("#")&&f.length===2){const g=n[f];if(Array.isArray(g)){const m=[];g.forEach((b,k)=>{b===void 0?a?s.push(`Filter[${r}].${f}[${k}] is undefined`):o?.(`Fixed: Removed undefined value at ${f}[${k}]`):typeof b!="string"?a?s.push(`Filter[${r}].${f}[${k}] is not a string (got ${typeof b})`):o?.(`Fixed: Removed non-string value at ${f}[${k}] (was ${typeof b})`):(f==="#e"||f==="#p")&&!isValidHex64$1(b)?a?s.push(`Filter[${r}].${f}[${k}] is not a valid 64-char hex string: "${b}"`):o?.(`Fixed: Removed invalid hex string at ${f}[${k}]`):m.push(b)}),a||(c[f]=m.length>0?m:void 0)}}return a||Object.keys(c).forEach(f=>{c[f]===void 0&&delete c[f]}),c}function runAIGuardrailsForFilter$1(n,t,r){const s=r.aiGuardrails,o=JSON.stringify(n,null,2);if(Object.keys(n).length===1&&n.limit!==void 0&&s.error(GuardrailCheckId$1.FILTER_ONLY_LIMIT,`Filter[${t}] contains only 'limit' without any filtering criteria.

 Your filter:
${o}

  This will fetch random events from relays without any criteria.`,`Add filtering criteria:
    { kinds: [1], limit: 10 }
    { authors: [pubkey], limit: 10 }
    { limit: 10 }`),Object.keys(n).length===0&&s.error(GuardrailCheckId$1.FILTER_EMPTY,`Filter[${t}] is empty.

 Your filter:
${o}

  This will request ALL events from relays, which is never what you want.`,"Add filtering criteria like 'kinds', 'authors', or tags.",!1),n.since!==void 0&&n.until!==void 0&&n.since>n.until){const c=new Date(n.since*1e3).toISOString(),f=new Date(n.until*1e3).toISOString();s.error(GuardrailCheckId$1.FILTER_SINCE_AFTER_UNTIL,`Filter[${t}] has 'since' AFTER 'until'.

 Your filter:
${o}

 since: ${n.since} (${c})
 until: ${n.until} (${f})

No events can match this time range!`,"'since' must be BEFORE 'until'. Both are Unix timestamps in seconds.",!1)}const a=/^n(addr|event|ote|pub|profile)1/;n.ids&&n.ids.forEach((c,f)=>{typeof c=="string"&&(a.test(c)?s.error(GuardrailCheckId$1.FILTER_BECH32_IN_ARRAY,`Filter[${t}].ids[${f}] contains bech32: "${c}". IDs must be hex, not bech32.`,'Use filterFromId() to decode bech32 first: import { filterFromId } from "@nostr-dev-kit/ndk"',!1):isValidHex64$1(c)||s.error(GuardrailCheckId$1.FILTER_INVALID_HEX,`Filter[${t}].ids[${f}] is not a valid 64-char hex string: "${c}"`,`Event IDs must be 64-character hexadecimal strings. Invalid IDs often come from corrupted data in user-generated lists. Always validate hex strings before using them in filters:

   const validIds = ids.filter(id => /^[0-9a-f]{64}$/i.test(id));`,!1))}),n.authors&&n.authors.forEach((c,f)=>{typeof c=="string"&&(a.test(c)?s.error(GuardrailCheckId$1.FILTER_BECH32_IN_ARRAY,`Filter[${t}].authors[${f}] contains bech32: "${c}". Authors must be hex pubkeys, not npub.`,"Use ndkUser.pubkey instead. Example: { authors: [ndkUser.pubkey] }",!1):isValidHex64$1(c)||s.error(GuardrailCheckId$1.FILTER_INVALID_HEX,`Filter[${t}].authors[${f}] is not a valid 64-char hex pubkey: "${c}"`,`Kind:3 follow lists can contain invalid entries like labels ("Follow List"), partial strings ("highlig"), or other corrupted data. You MUST validate all pubkeys before using them in filters.

   Example:
   const validPubkeys = pubkeys.filter(p => /^[0-9a-f]{64}$/i.test(p));
   ndk.subscribe({ authors: validPubkeys, kinds: [1] });`,!1))});for(const c in n)if(c.startsWith("#")&&c.length===2){const f=n[c];Array.isArray(f)&&f.forEach((g,m)=>{typeof g=="string"&&(c==="#e"||c==="#p")&&(a.test(g)?s.error(GuardrailCheckId$1.FILTER_BECH32_IN_ARRAY,`Filter[${t}].${c}[${m}] contains bech32: "${g}". Tag values must be decoded.`,"Use filterFromId() or nip19.decode() to get the hex value first.",!1):isValidHex64$1(g)||s.error(GuardrailCheckId$1.FILTER_INVALID_HEX,`Filter[${t}].${c}[${m}] is not a valid 64-char hex string: "${g}"`,`${c==="#e"?"Event IDs":"Public keys"} in tag filters must be 64-character hexadecimal strings. Kind:3 follow lists and other user-generated content can contain invalid data. Always filter before using:

   const validValues = values.filter(v => /^[0-9a-f]{64}$/i.test(v));`,!1))})}n["#a"]&&n["#a"]?.forEach((f,g)=>{if(typeof f=="string")if(!/^\d+:[0-9a-f]{64}:.*$/.test(f))s.error(GuardrailCheckId$1.FILTER_INVALID_A_TAG,`Filter[${t}].#a[${g}] has invalid format: "${f}". Must be "kind:pubkey:d-tag".`,'Example: "30023:fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52:my-article"',!1);else{const m=Number.parseInt(f.split(":")[0],10);(m<3e4||m>39999)&&s.error(GuardrailCheckId$1.FILTER_INVALID_A_TAG,`Filter[${t}].#a[${g}] uses non-addressable kind ${m}: "${f}". #a filters are only for addressable events (kinds 30000-39999).`,`Addressable events include:
    30000-30039: Parameterized Replaceable Events (profiles, settings, etc.)
    30040-39999: Other addressable events

For regular events (kind ${m}), use:
    #e filter for specific event IDs
    kinds + authors filters for event queries`,!1)}}),n["#t"]&&n["#t"]?.forEach((f,g)=>{typeof f=="string"&&f.startsWith("#")&&s.error(GuardrailCheckId$1.FILTER_HASHTAG_WITH_PREFIX,`Filter[${t}].#t[${g}] contains hashtag with # prefix: "${f}". Hashtag values should NOT include the # symbol.`,`Remove the # prefix from hashtag filters:
    { "#t": ["nostr"] }
    { "#t": ["#nostr"] }`,!1)})}function queryFullyFilled$1(n){return!!(filterIncludesIds$1(n.filter)&&resultHasAllRequestedIds$1(n))}function filterIncludesIds$1(n){return!!n.ids}function resultHasAllRequestedIds$1(n){const t=n.filter.ids;return!!t&&t.length===n.eventFirstSeen.size}function filterFromId$1(n){let t;if(n.match(NIP33_A_REGEX$1)){const[r,s,o]=n.split(":"),a={authors:[s],kinds:[Number.parseInt(r)]};return o&&(a["#d"]=[o]),a}if(n.match(BECH32_REGEX3))try{switch(t=nip19_exports$2.decode(n),t.type){case"nevent":{const r={ids:[t.data.id]};return t.data.author&&(r.authors=[t.data.author]),t.data.kind&&(r.kinds=[t.data.kind]),r}case"note":return{ids:[t.data]};case"naddr":{const r={authors:[t.data.pubkey],kinds:[t.data.kind]};return t.data.identifier&&(r["#d"]=[t.data.identifier]),r}}}catch(r){console.error("Error decoding",n,r)}return{ids:[n]}}function isNip33AValue$1(n){return n.match(NIP33_A_REGEX$1)!==null}var NIP33_A_REGEX$1=/^(\d+):([0-9A-Fa-f]+)(?::(.*))?$/,BECH32_REGEX3=/^n(event|ote|profile|pub|addr)1[\d\w]+$/;function relaysFromBech32$1(n,t){try{const r=nip19_exports$2.decode(n);if(["naddr","nevent"].includes(r?.type)){const s=r.data;if(s?.relays)return s.relays.map(o=>new NDKRelay$1(o,t.relayAuthDefaultPolicy,t))}}catch{}return[]}var defaultOpts$1={closeOnEose:!1,cacheUsage:"CACHE_FIRST",dontSaveToCache:!1,groupable:!0,groupableDelay:10,groupableDelayType:"at-most",cacheUnconstrainFilter:["limit","since","until"],includeMuted:!1},NDKSubscription$1=class extends import_tseep4.EventEmitter{subId;filters;opts;pool;skipVerification=!1;skipValidation=!1;exclusiveRelay=!1;relayFilters;relaySet;ndk;debug;eventFirstSeen=new Map;eosesSeen=new Set;lastEventReceivedAt;mostRecentCacheEventTimestamp;internalId;closeOnEose;poolMonitor;skipOptimisticPublishEvent=!1;cacheUnconstrainFilter;constructor(t,r,s,o){super(),this.ndk=t,this.opts={...defaultOpts$1,...s||{}},this.pool=this.opts.pool||t.pool;const a=Array.isArray(r)?r:[r],c=t.filterValidationMode==="validate"?"validate":t.filterValidationMode==="fix"?"fix":"ignore";if(this.filters=processFilters$1(a,c,t.debug,t),this.filters.length===0)throw new Error("Subscription must have at least one filter");this.subId=o||this.opts.subId,this.internalId=Math.random().toString(36).substring(7),this.debug=t.debug.extend(`subscription[${this.opts.subId??this.internalId}]`),this.opts.relaySet?this.relaySet=this.opts.relaySet:this.opts.relayUrls&&(this.relaySet=NDKRelaySet$1.fromRelayUrls(this.opts.relayUrls,this.ndk)),this.skipVerification=this.opts.skipVerification||!1,this.skipValidation=this.opts.skipValidation||!1,this.closeOnEose=this.opts.closeOnEose||!1,this.skipOptimisticPublishEvent=this.opts.skipOptimisticPublishEvent||!1,this.cacheUnconstrainFilter=this.opts.cacheUnconstrainFilter,this.exclusiveRelay=this.opts.exclusiveRelay||!1,this.opts.onEvent&&this.on("event",this.opts.onEvent),this.opts.onEose&&this.on("eose",this.opts.onEose),this.opts.onClose&&this.on("close",this.opts.onClose)}relaysMissingEose(){return this.relayFilters?Array.from(this.relayFilters?.keys()).filter(r=>!this.eosesSeen.has(this.pool.getRelay(r,!1,!1))):[]}get filter(){return this.filters[0]}get groupableDelay(){if(this.isGroupable())return this.opts?.groupableDelay}get groupableDelayType(){return this.opts?.groupableDelayType||"at-most"}isGroupable(){return this.opts?.groupable||!1}shouldQueryCache(){return this.opts.addSinceFromCache?!0:this.opts?.cacheUsage==="ONLY_RELAY"?!1:(this.filters.some(r=>r.kinds?.some(s=>kindIsEphemeral$1(s))),!0)}shouldQueryRelays(){return this.opts?.cacheUsage!=="ONLY_CACHE"}shouldWaitForCache(){return this.opts.addSinceFromCache?!0:!!this.opts.closeOnEose&&!!this.ndk.cacheAdapter?.locking&&this.opts.cacheUsage!=="PARALLEL"}start(t=!0){let r;const s=a=>{if(a.length===0){t||(r=a);return}if(!t){let f=this.mostRecentCacheEventTimestamp||0;for(const g of a)g.ndk=this.ndk,g.created_at&&g.created_at>f&&(f=g.created_at);this.mostRecentCacheEventTimestamp=f,r=a;return}let c=this.mostRecentCacheEventTimestamp||0;for(const f of a)f.created_at&&f.created_at>c&&(c=f.created_at);this.mostRecentCacheEventTimestamp=c;for(const f of a)this.eventReceived(f,void 0,!0,!1)},o=()=>{this.shouldQueryRelays()?(this.startWithRelays(),this.startPoolMonitor()):this.emit("eose",this)};return this.shouldQueryCache()?(r=this.startWithCache(),r instanceof Promise?this.shouldWaitForCache()?(r.then(a=>{if(this.opts.onEvents){let c=this.mostRecentCacheEventTimestamp||0;for(const f of a)f.ndk=this.ndk,f.created_at&&f.created_at>c&&(c=f.created_at);this.mostRecentCacheEventTimestamp=c,this.opts.onEvents(a)}else s(a);if(queryFullyFilled$1(this)){this.emit("eose",this);return}o()}),null):(r.then(a=>{if(this.opts.onEvents){let c=this.mostRecentCacheEventTimestamp||0;for(const f of a)f.ndk=this.ndk,f.created_at&&f.created_at>c&&(c=f.created_at);this.mostRecentCacheEventTimestamp=c,this.opts.onEvents(a)}else s(a);this.shouldQueryRelays()||this.emit("eose",this)}),this.shouldQueryRelays()&&o(),null):(s(r),queryFullyFilled$1(this)?this.emit("eose",this):o(),r)):(o(),null)}startPoolMonitor(){this.debug.extend("pool-monitor"),this.poolMonitor=t=>{if(this.relayFilters?.has(t.url))return;calculateRelaySetsFromFilters$1(this.ndk,this.filters,this.pool,this.opts.relayGoalPerAuthor).get(t.url)&&(this.relayFilters?.set(t.url,this.filters),t.subscribe(this,this.filters))},this.pool.on("relay:connect",this.poolMonitor)}onStopped;stop(){this.emit("close",this),this.poolMonitor&&this.pool.off("relay:connect",this.poolMonitor),this.onStopped?.()}hasAuthorsFilter(){return this.filters.some(t=>t.authors?.length)}startWithCache(){return this.ndk.cacheAdapter?.query?this.ndk.cacheAdapter.query(this):[]}startWithRelays(){let t=this.filters;if(this.opts.addSinceFromCache&&this.mostRecentCacheEventTimestamp){const r=this.mostRecentCacheEventTimestamp+1;t=t.map(s=>({...s,since:Math.max(s.since||0,r)}))}if(!this.relaySet||this.relaySet.relays.size===0)this.relayFilters=calculateRelaySetsFromFilters$1(this.ndk,t,this.pool,this.opts.relayGoalPerAuthor);else{this.relayFilters=new Map;for(const r of this.relaySet.relays)this.relayFilters.set(r.url,t)}for(const[r,s]of this.relayFilters)this.pool.getRelay(r,!0,!0,s).subscribe(this,s)}refreshRelayConnections(){if(this.relaySet&&this.relaySet.relays.size>0)return;const t=calculateRelaySetsFromFilters$1(this.ndk,this.filters,this.pool,this.opts.relayGoalPerAuthor);for(const[r,s]of t)this.relayFilters?.has(r)||(this.relayFilters?.set(r,s),this.pool.getRelay(r,!0,!0,s).subscribe(this,s))}eventReceived(t,r,s=!1,o=!1){const a=t.id,c=this.eventFirstSeen.has(a);let f;if(t instanceof NDKEvent$1&&(f=t),c){const g=Date.now()-(this.eventFirstSeen.get(a)||0);if(this.emit("event:dup",t,r,g,this,s,o),this.opts?.onEventDup&&this.opts.onEventDup(t,r,g,this,s,o),!s&&!o&&r&&this.ndk.cacheAdapter?.setEventDup&&!this.opts.dontSaveToCache&&(f??=t instanceof NDKEvent$1?t:new NDKEvent$1(this.ndk,t),this.ndk.cacheAdapter.setEventDup(f,r)),r){const m=verifiedSignatures$1.get(a);if(m&&typeof m=="string")if(t.sig===m)r.addValidatedEvent();else{const b=t instanceof NDKEvent$1?t:new NDKEvent$1(this.ndk,t);this.ndk.reportInvalidSignature(b,r)}}}else{if(this.ndk.futureTimestampGrace!==void 0&&t.created_at){const g=Math.floor(Date.now()/1e3),m=t.created_at-g;if(m>this.ndk.futureTimestampGrace){this.debug("Event discarded: timestamp %d is %d seconds in the future (grace: %d seconds)",t.created_at,m,this.ndk.futureTimestampGrace);return}}if(f??=new NDKEvent$1(this.ndk,t),f.ndk=this.ndk,f.relay=r,!s&&!o){if(!this.skipValidation&&!f.isValid){this.debug("Event failed validation %s from relay %s",a,r?.url);return}if(r)if(r.shouldValidateEvent()&&!this.skipVerification)if(f.relay=r,this.ndk.asyncSigVerification)f.verifySignature(!0);else{if(!f.verifySignature(!0)){this.debug("Event failed signature validation",t),this.ndk.reportInvalidSignature(f,r);return}r.addValidatedEvent()}else r.addNonValidatedEvent();this.ndk.cacheAdapter&&!this.opts.dontSaveToCache&&this.ndk.cacheAdapter.setEvent(f,this.filters,r)}if(!this.opts.includeMuted&&this.ndk.muteFilter&&this.ndk.muteFilter(f)){this.debug("Event muted, skipping");return}(!o||this.skipOptimisticPublishEvent!==!0)&&(this.emitEvent(this.opts?.wrap??!1,f,r,s,o),this.eventFirstSeen.set(a,Date.now()))}this.lastEventReceivedAt=Date.now()}emitEvent(t,r,s,o,a){const c=t?wrapEvent3(r):r;c instanceof Promise?c.then(f=>this.emitEvent(!1,f,s,o,a)):c&&this.emit("event",c,s,this,o,a)}closedReceived(t,r){this.emit("closed",t,r)}eoseTimeout;eosed=!1;eoseReceived(t){this.eosesSeen.add(t);let r=this.lastEventReceivedAt?Date.now()-this.lastEventReceivedAt:void 0;const s=this.eosesSeen.size===this.relayFilters?.size,o=queryFullyFilled$1(this),a=c=>{this.eosed||(this.eoseTimeout&&clearTimeout(this.eoseTimeout),this.emit("eose",this),this.eosed=!0,this.opts?.closeOnEose&&this.stop())};if(o||s)a();else if(this.relayFilters){let c=1e3;const f=new Set(this.pool.connectedRelays().map(b=>b.url)),g=Array.from(this.relayFilters.keys()).filter(b=>f.has(b));if(g.length===0){this.debug("No connected relays, waiting for all relays to connect",Array.from(this.relayFilters.keys()).join(", "));return}const m=this.eosesSeen.size/g.length;if(this.eosesSeen.size>=2&&m>=.5){if(c=c*(1-m),c===0){a();return}this.eoseTimeout&&clearTimeout(this.eoseTimeout);const b=()=>{r=this.lastEventReceivedAt?Date.now()-this.lastEventReceivedAt:void 0,r!==void 0&&r<20?this.eoseTimeout=setTimeout(b,c):a()};this.eoseTimeout=setTimeout(b,c)}}}},kindIsEphemeral$1=n=>n>=2e4&&n<3e4;async function follows$1(n,t,r=3){if(!this.ndk)throw new Error("NDK not set");const s=await this.ndk.fetchEvent({kinds:[r],authors:[this.pubkey]},n||{groupable:!1});if(s){const o=new Set;return s.tags.forEach(a=>{a[0]==="p"&&a[1]&&isValidPubkey$1(a[1])&&o.add(a[1])}),t&&this.ndk?.outboxTracker?.trackUsers(Array.from(o)),[...o].reduce((a,c)=>{const f=new NDKUser$1({pubkey:c});return f.ndk=this.ndk,a.add(f),a},new Set)}return new Set}var NIP05_REGEX2=/^(?:([\w.+-]+)@)?([\w.-]+)$/;async function getNip05For$1(n,t,r=fetch,s={}){return await n.queuesNip05.add({id:t,func:async()=>{if(n.cacheAdapter?.loadNip05){const g=await n.cacheAdapter.loadNip05(t);if(g!=="missing"){if(g){const m=new NDKUser$1({pubkey:g.pubkey,relayUrls:g.relays,nip46Urls:g.nip46});return m.ndk=n,m}if(s.cache!=="no-cache")return null}}const o=t.match(NIP05_REGEX2);if(!o)return null;const[a,c="_",f]=o;try{const g=await r(`https://${f}/.well-known/nostr.json?name=${c}`,s),{names:m,relays:b,nip46:k}=parseNIP05Result$1(await g.json()),_=m[c.toLowerCase()];let A=null;return _&&(A={pubkey:_,relays:b?.[_],nip46:k?.[_]}),n?.cacheAdapter?.saveNip05&&n.cacheAdapter.saveNip05(t,A),A}catch(g){return n?.cacheAdapter?.saveNip05&&n?.cacheAdapter.saveNip05(t,null),console.error("Failed to fetch NIP05 for",t,g),null}}})}function parseNIP05Result$1(n){const t={names:{}};for(const[r,s]of Object.entries(n.names))typeof r=="string"&&typeof s=="string"&&(t.names[r.toLowerCase()]=s);if(n.relays){t.relays={};for(const[r,s]of Object.entries(n.relays))typeof r=="string"&&Array.isArray(s)&&(t.relays[r]=s.filter(o=>typeof o=="string"))}if(n.nip46){t.nip46={};for(const[r,s]of Object.entries(n.nip46))typeof r=="string"&&Array.isArray(s)&&(t.nip46[r]=s.filter(o=>typeof o=="string"))}return t}function profileFromEvent$1(n){const t={};let r;try{r=JSON.parse(n.content)}catch(s){throw new Error(`Failed to parse profile event: ${s}`)}t.profileEvent=JSON.stringify(n.rawEvent());for(const s of Object.keys(r))switch(s){case"name":t.name=r.name;break;case"display_name":t.displayName=r.display_name;break;case"image":case"picture":t.picture=r.picture||r.image,t.image=t.picture;break;case"banner":t.banner=r.banner;break;case"bio":t.bio=r.bio;break;case"nip05":t.nip05=r.nip05;break;case"lud06":t.lud06=r.lud06;break;case"lud16":t.lud16=r.lud16;break;case"about":t.about=r.about;break;case"website":t.website=r.website;break;default:t[s]=r[s];break}return t.created_at=n.created_at,t}function serializeProfile$1(n){const t={};for(const[r,s]of Object.entries(n))switch(r){case"username":case"name":t.name=s;break;case"displayName":t.display_name=s;break;case"image":case"picture":t.picture=s;break;case"bio":case"about":t.about=s;break;default:t[r]=s;break}return JSON.stringify(t)}var NDKUser$1=class nr{ndk;profile;profileEvent;_npub;_pubkey;relayUrls=[];nip46Urls=[];constructor(t){if(t.npub&&(this._npub=t.npub),t.hexpubkey&&(this._pubkey=t.hexpubkey),t.pubkey&&(this._pubkey=t.pubkey),t.relayUrls&&(this.relayUrls=t.relayUrls),t.nip46Urls&&(this.nip46Urls=t.nip46Urls),t.nprofile)try{const r=nip19_exports$2.decode(t.nprofile);r.type==="nprofile"&&(this._pubkey=r.data.pubkey,r.data.relays&&r.data.relays.length>0&&this.relayUrls.push(...r.data.relays))}catch(r){console.error("Failed to decode nprofile",r)}}get npub(){if(!this._npub){if(!this._pubkey)throw new Error("pubkey not set");this._npub=nip19_exports$2.npubEncode(this.pubkey)}return this._npub}get nprofile(){const t=this.profileEvent?.onRelays?.map(r=>r.url);return nip19_exports$2.nprofileEncode({pubkey:this.pubkey,relays:t})}set npub(t){this._npub=t}get pubkey(){if(!this._pubkey){if(!this._npub)throw new Error("npub not set");this._pubkey=nip19_exports$2.decode(this.npub).data}return this._pubkey}set pubkey(t){this._pubkey=t}filter(){return{"#p":[this.pubkey]}}async getZapInfo(t){if(!this.ndk)throw new Error("No NDK instance found");const r=async c=>{if(!t)return c;let f;const g=new Promise((m,b)=>{f=setTimeout(()=>b(new Error("Timeout")),t)});try{const m=await Promise.race([c,g]);return f&&clearTimeout(f),m}catch(m){if(m instanceof Error&&m.message==="Timeout")try{return await c}catch{return}return}},[s,o]=await Promise.all([r(this.fetchProfile()),r(this.ndk.fetchEvent({kinds:[10019],authors:[this.pubkey]}))]),a=new Map;if(o){const c=NDKCashuMintList$1.from(o);c.mints.length>0&&a.set("nip61",{mints:c.mints,relays:c.relays,p2pk:c.p2pk})}if(s){const{lud06:c,lud16:f}=s;a.set("nip57",{lud06:c,lud16:f})}return a}static async fromNip05(t,r,s=!1){if(!r)throw new Error("No NDK instance found");const o={};s&&(o.cache="no-cache");const a=await getNip05For$1(r,t,r?.httpFetch,o);if(a){const c=new nr({pubkey:a.pubkey,relayUrls:a.relays,nip46Urls:a.nip46});return c.ndk=r,c}}async fetchProfile(t,r=!1){if(!this.ndk)throw new Error("NDK not set");let s=null;if(this.ndk.cacheAdapter&&(this.ndk.cacheAdapter.fetchProfile||this.ndk.cacheAdapter.fetchProfileSync)&&t?.cacheUsage!=="ONLY_RELAY"){let o=null;if(this.ndk.cacheAdapter.fetchProfileSync?o=this.ndk.cacheAdapter.fetchProfileSync(this.pubkey):this.ndk.cacheAdapter.fetchProfile&&(o=await this.ndk.cacheAdapter.fetchProfile(this.pubkey)),o)return this.profile=o,o}return t??={},t.cacheUsage??="ONLY_RELAY",t.closeOnEose??=!0,t.groupable??=!0,t.groupableDelay??=25,s||(s=await this.ndk.fetchEvent({kinds:[0],authors:[this.pubkey]},t)),s?(this.profile=profileFromEvent$1(s),r&&this.profile&&this.ndk.cacheAdapter&&this.ndk.cacheAdapter.saveProfile&&this.ndk.cacheAdapter.saveProfile(this.pubkey,this.profile),this.profile):null}follows=follows$1.bind(this);async followSet(t,r,s=3){const o=await this.follows(t,r,s);return new Set(Array.from(o).map(a=>a.pubkey))}tagReference(){return["p",this.pubkey]}referenceTags(t){const r=[["p",this.pubkey]];return t&&r[0].push("",t),r}async publish(){if(!this.ndk)throw new Error("No NDK instance found");if(!this.profile)throw new Error("No profile available");this.ndk.assertSigner(),await new NDKEvent$1(this.ndk,{kind:0,content:serializeProfile$1(this.profile)}).publish()}async follow(t,r,s=3){if(!this.ndk)throw new Error("No NDK instance found");this.ndk.assertSigner(),r||(r=await this.follows(void 0,void 0,s));const o=Array.isArray(t)?t:[t];let a=!1;for(const f of o){const g=typeof f=="string"?f:f.pubkey;Array.from(r).some(b=>typeof b=="string"?b===g:b.pubkey===g)||(r.add(f),a=!0)}if(!a)return!1;const c=new NDKEvent$1(this.ndk,{kind:s});for(const f of r)typeof f=="string"?c.tags.push(["p",f]):c.tag(f);return await c.publish(),!0}async unfollow(t,r,s=3){if(!this.ndk)throw new Error("No NDK instance found");this.ndk.assertSigner(),r||(r=await this.follows(void 0,void 0,s));const o=Array.isArray(t)?t:[t],a=new Set(o.map(m=>typeof m=="string"?m:m.pubkey)),c=new Set;let f=!1;for(const m of r){const b=typeof m=="string"?m:m.pubkey;a.has(b)?f=!0:c.add(m)}if(!f)return!1;const g=new NDKEvent$1(this.ndk,{kind:s});for(const m of c)typeof m=="string"?g.tags.push(["p",m]):g.tag(m);return await g.publish()}async validateNip05(t){if(!this.ndk)throw new Error("No NDK instance found");const r=await getNip05For$1(this.ndk,t);return r===null?null:r.pubkey===this.pubkey}},signerRegistry$1=new Map;function registerSigner$1(n,t){signerRegistry$1.set(n,t)}var NDKPrivateKeySigner$1=class dn{_user;_privateKey;_pubkey;constructor(t,r){if(typeof t=="string")if(t.startsWith("nsec1")){const{type:s,data:o}=nip19_exports$2.decode(t);if(s==="nsec")this._privateKey=o;else throw new Error("Invalid private key provided.")}else if(t.length===64)this._privateKey=hexToBytes3(t);else throw new Error("Invalid private key provided.");else this._privateKey=t;this._pubkey=getPublicKey$1(this._privateKey),r&&(this._user=r.getUser({pubkey:this._pubkey})),this._user??=new NDKUser$1({pubkey:this._pubkey})}get privateKey(){if(!this._privateKey)throw new Error("Not ready");return bytesToHex3(this._privateKey)}get pubkey(){if(!this._pubkey)throw new Error("Not ready");return this._pubkey}get nsec(){if(!this._privateKey)throw new Error("Not ready");return nip19_exports$2.nsecEncode(this._privateKey)}get npub(){if(!this._pubkey)throw new Error("Not ready");return nip19_exports$2.npubEncode(this._pubkey)}encryptToNcryptsec(t,r=16,s=2){if(!this._privateKey)throw new Error("Private key not available");return encrypt3(this._privateKey,t,r,s)}static generate(){const t=generateSecretKey$1();return new dn(t)}static fromNcryptsec(t,r,s){const o=decrypt3(t,r);return new dn(o,s)}async blockUntilReady(){return this._user}async user(){return this._user}get userSync(){return this._user}async sign(t){if(!this._privateKey)throw Error("Attempted to sign without a private key");return finalizeEvent$1(t,this._privateKey).sig}async encryptionEnabled(t){const r=[];return(!t||t==="nip04")&&r.push("nip04"),(!t||t==="nip44")&&r.push("nip44"),r}async encrypt(t,r,s){if(!this._privateKey||!this.privateKey)throw Error("Attempted to encrypt without a private key");const o=t.pubkey;if(s==="nip44"){const a=nip44_exports$1.v2.utils.getConversationKey(this._privateKey,o);return await nip44_exports$1.v2.encrypt(r,a)}return await nip04_exports$1.encrypt(this._privateKey,o,r)}async decrypt(t,r,s){if(!this._privateKey||!this.privateKey)throw Error("Attempted to decrypt without a private key");const o=t.pubkey;if(s==="nip44"){const a=nip44_exports$1.v2.utils.getConversationKey(this._privateKey,o);return await nip44_exports$1.v2.decrypt(r,a)}return await nip04_exports$1.decrypt(this._privateKey,o,r)}toPayload(){if(!this._privateKey)throw new Error("Private key not available");const t={type:"private-key",payload:this.privateKey};return JSON.stringify(t)}static async fromPayload(t,r){const s=JSON.parse(t);if(s.type!=="private-key")throw new Error(`Invalid payload type: expected 'private-key', got ${s.type}`);if(!s.payload||typeof s.payload!="string")throw new Error("Invalid payload content for private-key signer");return new dn(s.payload,r)}};registerSigner$1("private-key",NDKPrivateKeySigner$1);function dedup$1(n,t){return n.created_at>t.created_at?n:t}async function getRelayListForUser$1(n,t){return(await getRelayListForUsers$1([n],t)).get(n)}async function getRelayListForUsers$1(n,t,r=!1,s=1e3,o){const a=t.outboxPool||t.pool,c=new Set;for(const _ of a.relays.values())c.add(_);if(o)for(const _ of o.values())for(const A of _){const B=a.getRelay(A,!0,!0);B&&c.add(B)}const f=new Map,g=new Map,m=new NDKRelaySet$1(c,t);if(t.cacheAdapter?.locking&&!r){const _=await t.fetchEvents({kinds:[3,10002],authors:Array.from(new Set(n))},{cacheUsage:"ONLY_CACHE",subId:"ndk-relay-list-fetch"});for(const A of _)A.kind===10002&&f.set(A.pubkey,NDKRelayList$1.from(A));for(const A of _)if(A.kind===3){if(f.has(A.pubkey))continue;const B=relayListFromKind3$1(t,A);B&&g.set(A.pubkey,B)}n=n.filter(A=>!f.has(A)&&!g.has(A))}if(n.length===0)return f;const b=new Map,k=new Map;return new Promise(_=>{let A=!1;(async()=>{const L={closeOnEose:!0,pool:a,groupable:!0,subId:"ndk-relay-list-fetch",addSinceFromCache:!0,relaySet:m};m&&(L.relaySet=m),t.subscribe({kinds:[3,10002],authors:n},L,{onEvent:re=>{if(re.kind===10002){const ze=b.get(re.pubkey);if(ze&&ze.created_at>re.created_at)return;b.set(re.pubkey,re)}else if(re.kind===3){const ze=k.get(re.pubkey);if(ze&&ze.created_at>re.created_at)return;k.set(re.pubkey,re)}},onEose:()=>{if(!A){A=!0,t.debug(`[getRelayListForUsers] EOSE - relayListEvents: ${b.size}, contactListEvents: ${k.size}`);for(const re of b.values())f.set(re.pubkey,NDKRelayList$1.from(re));for(const re of n){if(f.has(re))continue;const ze=k.get(re);if(!ze)continue;const se=relayListFromKind3$1(t,ze);se&&f.set(re,se)}t.debug(`[getRelayListForUsers] Returning ${f.size} relay lists for ${n.length} pubkeys`),_(f)}}});const Z=Array.from(c).some(re=>re.status<=2),ve=Array.from(c).some(re=>re.status===4);let We=s;(Z||ve)&&(We=s+3e3),t.debug(`[getRelayListForUsers] Setting fallback timeout to ${We}ms (disconnected: ${Z}, connecting: ${ve})`,{pubkeys:n}),setTimeout(()=>{A||(A=!0,t.debug(`[getRelayListForUsers] Timeout reached, returning ${f.size} relay lists`),_(f))},We)})()})}var OutboxItem$1=class{type;relayUrlScores;readRelays;writeRelays;constructor(t){this.type=t,this.relayUrlScores=new Map,this.readRelays=new Set,this.writeRelays=new Set}},OutboxTracker$1=class extends import_tseep6.EventEmitter{data;ndk;debug;constructor(t){super(),this.ndk=t,this.debug=t.debug.extend("outbox-tracker"),this.data=new import_typescript_lru_cache2.LRUCache({maxSize:1e5,entryExpirationTimeInMS:120*1e3})}async trackUsers(t,r=!1){const s=[];for(let o=0;o<t.length;o+=400){const a=t.slice(o,o+400),c=a.map(g=>getKeyFromItem$1(g)).filter(g=>!this.data.has(g));if(c.length===0)continue;for(const g of c)this.data.set(g,new OutboxItem$1("user"));const f=new Map;for(const g of a)g instanceof NDKUser$1&&g.relayUrls.length>0&&f.set(g.pubkey,g.relayUrls);s.push(new Promise(g=>{getRelayListForUsers$1(c,this.ndk,r,1e3,f).then(m=>{this.debug(`Received relay lists for ${m.size} pubkeys out of ${c.length} requested`);for(const[b,k]of m){let _=this.data.get(b);if(_??=new OutboxItem$1("user"),k){if(_.readRelays=new Set(normalize2(k.readRelayUrls)),_.writeRelays=new Set(normalize2(k.writeRelayUrls)),this.ndk.relayConnectionFilter){for(const A of _.readRelays)this.ndk.relayConnectionFilter(A)||_.readRelays.delete(A);for(const A of _.writeRelays)this.ndk.relayConnectionFilter(A)||_.writeRelays.delete(A)}this.data.set(b,_),this.emit("user:relay-list-updated",b,_),this.debug(`Adding ${_.readRelays.size} read relays and ${_.writeRelays.size} write relays for ${b}`,k?.rawEvent())}}}).finally(g)}))}return Promise.all(s)}track(t,r,s=!0){const o=getKeyFromItem$1(t);r??=getTypeFromItem$1(t);let a=this.data.get(o);return a||(a=new OutboxItem$1(r),t instanceof NDKUser$1&&this.trackUsers([t])),a}};function getKeyFromItem$1(n){return n instanceof NDKUser$1?n.pubkey:n}function getTypeFromItem$1(n){return n instanceof NDKUser$1?"user":"kind"}function correctRelaySet$1(n,t){const r=t.connectedRelays();if(!Array.from(n.relays).some(o=>r.map(a=>a.url).includes(o.url)))for(const o of r)n.addRelay(o);if(r.length===0)for(const o of t.relays.values())n.addRelay(o);return n}var NDKSubscriptionManager$1=class{subscriptions;seenEvents=new import_typescript_lru_cache3.LRUCache({maxSize:1e4,entryExpirationTimeInMS:300*1e3});constructor(){this.subscriptions=new Map}add(t){this.subscriptions.set(t.internalId,t),t.onStopped,t.onStopped=()=>{this.subscriptions.delete(t.internalId)},t.on("close",()=>{this.subscriptions.delete(t.internalId)})}seenEvent(t,r){const s=this.seenEvents.get(t)||[];s.some(o=>o.url===r.url)||s.push(r),this.seenEvents.set(t,s)}dispatchEvent(t,r,s=!1){r&&this.seenEvent(t.id,r);const o=this.subscriptions.values(),a=[];for(const c of o)matchFilters$1(c.filters,t)&&a.push(c);for(const c of a){if(c.exclusiveRelay&&c.relaySet){let f=!1;if(s?f=!c.skipOptimisticPublishEvent:r?f=c.relaySet.relays.has(r):f=(this.seenEvents.get(t.id)||[]).some(m=>c.relaySet.relays.has(m)),!f){c.debug.extend("exclusive-relay")("Rejected event %s from %s (relay not in exclusive set)",t.id,r?.url||(s?"optimistic":"cache"));continue}}c.eventReceived(t,r,!1,s)}}},debug6$1=import_debug8.default("ndk:active-user");async function getUserRelayList$1(n){if(!this.autoConnectUserRelays)return;const t=await getRelayListForUser$1(n.pubkey,this);if(t){for(const r of t.relays){let s=this.pool.relays.get(r);s||(s=new NDKRelay$1(r,this.relayAuthDefaultPolicy,this),this.pool.addRelay(s))}return debug6$1("Connected to %d user relays",t.relays.length),t}}async function setActiveUser$1(n){if(!this.autoConnectUserRelays)return;const t=this.outboxPool||this.pool;t.connectedRelays.length>0?await getUserRelayList$1.call(this,n):t.once("connect",async()=>{await getUserRelayList$1.call(this,n)})}function getEntity$1(n){try{const t=nip19_exports$2.decode(n);return t.type==="npub"?npub$1(this,t.data):t.type==="nprofile"?nprofile$1(this,t.data):t}catch{return null}}function npub$1(n,t){return n.getUser({pubkey:t})}function nprofile$1(n,t){const r=n.getUser({pubkey:t.pubkey});return t.relays&&(r.relayUrls=t.relays),r}function isValidHint$1(n){if(!n||n==="")return!1;try{return new URL(n),!0}catch{return!1}}async function fetchEventFromTag$1(n,t,r,s={type:"timeout"}){const o=this.debug.extend("fetch-event-from-tag"),[a,c,f]=n;r={},o("fetching event from tag",n,r,s);const g=getRelaysForSync$1(this,t.pubkey);if(g&&g.size>0){o("fetching event from author relays %o",Array.from(g));const L=NDKRelaySet$1.fromRelayUrls(Array.from(g),this),Z=await this.fetchEvent(c,r,L);if(Z)return Z}else o("no author relays found for %s",t.pubkey,t);const m=calculateRelaySetsFromFilters$1(this,[{ids:[c]}],this.pool);o("fetching event without relay hint",m);const b=await this.fetchEvent(c,r);if(b)return b;if(f&&f!==""){const L=await this.fetchEvent(c,r,this.pool.getRelay(f,!0,!0,[{ids:[c]}]));if(L)return L}let k;const _=isValidHint$1(f)?this.pool.getRelay(f,!1,!0,[{ids:[c]}]):void 0,A=new Promise(L=>{this.fetchEvent(c,r,_).then(L)});if(!isValidHint$1(f)||s.type==="none")return A;const B=new Promise(async L=>{const Z=s.relaySet,ve=s.timeout??1500,We=new Promise(re=>setTimeout(re,ve));if(s.type==="timeout"&&await We,k)L(k);else{o("fallback fetch triggered");const re=await this.fetchEvent(c,r,Z);L(re)}});switch(s.type){case"timeout":return Promise.race([A,B]);case"eose":return k=await A,k||B}}var Queue2=class{queue=[];maxConcurrency;processing=new Set;promises=new Map;constructor(n,t){this.maxConcurrency=t}add(n){if(this.promises.has(n.id))return this.promises.get(n.id);const t=new Promise((r,s)=>{this.queue.push({...n,func:()=>n.func().then(o=>(r(o),o),o=>{throw s(o),o})}),this.process()});return this.promises.set(n.id,t),t.finally(()=>{this.promises.delete(n.id),this.processing.delete(n.id),this.process()}),t}process(){if(this.processing.size>=this.maxConcurrency||this.queue.length===0)return;const n=this.queue.shift();!n||this.processing.has(n.id)||(this.processing.add(n.id),n.func())}clear(){this.queue=[]}clearProcessing(){this.processing.clear()}clearAll(){this.clear(),this.clearProcessing()}length(){return this.queue.length}},DEFAULT_OUTBOX_RELAYS$1=["wss://purplepag.es/","wss://nos.lol/"];(class extends import_tseep5.EventEmitter{_explicitRelayUrls;pool;outboxPool;_signer;_activeUser;cacheAdapter;debug;devWriteRelaySet;outboxTracker;muteFilter;relayConnectionFilter;clientName;clientNip89;queuesZapConfig;queuesNip05;asyncSigVerification=!1;initialValidationRatio=1;lowestValidationRatio=.1;validationRatioFn;filterValidationMode="validate";subManager;aiGuardrails;futureTimestampGrace;_signatureVerificationFunction;_signatureVerificationWorker;signatureVerificationTimeMs=0;publishingFailureHandled=!1;pools=[];relayAuthDefaultPolicy;httpFetch;netDebug;autoConnectUserRelays=!0;_wallet;walletConfig;constructor(n={}){super(),this.debug=n.debug||import_debug7.default("ndk"),this.netDebug=n.netDebug,this._explicitRelayUrls=n.explicitRelayUrls||[],this.subManager=new NDKSubscriptionManager$1,this.pool=new NDKPool$1(n.explicitRelayUrls||[],this),this.pool.name="Main",this.pool.on("relay:auth",async(t,r)=>{this.relayAuthDefaultPolicy&&await this.relayAuthDefaultPolicy(t,r)}),this.autoConnectUserRelays=n.autoConnectUserRelays??!0,this.clientName=n.clientName,this.clientNip89=n.clientNip89,this.relayAuthDefaultPolicy=n.relayAuthDefaultPolicy,n.enableOutboxModel!==!1&&(this.outboxPool=new NDKPool$1(n.outboxRelayUrls||DEFAULT_OUTBOX_RELAYS$1,this,{debug:this.debug.extend("outbox-pool"),name:"Outbox Pool"}),this.outboxTracker=new OutboxTracker$1(this),this.outboxTracker.on("user:relay-list-updated",(t,r)=>{this.debug(`Outbox relay list updated for ${t}`);for(const s of this.subManager.subscriptions.values())s.filters.some(a=>a.authors?.includes(t))&&typeof s.refreshRelayConnections=="function"&&(this.debug(`Refreshing relay connections for subscription ${s.internalId}`),s.refreshRelayConnections())})),this.signer=n.signer,this.cacheAdapter=n.cacheAdapter,this.muteFilter=n.muteFilter,this.relayConnectionFilter=n.relayConnectionFilter,n.devWriteRelayUrls&&(this.devWriteRelaySet=NDKRelaySet$1.fromRelayUrls(n.devWriteRelayUrls,this)),this.queuesZapConfig=new Queue2("zaps",3),this.queuesNip05=new Queue2("nip05",10),n.signatureVerificationWorker&&(this.signatureVerificationWorker=n.signatureVerificationWorker),n.signatureVerificationFunction&&(this.signatureVerificationFunction=n.signatureVerificationFunction),this.initialValidationRatio=n.initialValidationRatio||1,this.lowestValidationRatio=n.lowestValidationRatio||.1,this.validationRatioFn=n.validationRatioFn||this.defaultValidationRatioFn,this.filterValidationMode=n.filterValidationMode||"validate",this.aiGuardrails=new AIGuardrails$1(n.aiGuardrails||!1),this.futureTimestampGrace=n.futureTimestampGrace,this.aiGuardrails.ndkInstantiated(this);try{this.httpFetch=fetch}catch{}}set explicitRelayUrls(n){this._explicitRelayUrls=n.map(normalizeRelayUrl$1),this.pool.relayUrls=n}get explicitRelayUrls(){return this._explicitRelayUrls||[]}set signatureVerificationWorker(n){this._signatureVerificationWorker=n,n?(signatureVerificationInit$1(n),this.asyncSigVerification=!0):this.asyncSigVerification=!1}set signatureVerificationFunction(n){this._signatureVerificationFunction=n,this.asyncSigVerification=!!n}get signatureVerificationFunction(){return this._signatureVerificationFunction}addExplicitRelay(n,t,r=!0){let s;return typeof n=="string"?s=new NDKRelay$1(n,t,this):s=n,this.pool.addRelay(s,r),this.explicitRelayUrls?.push(s.url),s}toJSON(){return{relayCount:this.pool.relays.size}.toString()}get activeUser(){return this._activeUser}set activeUser(n){const t=this._activeUser?.pubkey!==n?.pubkey;this._activeUser=n,t&&this.emit("activeUser:change",n),n&&t&&setActiveUser$1.call(this,n)}get signer(){return this._signer}set signer(n){this._signer=n,n&&this.emit("signer:ready",n),n?.user().then(t=>{t.ndk=this,this.activeUser=t})}async connect(n){this._signer&&this.autoConnectUserRelays&&(this.debug("Attempting to connect to user relays specified by signer %o",await this._signer.relays?.(this)),this._signer.relays&&(await this._signer.relays(this)).forEach(s=>this.pool.addRelay(s)));const t=[this.pool.connect(n)];return this.outboxPool&&t.push(this.outboxPool.connect(n)),this.cacheAdapter?.initializeAsync&&t.push(this.cacheAdapter.initializeAsync(this)),Promise.allSettled(t).then(()=>{})}reportInvalidSignature(n,t){this.debug(`Invalid signature detected for event ${n.id}${t?` from relay ${t.url}`:""}`),this.emit("event:invalid-sig",n,t)}defaultValidationRatioFn(n,t,r){if(t<10)return this.initialValidationRatio;const s=Math.min(t/100,1),o=this.initialValidationRatio*(1-s)+this.lowestValidationRatio*s;return Math.max(o,this.lowestValidationRatio)}getUser(n){if(typeof n=="string")if(n.startsWith("npub1")){const{type:r,data:s}=nip19_exports$2.decode(n);if(r!=="npub")throw new Error(`Invalid npub: ${n}`);return this.getUser({pubkey:s})}else if(n.startsWith("nprofile1")){const{type:r,data:s}=nip19_exports$2.decode(n);if(r!=="nprofile")throw new Error(`Invalid nprofile: ${n}`);return this.getUser({pubkey:s.pubkey,relayUrls:s.relays})}else return this.getUser({pubkey:n});const t=new NDKUser$1(n);return t.ndk=this,t}async getUserFromNip05(n,t=!1){return NDKUser$1.fromNip05(n,this,t)}async fetchUser(n,t=!1){if(isValidNip05$1(n))return NDKUser$1.fromNip05(n,this,t);if(n.startsWith("npub1")){const{type:r,data:s}=nip19_exports$2.decode(n);if(r!=="npub")throw new Error(`Invalid npub: ${n}`);const o=new NDKUser$1({pubkey:s});return o.ndk=this,o}else if(n.startsWith("nprofile1")){const{type:r,data:s}=nip19_exports$2.decode(n);if(r!=="nprofile")throw new Error(`Invalid nprofile: ${n}`);const o=new NDKUser$1({pubkey:s.pubkey,relayUrls:s.relays});return o.ndk=this,o}else{const r=new NDKUser$1({pubkey:n});return r.ndk=this,r}}subscribe(n,t,r=!0,s=!0){let o=t?.relaySet,a=s;r instanceof NDKRelaySet$1?(console.warn("relaySet is deprecated, use opts.relaySet instead. This will be removed in version v2.14.0"),o=r,a=s):(typeof r=="boolean"||typeof r=="object")&&(a=r);const c={relaySet:o,...t};a&&typeof a=="object"&&(a.onEvent&&(c.onEvent=a.onEvent),a.onEose&&(c.onEose=a.onEose),a.onClose&&(c.onClose=a.onClose),a.onEvents&&(c.onEvents=a.onEvents));const f=new NDKSubscription$1(this,n,c);this.subManager.add(f),this.aiGuardrails?.subscription?.created(Array.isArray(n)?n:[n],c);const g=f.pool;if(f.relaySet)for(const m of f.relaySet.relays)g.useTemporaryRelay(m,void 0,f.filters);if(this.outboxPool&&f.hasAuthorsFilter()){const m=f.filters.filter(b=>b.authors&&b.authors?.length>0).flatMap(b=>b.authors);this.outboxTracker?.trackUsers(m)}return a&&setTimeout(async()=>{this.cacheAdapter?.initializeAsync&&!this.cacheAdapter.ready&&await this.cacheAdapter.initializeAsync(this),f.start()},0),f}fetchEventFromTag=fetchEventFromTag$1.bind(this);fetchEventSync(n){if(!this.cacheAdapter)throw new Error("Cache adapter not set");let t;typeof n=="string"?t=[filterFromId$1(n)]:t=n;const r=new NDKSubscription$1(this,t),s=this.cacheAdapter.query(r);if(s instanceof Promise)throw new Error("Cache adapter is async");return s.map(o=>(o.ndk=this,o))}async fetchEvent(n,t,r){let s,o;if(r instanceof NDKRelay$1?o=new NDKRelaySet$1(new Set([r]),this):r instanceof NDKRelaySet$1&&(o=r),!r&&typeof n=="string"&&!isNip33AValue$1(n)){const a=relaysFromBech32$1(n,this);a.length>0&&(o=new NDKRelaySet$1(new Set(a),this),o=correctRelaySet$1(o,this.pool))}if(typeof n=="string"?s=[filterFromId$1(n)]:Array.isArray(n)?s=n:s=[n],typeof n!="string"&&this.aiGuardrails?.ndk?.fetchingEvents(s),s.length===0)throw new Error(`Invalid filter: ${JSON.stringify(n)}`);return new Promise((a,c)=>{let f=null;const g=_=>{_.ndk=this,_.isReplaceable()?(!f||f.created_at<_.created_at)&&(f=_):(clearTimeout(k),b?.stop(),this.aiGuardrails._nextCallDisabled=null,a(_))},m={...t||{},closeOnEose:!0,onEvents:_=>{for(const A of _)g(A)},onEvent:_=>{g(_)},onEose:()=>{clearTimeout(k),this.aiGuardrails._nextCallDisabled=null,a(f)}};o&&(m.relaySet=o);let b;const k=setTimeout(()=>{b.stop(),this.aiGuardrails._nextCallDisabled=null,a(f)},1e4);b=this.subscribe(s,m)})}async fetchEvents(n,t,r){return this.aiGuardrails?.ndk?.fetchingEvents(n,t),new Promise(s=>{const o=new Map,a=f=>{let g;f instanceof NDKEvent$1?g=f:g=new NDKEvent$1(void 0,f);const m=g.deduplicationKey(),b=o.get(m);b&&(g=dedup$1(b,g)),g.ndk=this,o.set(m,g)},c={...t||{},closeOnEose:!0,onEvents:f=>{for(const g of f)a(g)},onEvent:a,onEose:()=>{this.aiGuardrails._nextCallDisabled=null,s(new Set(o.values()))}};r&&(c.relaySet=r),this.subscribe(n,c)})}assertSigner(){if(!this.signer)throw this.emit("signer:required"),new Error("Signer required")}getEntity=getEntity$1.bind(this);guardrailOff(n){return n?typeof n=="string"?this.aiGuardrails._nextCallDisabled=new Set([n]):this.aiGuardrails._nextCallDisabled=new Set(n):this.aiGuardrails._nextCallDisabled="all",this}set wallet(n){if(!n){this._wallet=void 0,this.walletConfig=void 0;return}this._wallet=n,this.walletConfig??={},this.walletConfig.lnPay=n?.lnPay?.bind(n),this.walletConfig.cashuPay=n?.cashuPay?.bind(n)}get wallet(){return this._wallet}});var nip19_exports2={};__reExport$1(nip19_exports2,exports_nip19);var nip49_exports$1={};__reExport$1(nip49_exports$1,exports_nip49);function disconnect$1(n,t){return t??=import_debug9.default("ndk:relay:auth-policies:disconnect"),async r=>{t?.(`Relay ${r.url} requested authentication, disconnecting`),n.removeRelay(r.url)}}async function signAndAuth$1(n,t,r,s,o,a){try{await n.sign(r),o(n)}catch(c){s?.(`Failed to publish auth event to relay ${t.url}`,c),a(n)}}function signIn$1({ndk:n,signer:t,debug:r}={}){return r??=import_debug9.default("ndk:auth-policies:signIn"),async(s,o)=>{r?.(`Relay ${s.url} requested authentication, signing in`);const a=new NDKEvent$1(n);return a.kind=22242,a.tags=[["relay",s.url],["challenge",o]],t??=n?.signer,new Promise(async(c,f)=>{t?await signAndAuth$1(a,s,t,r,c,f):n?.once("signer:ready",async g=>{await signAndAuth$1(a,s,g,r,c,f)})})}}var NDKRelayAuthPolicies$1={disconnect:disconnect$1,signIn:signIn$1};async function ndkSignerFromPayload$1(n,t){let r;try{r=JSON.parse(n)}catch(o){console.error("Failed to parse signer payload string",n,o);return}if(!r||typeof r.type!="string"){console.error("Failed to parse signer payload string",n,new Error("Missing type field"));return}const s=signerRegistry$1.get(r.type);if(!s)throw new Error(`Unknown signer type: ${r.type}`);try{return await s.fromPayload(n,t)}catch(o){const a=o instanceof Error?o.message:String(o);throw new Error(`Failed to deserialize signer type ${r.type}: ${a}`)}}var NDKNip07Signer$1=class rr{_userPromise;encryptionQueue=[];encryptionProcessing=!1;debug;waitTimeout;_pubkey;ndk;_user;constructor(t=1e3,r){this.debug=import_debug10.default("ndk:nip07"),this.waitTimeout=t,this.ndk=r}get pubkey(){if(!this._pubkey)throw new Error("Not ready");return this._pubkey}async blockUntilReady(){await this.waitForExtension();const t=await window.nostr?.getPublicKey();if(!t)throw new Error("User rejected access");this._pubkey=t;let r;return this.ndk?r=this.ndk.getUser({pubkey:t}):r=new NDKUser$1({pubkey:t}),this._user=r,r}async user(){return this._userPromise||(this._userPromise=this.blockUntilReady()),this._userPromise}get userSync(){if(!this._user)throw new Error("User not ready");return this._user}async sign(t){await this.waitForExtension();const r=await window.nostr?.signEvent(t);if(!r)throw new Error("Failed to sign event");return r.sig}async relays(t){await this.waitForExtension();const r=await window.nostr?.getRelays?.()||{},s=[];for(const o of Object.keys(r))r[o].read&&r[o].write&&s.push(o);return s.map(o=>new NDKRelay$1(o,t?.relayAuthDefaultPolicy,t))}async encryptionEnabled(t){const r=[];return(!t||t==="nip04")&&window.nostr?.nip04&&r.push("nip04"),(!t||t==="nip44")&&window.nostr?.nip44&&r.push("nip44"),r}async encrypt(t,r,s="nip04"){if(!await this.encryptionEnabled(s))throw new Error(`${s}encryption is not available from your browser extension`);await this.waitForExtension();const o=t.pubkey;return this.queueEncryption(s,"encrypt",o,r)}async decrypt(t,r,s="nip04"){if(!await this.encryptionEnabled(s))throw new Error(`${s}encryption is not available from your browser extension`);await this.waitForExtension();const o=t.pubkey;return this.queueEncryption(s,"decrypt",o,r)}async queueEncryption(t,r,s,o){return new Promise((a,c)=>{this.encryptionQueue.push({scheme:t,method:r,counterpartyHexpubkey:s,value:o,resolve:a,reject:c}),this.encryptionProcessing||this.processEncryptionQueue()})}async processEncryptionQueue(t,r=0){if(!t&&this.encryptionQueue.length===0){this.encryptionProcessing=!1;return}this.encryptionProcessing=!0;const s=t||this.encryptionQueue.shift();if(!s){this.encryptionProcessing=!1;return}const{scheme:o,method:a,counterpartyHexpubkey:c,value:f,resolve:g,reject:m}=s;this.debug("Processing encryption queue item",{method:a,counterpartyHexpubkey:c,value:f});try{const b=await window.nostr?.[o]?.[a](c,f);if(!b)throw new Error("Failed to encrypt/decrypt");g(b)}catch(b){const k=b instanceof Error?b.message:String(b);if(k.includes("call already executing")&&r<5){this.debug("Retrying encryption queue item",{method:a,counterpartyHexpubkey:c,value:f,retries:r}),setTimeout(()=>{this.processEncryptionQueue(s,r+1)},50*r);return}m(b instanceof Error?b:new Error(k))}this.processEncryptionQueue()}waitForExtension(){return new Promise((t,r)=>{if(window.nostr){t();return}let s;const o=setInterval(()=>{window.nostr&&(clearTimeout(s),clearInterval(o),t())},100);s=setTimeout(()=>{clearInterval(o),r(new Error("NIP-07 extension not available"))},this.waitTimeout)})}toPayload(){return JSON.stringify({type:"nip07",payload:""})}static async fromPayload(t,r){const s=JSON.parse(t);if(s.type!=="nip07")throw new Error(`Invalid payload type: expected 'nip07', got ${s.type}`);return new rr(void 0,r)}};registerSigner$1("nip07",NDKNip07Signer$1);var NDKNostrRpc$1=class extends import_tseep7.EventEmitter{ndk;signer;relaySet;debug;encryptionType="nip44";pool;constructor(t,r,s,o){if(super(),this.ndk=t,this.signer=r,o){this.pool=new NDKPool$1(o,t,{debug:s.extend("rpc-pool"),name:"Nostr RPC"}),this.relaySet=new NDKRelaySet$1(new Set,t,this.pool);for(const a of o){const c=this.pool.getRelay(a,!1,!1);c.authPolicy=NDKRelayAuthPolicies$1.signIn({ndk:t,signer:r,debug:s}),this.relaySet.addRelay(c),c.connect()}}this.debug=s.extend("rpc")}subscribe(t){return new Promise(r=>{const s=this.ndk.subscribe(t,{closeOnEose:!1,groupable:!1,cacheUsage:"ONLY_RELAY",pool:this.pool,relaySet:this.relaySet,onEvent:async o=>{try{const a=await this.parseEvent(o);a.method?this.emit("request",a):(this.emit(`response-${a.id}`,a),this.emit("response",a))}catch(a){this.debug("error parsing event",a,o.rawEvent())}},onEose:()=>{this.debug("eosed"),r(s)}})})}async parseEvent(t){this.encryptionType==="nip44"&&t.content.includes("?iv=")?this.encryptionType="nip04":this.encryptionType==="nip04"&&!t.content.includes("?iv=")&&(this.encryptionType="nip44");const r=this.ndk.getUser({pubkey:t.pubkey});r.ndk=this.ndk;let s;try{s=await this.signer.decrypt(r,t.content,this.encryptionType)}catch{const k=this.encryptionType==="nip04"?"nip44":"nip04";s=await this.signer.decrypt(r,t.content,k),this.encryptionType=k}const o=JSON.parse(s),{id:a,method:c,params:f,result:g,error:m}=o;return c?{id:a,pubkey:t.pubkey,method:c,params:f,event:t}:{id:a,result:g,error:m,event:t}}async sendResponse(t,r,s,o=24133,a){const c={id:t,result:s};a&&(c.error=a);const f=await this.signer.user(),g=this.ndk.getUser({pubkey:r}),m=new NDKEvent$1(this.ndk,{kind:o,content:JSON.stringify(c),tags:[["p",r]],pubkey:f.pubkey});m.content=await this.signer.encrypt(g,m.content,this.encryptionType),await m.sign(this.signer),await m.publish(this.relaySet)}async sendRequest(t,r,s=[],o=24133,a){const c=Math.random().toString(36).substring(7),f=await this.signer.user(),g=this.ndk.getUser({pubkey:t}),m={id:c,method:r,params:s},b=new Promise(()=>{const _=A=>{A.result==="auth_url"?(this.once(`response-${c}`,_),this.emit("authUrl",A.error)):a&&a(A)};this.once(`response-${c}`,_)}),k=new NDKEvent$1(this.ndk,{kind:o,content:JSON.stringify(m),tags:[["p",t]],pubkey:f.pubkey});return k.content=await this.signer.encrypt(g,k.content,this.encryptionType),await k.sign(this.signer),await k.publish(this.relaySet),b}};function nostrConnectGenerateSecret$1(){return Math.random().toString(36).substring(2,15)}function generateNostrConnectUri$1(n,t,r,s){const o={name:s?.name?encodeURIComponent(s.name):"",url:s?.url?encodeURIComponent(s.url):"",image:s?.image?encodeURIComponent(s.image):"",perms:s?.perms?encodeURIComponent(s.perms):""};let a=`nostrconnect://${n}?image=${o.image}&url=${o.url}&name=${o.name}&perms=${o.perms}&secret=${encodeURIComponent(t)}`;return r&&(a+=`&relay=${encodeURIComponent(r)}`),a}var NDKNip46Signer$1=class fn extends import_tseep8.EventEmitter{ndk;_user;bunkerPubkey;userPubkey;get pubkey(){if(!this.userPubkey)throw new Error("Not ready");return this.userPubkey}secret;localSigner;nip05;rpc;debug;relayUrls;subscription;nostrConnectUri;nostrConnectSecret;constructor(t,r,s,o,a){super(),this.ndk=t,this.debug=t.debug.extend("nip46:signer"),this.relayUrls=o,s?typeof s=="string"?this.localSigner=new NDKPrivateKeySigner$1(s):this.localSigner=s:this.localSigner=NDKPrivateKeySigner$1.generate(),r===!1||(r?r.startsWith("bunker://")?this.bunkerFlowInit(r):this.nip05Init(r):this.nostrconnectFlowInit(a)),this.rpc=new NDKNostrRpc$1(this.ndk,this.localSigner,this.debug,this.relayUrls)}static bunker(t,r,s){return new fn(t,r,s)}static nostrconnect(t,r,s,o){return new fn(t,void 0,s,[r],o)}nostrconnectFlowInit(t){this.nostrConnectSecret=nostrConnectGenerateSecret$1();const r=this.localSigner.pubkey;this.nostrConnectUri=generateNostrConnectUri$1(r,this.nostrConnectSecret,this.relayUrls?.[0],t)}bunkerFlowInit(t){const r=new URL(t),s=r.hostname||r.pathname.replace(/^\/\//,""),o=r.searchParams.get("pubkey"),a=r.searchParams.getAll("relay"),c=r.searchParams.get("secret");this.bunkerPubkey=s,this.userPubkey=o,this.relayUrls=a,this.secret=c}nip05Init(t){this.nip05=t}async startListening(){if(this.subscription)return;const t=await this.localSigner.user();if(!t)throw new Error("Local signer not ready");this.subscription=await this.rpc.subscribe({kinds:[24133],"#p":[t.pubkey]})}async user(){return this._user?this._user:this.blockUntilReady()}get userSync(){if(!this._user)throw new Error("Remote user not ready synchronously");return this._user}async blockUntilReadyNostrConnect(){return new Promise((t,r)=>{const s=o=>{o.result===this.nostrConnectSecret&&(this._user=o.event.author,this.userPubkey=o.event.pubkey,this.bunkerPubkey=o.event.pubkey,this.rpc.off("response",s),t(this._user))};this.startListening(),this.rpc.on("response",s)})}async blockUntilReady(){if(!this.bunkerPubkey&&!this.nostrConnectSecret&&!this.nip05)throw new Error("Bunker pubkey not set");if(this.nostrConnectSecret)return this.blockUntilReadyNostrConnect();if(this.nip05&&!this.userPubkey){const t=await NDKUser$1.fromNip05(this.nip05,this.ndk);t&&(this._user=t,this.userPubkey=t.pubkey,this.relayUrls=t.nip46Urls,this.rpc=new NDKNostrRpc$1(this.ndk,this.localSigner,this.debug,this.relayUrls))}if(!this.bunkerPubkey&&this.userPubkey)this.bunkerPubkey=this.userPubkey;else if(!this.bunkerPubkey)throw new Error("Bunker pubkey not set");return await this.startListening(),this.rpc.on("authUrl",(...t)=>{this.emit("authUrl",...t)}),new Promise((t,r)=>{const s=[this.userPubkey??""];if(this.secret&&s.push(this.secret),!this.bunkerPubkey)throw new Error("Bunker pubkey not set");this.rpc.sendRequest(this.bunkerPubkey,"connect",s,24133,o=>{o.result==="ack"?this.getPublicKey().then(a=>{this.userPubkey=a,this._user=this.ndk.getUser({pubkey:a}),t(this._user)}):r(o.error)})})}stop(){this.subscription?.stop(),this.subscription=void 0}async getPublicKey(){return this.userPubkey?this.userPubkey:new Promise((t,r)=>{if(!this.bunkerPubkey)throw new Error("Bunker pubkey not set");this.rpc.sendRequest(this.bunkerPubkey,"get_public_key",[],24133,s=>{t(s.result)})})}async encryptionEnabled(t){return t?[t]:Promise.resolve(["nip04","nip44"])}async encrypt(t,r,s="nip04"){return this.encryption(t,r,s,"encrypt")}async decrypt(t,r,s="nip04"){return this.encryption(t,r,s,"decrypt")}async encryption(t,r,s,o){return new Promise((c,f)=>{if(!this.bunkerPubkey)throw new Error("Bunker pubkey not set");this.rpc.sendRequest(this.bunkerPubkey,`${s}_${o}`,[t.pubkey,r],24133,g=>{g.error?f(g.error):c(g.result)})})}async sign(t){return new Promise((s,o)=>{if(!this.bunkerPubkey)throw new Error("Bunker pubkey not set");this.rpc.sendRequest(this.bunkerPubkey,"sign_event",[JSON.stringify(t)],24133,a=>{if(a.error)o(a.error);else{const c=JSON.parse(a.result);s(c.sig)}})})}async createAccount(t,r,s){await this.startListening();const o=[];return t&&o.push(t),r&&o.push(r),s&&o.push(s),new Promise((a,c)=>{if(!this.bunkerPubkey)throw new Error("Bunker pubkey not set");this.rpc.sendRequest(this.bunkerPubkey,"create_account",o,24133,f=>{if(f.error)c(f.error);else{const g=f.result;a(g)}})})}toPayload(){if(!this.bunkerPubkey||!this.userPubkey)throw new Error("NIP-46 signer is not fully initialized for serialization");const t={type:"nip46",payload:{bunkerPubkey:this.bunkerPubkey,userPubkey:this.userPubkey,relayUrls:this.relayUrls,secret:this.secret,localSignerPayload:this.localSigner.toPayload(),nip05:this.nip05||null}};return JSON.stringify(t)}static async fromPayload(t,r){if(!r)throw new Error("NDK instance is required to deserialize NIP-46 signer");const s=JSON.parse(t);if(s.type!=="nip46")throw new Error(`Invalid payload type: expected 'nip46', got ${s.type}`);const o=s.payload;if(!o||typeof o!="object"||!o.localSignerPayload)throw new Error("Invalid payload content for nip46 signer");const a=await ndkSignerFromPayload$1(o.localSignerPayload,r);if(!a)throw new Error("Failed to deserialize local signer for NIP-46");if(!(a instanceof NDKPrivateKeySigner$1))throw new Error("Local signer must be an instance of NDKPrivateKeySigner");let c;return c=new fn(r,!1,a,o.relayUrls),c.userPubkey=o.userPubkey,c.bunkerPubkey=o.bunkerPubkey,c.relayUrls=o.relayUrls,c.secret=o.secret,o.userPubkey&&(c._user=new NDKUser$1({pubkey:o.userPubkey}),c._user&&(c._user.ndk=r)),c}};registerSigner$1("nip46",NDKNip46Signer$1);function matchFilter2(n,t){if(n.ids&&n.ids.indexOf(t.id)===-1||n.kinds&&n.kinds.indexOf(t.kind)===-1||n.authors&&n.authors.indexOf(t.pubkey)===-1)return!1;for(const r in n)if(r[0]==="#"){const s=r.slice(1);if(s==="t"){const o=n[`#${s}`]?.map(a=>a.toLowerCase());if(o&&!t.tags.find(([a,c])=>a===s&&o?.indexOf(c.toLowerCase())!==-1))return!1}else{const o=n[`#${s}`];if(o&&!t.tags.find(([a,c])=>a===s&&o?.indexOf(c)!==-1))return!1}}return!(n.since&&t.created_at<n.since||n.until&&t.created_at>n.until)}import_debug12.default("ndk:zapper:ln");import_debug11.default("ndk:zapper");async function getDecryptedEvent(n){await this.ensureInitialized();const t=await this.postWorkerMessage({type:"getDecryptedEvent",payload:{wrapperId:n}});if(t&&t.event)try{const r=deserialize$1(t.event);return new NDKEvent$1(this.ndk,r)}catch(r){return console.error("[getDecryptedEvent] Parse error:",r),null}return null}async function getEvent(n){await this.ensureInitialized();const t=await this.postWorkerMessage({type:"getEvent",payload:{id:n}});if(t&&t.raw)try{return JSON.parse(t.raw)}catch{return null}return null}async function getProfiles(n){if(await this.ensureInitialized(),typeof n=="function")throw new Error("getProfiles with filter functions is not supported in worker mode. Use filter descriptors instead.");const t=await this.postWorkerMessage({type:"getProfiles",payload:n}),r=new Map;for(const{pubkey:s,profile:o}of t)r.set(s,o);return r}async function getRelayStatus(n){await this.ensureInitialized();const t=this.metadataCache?.getRelayInfo(n);if(t)return t;const r=await this.postWorkerMessage({type:"getRelayStatus",payload:{relayUrl:n}});if(r&&r.info)try{const s=JSON.parse(r.info);return this.metadataCache?.setRelayInfo(n,s),s}catch{return}}async function getUnpublishedEvents(){await this.ensureInitialized();const n=await this.postWorkerMessage({type:"getUnpublishedEvents",payload:{}}),t=[];if(n)for(const r of n)try{const s=JSON.parse(r.event),o=r.relays?JSON.parse(r.relays):[];t.push({event:s,relays:o,lastTryAt:r.lastTryAt})}catch{}return t}async function loadNip05(n,t=3600){await this.ensureInitialized();const r=this.metadataCache?.getNip05(n);if(r!==void 0){if(r.profile===null||r.profile===void 0){const a=Date.now();return r.fetched_at&&r.fetched_at+t*1e3<a?"missing":null}return r.profile}const s=await this.postWorkerMessage({type:"loadNip05",payload:{nip05:n}});if(!s)return"missing";const o=Date.now();if(this.metadataCache?.setNip05(n,s),s.profile===null||s.profile===void 0)return s.fetched_at&&s.fetched_at+t*1e3<o?"missing":null;try{return JSON.parse(s.profile)}catch{return"missing"}}function query(n){return this.ready?queryWorker.call(this,n):this.initializationPromise?this.initializationPromise.then(async()=>await queryWorker.call(this,n)):[]}async function queryWorker(n){const t=filterForCache(n),r=await this.postWorkerMessage({type:"query",payload:{filters:t,cacheUnconstrainFilter:n.cacheUnconstrainFilter,subId:n.subId}}),{decodeEvents:s}=await Promise.resolve().then(()=>exports_decoder);let o;try{o=s(r.buffer)}catch(c){return console.error("Failed to decode events from cache, cache may be corrupted:",c),[]}const a=new Map;for(const c of t){const f=foundEvents(n,o,c);for(const{event:g,relayUrl:m}of f)if(g&&g.id&&(a.set(g.id,g),m)){const b=n.pool.getRelay(m,!1);b&&(g.relay=b,n.ndk&&n.ndk.subManager.seenEvent(g.id,b))}}return Array.from(a.values())}function filterForCache(n){return n.cacheUnconstrainFilter?n.filters.map(r=>({...r})).filter(r=>{for(const s of n.cacheUnconstrainFilter)delete r[s];return Object.keys(r).length>0}):n.filters}function foundEvents(n,t,r){const s=[];let o;for(const a of t){const c=foundEvent(n,a,a.relay,r);if(c){const f=c.event.tagValue("expiration");if(f&&(o??=Math.floor(Date.now()/1e3),o>Number.parseInt(f)))continue;if(s.push(c),r?.limit&&s.length>=r.limit)break}}return s}function foundEvent(n,t,r,s){try{let o;if("raw"in t&&t.raw!==void 0&&t.raw!==null){const f=JSON.parse(t.raw);Array.isArray(f)?o={id:f[0],pubkey:f[1],created_at:f[2],kind:f[3],tags:f[4],content:f[5],sig:f[6]}:o=f}else o={id:t.id,pubkey:t.pubkey,created_at:t.created_at,kind:t.kind,tags:t.tags,content:t.content,sig:t.sig};if(s&&!matchFilter2(s,o))return null;const a=new NDKEvent$1(void 0,o),c=("relay_url"in t?t.relay_url:null)||null;return{event:a,relayUrl:c}}catch(o){return console.error("failed to deserialize event",o,"record:",t,"record.raw:","raw"in t?t.raw:void 0),null}}async function saveNip05(n,t){const r=t?JSON.stringify(t):null,s=Date.now();await this.ensureInitialized(),this.metadataCache?.setNip05(n,{profile:r,fetched_at:s}),await this.postWorkerMessage({type:"saveNip05",payload:{nip05:n,profile:r,fetchedAt:s}})}async function saveProfile(n,t){const r=JSON.stringify(t),s=Math.floor(Date.now()/1e3);await this.ensureInitialized();const o={...t,cachedAt:s};this.metadataCache?.setProfile(n,o),await this.postWorkerMessage({type:"saveProfile",payload:{pubkey:n,profile:r,updatedAt:s}})}async function setEvent(n,t,r){await this.ensureInitialized(),await this.batchEvent({id:n.id,pubkey:n.pubkey,created_at:n.created_at,kind:n.kind,tags:n.tags,content:n.content,sig:n.sig},r?.url)}async function updateRelayStatus(n,t){const r=await this.getRelayStatus(n),s={...r,...t,metadata:{...r?.metadata,...t.metadata}};if(s.metadata)for(const[o,a]of Object.entries(s.metadata))a===void 0&&delete s.metadata[o];await this.ensureInitialized(),this.metadataCache?.setRelayInfo(n,s),await this.postWorkerMessage({type:"updateRelayStatus",payload:{relayUrl:n,info:JSON.stringify(s)}})}class MetadataLRUCache{profiles;relayInfo;nip05;maxSize;profileAccessOrder;relayAccessOrder;nip05AccessOrder;constructor(t=1e3){this.profiles=new Map,this.relayInfo=new Map,this.nip05=new Map,this.maxSize=t,this.profileAccessOrder=[],this.relayAccessOrder=[],this.nip05AccessOrder=[]}getProfile(t){const r=this.profiles.get(t);if(r){const s=this.profileAccessOrder.indexOf(t);s>-1&&this.profileAccessOrder.splice(s,1),this.profileAccessOrder.push(t)}return r?.value}setProfile(t,r){this.profiles.set(t,{value:r,timestamp:Date.now()});const s=this.profileAccessOrder.indexOf(t);if(s>-1&&this.profileAccessOrder.splice(s,1),this.profileAccessOrder.push(t),this.profiles.size>this.maxSize){const o=this.profileAccessOrder.shift();o&&this.profiles.delete(o)}}deleteProfile(t){this.profiles.delete(t);const r=this.profileAccessOrder.indexOf(t);r>-1&&this.profileAccessOrder.splice(r,1)}getRelayInfo(t){const r=this.relayInfo.get(t);if(r){const s=this.relayAccessOrder.indexOf(t);s>-1&&this.relayAccessOrder.splice(s,1),this.relayAccessOrder.push(t)}return r?.value}setRelayInfo(t,r){this.relayInfo.set(t,{value:r,timestamp:Date.now()});const s=this.relayAccessOrder.indexOf(t);if(s>-1&&this.relayAccessOrder.splice(s,1),this.relayAccessOrder.push(t),this.relayInfo.size>this.maxSize){const o=this.relayAccessOrder.shift();o&&this.relayInfo.delete(o)}}deleteRelayInfo(t){this.relayInfo.delete(t);const r=this.relayAccessOrder.indexOf(t);r>-1&&this.relayAccessOrder.splice(r,1)}getNip05(t){const r=this.nip05.get(t);if(r){const s=this.nip05AccessOrder.indexOf(t);s>-1&&this.nip05AccessOrder.splice(s,1),this.nip05AccessOrder.push(t)}return r?.value}setNip05(t,r){this.nip05.set(t,{value:r,timestamp:Date.now()});const s=this.nip05AccessOrder.indexOf(t);if(s>-1&&this.nip05AccessOrder.splice(s,1),this.nip05AccessOrder.push(t),this.nip05.size>this.maxSize){const o=this.nip05AccessOrder.shift();o&&this.nip05.delete(o)}}deleteNip05(t){this.nip05.delete(t);const r=this.nip05AccessOrder.indexOf(t);r>-1&&this.nip05AccessOrder.splice(r,1)}clear(){this.profiles.clear(),this.relayInfo.clear(),this.nip05.clear(),this.profileAccessOrder=[],this.relayAccessOrder=[],this.nip05AccessOrder=[]}getMetrics(){return{profileCount:this.profiles.size,relayInfoCount:this.relayInfo.size,nip05Count:this.nip05.size,totalCount:this.profiles.size+this.relayInfo.size+this.nip05.size,maxSize:this.maxSize}}}var PACKAGE_VERSION="0.8.2";class NDKCacheAdapterSqliteWasm{dbName;wasmUrl;locking=!1;ndk;ready=!1;worker;workerUrl;pendingRequests=new Map;nextRequestId=0;initializationPromise;metadataCache;eventBatch=[];batchTimeout=null;BATCH_DELAY_MS=0;MAX_BATCH_SIZE=100;saveDebounceMs;disableAutosave;constructor(t={}){this.dbName=t.dbName||"ndk-cache",this.wasmUrl=t.wasmUrl,this.workerUrl=t.workerUrl,this.saveDebounceMs=t.saveDebounceMs,this.disableAutosave=t.disableAutosave,this.metadataCache=new MetadataLRUCache(t.metadataLruSize||1e3)}async initializeAsync(t){return this.initializationPromise?this.initializationPromise:(this.initializationPromise=(async()=>{this.ndk=t,await this.initializeWorker(),this.ready=!0})(),this.initializationPromise)}async initializeWorker(){let t=this.workerUrl;if(!t)try{t=new URL(""+new URL("../assets/worker.Dfd9wYkT.js",import.meta.url).href,import.meta.url).toString()}catch(r){throw console.error("Failed to determine worker URL automatically. Please provide 'workerUrl' option.",r),new Error("Worker URL configuration error.")}try{this.worker=new Worker(t,{type:"module"})}catch(r){const o=function(a){return typeof a=="object"&&a!==null&&"message"in a&&typeof a.message=="string"}(r)?r.message.toLowerCase():"";throw o.includes("404")||o.includes("not found")||o.includes("failed to fetch")||o.includes("networkerror")||o.includes("could not load")||o.includes("cannot find")?console.error(`[NDK-cache-sqlite-wasm] Failed to load worker file at "${t}".
This usually means the worker asset is missing or not served correctly (e.g., 404 error).
Please ensure the worker file exists at the specified URL and is accessible to the browser. Check your bundler configuration and asset paths. See the documentation for details.`,r):console.error(`[NDK-cache-sqlite-wasm] Error while creating worker at "${t}":`,r),r}this.worker.onmessage=r=>{const s=r.data;if(s.type==="warmupProfiles"){this.handleProfileWarmup(s.profiles);return}if(s._protocol&&s._protocol!=="ndk-cache-sqlite"){console.error("[NDK Cache SQLite WASM]  Wrong worker protocol!",`

Expected: ndk-cache-sqlite`,`
Received: ${s._protocol}`,`

This means the wrong worker instance was passed to the cache adapter.`,`
Make sure you are using the correct worker file for the cache.`);return}s._version&&s._version!==PACKAGE_VERSION&&console.warn("[NDK Cache SQLite WASM]   Worker version mismatch!",`
Library version: ${PACKAGE_VERSION}`,`
Worker version: ${s._version}`,`

Update your worker file:`,`
  cp node_modules/@nostr-dev-kit/cache-sqlite-wasm/dist/worker.js public/`);const{id:o,result:a,error:c}=s,f=this.pendingRequests.get(o);f&&(c?f.reject(new Error(`Worker error: ${c.message||c}`)):f.resolve(a),this.pendingRequests.delete(o))},this.worker.onerror=r=>{const s=r.message||"unknown error";console.error(`[NDK-cache-sqlite-wasm]  Worker failed: ${s}

 Common solutions:
1. Copy worker.js and sql-wasm.wasm to your public directory:
   cp node_modules/@nostr-dev-kit/cache-sqlite-wasm/dist/worker.js public/
   cp node_modules/@nostr-dev-kit/cache-sqlite-wasm/dist/sql-wasm.wasm public/

2. Ensure your bundler serves the public directory correctly

3. Check browser DevTools Network tab for 404 errors on worker.js

Current workerUrl: ${t}`),this.pendingRequests.forEach(o=>o.reject(new Error(`Worker failed: ${s}. Check console for setup instructions.`))),this.pendingRequests.clear()},await this.postWorkerMessage({type:"init",payload:{dbName:this.dbName,wasmUrl:this.wasmUrl,saveDebounceMs:this.saveDebounceMs,disableAutosave:this.disableAutosave}})}async postWorkerMessage(t){if(!this.worker)return Promise.reject(new Error("Worker not initialized"));const r=`req-${this.nextRequestId++}`;return new Promise((s,o)=>{this.pendingRequests.set(r,{resolve:s,reject:o});const a={...t,id:r};this.worker.postMessage(a)})}handleProfileWarmup(t){for(const{pubkey:r,profile:s}of t)this.metadataCache.setProfile(r,s)}async flushEventBatch(){if(this.eventBatch.length===0)return;const t=this.eventBatch;this.eventBatch=[],this.batchTimeout=null;try{await this.postWorkerMessage({type:"setEventBatch",payload:{events:t.map(r=>({event:r.event,relay:r.relay}))}}),t.forEach(r=>r.resolve())}catch(r){const s=r instanceof Error?r:new Error(String(r));t.forEach(o=>o.reject(s))}}batchEvent(t,r){return new Promise((s,o)=>{this.eventBatch.push({event:t,relay:r,resolve:s,reject:o}),this.eventBatch.length>=this.MAX_BATCH_SIZE?(this.batchTimeout!==null&&(clearTimeout(this.batchTimeout),this.batchTimeout=null),this.flushEventBatch()):this.batchTimeout===null&&(this.batchTimeout=setTimeout(()=>{this.flushEventBatch()},this.BATCH_DELAY_MS))})}async setEvent(t,r,s){return setEvent.call(this,t,r,s)}async getEvent(t){return getEvent.call(this,t)}async fetchProfile(t){return fetchProfile.call(this,t)}async saveProfile(t,r){return saveProfile.call(this,t,r)}async updateRelayStatus(t,r){return updateRelayStatus.call(this,t,r)}async getRelayStatus(t){return getRelayStatus.call(this,t)}async getDecryptedEvent(t){return getDecryptedEvent.call(this,t)}async addDecryptedEvent(t,r){return addDecryptedEvent.call(this,t,r)}async addUnpublishedEvent(t,r,s=Date.now()){return addUnpublishedEvent.call(this,t,r,s)}async getUnpublishedEvents(){return getUnpublishedEvents.call(this)}async discardUnpublishedEvent(t){return discardUnpublishedEvent.call(this,t)}query(t){return query.call(this,t)}async getProfiles(t){return getProfiles.call(this,t)}async getCacheStats(){return getCacheStats.call(this)}async loadNip05(t){return loadNip05.call(this,t)}async saveNip05(t,r){return saveNip05.call(this,t,r)}getMetadataCacheStatus(){return this.metadataCache.getMetrics()}clearMetadataCache(){this.metadataCache.clear()}async getCacheData(t,r,s){return await this.ensureInitialized(),await this.postWorkerMessage({type:"getCacheData",payload:{namespace:t,key:r,maxAgeInSecs:s}})}async setCacheData(t,r,s){await this.ensureInitialized(),await this.postWorkerMessage({type:"setCacheData",payload:{namespace:t,key:r,data:s}})}async ensureInitialized(){this.ready||this.initializationPromise&&await this.initializationPromise}}var src_default=NDKCacheAdapterSqliteWasm;function getDefaultExportFromCjs(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function getAugmentedNamespace(n){if(Object.prototype.hasOwnProperty.call(n,"__esModule"))return n;var t=n.default;if(typeof t=="function"){var r=function s(){var o=!1;try{o=this instanceof s}catch{}return o?Reflect.construct(t,arguments,this.constructor):t.apply(this,arguments)};r.prototype=t.prototype}else r={};return Object.defineProperty(r,"__esModule",{value:!0}),Object.keys(n).forEach(function(s){var o=Object.getOwnPropertyDescriptor(n,s);Object.defineProperty(r,s,o.get?o:{enumerable:!0,get:function(){return n[s]}})}),r}var lib={},types={},hasRequiredTypes;function requireTypes(){return hasRequiredTypes||(hasRequiredTypes=1,Object.defineProperty(types,"__esModule",{value:!0})),types}var ee={},taskCollection$1={},taskCollection={},utils$2={},hasRequiredUtils$1;function requireUtils$1(){if(hasRequiredUtils$1)return utils$2;hasRequiredUtils$1=1,Object.defineProperty(utils$2,"__esModule",{value:!0}),utils$2._fast_remove_single=void 0;function n(t,r){r!==-1&&(r===0?t.shift():r===t.length-1?t.length=t.length-1:t.splice(r,1))}return utils$2._fast_remove_single=n,utils$2}var bakeCollection={},hasRequiredBakeCollection;function requireBakeCollection(){return hasRequiredBakeCollection||(hasRequiredBakeCollection=1,(function(exports){Object.defineProperty(exports,"__esModule",{value:!0}),exports.bakeCollectionVariadic=exports.bakeCollectionAwait=exports.bakeCollection=exports.BAKED_EMPTY_FUNC=void 0,exports.BAKED_EMPTY_FUNC=(function(){});var FORLOOP_FALLBACK=1500;function generateArgsDefCode(n){var t="";if(n===0)return t;for(var r=0;r<n-1;++r)t+="arg"+String(r)+", ";return t+="arg"+String(n-1),t}function generateBodyPartsCode(n,t){for(var r="",s="",o=0;o<t;++o)r+="var f".concat(o," = collection[").concat(o,`];
`),s+="f".concat(o,"(").concat(n,`)
`);return{funcDefCode:r,funcCallCode:s}}function generateBodyPartsVariadicCode(n){for(var t="",r="",s=0;s<n;++s)t+="var f".concat(s," = collection[").concat(s,`];
`),r+="f".concat(s,`.apply(undefined, arguments)
`);return{funcDefCode:t,funcCallCode:r}}function bakeCollection(collection,fixedArgsNum){if(collection.length===0)return exports.BAKED_EMPTY_FUNC;if(collection.length===1)return collection[0];var funcFactoryCode;if(collection.length<FORLOOP_FALLBACK){var argsDefCode=generateArgsDefCode(fixedArgsNum),_a=generateBodyPartsCode(argsDefCode,collection.length),funcDefCode=_a.funcDefCode,funcCallCode=_a.funcCallCode;funcFactoryCode=`(function(collection) {
            `.concat(funcDefCode,`
            collection = undefined;
            return (function(`).concat(argsDefCode,`) {
                `).concat(funcCallCode,`
            });
        })`)}else{var argsDefCode=generateArgsDefCode(fixedArgsNum);collection.length%10===0?funcFactoryCode=`(function(collection) {
                return (function(`.concat(argsDefCode,`) {
                    for (var i = 0; i < collection.length; i += 10) {
                        collection[i](`).concat(argsDefCode,`);
                        collection[i+1](`).concat(argsDefCode,`);
                        collection[i+2](`).concat(argsDefCode,`);
                        collection[i+3](`).concat(argsDefCode,`);
                        collection[i+4](`).concat(argsDefCode,`);
                        collection[i+5](`).concat(argsDefCode,`);
                        collection[i+6](`).concat(argsDefCode,`);
                        collection[i+7](`).concat(argsDefCode,`);
                        collection[i+8](`).concat(argsDefCode,`);
                        collection[i+9](`).concat(argsDefCode,`);
                    }
                });
            })`):collection.length%4===0?funcFactoryCode=`(function(collection) {
                return (function(`.concat(argsDefCode,`) {
                    for (var i = 0; i < collection.length; i += 4) {
                        collection[i](`).concat(argsDefCode,`);
                        collection[i+1](`).concat(argsDefCode,`);
                        collection[i+2](`).concat(argsDefCode,`);
                        collection[i+3](`).concat(argsDefCode,`);
                    }
                });
            })`):collection.length%3===0?funcFactoryCode=`(function(collection) {
                return (function(`.concat(argsDefCode,`) {
                    for (var i = 0; i < collection.length; i += 3) {
                        collection[i](`).concat(argsDefCode,`);
                        collection[i+1](`).concat(argsDefCode,`);
                        collection[i+2](`).concat(argsDefCode,`);
                    }
                });
            })`):funcFactoryCode=`(function(collection) {
                return (function(`.concat(argsDefCode,`) {
                    for (var i = 0; i < collection.length; ++i) {
                        collection[i](`).concat(argsDefCode,`);
                    }
                });
            })`)}{var funcFactory=eval(funcFactoryCode);return funcFactory(collection)}}exports.bakeCollection=bakeCollection;function bakeCollectionAwait(collection,fixedArgsNum){if(collection.length===0)return exports.BAKED_EMPTY_FUNC;if(collection.length===1)return collection[0];var funcFactoryCode;if(collection.length<FORLOOP_FALLBACK){var argsDefCode=generateArgsDefCode(fixedArgsNum),_a=generateBodyPartsCode(argsDefCode,collection.length),funcDefCode=_a.funcDefCode,funcCallCode=_a.funcCallCode;funcFactoryCode=`(function(collection) {
            `.concat(funcDefCode,`
            collection = undefined;
            return (function(`).concat(argsDefCode,`) {
                return Promise.all([ `).concat(funcCallCode,` ]);
            });
        })`)}else{var argsDefCode=generateArgsDefCode(fixedArgsNum);funcFactoryCode=`(function(collection) {
            return (function(`.concat(argsDefCode,`) {
                var promises = Array(collection.length);
                for (var i = 0; i < collection.length; ++i) {
                    promises[i] = collection[i](`).concat(argsDefCode,`);
                }
                return Promise.all(promises);
            });
        })`)}{var funcFactory=eval(funcFactoryCode);return funcFactory(collection)}}exports.bakeCollectionAwait=bakeCollectionAwait;function bakeCollectionVariadic(collection){if(collection.length===0)return exports.BAKED_EMPTY_FUNC;if(collection.length===1)return collection[0];var funcFactoryCode;if(collection.length<FORLOOP_FALLBACK){var _a=generateBodyPartsVariadicCode(collection.length),funcDefCode=_a.funcDefCode,funcCallCode=_a.funcCallCode;funcFactoryCode=`(function(collection) {
            `.concat(funcDefCode,`
            collection = undefined;
            return (function() {
                `).concat(funcCallCode,`
            });
        })`)}else funcFactoryCode=`(function(collection) {
            return (function() {
                for (var i = 0; i < collection.length; ++i) {
                    collection[i].apply(undefined, arguments);
                }
            });
        })`;{var funcFactory=eval(funcFactoryCode);return funcFactory(collection)}}exports.bakeCollectionVariadic=bakeCollectionVariadic})(bakeCollection)),bakeCollection}var hasRequiredTaskCollection$1;function requireTaskCollection$1(){if(hasRequiredTaskCollection$1)return taskCollection;hasRequiredTaskCollection$1=1;var n=taskCollection&&taskCollection.__spreadArray||function(re,ze,se){if(se||arguments.length===2)for(var ne=0,X=ze.length,$e;ne<X;ne++)($e||!(ne in ze))&&($e||($e=Array.prototype.slice.call(ze,0,ne)),$e[ne]=ze[ne]);return re.concat($e||Array.prototype.slice.call(ze))};Object.defineProperty(taskCollection,"__esModule",{value:!0}),taskCollection.TaskCollection=void 0;var t=requireUtils$1(),r=requireBakeCollection();function s(re,ze){var se=this.length;if(se>1)if(ze){var ne;(ne=this._tasks).push.apply(ne,arguments),this.length+=arguments.length}else this._tasks.push(re),this.length++;else if(ze){if(se===1){var X=Array(1+arguments.length);X.push(X),X.push.apply(X,arguments),this._tasks=X}else{var X=Array(arguments.length);X.push.apply(X,arguments),this._tasks=X}this.length+=arguments.length}else se===1?this._tasks=[this._tasks,re]:this._tasks=re,this.length++}function o(re,ze){var se=this.length;if(se>1)if(ze){var ne;(ne=this._tasks).push.apply(ne,arguments),this.length+=arguments.length}else this._tasks.push(re),this.length++;else if(ze){if(se===1){var X=Array(1+arguments.length);X.push(X),X.push.apply(X,arguments),this._tasks=X}else{var X=Array(arguments.length);X.push.apply(X,arguments),this._tasks=X}this.length+=arguments.length}else se===1?this._tasks=[this._tasks,re]:this._tasks=re,this.length++;this.firstEmitBuildStrategy?this.call=k:this.rebuild()}function a(re){this.length!==0&&(this.length===1?this._tasks===re&&(this.length=0):((0,t._fast_remove_single)(this._tasks,this._tasks.lastIndexOf(re)),this._tasks.length===1?(this._tasks=this._tasks[0],this.length=1):this.length=this._tasks.length))}function c(re){if(this.length!==0){if(this.length===1)if(this._tasks===re&&(this.length=0),this.firstEmitBuildStrategy){this.call=r.BAKED_EMPTY_FUNC;return}else{this.rebuild();return}else(0,t._fast_remove_single)(this._tasks,this._tasks.lastIndexOf(re)),this._tasks.length===1?(this._tasks=this._tasks[0],this.length=1):this.length=this._tasks.length;this.firstEmitBuildStrategy?this.call=k:this.rebuild()}}function f(re){for(var ze,se=[],ne=1;ne<arguments.length;ne++)se[ne-1]=arguments[ne];this.length===0?(this._tasks=se,this.length=1):this.length===1?(se.unshift(this._tasks),this._tasks=se,this.length=this._tasks.length):((ze=this._tasks).splice.apply(ze,n([re,0],se,!1)),this.length=this._tasks.length)}function g(re){for(var ze,se=[],ne=1;ne<arguments.length;ne++)se[ne-1]=arguments[ne];this.length===0?(this._tasks=se,this.length=1):this.length===1?(se.unshift(this._tasks),this._tasks=se,this.length=this._tasks.length):((ze=this._tasks).splice.apply(ze,n([re,0],se,!1)),this.length=this._tasks.length),this.firstEmitBuildStrategy?this.call=k:this.rebuild()}function m(){this.length===0?this.call=r.BAKED_EMPTY_FUNC:this.length===1?this.call=this._tasks:this.call=(0,r.bakeCollection)(this._tasks,this.argsNum)}function b(){this.length===0?this.call=r.BAKED_EMPTY_FUNC:this.length===1?this.call=this._tasks:this.call=(0,r.bakeCollectionAwait)(this._tasks,this.argsNum)}function k(){this.rebuild(),this.call.apply(void 0,arguments)}var _=(function(){function re(ze,se,ne,X){se===void 0&&(se=!0),ne===void 0&&(ne=null),X===void 0&&(X=!1),this.awaitTasks=X,this.call=r.BAKED_EMPTY_FUNC,this.argsNum=ze,this.firstEmitBuildStrategy=!0,X?this.rebuild=b.bind(this):this.rebuild=m.bind(this),this.setAutoRebuild(se),ne?typeof ne=="function"?(this._tasks=ne,this.length=1):(this._tasks=ne,this.length=ne.length):(this._tasks=null,this.length=0),se&&this.rebuild()}return re})();taskCollection.TaskCollection=_;function A(){this._tasks=null,this.length=0,this.call=r.BAKED_EMPTY_FUNC}function B(){this._tasks=null,this.length=0,this.call=r.BAKED_EMPTY_FUNC}function L(re){this.argsNum<re&&(this.argsNum=re,this.firstEmitBuildStrategy?this.call=k:this.rebuild())}function Z(re){re?(this.push=o.bind(this),this.insert=g.bind(this),this.removeLast=c.bind(this)):(this.push=s.bind(this),this.insert=f.bind(this),this.removeLast=a.bind(this))}function ve(){return this.length===0?[]:this.length===1?[this._tasks]:this._tasks}function We(re){re.length===0?(this.length=0,this.call=r.BAKED_EMPTY_FUNC):re.length===1?(this.length=1,this.call=re[0],this._tasks=re[0]):(this.length=re.length,this._tasks=re,this.firstEmitBuildStrategy?this.call=k:this.rebuild())}return _.prototype.fastClear=A,_.prototype.clear=B,_.prototype.growArgsNum=L,_.prototype.setAutoRebuild=Z,_.prototype.tasksAsArray=ve,_.prototype.setTasks=We,taskCollection}var hasRequiredTaskCollection;function requireTaskCollection(){return hasRequiredTaskCollection||(hasRequiredTaskCollection=1,(function(n){var t=taskCollection$1&&taskCollection$1.__createBinding||(Object.create?(function(s,o,a,c){c===void 0&&(c=a);var f=Object.getOwnPropertyDescriptor(o,a);(!f||("get"in f?!o.__esModule:f.writable||f.configurable))&&(f={enumerable:!0,get:function(){return o[a]}}),Object.defineProperty(s,c,f)}):(function(s,o,a,c){c===void 0&&(c=a),s[c]=o[a]})),r=taskCollection$1&&taskCollection$1.__exportStar||function(s,o){for(var a in s)a!=="default"&&!Object.prototype.hasOwnProperty.call(o,a)&&t(o,s,a)};Object.defineProperty(n,"__esModule",{value:!0}),r(requireTaskCollection$1(),n)})(taskCollection$1)),taskCollection$1}var utils$1={},hasRequiredUtils;function requireUtils(){if(hasRequiredUtils)return utils$1;hasRequiredUtils=1,Object.defineProperty(utils$1,"__esModule",{value:!0}),utils$1.nullObj=void 0;function n(){var t={};return t.__proto__=null,t}return utils$1.nullObj=n,utils$1}var hasRequiredEe;function requireEe(){if(hasRequiredEe)return ee;hasRequiredEe=1;var n=ee&&ee.__spreadArray||function(se,ne,X){if(X||arguments.length===2)for(var $e=0,Ve=ne.length,Ze;$e<Ve;$e++)(Ze||!($e in ne))&&(Ze||(Ze=Array.prototype.slice.call(ne,0,$e)),Ze[$e]=ne[$e]);return se.concat(Ze||Array.prototype.slice.call(ne))};Object.defineProperty(ee,"__esModule",{value:!0}),ee.EventEmitter=void 0;var t=requireTaskCollection(),r=requireUtils$1(),s=requireUtils();function o(se,ne,X,$e,Ve,Ze){var He=this.events[se];if(He){if(He.length===0)return!1;if(He.argsNum<6)He.call(ne,X,$e,Ve,Ze);else{for(var Le=new Array(He.argsNum),Q=0,oe=Le.length;Q<oe;++Q)Le[Q]=arguments[Q+1];He.call.apply(void 0,Le)}return!0}return!1}function a(se,ne,X,$e,Ve,Ze){var He=this.events[se],Le;if(He!==void 0){if(He.length===0)return!1;if(He.argsNum<6)He.call(ne,X,$e,Ve,Ze);else{Le=new Array(He.argsNum);for(var Q=0,oe=Le.length;Q<oe;++Q)Le[Q]=arguments[Q+1];He.call.apply(void 0,Le)}}var Y=this.onceEvents[se];if(Y){if(typeof Y=="function")if(this.onceEvents[se]=void 0,arguments.length<6)Y(ne,X,$e,Ve,Ze);else{if(Le===void 0){Le=new Array(arguments.length-1);for(var Q=0,oe=Le.length;Q<oe;++Q)Le[Q]=arguments[Q+1]}Y.apply(void 0,Le)}else{var Ce=Y;if(this.onceEvents[se]=void 0,arguments.length<6)for(var Q=0;Q<Ce.length;++Q)Ce[Q](ne,X,$e,Ve,Ze);else{if(Le===void 0){Le=new Array(arguments.length-1);for(var Q=0,oe=Le.length;Q<oe;++Q)Le[Q]=arguments[Q+1]}for(var Q=0;Q<Ce.length;++Q)Ce[Q].apply(void 0,Le)}}return!0}return He!==void 0}var c=(function(){function se(){this.events=(0,s.nullObj)(),this.onceEvents=(0,s.nullObj)(),this._symbolKeys=new Set,this.maxListeners=1/0}return Object.defineProperty(se.prototype,"_eventsCount",{get:function(){return this.eventNames().length},enumerable:!1,configurable:!0}),se})();ee.EventEmitter=c;function f(se,ne){switch(this.emit===o&&(this.emit=a),typeof this.onceEvents[se]){case"undefined":this.onceEvents[se]=ne,typeof se=="symbol"&&this._symbolKeys.add(se);break;case"function":this.onceEvents[se]=[this.onceEvents[se],ne];break;case"object":this.onceEvents[se].push(ne)}return this}function g(se,ne,X){if(X===void 0&&(X=ne.length),typeof ne!="function")throw new TypeError("The listener must be a function");var $e=this.events[se];return $e?($e.push(ne),$e.growArgsNum(X),this.maxListeners!==1/0&&this.maxListeners<=$e.length&&console.warn('Maximum event listeners for "'.concat(String(se),'" event!'))):(this.events[se]=new t.TaskCollection(X,!0,ne,!1),typeof se=="symbol"&&this._symbolKeys.add(se)),this}function m(se,ne){var X=this.events[se];X&&X.removeLast(ne);var $e=this.onceEvents[se];return $e&&(typeof $e=="function"?this.onceEvents[se]=void 0:typeof $e=="object"&&($e.length===1&&$e[0]===ne?this.onceEvents[se]=void 0:(0,r._fast_remove_single)($e,$e.lastIndexOf(ne)))),this}function b(se,ne,X,$e){X===void 0&&(X=this),$e===void 0&&($e=ne.length),this.boundFuncs||(this.boundFuncs=new Map);var Ve=ne.bind(X);return this.boundFuncs.set(ne,Ve),this.addListener(se,Ve,$e)}function k(se,ne){var X,$e,Ve=(X=this.boundFuncs)===null||X===void 0?void 0:X.get(ne);return($e=this.boundFuncs)===null||$e===void 0||$e.delete(ne),this.removeListener(se,Ve)}function _(se){return this.events[se]&&!!this.events[se].length}function A(se,ne,X){if(X===void 0&&(X=ne.length),typeof ne!="function")throw new TypeError("The listener must be a function");var $e=this.events[se];return!$e||!($e instanceof t.TaskCollection)?($e=this.events[se]=new t.TaskCollection(X,!0,ne,!1),typeof se=="symbol"&&this._symbolKeys.add(se)):($e.insert(0,ne),$e.growArgsNum(X),this.maxListeners!==1/0&&this.maxListeners<=$e.length&&console.warn('Maximum event listeners for "'.concat(String(se),'" event!'))),this}function B(se,ne){this.emit===o&&(this.emit=a);var X=this.onceEvents[se];return X?typeof X!="object"?(this.onceEvents[se]=[ne,X],typeof se=="symbol"&&this._symbolKeys.add(se)):(X.unshift(ne),this.maxListeners!==1/0&&this.maxListeners<=X.length&&console.warn('Maximum event listeners for "'.concat(String(se),'" once event!'))):(this.onceEvents[se]=[ne],typeof se=="symbol"&&this._symbolKeys.add(se)),this}function L(se){return se===void 0?(this.events=(0,s.nullObj)(),this.onceEvents=(0,s.nullObj)(),this._symbolKeys=new Set):(this.events[se]=void 0,this.onceEvents[se]=void 0,typeof se=="symbol"&&this._symbolKeys.delete(se)),this}function Z(se){return this.maxListeners=se,this}function ve(){return this.maxListeners}function We(se){return this.emit===o?this.events[se]?this.events[se].tasksAsArray().slice():[]:this.events[se]&&this.onceEvents[se]?n(n([],this.events[se].tasksAsArray(),!0),typeof this.onceEvents[se]=="function"?[this.onceEvents[se]]:this.onceEvents[se],!0):this.events[se]?this.events[se].tasksAsArray():this.onceEvents[se]?typeof this.onceEvents[se]=="function"?[this.onceEvents[se]]:this.onceEvents[se]:[]}function re(){var se=this;if(this.emit===o){var ne=Object.keys(this.events);return n(n([],ne,!0),Array.from(this._symbolKeys),!0).filter(function($e){return $e in se.events&&se.events[$e]&&se.events[$e].length})}else{var ne=Object.keys(this.events).filter(function(Ve){return se.events[Ve]&&se.events[Ve].length}),X=Object.keys(this.onceEvents).filter(function(Ve){return se.onceEvents[Ve]&&se.onceEvents[Ve].length});return n(n(n([],ne,!0),X,!0),Array.from(this._symbolKeys).filter(function(Ve){return Ve in se.events&&se.events[Ve]&&se.events[Ve].length||Ve in se.onceEvents&&se.onceEvents[Ve]&&se.onceEvents[Ve].length}),!0)}}function ze(se){return this.emit===o?this.events[se]&&this.events[se].length||0:(this.events[se]&&this.events[se].length||0)+(this.onceEvents[se]&&this.onceEvents[se].length||0)}return c.prototype.emit=o,c.prototype.on=g,c.prototype.once=f,c.prototype.addListener=g,c.prototype.removeListener=m,c.prototype.addListenerBound=b,c.prototype.removeListenerBound=k,c.prototype.hasListeners=_,c.prototype.prependListener=A,c.prototype.prependOnceListener=B,c.prototype.off=m,c.prototype.removeAllListeners=L,c.prototype.setMaxListeners=Z,c.prototype.getMaxListeners=ve,c.prototype.listeners=We,c.prototype.eventNames=re,c.prototype.listenerCount=ze,ee}var hasRequiredLib;function requireLib(){return hasRequiredLib||(hasRequiredLib=1,(function(n){var t=lib&&lib.__createBinding||(Object.create?(function(s,o,a,c){c===void 0&&(c=a);var f=Object.getOwnPropertyDescriptor(o,a);(!f||("get"in f?!o.__esModule:f.writable||f.configurable))&&(f={enumerable:!0,get:function(){return o[a]}}),Object.defineProperty(s,c,f)}):(function(s,o,a,c){c===void 0&&(c=a),s[c]=o[a]})),r=lib&&lib.__exportStar||function(s,o){for(var a in s)a!=="default"&&!Object.prototype.hasOwnProperty.call(o,a)&&t(o,s,a)};Object.defineProperty(n,"__esModule",{value:!0}),r(requireTypes(),n),r(requireEe(),n)})(lib)),lib}var libExports=requireLib(),browser={exports:{}},ms,hasRequiredMs;function requireMs(){if(hasRequiredMs)return ms;hasRequiredMs=1;var n=1e3,t=n*60,r=t*60,s=r*24,o=s*7,a=s*365.25;ms=function(b,k){k=k||{};var _=typeof b;if(_==="string"&&b.length>0)return c(b);if(_==="number"&&isFinite(b))return k.long?g(b):f(b);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(b))};function c(b){if(b=String(b),!(b.length>100)){var k=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(b);if(k){var _=parseFloat(k[1]),A=(k[2]||"ms").toLowerCase();switch(A){case"years":case"year":case"yrs":case"yr":case"y":return _*a;case"weeks":case"week":case"w":return _*o;case"days":case"day":case"d":return _*s;case"hours":case"hour":case"hrs":case"hr":case"h":return _*r;case"minutes":case"minute":case"mins":case"min":case"m":return _*t;case"seconds":case"second":case"secs":case"sec":case"s":return _*n;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return _;default:return}}}}function f(b){var k=Math.abs(b);return k>=s?Math.round(b/s)+"d":k>=r?Math.round(b/r)+"h":k>=t?Math.round(b/t)+"m":k>=n?Math.round(b/n)+"s":b+"ms"}function g(b){var k=Math.abs(b);return k>=s?m(b,k,s,"day"):k>=r?m(b,k,r,"hour"):k>=t?m(b,k,t,"minute"):k>=n?m(b,k,n,"second"):b+" ms"}function m(b,k,_,A){var B=k>=_*1.5;return Math.round(b/_)+" "+A+(B?"s":"")}return ms}var common,hasRequiredCommon;function requireCommon(){if(hasRequiredCommon)return common;hasRequiredCommon=1;function n(t){s.debug=s,s.default=s,s.coerce=m,s.disable=f,s.enable=a,s.enabled=g,s.humanize=requireMs(),s.destroy=b,Object.keys(t).forEach(k=>{s[k]=t[k]}),s.names=[],s.skips=[],s.formatters={};function r(k){let _=0;for(let A=0;A<k.length;A++)_=(_<<5)-_+k.charCodeAt(A),_|=0;return s.colors[Math.abs(_)%s.colors.length]}s.selectColor=r;function s(k){let _,A=null,B,L;function Z(...ve){if(!Z.enabled)return;const We=Z,re=Number(new Date),ze=re-(_||re);We.diff=ze,We.prev=_,We.curr=re,_=re,ve[0]=s.coerce(ve[0]),typeof ve[0]!="string"&&ve.unshift("%O");let se=0;ve[0]=ve[0].replace(/%([a-zA-Z%])/g,(X,$e)=>{if(X==="%%")return"%";se++;const Ve=s.formatters[$e];if(typeof Ve=="function"){const Ze=ve[se];X=Ve.call(We,Ze),ve.splice(se,1),se--}return X}),s.formatArgs.call(We,ve),(We.log||s.log).apply(We,ve)}return Z.namespace=k,Z.useColors=s.useColors(),Z.color=s.selectColor(k),Z.extend=o,Z.destroy=s.destroy,Object.defineProperty(Z,"enabled",{enumerable:!0,configurable:!1,get:()=>A!==null?A:(B!==s.namespaces&&(B=s.namespaces,L=s.enabled(k)),L),set:ve=>{A=ve}}),typeof s.init=="function"&&s.init(Z),Z}function o(k,_){const A=s(this.namespace+(typeof _>"u"?":":_)+k);return A.log=this.log,A}function a(k){s.save(k),s.namespaces=k,s.names=[],s.skips=[];const _=(typeof k=="string"?k:"").trim().replace(/\s+/g,",").split(",").filter(Boolean);for(const A of _)A[0]==="-"?s.skips.push(A.slice(1)):s.names.push(A)}function c(k,_){let A=0,B=0,L=-1,Z=0;for(;A<k.length;)if(B<_.length&&(_[B]===k[A]||_[B]==="*"))_[B]==="*"?(L=B,Z=A,B++):(A++,B++);else if(L!==-1)B=L+1,Z++,A=Z;else return!1;for(;B<_.length&&_[B]==="*";)B++;return B===_.length}function f(){const k=[...s.names,...s.skips.map(_=>"-"+_)].join(",");return s.enable(""),k}function g(k){for(const _ of s.skips)if(c(k,_))return!1;for(const _ of s.names)if(c(k,_))return!0;return!1}function m(k){return k instanceof Error?k.stack||k.message:k}function b(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return s.enable(s.load()),s}return common=n,common}var hasRequiredBrowser;function requireBrowser(){return hasRequiredBrowser||(hasRequiredBrowser=1,(function(n,t){var r={};t.formatArgs=o,t.save=a,t.load=c,t.useColors=s,t.storage=f(),t.destroy=(()=>{let m=!1;return()=>{m||(m=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),t.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function s(){if(typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs))return!0;if(typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))return!1;let m;return typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&(m=navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/))&&parseInt(m[1],10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}function o(m){if(m[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+m[0]+(this.useColors?"%c ":" ")+"+"+n.exports.humanize(this.diff),!this.useColors)return;const b="color: "+this.color;m.splice(1,0,b,"color: inherit");let k=0,_=0;m[0].replace(/%[a-zA-Z%]/g,A=>{A!=="%%"&&(k++,A==="%c"&&(_=k))}),m.splice(_,0,b)}t.log=console.debug||console.log||(()=>{});function a(m){try{m?t.storage.setItem("debug",m):t.storage.removeItem("debug")}catch{}}function c(){let m;try{m=t.storage.getItem("debug")||t.storage.getItem("DEBUG")}catch{}return!m&&typeof process<"u"&&"env"in process&&(m=r.DEBUG),m}function f(){try{return localStorage}catch{}}n.exports=requireCommon()(t);const{formatters:g}=n.exports;g.j=function(m){try{return JSON.stringify(m)}catch(b){return"[UnexpectedJSONParseError]: "+b.message}}})(browser,browser.exports)),browser.exports}var browserExports=requireBrowser();const debug$1=getDefaultExportFromCjs(browserExports);function number$2(n){if(!Number.isSafeInteger(n)||n<0)throw new Error(`Wrong positive integer: ${n}`)}function bytes$3(n,...t){if(!(n instanceof Uint8Array))throw new Error("Expected Uint8Array");if(t.length>0&&!t.includes(n.length))throw new Error(`Expected Uint8Array of length ${t}, not of length=${n.length}`)}function hash$1(n){if(typeof n!="function"||typeof n.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");number$2(n.outputLen),number$2(n.blockLen)}function exists$2(n,t=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(t&&n.finished)throw new Error("Hash#digest() has already been called")}function output$2(n,t){bytes$3(n);const r=t.outputLen;if(n.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}const crypto$3=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;const u8a$2=n=>n instanceof Uint8Array,createView$3=n=>new DataView(n.buffer,n.byteOffset,n.byteLength),rotr$2=(n,t)=>n<<32-t|n>>>t,isLE$2=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE$2)throw new Error("Non little-endian hardware is not supported");function utf8ToBytes$4(n){if(typeof n!="string")throw new Error(`utf8ToBytes expected string, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}function toBytes$3(n){if(typeof n=="string"&&(n=utf8ToBytes$4(n)),!u8a$2(n))throw new Error(`expected Uint8Array, got ${typeof n}`);return n}function concatBytes$3(...n){const t=new Uint8Array(n.reduce((s,o)=>s+o.length,0));let r=0;return n.forEach(s=>{if(!u8a$2(s))throw new Error("Uint8Array expected");t.set(s,r),r+=s.length}),t}let Hash$2=class{clone(){return this._cloneInto()}};function wrapConstructor$1(n){const t=s=>n().update(toBytes$3(s)).digest(),r=n();return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=()=>n(),t}function randomBytes$2(n=32){if(crypto$3&&typeof crypto$3.getRandomValues=="function")return crypto$3.getRandomValues(new Uint8Array(n));throw new Error("crypto.getRandomValues must be defined")}function setBigUint64$3(n,t,r,s){if(typeof n.setBigUint64=="function")return n.setBigUint64(t,r,s);const o=BigInt(32),a=BigInt(4294967295),c=Number(r>>o&a),f=Number(r&a),g=s?4:0,m=s?0:4;n.setUint32(t+g,c,s),n.setUint32(t+m,f,s)}let SHA2$1=class extends Hash$2{constructor(t,r,s,o){super(),this.blockLen=t,this.outputLen=r,this.padOffset=s,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=createView$3(this.buffer)}update(t){exists$2(this);const{view:r,buffer:s,blockLen:o}=this;t=toBytes$3(t);const a=t.length;for(let c=0;c<a;){const f=Math.min(o-this.pos,a-c);if(f===o){const g=createView$3(t);for(;o<=a-c;c+=o)this.process(g,c);continue}s.set(t.subarray(c,c+f),this.pos),this.pos+=f,c+=f,this.pos===o&&(this.process(r,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){exists$2(this),output$2(t,this),this.finished=!0;const{buffer:r,view:s,blockLen:o,isLE:a}=this;let{pos:c}=this;r[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>o-c&&(this.process(s,0),c=0);for(let k=c;k<o;k++)r[k]=0;setBigUint64$3(s,o-8,BigInt(this.length*8),a),this.process(s,0);const f=createView$3(t),g=this.outputLen;if(g%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const m=g/4,b=this.get();if(m>b.length)throw new Error("_sha2: outputLen bigger than state");for(let k=0;k<m;k++)f.setUint32(4*k,b[k],a)}digest(){const{buffer:t,outputLen:r}=this;this.digestInto(t);const s=t.slice(0,r);return this.destroy(),s}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:r,buffer:s,length:o,finished:a,destroyed:c,pos:f}=this;return t.length=o,t.pos=f,t.finished=a,t.destroyed=c,o%r&&t.buffer.set(s),t}};const Chi$2=(n,t,r)=>n&t^~n&r,Maj$2=(n,t,r)=>n&t^n&r^t&r,SHA256_K$2=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),IV$1=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W$2=new Uint32Array(64);let SHA256$2=class extends SHA2$1{constructor(){super(64,32,8,!1),this.A=IV$1[0]|0,this.B=IV$1[1]|0,this.C=IV$1[2]|0,this.D=IV$1[3]|0,this.E=IV$1[4]|0,this.F=IV$1[5]|0,this.G=IV$1[6]|0,this.H=IV$1[7]|0}get(){const{A:t,B:r,C:s,D:o,E:a,F:c,G:f,H:g}=this;return[t,r,s,o,a,c,f,g]}set(t,r,s,o,a,c,f,g){this.A=t|0,this.B=r|0,this.C=s|0,this.D=o|0,this.E=a|0,this.F=c|0,this.G=f|0,this.H=g|0}process(t,r){for(let k=0;k<16;k++,r+=4)SHA256_W$2[k]=t.getUint32(r,!1);for(let k=16;k<64;k++){const _=SHA256_W$2[k-15],A=SHA256_W$2[k-2],B=rotr$2(_,7)^rotr$2(_,18)^_>>>3,L=rotr$2(A,17)^rotr$2(A,19)^A>>>10;SHA256_W$2[k]=L+SHA256_W$2[k-7]+B+SHA256_W$2[k-16]|0}let{A:s,B:o,C:a,D:c,E:f,F:g,G:m,H:b}=this;for(let k=0;k<64;k++){const _=rotr$2(f,6)^rotr$2(f,11)^rotr$2(f,25),A=b+_+Chi$2(f,g,m)+SHA256_K$2[k]+SHA256_W$2[k]|0,L=(rotr$2(s,2)^rotr$2(s,13)^rotr$2(s,22))+Maj$2(s,o,a)|0;b=m,m=g,g=f,f=c+A|0,c=a,a=o,o=s,s=A+L|0}s=s+this.A|0,o=o+this.B|0,a=a+this.C|0,c=c+this.D|0,f=f+this.E|0,g=g+this.F|0,m=m+this.G|0,b=b+this.H|0,this.set(s,o,a,c,f,g,m,b)}roundClean(){SHA256_W$2.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};const sha256$3=wrapConstructor$1(()=>new SHA256$2);const _0n$9=BigInt(0),_1n$9=BigInt(1),_2n$5=BigInt(2),u8a$1=n=>n instanceof Uint8Array,hexes$2=Array.from({length:256},(n,t)=>t.toString(16).padStart(2,"0"));function bytesToHex$3(n){if(!u8a$1(n))throw new Error("Uint8Array expected");let t="";for(let r=0;r<n.length;r++)t+=hexes$2[n[r]];return t}function numberToHexUnpadded$1(n){const t=n.toString(16);return t.length&1?`0${t}`:t}function hexToNumber$1(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return BigInt(n===""?"0":`0x${n}`)}function hexToBytes$3(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);const t=n.length;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(t/2);for(let s=0;s<r.length;s++){const o=s*2,a=n.slice(o,o+2),c=Number.parseInt(a,16);if(Number.isNaN(c)||c<0)throw new Error("Invalid byte sequence");r[s]=c}return r}function bytesToNumberBE$1(n){return hexToNumber$1(bytesToHex$3(n))}function bytesToNumberLE$1(n){if(!u8a$1(n))throw new Error("Uint8Array expected");return hexToNumber$1(bytesToHex$3(Uint8Array.from(n).reverse()))}function numberToBytesBE$1(n,t){return hexToBytes$3(n.toString(16).padStart(t*2,"0"))}function numberToBytesLE$1(n,t){return numberToBytesBE$1(n,t).reverse()}function numberToVarBytesBE(n){return hexToBytes$3(numberToHexUnpadded$1(n))}function ensureBytes$1(n,t,r){let s;if(typeof t=="string")try{s=hexToBytes$3(t)}catch(a){throw new Error(`${n} must be valid hex string, got "${t}". Cause: ${a}`)}else if(u8a$1(t))s=Uint8Array.from(t);else throw new Error(`${n} must be hex string or Uint8Array`);const o=s.length;if(typeof r=="number"&&o!==r)throw new Error(`${n} expected ${r} bytes, got ${o}`);return s}function concatBytes$2(...n){const t=new Uint8Array(n.reduce((s,o)=>s+o.length,0));let r=0;return n.forEach(s=>{if(!u8a$1(s))throw new Error("Uint8Array expected");t.set(s,r),r+=s.length}),t}function equalBytes$1(n,t){if(n.length!==t.length)return!1;for(let r=0;r<n.length;r++)if(n[r]!==t[r])return!1;return!0}function utf8ToBytes$3(n){if(typeof n!="string")throw new Error(`utf8ToBytes expected string, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}function bitLen$1(n){let t;for(t=0;n>_0n$9;n>>=_1n$9,t+=1);return t}function bitGet(n,t){return n>>BigInt(t)&_1n$9}const bitSet=(n,t,r)=>n|(r?_1n$9:_0n$9)<<BigInt(t),bitMask$1=n=>(_2n$5<<BigInt(n-1))-_1n$9,u8n=n=>new Uint8Array(n),u8fr=n=>Uint8Array.from(n);function createHmacDrbg$1(n,t,r){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof r!="function")throw new Error("hmacFn must be a function");let s=u8n(n),o=u8n(n),a=0;const c=()=>{s.fill(1),o.fill(0),a=0},f=(...k)=>r(o,s,...k),g=(k=u8n())=>{o=f(u8fr([0]),k),s=f(),k.length!==0&&(o=f(u8fr([1]),k),s=f())},m=()=>{if(a++>=1e3)throw new Error("drbg: tried 1000 values");let k=0;const _=[];for(;k<t;){s=f();const A=s.slice();_.push(A),k+=s.length}return concatBytes$2(..._)};return(k,_)=>{c(),g(k);let A;for(;!(A=_(m()));)g();return c(),A}}const validatorFns={bigint:n=>typeof n=="bigint",function:n=>typeof n=="function",boolean:n=>typeof n=="boolean",string:n=>typeof n=="string",stringOrUint8Array:n=>typeof n=="string"||n instanceof Uint8Array,isSafeInteger:n=>Number.isSafeInteger(n),array:n=>Array.isArray(n),field:(n,t)=>t.Fp.isValid(n),hash:n=>typeof n=="function"&&Number.isSafeInteger(n.outputLen)};function validateObject(n,t,r={}){const s=(o,a,c)=>{const f=validatorFns[a];if(typeof f!="function")throw new Error(`Invalid validator "${a}", expected function`);const g=n[o];if(!(c&&g===void 0)&&!f(g,n))throw new Error(`Invalid param ${String(o)}=${g} (${typeof g}), expected ${a}`)};for(const[o,a]of Object.entries(t))s(o,a,!1);for(const[o,a]of Object.entries(r))s(o,a,!0);return n}const ut=Object.freeze(Object.defineProperty({__proto__:null,bitGet,bitLen:bitLen$1,bitMask:bitMask$1,bitSet,bytesToHex:bytesToHex$3,bytesToNumberBE:bytesToNumberBE$1,bytesToNumberLE:bytesToNumberLE$1,concatBytes:concatBytes$2,createHmacDrbg:createHmacDrbg$1,ensureBytes:ensureBytes$1,equalBytes:equalBytes$1,hexToBytes:hexToBytes$3,hexToNumber:hexToNumber$1,numberToBytesBE:numberToBytesBE$1,numberToBytesLE:numberToBytesLE$1,numberToHexUnpadded:numberToHexUnpadded$1,numberToVarBytesBE,utf8ToBytes:utf8ToBytes$3,validateObject},Symbol.toStringTag,{value:"Module"}));const _0n$8=BigInt(0),_1n$8=BigInt(1),_2n$4=BigInt(2),_3n$3=BigInt(3),_4n$2=BigInt(4),_5n$1=BigInt(5),_8n$1=BigInt(8);BigInt(9);BigInt(16);function mod$1(n,t){const r=n%t;return r>=_0n$8?r:t+r}function pow(n,t,r){if(r<=_0n$8||t<_0n$8)throw new Error("Expected power/modulo > 0");if(r===_1n$8)return _0n$8;let s=_1n$8;for(;t>_0n$8;)t&_1n$8&&(s=s*n%r),n=n*n%r,t>>=_1n$8;return s}function pow2$1(n,t,r){let s=n;for(;t-- >_0n$8;)s*=s,s%=r;return s}function invert$1(n,t){if(n===_0n$8||t<=_0n$8)throw new Error(`invert: expected positive integers, got n=${n} mod=${t}`);let r=mod$1(n,t),s=t,o=_0n$8,a=_1n$8;for(;r!==_0n$8;){const f=s/r,g=s%r,m=o-a*f;s=r,r=g,o=a,a=m}if(s!==_1n$8)throw new Error("invert: does not exist");return mod$1(o,t)}function tonelliShanks$1(n){const t=(n-_1n$8)/_2n$4;let r,s,o;for(r=n-_1n$8,s=0;r%_2n$4===_0n$8;r/=_2n$4,s++);for(o=_2n$4;o<n&&pow(o,t,n)!==n-_1n$8;o++);if(s===1){const c=(n+_1n$8)/_4n$2;return function(g,m){const b=g.pow(m,c);if(!g.eql(g.sqr(b),m))throw new Error("Cannot find square root");return b}}const a=(r+_1n$8)/_2n$4;return function(f,g){if(f.pow(g,t)===f.neg(f.ONE))throw new Error("Cannot find square root");let m=s,b=f.pow(f.mul(f.ONE,o),r),k=f.pow(g,a),_=f.pow(g,r);for(;!f.eql(_,f.ONE);){if(f.eql(_,f.ZERO))return f.ZERO;let A=1;for(let L=f.sqr(_);A<m&&!f.eql(L,f.ONE);A++)L=f.sqr(L);const B=f.pow(b,_1n$8<<BigInt(m-A-1));b=f.sqr(B),k=f.mul(k,B),_=f.mul(_,b),m=A}return k}}function FpSqrt$1(n){if(n%_4n$2===_3n$3){const t=(n+_1n$8)/_4n$2;return function(s,o){const a=s.pow(o,t);if(!s.eql(s.sqr(a),o))throw new Error("Cannot find square root");return a}}if(n%_8n$1===_5n$1){const t=(n-_5n$1)/_8n$1;return function(s,o){const a=s.mul(o,_2n$4),c=s.pow(a,t),f=s.mul(o,c),g=s.mul(s.mul(f,_2n$4),c),m=s.mul(f,s.sub(g,s.ONE));if(!s.eql(s.sqr(m),o))throw new Error("Cannot find square root");return m}}return tonelliShanks$1(n)}const FIELD_FIELDS$1=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function validateField$1(n){const t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},r=FIELD_FIELDS$1.reduce((s,o)=>(s[o]="function",s),t);return validateObject(n,r)}function FpPow$1(n,t,r){if(r<_0n$8)throw new Error("Expected power > 0");if(r===_0n$8)return n.ONE;if(r===_1n$8)return t;let s=n.ONE,o=t;for(;r>_0n$8;)r&_1n$8&&(s=n.mul(s,o)),o=n.sqr(o),r>>=_1n$8;return s}function FpInvertBatch$1(n,t){const r=new Array(t.length),s=t.reduce((a,c,f)=>n.is0(c)?a:(r[f]=a,n.mul(a,c)),n.ONE),o=n.inv(s);return t.reduceRight((a,c,f)=>n.is0(c)?a:(r[f]=n.mul(a,r[f]),n.mul(a,c)),o),r}function nLength$1(n,t){const r=t!==void 0?t:n.toString(2).length,s=Math.ceil(r/8);return{nBitLength:r,nByteLength:s}}function Field$1(n,t,r=!1,s={}){if(n<=_0n$8)throw new Error(`Expected Field ORDER > 0, got ${n}`);const{nBitLength:o,nByteLength:a}=nLength$1(n,t);if(a>2048)throw new Error("Field lengths over 2048 bytes are not supported");const c=FpSqrt$1(n),f=Object.freeze({ORDER:n,BITS:o,BYTES:a,MASK:bitMask$1(o),ZERO:_0n$8,ONE:_1n$8,create:g=>mod$1(g,n),isValid:g=>{if(typeof g!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof g}`);return _0n$8<=g&&g<n},is0:g=>g===_0n$8,isOdd:g=>(g&_1n$8)===_1n$8,neg:g=>mod$1(-g,n),eql:(g,m)=>g===m,sqr:g=>mod$1(g*g,n),add:(g,m)=>mod$1(g+m,n),sub:(g,m)=>mod$1(g-m,n),mul:(g,m)=>mod$1(g*m,n),pow:(g,m)=>FpPow$1(f,g,m),div:(g,m)=>mod$1(g*invert$1(m,n),n),sqrN:g=>g*g,addN:(g,m)=>g+m,subN:(g,m)=>g-m,mulN:(g,m)=>g*m,inv:g=>invert$1(g,n),sqrt:s.sqrt||(g=>c(f,g)),invertBatch:g=>FpInvertBatch$1(f,g),cmov:(g,m,b)=>b?m:g,toBytes:g=>r?numberToBytesLE$1(g,a):numberToBytesBE$1(g,a),fromBytes:g=>{if(g.length!==a)throw new Error(`Fp.fromBytes: expected ${a}, got ${g.length}`);return r?bytesToNumberLE$1(g):bytesToNumberBE$1(g)}});return Object.freeze(f)}function getFieldBytesLength$1(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const t=n.toString(2).length;return Math.ceil(t/8)}function getMinHashLength$1(n){const t=getFieldBytesLength$1(n);return t+Math.ceil(t/2)}function mapHashToField$1(n,t,r=!1){const s=n.length,o=getFieldBytesLength$1(t),a=getMinHashLength$1(t);if(s<16||s<a||s>1024)throw new Error(`expected ${a}-1024 bytes of input, got ${s}`);const c=r?bytesToNumberBE$1(n):bytesToNumberLE$1(n),f=mod$1(c,t-_1n$8)+_1n$8;return r?numberToBytesLE$1(f,o):numberToBytesBE$1(f,o)}const _0n$7=BigInt(0),_1n$7=BigInt(1);function wNAF$1(n,t){const r=(o,a)=>{const c=a.negate();return o?c:a},s=o=>{const a=Math.ceil(t/o)+1,c=2**(o-1);return{windows:a,windowSize:c}};return{constTimeNegate:r,unsafeLadder(o,a){let c=n.ZERO,f=o;for(;a>_0n$7;)a&_1n$7&&(c=c.add(f)),f=f.double(),a>>=_1n$7;return c},precomputeWindow(o,a){const{windows:c,windowSize:f}=s(a),g=[];let m=o,b=m;for(let k=0;k<c;k++){b=m,g.push(b);for(let _=1;_<f;_++)b=b.add(m),g.push(b);m=b.double()}return g},wNAF(o,a,c){const{windows:f,windowSize:g}=s(o);let m=n.ZERO,b=n.BASE;const k=BigInt(2**o-1),_=2**o,A=BigInt(o);for(let B=0;B<f;B++){const L=B*g;let Z=Number(c&k);c>>=A,Z>g&&(Z-=_,c+=_1n$7);const ve=L,We=L+Math.abs(Z)-1,re=B%2!==0,ze=Z<0;Z===0?b=b.add(r(re,a[ve])):m=m.add(r(ze,a[We]))}return{p:m,f:b}},wNAFCached(o,a,c,f){const g=o._WINDOW_SIZE||1;let m=a.get(o);return m||(m=this.precomputeWindow(o,g),g!==1&&a.set(o,f(m))),this.wNAF(g,m,c)}}}function validateBasic(n){return validateField$1(n.Fp),validateObject(n,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...nLength$1(n.n,n.nBitLength),...n,p:n.Fp.ORDER})}function validatePointOpts(n){const t=validateBasic(n);validateObject(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:r,Fp:s,a:o}=t;if(r){if(!s.eql(o,s.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof r!="object"||typeof r.beta!="bigint"||typeof r.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...t})}const{bytesToNumberBE:b2n,hexToBytes:h2b}=ut,DER$1={Err:class extends Error{constructor(t=""){super(t)}},_parseInt(n){const{Err:t}=DER$1;if(n.length<2||n[0]!==2)throw new t("Invalid signature integer tag");const r=n[1],s=n.subarray(2,r+2);if(!r||s.length!==r)throw new t("Invalid signature integer: wrong length");if(s[0]&128)throw new t("Invalid signature integer: negative");if(s[0]===0&&!(s[1]&128))throw new t("Invalid signature integer: unnecessary leading zero");return{d:b2n(s),l:n.subarray(r+2)}},toSig(n){const{Err:t}=DER$1,r=typeof n=="string"?h2b(n):n;if(!(r instanceof Uint8Array))throw new Error("ui8a expected");let s=r.length;if(s<2||r[0]!=48)throw new t("Invalid signature tag");if(r[1]!==s-2)throw new t("Invalid signature: incorrect length");const{d:o,l:a}=DER$1._parseInt(r.subarray(2)),{d:c,l:f}=DER$1._parseInt(a);if(f.length)throw new t("Invalid signature: left bytes after parsing");return{r:o,s:c}},hexFromSig(n){const t=m=>Number.parseInt(m[0],16)&8?"00"+m:m,r=m=>{const b=m.toString(16);return b.length&1?`0${b}`:b},s=t(r(n.s)),o=t(r(n.r)),a=s.length/2,c=o.length/2,f=r(a),g=r(c);return`30${r(c+a+4)}02${g}${o}02${f}${s}`}},_0n$6=BigInt(0),_1n$6=BigInt(1);BigInt(2);const _3n$2=BigInt(3);BigInt(4);function weierstrassPoints(n){const t=validatePointOpts(n),{Fp:r}=t,s=t.toBytes||((B,L,Z)=>{const ve=L.toAffine();return concatBytes$2(Uint8Array.from([4]),r.toBytes(ve.x),r.toBytes(ve.y))}),o=t.fromBytes||(B=>{const L=B.subarray(1),Z=r.fromBytes(L.subarray(0,r.BYTES)),ve=r.fromBytes(L.subarray(r.BYTES,2*r.BYTES));return{x:Z,y:ve}});function a(B){const{a:L,b:Z}=t,ve=r.sqr(B),We=r.mul(ve,B);return r.add(r.add(We,r.mul(B,L)),Z)}if(!r.eql(r.sqr(t.Gy),a(t.Gx)))throw new Error("bad generator point: equation left != right");function c(B){return typeof B=="bigint"&&_0n$6<B&&B<t.n}function f(B){if(!c(B))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function g(B){const{allowedPrivateKeyLengths:L,nByteLength:Z,wrapPrivateKey:ve,n:We}=t;if(L&&typeof B!="bigint"){if(B instanceof Uint8Array&&(B=bytesToHex$3(B)),typeof B!="string"||!L.includes(B.length))throw new Error("Invalid key");B=B.padStart(Z*2,"0")}let re;try{re=typeof B=="bigint"?B:bytesToNumberBE$1(ensureBytes$1("private key",B,Z))}catch{throw new Error(`private key must be ${Z} bytes, hex or bigint, not ${typeof B}`)}return ve&&(re=mod$1(re,We)),f(re),re}const m=new Map;function b(B){if(!(B instanceof k))throw new Error("ProjectivePoint expected")}class k{constructor(L,Z,ve){if(this.px=L,this.py=Z,this.pz=ve,L==null||!r.isValid(L))throw new Error("x required");if(Z==null||!r.isValid(Z))throw new Error("y required");if(ve==null||!r.isValid(ve))throw new Error("z required")}static fromAffine(L){const{x:Z,y:ve}=L||{};if(!L||!r.isValid(Z)||!r.isValid(ve))throw new Error("invalid affine point");if(L instanceof k)throw new Error("projective point not allowed");const We=re=>r.eql(re,r.ZERO);return We(Z)&&We(ve)?k.ZERO:new k(Z,ve,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(L){const Z=r.invertBatch(L.map(ve=>ve.pz));return L.map((ve,We)=>ve.toAffine(Z[We])).map(k.fromAffine)}static fromHex(L){const Z=k.fromAffine(o(ensureBytes$1("pointHex",L)));return Z.assertValidity(),Z}static fromPrivateKey(L){return k.BASE.multiply(g(L))}_setWindowSize(L){this._WINDOW_SIZE=L,m.delete(this)}assertValidity(){if(this.is0()){if(t.allowInfinityPoint&&!r.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:L,y:Z}=this.toAffine();if(!r.isValid(L)||!r.isValid(Z))throw new Error("bad point: x or y not FE");const ve=r.sqr(Z),We=a(L);if(!r.eql(ve,We))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:L}=this.toAffine();if(r.isOdd)return!r.isOdd(L);throw new Error("Field doesn't support isOdd")}equals(L){b(L);const{px:Z,py:ve,pz:We}=this,{px:re,py:ze,pz:se}=L,ne=r.eql(r.mul(Z,se),r.mul(re,We)),X=r.eql(r.mul(ve,se),r.mul(ze,We));return ne&&X}negate(){return new k(this.px,r.neg(this.py),this.pz)}double(){const{a:L,b:Z}=t,ve=r.mul(Z,_3n$2),{px:We,py:re,pz:ze}=this;let se=r.ZERO,ne=r.ZERO,X=r.ZERO,$e=r.mul(We,We),Ve=r.mul(re,re),Ze=r.mul(ze,ze),He=r.mul(We,re);return He=r.add(He,He),X=r.mul(We,ze),X=r.add(X,X),se=r.mul(L,X),ne=r.mul(ve,Ze),ne=r.add(se,ne),se=r.sub(Ve,ne),ne=r.add(Ve,ne),ne=r.mul(se,ne),se=r.mul(He,se),X=r.mul(ve,X),Ze=r.mul(L,Ze),He=r.sub($e,Ze),He=r.mul(L,He),He=r.add(He,X),X=r.add($e,$e),$e=r.add(X,$e),$e=r.add($e,Ze),$e=r.mul($e,He),ne=r.add(ne,$e),Ze=r.mul(re,ze),Ze=r.add(Ze,Ze),$e=r.mul(Ze,He),se=r.sub(se,$e),X=r.mul(Ze,Ve),X=r.add(X,X),X=r.add(X,X),new k(se,ne,X)}add(L){b(L);const{px:Z,py:ve,pz:We}=this,{px:re,py:ze,pz:se}=L;let ne=r.ZERO,X=r.ZERO,$e=r.ZERO;const Ve=t.a,Ze=r.mul(t.b,_3n$2);let He=r.mul(Z,re),Le=r.mul(ve,ze),Q=r.mul(We,se),oe=r.add(Z,ve),Y=r.add(re,ze);oe=r.mul(oe,Y),Y=r.add(He,Le),oe=r.sub(oe,Y),Y=r.add(Z,We);let Ce=r.add(re,se);return Y=r.mul(Y,Ce),Ce=r.add(He,Q),Y=r.sub(Y,Ce),Ce=r.add(ve,We),ne=r.add(ze,se),Ce=r.mul(Ce,ne),ne=r.add(Le,Q),Ce=r.sub(Ce,ne),$e=r.mul(Ve,Y),ne=r.mul(Ze,Q),$e=r.add(ne,$e),ne=r.sub(Le,$e),$e=r.add(Le,$e),X=r.mul(ne,$e),Le=r.add(He,He),Le=r.add(Le,He),Q=r.mul(Ve,Q),Y=r.mul(Ze,Y),Le=r.add(Le,Q),Q=r.sub(He,Q),Q=r.mul(Ve,Q),Y=r.add(Y,Q),He=r.mul(Le,Y),X=r.add(X,He),He=r.mul(Ce,Y),ne=r.mul(oe,ne),ne=r.sub(ne,He),He=r.mul(oe,Le),$e=r.mul(Ce,$e),$e=r.add($e,He),new k(ne,X,$e)}subtract(L){return this.add(L.negate())}is0(){return this.equals(k.ZERO)}wNAF(L){return A.wNAFCached(this,m,L,Z=>{const ve=r.invertBatch(Z.map(We=>We.pz));return Z.map((We,re)=>We.toAffine(ve[re])).map(k.fromAffine)})}multiplyUnsafe(L){const Z=k.ZERO;if(L===_0n$6)return Z;if(f(L),L===_1n$6)return this;const{endo:ve}=t;if(!ve)return A.unsafeLadder(this,L);let{k1neg:We,k1:re,k2neg:ze,k2:se}=ve.splitScalar(L),ne=Z,X=Z,$e=this;for(;re>_0n$6||se>_0n$6;)re&_1n$6&&(ne=ne.add($e)),se&_1n$6&&(X=X.add($e)),$e=$e.double(),re>>=_1n$6,se>>=_1n$6;return We&&(ne=ne.negate()),ze&&(X=X.negate()),X=new k(r.mul(X.px,ve.beta),X.py,X.pz),ne.add(X)}multiply(L){f(L);let Z=L,ve,We;const{endo:re}=t;if(re){const{k1neg:ze,k1:se,k2neg:ne,k2:X}=re.splitScalar(Z);let{p:$e,f:Ve}=this.wNAF(se),{p:Ze,f:He}=this.wNAF(X);$e=A.constTimeNegate(ze,$e),Ze=A.constTimeNegate(ne,Ze),Ze=new k(r.mul(Ze.px,re.beta),Ze.py,Ze.pz),ve=$e.add(Ze),We=Ve.add(He)}else{const{p:ze,f:se}=this.wNAF(Z);ve=ze,We=se}return k.normalizeZ([ve,We])[0]}multiplyAndAddUnsafe(L,Z,ve){const We=k.BASE,re=(se,ne)=>ne===_0n$6||ne===_1n$6||!se.equals(We)?se.multiplyUnsafe(ne):se.multiply(ne),ze=re(this,Z).add(re(L,ve));return ze.is0()?void 0:ze}toAffine(L){const{px:Z,py:ve,pz:We}=this,re=this.is0();L==null&&(L=re?r.ONE:r.inv(We));const ze=r.mul(Z,L),se=r.mul(ve,L),ne=r.mul(We,L);if(re)return{x:r.ZERO,y:r.ZERO};if(!r.eql(ne,r.ONE))throw new Error("invZ was invalid");return{x:ze,y:se}}isTorsionFree(){const{h:L,isTorsionFree:Z}=t;if(L===_1n$6)return!0;if(Z)return Z(k,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:L,clearCofactor:Z}=t;return L===_1n$6?this:Z?Z(k,this):this.multiplyUnsafe(t.h)}toRawBytes(L=!0){return this.assertValidity(),s(k,this,L)}toHex(L=!0){return bytesToHex$3(this.toRawBytes(L))}}k.BASE=new k(t.Gx,t.Gy,r.ONE),k.ZERO=new k(r.ZERO,r.ONE,r.ZERO);const _=t.nBitLength,A=wNAF$1(k,t.endo?Math.ceil(_/2):_);return{CURVE:t,ProjectivePoint:k,normPrivateKeyToScalar:g,weierstrassEquation:a,isWithinCurveOrder:c}}function validateOpts(n){const t=validateBasic(n);return validateObject(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}function weierstrass$1(n){const t=validateOpts(n),{Fp:r,n:s}=t,o=r.BYTES+1,a=2*r.BYTES+1;function c(Y){return _0n$6<Y&&Y<r.ORDER}function f(Y){return mod$1(Y,s)}function g(Y){return invert$1(Y,s)}const{ProjectivePoint:m,normPrivateKeyToScalar:b,weierstrassEquation:k,isWithinCurveOrder:_}=weierstrassPoints({...t,toBytes(Y,Ce,je){const Je=Ce.toAffine(),Ge=r.toBytes(Je.x),Xe=concatBytes$2;return je?Xe(Uint8Array.from([Ce.hasEvenY()?2:3]),Ge):Xe(Uint8Array.from([4]),Ge,r.toBytes(Je.y))},fromBytes(Y){const Ce=Y.length,je=Y[0],Je=Y.subarray(1);if(Ce===o&&(je===2||je===3)){const Ge=bytesToNumberBE$1(Je);if(!c(Ge))throw new Error("Point is not on curve");const Xe=k(Ge);let Qe=r.sqrt(Xe);const rt=(Qe&_1n$6)===_1n$6;return(je&1)===1!==rt&&(Qe=r.neg(Qe)),{x:Ge,y:Qe}}else if(Ce===a&&je===4){const Ge=r.fromBytes(Je.subarray(0,r.BYTES)),Xe=r.fromBytes(Je.subarray(r.BYTES,2*r.BYTES));return{x:Ge,y:Xe}}else throw new Error(`Point of length ${Ce} was invalid. Expected ${o} compressed bytes or ${a} uncompressed bytes`)}}),A=Y=>bytesToHex$3(numberToBytesBE$1(Y,t.nByteLength));function B(Y){const Ce=s>>_1n$6;return Y>Ce}function L(Y){return B(Y)?f(-Y):Y}const Z=(Y,Ce,je)=>bytesToNumberBE$1(Y.slice(Ce,je));class ve{constructor(Ce,je,Je){this.r=Ce,this.s=je,this.recovery=Je,this.assertValidity()}static fromCompact(Ce){const je=t.nByteLength;return Ce=ensureBytes$1("compactSignature",Ce,je*2),new ve(Z(Ce,0,je),Z(Ce,je,2*je))}static fromDER(Ce){const{r:je,s:Je}=DER$1.toSig(ensureBytes$1("DER",Ce));return new ve(je,Je)}assertValidity(){if(!_(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!_(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(Ce){return new ve(this.r,this.s,Ce)}recoverPublicKey(Ce){const{r:je,s:Je,recovery:Ge}=this,Xe=X(ensureBytes$1("msgHash",Ce));if(Ge==null||![0,1,2,3].includes(Ge))throw new Error("recovery id invalid");const Qe=Ge===2||Ge===3?je+t.n:je;if(Qe>=r.ORDER)throw new Error("recovery id 2 or 3 invalid");const rt=(Ge&1)===0?"02":"03",_t=m.fromHex(rt+A(Qe)),ht=g(Qe),ot=f(-Xe*ht),xt=f(Je*ht),St=m.BASE.multiplyAndAddUnsafe(_t,ot,xt);if(!St)throw new Error("point at infinify");return St.assertValidity(),St}hasHighS(){return B(this.s)}normalizeS(){return this.hasHighS()?new ve(this.r,f(-this.s),this.recovery):this}toDERRawBytes(){return hexToBytes$3(this.toDERHex())}toDERHex(){return DER$1.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return hexToBytes$3(this.toCompactHex())}toCompactHex(){return A(this.r)+A(this.s)}}const We={isValidPrivateKey(Y){try{return b(Y),!0}catch{return!1}},normPrivateKeyToScalar:b,randomPrivateKey:()=>{const Y=getMinHashLength$1(t.n);return mapHashToField$1(t.randomBytes(Y),t.n)},precompute(Y=8,Ce=m.BASE){return Ce._setWindowSize(Y),Ce.multiply(BigInt(3)),Ce}};function re(Y,Ce=!0){return m.fromPrivateKey(Y).toRawBytes(Ce)}function ze(Y){const Ce=Y instanceof Uint8Array,je=typeof Y=="string",Je=(Ce||je)&&Y.length;return Ce?Je===o||Je===a:je?Je===2*o||Je===2*a:Y instanceof m}function se(Y,Ce,je=!0){if(ze(Y))throw new Error("first arg must be private key");if(!ze(Ce))throw new Error("second arg must be public key");return m.fromHex(Ce).multiply(b(Y)).toRawBytes(je)}const ne=t.bits2int||function(Y){const Ce=bytesToNumberBE$1(Y),je=Y.length*8-t.nBitLength;return je>0?Ce>>BigInt(je):Ce},X=t.bits2int_modN||function(Y){return f(ne(Y))},$e=bitMask$1(t.nBitLength);function Ve(Y){if(typeof Y!="bigint")throw new Error("bigint expected");if(!(_0n$6<=Y&&Y<$e))throw new Error(`bigint expected < 2^${t.nBitLength}`);return numberToBytesBE$1(Y,t.nByteLength)}function Ze(Y,Ce,je=He){if(["recovered","canonical"].some(Bt=>Bt in je))throw new Error("sign() legacy options not supported");const{hash:Je,randomBytes:Ge}=t;let{lowS:Xe,prehash:Qe,extraEntropy:rt}=je;Xe==null&&(Xe=!0),Y=ensureBytes$1("msgHash",Y),Qe&&(Y=ensureBytes$1("prehashed msgHash",Je(Y)));const _t=X(Y),ht=b(Ce),ot=[Ve(ht),Ve(_t)];if(rt!=null){const Bt=rt===!0?Ge(r.BYTES):rt;ot.push(ensureBytes$1("extraEntropy",Bt))}const xt=concatBytes$2(...ot),St=_t;function Mt(Bt){const Ut=ne(Bt);if(!_(Ut))return;const Jt=g(Ut),Ft=m.BASE.multiply(Ut).toAffine(),Xt=f(Ft.x);if(Xt===_0n$6)return;const rn=f(Jt*f(St+Xt*ht));if(rn===_0n$6)return;let on=(Ft.x===Xt?0:2)|Number(Ft.y&_1n$6),nn=rn;return Xe&&B(rn)&&(nn=L(rn),on^=1),new ve(Xt,nn,on)}return{seed:xt,k2sig:Mt}}const He={lowS:t.lowS,prehash:!1},Le={lowS:t.lowS,prehash:!1};function Q(Y,Ce,je=He){const{seed:Je,k2sig:Ge}=Ze(Y,Ce,je),Xe=t;return createHmacDrbg$1(Xe.hash.outputLen,Xe.nByteLength,Xe.hmac)(Je,Ge)}m.BASE._setWindowSize(8);function oe(Y,Ce,je,Je=Le){const Ge=Y;if(Ce=ensureBytes$1("msgHash",Ce),je=ensureBytes$1("publicKey",je),"strict"in Je)throw new Error("options.strict was renamed to lowS");const{lowS:Xe,prehash:Qe}=Je;let rt,_t;try{if(typeof Ge=="string"||Ge instanceof Uint8Array)try{rt=ve.fromDER(Ge)}catch(Ft){if(!(Ft instanceof DER$1.Err))throw Ft;rt=ve.fromCompact(Ge)}else if(typeof Ge=="object"&&typeof Ge.r=="bigint"&&typeof Ge.s=="bigint"){const{r:Ft,s:Xt}=Ge;rt=new ve(Ft,Xt)}else throw new Error("PARSE");_t=m.fromHex(je)}catch(Ft){if(Ft.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(Xe&&rt.hasHighS())return!1;Qe&&(Ce=t.hash(Ce));const{r:ht,s:ot}=rt,xt=X(Ce),St=g(ot),Mt=f(xt*St),Bt=f(ht*St),Ut=m.BASE.multiplyAndAddUnsafe(_t,Mt,Bt)?.toAffine();return Ut?f(Ut.x)===ht:!1}return{CURVE:t,getPublicKey:re,getSharedSecret:se,sign:Q,verify:oe,ProjectivePoint:m,Signature:ve,utils:We}}let HMAC$2=class extends Hash$2{constructor(t,r){super(),this.finished=!1,this.destroyed=!1,hash$1(t);const s=toBytes$3(r);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,a=new Uint8Array(o);a.set(s.length>o?t.create().update(s).digest():s);for(let c=0;c<a.length;c++)a[c]^=54;this.iHash.update(a),this.oHash=t.create();for(let c=0;c<a.length;c++)a[c]^=106;this.oHash.update(a),a.fill(0)}update(t){return exists$2(this),this.iHash.update(t),this}digestInto(t){exists$2(this),bytes$3(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:r,iHash:s,finished:o,destroyed:a,blockLen:c,outputLen:f}=this;return t=t,t.finished=o,t.destroyed=a,t.blockLen=c,t.outputLen=f,t.oHash=r._cloneInto(t.oHash),t.iHash=s._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}};const hmac$2=(n,t,r)=>new HMAC$2(n,t).update(r).digest();hmac$2.create=(n,t)=>new HMAC$2(n,t);function getHash(n){return{hash:n,hmac:(t,...r)=>hmac$2(n,t,concatBytes$3(...r)),randomBytes:randomBytes$2}}function createCurve$1(n,t){const r=s=>weierstrass$1({...n,...getHash(s)});return Object.freeze({...r(t),create:r})}const secp256k1P=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),secp256k1N=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),_1n$5=BigInt(1),_2n$3=BigInt(2),divNearest$1=(n,t)=>(n+t/_2n$3)/t;function sqrtMod$1(n){const t=secp256k1P,r=BigInt(3),s=BigInt(6),o=BigInt(11),a=BigInt(22),c=BigInt(23),f=BigInt(44),g=BigInt(88),m=n*n*n%t,b=m*m*n%t,k=pow2$1(b,r,t)*b%t,_=pow2$1(k,r,t)*b%t,A=pow2$1(_,_2n$3,t)*m%t,B=pow2$1(A,o,t)*A%t,L=pow2$1(B,a,t)*B%t,Z=pow2$1(L,f,t)*L%t,ve=pow2$1(Z,g,t)*Z%t,We=pow2$1(ve,f,t)*L%t,re=pow2$1(We,r,t)*b%t,ze=pow2$1(re,c,t)*B%t,se=pow2$1(ze,s,t)*m%t,ne=pow2$1(se,_2n$3,t);if(!Fp.eql(Fp.sqr(ne),n))throw new Error("Cannot find square root");return ne}const Fp=Field$1(secp256k1P,void 0,void 0,{sqrt:sqrtMod$1}),secp256k1$1=createCurve$1({a:BigInt(0),b:BigInt(7),Fp,n:secp256k1N,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:n=>{const t=secp256k1N,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),s=-_1n$5*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),a=r,c=BigInt("0x100000000000000000000000000000000"),f=divNearest$1(a*n,t),g=divNearest$1(-s*n,t);let m=mod$1(n-f*r-g*o,t),b=mod$1(-f*s-g*a,t);const k=m>c,_=b>c;if(k&&(m=t-m),_&&(b=t-b),m>c||b>c)throw new Error("splitScalar: Endomorphism failed, k="+n);return{k1neg:k,k1:m,k2neg:_,k2:b}}}},sha256$3),_0n$5=BigInt(0),fe$1=n=>typeof n=="bigint"&&_0n$5<n&&n<secp256k1P,ge$1=n=>typeof n=="bigint"&&_0n$5<n&&n<secp256k1N,TAGGED_HASH_PREFIXES$1={};function taggedHash$1(n,...t){let r=TAGGED_HASH_PREFIXES$1[n];if(r===void 0){const s=sha256$3(Uint8Array.from(n,o=>o.charCodeAt(0)));r=concatBytes$2(s,s),TAGGED_HASH_PREFIXES$1[n]=r}return sha256$3(concatBytes$2(r,...t))}const pointToBytes$1=n=>n.toRawBytes(!0).slice(1),numTo32b=n=>numberToBytesBE$1(n,32),modP=n=>mod$1(n,secp256k1P),modN=n=>mod$1(n,secp256k1N),Point$1=secp256k1$1.ProjectivePoint,GmulAdd=(n,t,r)=>Point$1.BASE.multiplyAndAddUnsafe(n,t,r);function schnorrGetExtPubKey$1(n){let t=secp256k1$1.utils.normPrivateKeyToScalar(n),r=Point$1.fromPrivateKey(t);return{scalar:r.hasEvenY()?t:modN(-t),bytes:pointToBytes$1(r)}}function lift_x$1(n){if(!fe$1(n))throw new Error("bad x: need 0 < x < p");const t=modP(n*n),r=modP(t*n+BigInt(7));let s=sqrtMod$1(r);s%_2n$3!==_0n$5&&(s=modP(-s));const o=new Point$1(n,s,_1n$5);return o.assertValidity(),o}function challenge$1(...n){return modN(bytesToNumberBE$1(taggedHash$1("BIP0340/challenge",...n)))}function schnorrGetPublicKey$1(n){return schnorrGetExtPubKey$1(n).bytes}function schnorrSign$1(n,t,r=randomBytes$2(32)){const s=ensureBytes$1("message",n),{bytes:o,scalar:a}=schnorrGetExtPubKey$1(t),c=ensureBytes$1("auxRand",r,32),f=numTo32b(a^bytesToNumberBE$1(taggedHash$1("BIP0340/aux",c))),g=taggedHash$1("BIP0340/nonce",f,o,s),m=modN(bytesToNumberBE$1(g));if(m===_0n$5)throw new Error("sign failed: k is zero");const{bytes:b,scalar:k}=schnorrGetExtPubKey$1(m),_=challenge$1(b,o,s),A=new Uint8Array(64);if(A.set(b,0),A.set(numTo32b(modN(k+_*a)),32),!schnorrVerify$1(A,s,o))throw new Error("sign: Invalid signature produced");return A}function schnorrVerify$1(n,t,r){const s=ensureBytes$1("signature",n,64),o=ensureBytes$1("message",t),a=ensureBytes$1("publicKey",r,32);try{const c=lift_x$1(bytesToNumberBE$1(a)),f=bytesToNumberBE$1(s.subarray(0,32));if(!fe$1(f))return!1;const g=bytesToNumberBE$1(s.subarray(32,64));if(!ge$1(g))return!1;const m=challenge$1(numTo32b(f),pointToBytes$1(c),o),b=GmulAdd(c,g,modN(-m));return!(!b||!b.hasEvenY()||b.toAffine().x!==f)}catch{return!1}}const schnorr$1={getPublicKey:schnorrGetPublicKey$1,sign:schnorrSign$1,verify:schnorrVerify$1,utils:{randomPrivateKey:secp256k1$1.utils.randomPrivateKey,lift_x:lift_x$1,pointToBytes:pointToBytes$1,numberToBytesBE:numberToBytesBE$1,bytesToNumberBE:bytesToNumberBE$1,taggedHash:taggedHash$1,mod:mod$1}},crypto$2=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;const u8a=n=>n instanceof Uint8Array,u32$1=n=>new Uint32Array(n.buffer,n.byteOffset,Math.floor(n.byteLength/4)),createView$2=n=>new DataView(n.buffer,n.byteOffset,n.byteLength),rotr$1=(n,t)=>n<<32-t|n>>>t,isLE$1=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE$1)throw new Error("Non little-endian hardware is not supported");const hexes$1=Array.from({length:256},(n,t)=>t.toString(16).padStart(2,"0"));function bytesToHex$2(n){if(!u8a(n))throw new Error("Uint8Array expected");let t="";for(let r=0;r<n.length;r++)t+=hexes$1[n[r]];return t}function hexToBytes$2(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);const t=n.length;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(t/2);for(let s=0;s<r.length;s++){const o=s*2,a=n.slice(o,o+2),c=Number.parseInt(a,16);if(Number.isNaN(c)||c<0)throw new Error("Invalid byte sequence");r[s]=c}return r}function utf8ToBytes$2(n){if(typeof n!="string")throw new Error(`utf8ToBytes expected string, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}function toBytes$2(n){if(typeof n=="string"&&(n=utf8ToBytes$2(n)),!u8a(n))throw new Error(`expected Uint8Array, got ${typeof n}`);return n}function concatBytes$1(...n){const t=new Uint8Array(n.reduce((s,o)=>s+o.length,0));let r=0;return n.forEach(s=>{if(!u8a(s))throw new Error("Uint8Array expected");t.set(s,r),r+=s.length}),t}let Hash$1=class{clone(){return this._cloneInto()}};const isPlainObject=n=>Object.prototype.toString.call(n)==="[object Object]"&&n.constructor===Object;function checkOpts$1(n,t){if(t!==void 0&&(typeof t!="object"||!isPlainObject(t)))throw new Error("Options should be object or undefined");return Object.assign(n,t)}function wrapConstructor(n){const t=s=>n().update(toBytes$2(s)).digest(),r=n();return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=()=>n(),t}function randomBytes$1(n=32){if(crypto$2&&typeof crypto$2.getRandomValues=="function")return crypto$2.getRandomValues(new Uint8Array(n));throw new Error("crypto.getRandomValues must be defined")}function number$1(n){if(!Number.isSafeInteger(n)||n<0)throw new Error(`Wrong positive integer: ${n}`)}function bool$1(n){if(typeof n!="boolean")throw new Error(`Expected boolean, not ${n}`)}function bytes$2(n,...t){if(!(n instanceof Uint8Array))throw new Error("Expected Uint8Array");if(t.length>0&&!t.includes(n.length))throw new Error(`Expected Uint8Array of length ${t}, not of length=${n.length}`)}function hash(n){if(typeof n!="function"||typeof n.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");number$1(n.outputLen),number$1(n.blockLen)}function exists$1(n,t=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(t&&n.finished)throw new Error("Hash#digest() has already been called")}function output$1(n,t){bytes$2(n);const r=t.outputLen;if(n.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}const assert={number:number$1,bool:bool$1,bytes:bytes$2,hash,exists:exists$1,output:output$1};function setBigUint64$2(n,t,r,s){if(typeof n.setBigUint64=="function")return n.setBigUint64(t,r,s);const o=BigInt(32),a=BigInt(4294967295),c=Number(r>>o&a),f=Number(r&a),g=s?4:0,m=s?0:4;n.setUint32(t+g,c,s),n.setUint32(t+m,f,s)}class SHA2 extends Hash$1{constructor(t,r,s,o){super(),this.blockLen=t,this.outputLen=r,this.padOffset=s,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=createView$2(this.buffer)}update(t){assert.exists(this);const{view:r,buffer:s,blockLen:o}=this;t=toBytes$2(t);const a=t.length;for(let c=0;c<a;){const f=Math.min(o-this.pos,a-c);if(f===o){const g=createView$2(t);for(;o<=a-c;c+=o)this.process(g,c);continue}s.set(t.subarray(c,c+f),this.pos),this.pos+=f,c+=f,this.pos===o&&(this.process(r,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){assert.exists(this),assert.output(t,this),this.finished=!0;const{buffer:r,view:s,blockLen:o,isLE:a}=this;let{pos:c}=this;r[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>o-c&&(this.process(s,0),c=0);for(let k=c;k<o;k++)r[k]=0;setBigUint64$2(s,o-8,BigInt(this.length*8),a),this.process(s,0);const f=createView$2(t),g=this.outputLen;if(g%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const m=g/4,b=this.get();if(m>b.length)throw new Error("_sha2: outputLen bigger than state");for(let k=0;k<m;k++)f.setUint32(4*k,b[k],a)}digest(){const{buffer:t,outputLen:r}=this;this.digestInto(t);const s=t.slice(0,r);return this.destroy(),s}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:r,buffer:s,length:o,finished:a,destroyed:c,pos:f}=this;return t.length=o,t.pos=f,t.finished=a,t.destroyed=c,o%r&&t.buffer.set(s),t}}const Chi$1=(n,t,r)=>n&t^~n&r,Maj$1=(n,t,r)=>n&t^n&r^t&r,SHA256_K$1=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),IV=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W$1=new Uint32Array(64);let SHA256$1=class extends SHA2{constructor(){super(64,32,8,!1),this.A=IV[0]|0,this.B=IV[1]|0,this.C=IV[2]|0,this.D=IV[3]|0,this.E=IV[4]|0,this.F=IV[5]|0,this.G=IV[6]|0,this.H=IV[7]|0}get(){const{A:t,B:r,C:s,D:o,E:a,F:c,G:f,H:g}=this;return[t,r,s,o,a,c,f,g]}set(t,r,s,o,a,c,f,g){this.A=t|0,this.B=r|0,this.C=s|0,this.D=o|0,this.E=a|0,this.F=c|0,this.G=f|0,this.H=g|0}process(t,r){for(let k=0;k<16;k++,r+=4)SHA256_W$1[k]=t.getUint32(r,!1);for(let k=16;k<64;k++){const _=SHA256_W$1[k-15],A=SHA256_W$1[k-2],B=rotr$1(_,7)^rotr$1(_,18)^_>>>3,L=rotr$1(A,17)^rotr$1(A,19)^A>>>10;SHA256_W$1[k]=L+SHA256_W$1[k-7]+B+SHA256_W$1[k-16]|0}let{A:s,B:o,C:a,D:c,E:f,F:g,G:m,H:b}=this;for(let k=0;k<64;k++){const _=rotr$1(f,6)^rotr$1(f,11)^rotr$1(f,25),A=b+_+Chi$1(f,g,m)+SHA256_K$1[k]+SHA256_W$1[k]|0,L=(rotr$1(s,2)^rotr$1(s,13)^rotr$1(s,22))+Maj$1(s,o,a)|0;b=m,m=g,g=f,f=c+A|0,c=a,a=o,o=s,s=A+L|0}s=s+this.A|0,o=o+this.B|0,a=a+this.C|0,c=c+this.D|0,f=f+this.E|0,g=g+this.F|0,m=m+this.G|0,b=b+this.H|0,this.set(s,o,a,c,f,g,m,b)}roundClean(){SHA256_W$1.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};class SHA224 extends SHA256$1{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const sha256$2=wrapConstructor(()=>new SHA256$1);wrapConstructor(()=>new SHA224);function assertNumber$1(n){if(!Number.isSafeInteger(n))throw new Error(`Wrong integer: ${n}`)}function chain$2(...n){const t=(o,a)=>c=>o(a(c)),r=Array.from(n).reverse().reduce((o,a)=>o?t(o,a.encode):a.encode,void 0),s=n.reduce((o,a)=>o?t(o,a.decode):a.decode,void 0);return{encode:r,decode:s}}function alphabet$2(n){return{encode:t=>{if(!Array.isArray(t)||t.length&&typeof t[0]!="number")throw new Error("alphabet.encode input should be an array of numbers");return t.map(r=>{if(assertNumber$1(r),r<0||r>=n.length)throw new Error(`Digit index outside alphabet: ${r} (alphabet: ${n.length})`);return n[r]})},decode:t=>{if(!Array.isArray(t)||t.length&&typeof t[0]!="string")throw new Error("alphabet.decode input should be array of strings");return t.map(r=>{if(typeof r!="string")throw new Error(`alphabet.decode: not string element=${r}`);const s=n.indexOf(r);if(s===-1)throw new Error(`Unknown letter: "${r}". Allowed: ${n}`);return s})}}}function join$2(n=""){if(typeof n!="string")throw new Error("join separator should be string");return{encode:t=>{if(!Array.isArray(t)||t.length&&typeof t[0]!="string")throw new Error("join.encode input should be array of strings");for(let r of t)if(typeof r!="string")throw new Error(`join.encode: non-string input=${r}`);return t.join(n)},decode:t=>{if(typeof t!="string")throw new Error("join.decode input should be string");return t.split(n)}}}function padding$1(n,t="="){if(assertNumber$1(n),typeof t!="string")throw new Error("padding chr should be string");return{encode(r){if(!Array.isArray(r)||r.length&&typeof r[0]!="string")throw new Error("padding.encode input should be array of strings");for(let s of r)if(typeof s!="string")throw new Error(`padding.encode: non-string input=${s}`);for(;r.length*n%8;)r.push(t);return r},decode(r){if(!Array.isArray(r)||r.length&&typeof r[0]!="string")throw new Error("padding.encode input should be array of strings");for(let o of r)if(typeof o!="string")throw new Error(`padding.decode: non-string input=${o}`);let s=r.length;if(s*n%8)throw new Error("Invalid padding: string should have whole number of bytes");for(;s>0&&r[s-1]===t;s--)if(!((s-1)*n%8))throw new Error("Invalid padding: string has too much padding");return r.slice(0,s)}}}function normalize$2(n){if(typeof n!="function")throw new Error("normalize fn should be function");return{encode:t=>t,decode:t=>n(t)}}function convertRadix$2(n,t,r){if(t<2)throw new Error(`convertRadix: wrong from=${t}, base cannot be less than 2`);if(r<2)throw new Error(`convertRadix: wrong to=${r}, base cannot be less than 2`);if(!Array.isArray(n))throw new Error("convertRadix: data should be array");if(!n.length)return[];let s=0;const o=[],a=Array.from(n);for(a.forEach(c=>{if(assertNumber$1(c),c<0||c>=t)throw new Error(`Wrong integer: ${c}`)});;){let c=0,f=!0;for(let g=s;g<a.length;g++){const m=a[g],b=t*c+m;if(!Number.isSafeInteger(b)||t*c/t!==c||b-m!==t*c)throw new Error("convertRadix: carry overflow");if(c=b%r,a[g]=Math.floor(b/r),!Number.isSafeInteger(a[g])||a[g]*r+c!==b)throw new Error("convertRadix: carry overflow");if(f)a[g]?f=!1:s=g;else continue}if(o.push(c),f)break}for(let c=0;c<n.length-1&&n[c]===0;c++)o.push(0);return o.reverse()}const gcd$2=(n,t)=>t?gcd$2(t,n%t):n,radix2carry$2=(n,t)=>n+(t-gcd$2(n,t));function convertRadix2$2(n,t,r,s){if(!Array.isArray(n))throw new Error("convertRadix2: data should be array");if(t<=0||t>32)throw new Error(`convertRadix2: wrong from=${t}`);if(r<=0||r>32)throw new Error(`convertRadix2: wrong to=${r}`);if(radix2carry$2(t,r)>32)throw new Error(`convertRadix2: carry overflow from=${t} to=${r} carryBits=${radix2carry$2(t,r)}`);let o=0,a=0;const c=2**r-1,f=[];for(const g of n){if(assertNumber$1(g),g>=2**t)throw new Error(`convertRadix2: invalid data word=${g} from=${t}`);if(o=o<<t|g,a+t>32)throw new Error(`convertRadix2: carry overflow pos=${a} from=${t}`);for(a+=t;a>=r;a-=r)f.push((o>>a-r&c)>>>0);o&=2**a-1}if(o=o<<r-a&c,!s&&a>=t)throw new Error("Excess padding");if(!s&&o)throw new Error(`Non-zero padding: ${o}`);return s&&a>0&&f.push(o>>>0),f}function radix$2(n){return assertNumber$1(n),{encode:t=>{if(!(t instanceof Uint8Array))throw new Error("radix.encode input should be Uint8Array");return convertRadix$2(Array.from(t),2**8,n)},decode:t=>{if(!Array.isArray(t)||t.length&&typeof t[0]!="number")throw new Error("radix.decode input should be array of strings");return Uint8Array.from(convertRadix$2(t,n,2**8))}}}function radix2$2(n,t=!1){if(assertNumber$1(n),n<=0||n>32)throw new Error("radix2: bits should be in (0..32]");if(radix2carry$2(8,n)>32||radix2carry$2(n,8)>32)throw new Error("radix2: carry overflow");return{encode:r=>{if(!(r instanceof Uint8Array))throw new Error("radix2.encode input should be Uint8Array");return convertRadix2$2(Array.from(r),8,n,!t)},decode:r=>{if(!Array.isArray(r)||r.length&&typeof r[0]!="number")throw new Error("radix2.decode input should be array of strings");return Uint8Array.from(convertRadix2$2(r,n,8,t))}}}function unsafeWrapper$2(n){if(typeof n!="function")throw new Error("unsafeWrapper fn should be function");return function(...t){try{return n.apply(null,t)}catch{}}}const base16$1=chain$2(radix2$2(4),alphabet$2("0123456789ABCDEF"),join$2("")),base32$1=chain$2(radix2$2(5),alphabet$2("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),padding$1(5),join$2(""));chain$2(radix2$2(5),alphabet$2("0123456789ABCDEFGHIJKLMNOPQRSTUV"),padding$1(5),join$2(""));chain$2(radix2$2(5),alphabet$2("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),join$2(""),normalize$2(n=>n.toUpperCase().replace(/O/g,"0").replace(/[IL]/g,"1")));const base64$1=chain$2(radix2$2(6),alphabet$2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),padding$1(6),join$2("")),base64url$1=chain$2(radix2$2(6),alphabet$2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),padding$1(6),join$2("")),genBase58$2=n=>chain$2(radix$2(58),alphabet$2(n),join$2("")),base58$2=genBase58$2("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");genBase58$2("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");genBase58$2("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");const XMR_BLOCK_LEN$1=[0,2,3,5,6,7,9,10,11],base58xmr$1={encode(n){let t="";for(let r=0;r<n.length;r+=8){const s=n.subarray(r,r+8);t+=base58$2.encode(s).padStart(XMR_BLOCK_LEN$1[s.length],"1")}return t},decode(n){let t=[];for(let r=0;r<n.length;r+=11){const s=n.slice(r,r+11),o=XMR_BLOCK_LEN$1.indexOf(s.length),a=base58$2.decode(s);for(let c=0;c<a.length-o;c++)if(a[c]!==0)throw new Error("base58xmr: wrong padding");t=t.concat(Array.from(a.slice(a.length-o)))}return Uint8Array.from(t)}},BECH_ALPHABET$2=chain$2(alphabet$2("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),join$2("")),POLYMOD_GENERATORS$2=[996825010,642813549,513874426,1027748829,705979059];function bech32Polymod$2(n){const t=n>>25;let r=(n&33554431)<<5;for(let s=0;s<POLYMOD_GENERATORS$2.length;s++)(t>>s&1)===1&&(r^=POLYMOD_GENERATORS$2[s]);return r}function bechChecksum$2(n,t,r=1){const s=n.length;let o=1;for(let a=0;a<s;a++){const c=n.charCodeAt(a);if(c<33||c>126)throw new Error(`Invalid prefix (${n})`);o=bech32Polymod$2(o)^c>>5}o=bech32Polymod$2(o);for(let a=0;a<s;a++)o=bech32Polymod$2(o)^n.charCodeAt(a)&31;for(let a of t)o=bech32Polymod$2(o)^a;for(let a=0;a<6;a++)o=bech32Polymod$2(o);return o^=r,BECH_ALPHABET$2.encode(convertRadix2$2([o%2**30],30,5,!1))}function genBech32$2(n){const t=n==="bech32"?1:734539939,r=radix2$2(5),s=r.decode,o=r.encode,a=unsafeWrapper$2(s);function c(b,k,_=90){if(typeof b!="string")throw new Error(`bech32.encode prefix should be string, not ${typeof b}`);if(!Array.isArray(k)||k.length&&typeof k[0]!="number")throw new Error(`bech32.encode words should be array of numbers, not ${typeof k}`);const A=b.length+7+k.length;if(_!==!1&&A>_)throw new TypeError(`Length ${A} exceeds limit ${_}`);return b=b.toLowerCase(),`${b}1${BECH_ALPHABET$2.encode(k)}${bechChecksum$2(b,k,t)}`}function f(b,k=90){if(typeof b!="string")throw new Error(`bech32.decode input should be string, not ${typeof b}`);if(b.length<8||k!==!1&&b.length>k)throw new TypeError(`Wrong string length: ${b.length} (${b}). Expected (8..${k})`);const _=b.toLowerCase();if(b!==_&&b!==b.toUpperCase())throw new Error("String must be lowercase or uppercase");b=_;const A=b.lastIndexOf("1");if(A===0||A===-1)throw new Error('Letter "1" must be present between prefix and data only');const B=b.slice(0,A),L=b.slice(A+1);if(L.length<6)throw new Error("Data must be at least 6 characters long");const Z=BECH_ALPHABET$2.decode(L).slice(0,-6),ve=bechChecksum$2(B,Z,t);if(!L.endsWith(ve))throw new Error(`Invalid checksum in ${b}: expected "${ve}"`);return{prefix:B,words:Z}}const g=unsafeWrapper$2(f);function m(b){const{prefix:k,words:_}=f(b,!1);return{prefix:k,words:_,bytes:s(_)}}return{encode:c,decode:f,decodeToBytes:m,decodeUnsafe:g,fromWords:s,fromWordsUnsafe:a,toWords:o}}const bech32$2=genBech32$2("bech32");genBech32$2("bech32m");const utf8$1={encode:n=>new TextDecoder().decode(n),decode:n=>new TextEncoder().encode(n)},hex$1=chain$2(radix2$2(4),alphabet$2("0123456789abcdef"),join$2(""),normalize$2(n=>{if(typeof n!="string"||n.length%2)throw new TypeError(`hex.decode: expected string, got ${typeof n} with length ${n.length}`);return n.toLowerCase()})),CODERS$1={utf8:utf8$1,hex:hex$1,base16:base16$1,base32:base32$1,base64:base64$1,base64url:base64url$1,base58:base58$2,base58xmr:base58xmr$1};`${Object.keys(CODERS$1).join(", ")}`;function number(n){if(!Number.isSafeInteger(n)||n<0)throw new Error(`positive integer expected, not ${n}`)}function bool(n){if(typeof n!="boolean")throw new Error(`boolean expected, not ${n}`)}function isBytes$2(n){return n instanceof Uint8Array||n!=null&&typeof n=="object"&&n.constructor.name==="Uint8Array"}function bytes$1(n,...t){if(!isBytes$2(n))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(n.length))throw new Error(`Uint8Array expected of length ${t}, not of length=${n.length}`)}function exists(n,t=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(t&&n.finished)throw new Error("Hash#digest() has already been called")}function output(n,t){bytes$1(n);const r=t.outputLen;if(n.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}const u32=n=>new Uint32Array(n.buffer,n.byteOffset,Math.floor(n.byteLength/4)),createView$1=n=>new DataView(n.buffer,n.byteOffset,n.byteLength),isLE=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE)throw new Error("Non little-endian hardware is not supported");function utf8ToBytes$1(n){if(typeof n!="string")throw new Error(`string expected, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}function toBytes$1(n){if(typeof n=="string")n=utf8ToBytes$1(n);else if(isBytes$2(n))n=n.slice();else throw new Error(`Uint8Array expected, got ${typeof n}`);return n}function checkOpts(n,t){if(t==null||typeof t!="object")throw new Error("options must be defined");return Object.assign(n,t)}function equalBytes(n,t){if(n.length!==t.length)return!1;let r=0;for(let s=0;s<n.length;s++)r|=n[s]^t[s];return r===0}const wrapCipher=(n,t)=>(Object.assign(t,n),t);function setBigUint64$1(n,t,r,s){if(typeof n.setBigUint64=="function")return n.setBigUint64(t,r,s);const o=BigInt(32),a=BigInt(4294967295),c=Number(r>>o&a),f=Number(r&a),g=4,m=0;n.setUint32(t+g,c,s),n.setUint32(t+m,f,s)}const BLOCK_SIZE=16,POLY=283;function mul2(n){return n<<1^POLY&-(n>>7)}function mul(n,t){let r=0;for(;t>0;t>>=1)r^=n&-(t&1),n=mul2(n);return r}const sbox=(()=>{let n=new Uint8Array(256);for(let r=0,s=1;r<256;r++,s^=mul2(s))n[r]=s;const t=new Uint8Array(256);t[0]=99;for(let r=0;r<255;r++){let s=n[255-r];s|=s<<8,t[n[r]]=(s^s>>4^s>>5^s>>6^s>>7^99)&255}return t})(),invSbox=sbox.map((n,t)=>sbox.indexOf(t)),rotr32_8=n=>n<<24|n>>>8,rotl32_8=n=>n<<8|n>>>24;function genTtable(n,t){if(n.length!==256)throw new Error("Wrong sbox length");const r=new Uint32Array(256).map((m,b)=>t(n[b])),s=r.map(rotl32_8),o=s.map(rotl32_8),a=o.map(rotl32_8),c=new Uint32Array(256*256),f=new Uint32Array(256*256),g=new Uint16Array(256*256);for(let m=0;m<256;m++)for(let b=0;b<256;b++){const k=m*256+b;c[k]=r[m]^s[b],f[k]=o[m]^a[b],g[k]=n[m]<<8|n[b]}return{sbox:n,sbox2:g,T0:r,T1:s,T2:o,T3:a,T01:c,T23:f}}const tableEncoding=genTtable(sbox,n=>mul(n,3)<<24|n<<16|n<<8|mul(n,2)),tableDecoding=genTtable(invSbox,n=>mul(n,11)<<24|mul(n,13)<<16|mul(n,9)<<8|mul(n,14)),xPowers=(()=>{const n=new Uint8Array(16);for(let t=0,r=1;t<16;t++,r=mul2(r))n[t]=r;return n})();function expandKeyLE(n){bytes$1(n);const t=n.length;if(![16,24,32].includes(t))throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${t}`);const{sbox2:r}=tableEncoding,s=u32(n),o=s.length,a=f=>applySbox(r,f,f,f,f),c=new Uint32Array(t+28);c.set(s);for(let f=o;f<c.length;f++){let g=c[f-1];f%o===0?g=a(rotr32_8(g))^xPowers[f/o-1]:o>6&&f%o===4&&(g=a(g)),c[f]=c[f-o]^g}return c}function expandKeyDecLE(n){const t=expandKeyLE(n),r=t.slice(),s=t.length,{sbox2:o}=tableEncoding,{T0:a,T1:c,T2:f,T3:g}=tableDecoding;for(let m=0;m<s;m+=4)for(let b=0;b<4;b++)r[m+b]=t[s-m-4+b];t.fill(0);for(let m=4;m<s-4;m++){const b=r[m],k=applySbox(o,b,b,b,b);r[m]=a[k&255]^c[k>>>8&255]^f[k>>>16&255]^g[k>>>24]}return r}function apply0123(n,t,r,s,o,a){return n[r<<8&65280|s>>>8&255]^t[o>>>8&65280|a>>>24&255]}function applySbox(n,t,r,s,o){return n[t&255|r&65280]|n[s>>>16&255|o>>>16&65280]<<16}function encrypt$3(n,t,r,s,o){const{sbox2:a,T01:c,T23:f}=tableEncoding;let g=0;t^=n[g++],r^=n[g++],s^=n[g++],o^=n[g++];const m=n.length/4-2;for(let B=0;B<m;B++){const L=n[g++]^apply0123(c,f,t,r,s,o),Z=n[g++]^apply0123(c,f,r,s,o,t),ve=n[g++]^apply0123(c,f,s,o,t,r),We=n[g++]^apply0123(c,f,o,t,r,s);t=L,r=Z,s=ve,o=We}const b=n[g++]^applySbox(a,t,r,s,o),k=n[g++]^applySbox(a,r,s,o,t),_=n[g++]^applySbox(a,s,o,t,r),A=n[g++]^applySbox(a,o,t,r,s);return{s0:b,s1:k,s2:_,s3:A}}function decrypt$3(n,t,r,s,o){const{sbox2:a,T01:c,T23:f}=tableDecoding;let g=0;t^=n[g++],r^=n[g++],s^=n[g++],o^=n[g++];const m=n.length/4-2;for(let B=0;B<m;B++){const L=n[g++]^apply0123(c,f,t,o,s,r),Z=n[g++]^apply0123(c,f,r,t,o,s),ve=n[g++]^apply0123(c,f,s,r,t,o),We=n[g++]^apply0123(c,f,o,s,r,t);t=L,r=Z,s=ve,o=We}const b=n[g++]^applySbox(a,t,o,s,r),k=n[g++]^applySbox(a,r,t,o,s),_=n[g++]^applySbox(a,s,r,t,o),A=n[g++]^applySbox(a,o,s,r,t);return{s0:b,s1:k,s2:_,s3:A}}function getDst(n,t){if(!t)return new Uint8Array(n);if(bytes$1(t),t.length<n)throw new Error(`aes: wrong destination length, expected at least ${n}, got: ${t.length}`);return t}function validateBlockDecrypt(n){if(bytes$1(n),n.length%BLOCK_SIZE!==0)throw new Error(`aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size ${BLOCK_SIZE}`)}function validateBlockEncrypt(n,t,r){let s=n.length;const o=s%BLOCK_SIZE;if(!t&&o!==0)throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");const a=u32(n);if(t){let g=BLOCK_SIZE-o;g||(g=BLOCK_SIZE),s=s+g}const c=getDst(s,r),f=u32(c);return{b:a,o:f,out:c}}function validatePCKS(n,t){if(!t)return n;const r=n.length;if(!r)throw new Error("aes/pcks5: empty ciphertext not allowed");const s=n[r-1];if(s<=0||s>16)throw new Error(`aes/pcks5: wrong padding byte: ${s}`);const o=n.subarray(0,-s);for(let a=0;a<s;a++)if(n[r-a-1]!==s)throw new Error("aes/pcks5: wrong padding");return o}function padPCKS(n){const t=new Uint8Array(16),r=u32(t);t.set(n);const s=BLOCK_SIZE-n.length;for(let o=BLOCK_SIZE-s;o<BLOCK_SIZE;o++)t[o]=s;return r}const cbc=wrapCipher({blockSize:16,nonceLength:16},function n(t,r,s={}){bytes$1(t),bytes$1(r,16);const o=!s.disablePadding;return{encrypt:(a,c)=>{const f=expandKeyLE(t),{b:g,o:m,out:b}=validateBlockEncrypt(a,o,c),k=u32(r);let _=k[0],A=k[1],B=k[2],L=k[3],Z=0;for(;Z+4<=g.length;)_^=g[Z+0],A^=g[Z+1],B^=g[Z+2],L^=g[Z+3],{s0:_,s1:A,s2:B,s3:L}=encrypt$3(f,_,A,B,L),m[Z++]=_,m[Z++]=A,m[Z++]=B,m[Z++]=L;if(o){const ve=padPCKS(a.subarray(Z*4));_^=ve[0],A^=ve[1],B^=ve[2],L^=ve[3],{s0:_,s1:A,s2:B,s3:L}=encrypt$3(f,_,A,B,L),m[Z++]=_,m[Z++]=A,m[Z++]=B,m[Z++]=L}return f.fill(0),b},decrypt:(a,c)=>{validateBlockDecrypt(a);const f=expandKeyDecLE(t),g=u32(r),m=getDst(a.length,c),b=u32(a),k=u32(m);let _=g[0],A=g[1],B=g[2],L=g[3];for(let Z=0;Z+4<=b.length;){const ve=_,We=A,re=B,ze=L;_=b[Z+0],A=b[Z+1],B=b[Z+2],L=b[Z+3];const{s0:se,s1:ne,s2:X,s3:$e}=decrypt$3(f,_,A,B,L);k[Z++]=se^ve,k[Z++]=ne^We,k[Z++]=X^re,k[Z++]=$e^ze}return f.fill(0),validatePCKS(m,o)}}}),u8to16=(n,t)=>n[t++]&255|(n[t++]&255)<<8;class Poly1305{constructor(t){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,t=toBytes$1(t),bytes$1(t,32);const r=u8to16(t,0),s=u8to16(t,2),o=u8to16(t,4),a=u8to16(t,6),c=u8to16(t,8),f=u8to16(t,10),g=u8to16(t,12),m=u8to16(t,14);this.r[0]=r&8191,this.r[1]=(r>>>13|s<<3)&8191,this.r[2]=(s>>>10|o<<6)&7939,this.r[3]=(o>>>7|a<<9)&8191,this.r[4]=(a>>>4|c<<12)&255,this.r[5]=c>>>1&8190,this.r[6]=(c>>>14|f<<2)&8191,this.r[7]=(f>>>11|g<<5)&8065,this.r[8]=(g>>>8|m<<8)&8191,this.r[9]=m>>>5&127;for(let b=0;b<8;b++)this.pad[b]=u8to16(t,16+2*b)}process(t,r,s=!1){const o=s?0:2048,{h:a,r:c}=this,f=c[0],g=c[1],m=c[2],b=c[3],k=c[4],_=c[5],A=c[6],B=c[7],L=c[8],Z=c[9],ve=u8to16(t,r+0),We=u8to16(t,r+2),re=u8to16(t,r+4),ze=u8to16(t,r+6),se=u8to16(t,r+8),ne=u8to16(t,r+10),X=u8to16(t,r+12),$e=u8to16(t,r+14);let Ve=a[0]+(ve&8191),Ze=a[1]+((ve>>>13|We<<3)&8191),He=a[2]+((We>>>10|re<<6)&8191),Le=a[3]+((re>>>7|ze<<9)&8191),Q=a[4]+((ze>>>4|se<<12)&8191),oe=a[5]+(se>>>1&8191),Y=a[6]+((se>>>14|ne<<2)&8191),Ce=a[7]+((ne>>>11|X<<5)&8191),je=a[8]+((X>>>8|$e<<8)&8191),Je=a[9]+($e>>>5|o),Ge=0,Xe=Ge+Ve*f+Ze*(5*Z)+He*(5*L)+Le*(5*B)+Q*(5*A);Ge=Xe>>>13,Xe&=8191,Xe+=oe*(5*_)+Y*(5*k)+Ce*(5*b)+je*(5*m)+Je*(5*g),Ge+=Xe>>>13,Xe&=8191;let Qe=Ge+Ve*g+Ze*f+He*(5*Z)+Le*(5*L)+Q*(5*B);Ge=Qe>>>13,Qe&=8191,Qe+=oe*(5*A)+Y*(5*_)+Ce*(5*k)+je*(5*b)+Je*(5*m),Ge+=Qe>>>13,Qe&=8191;let rt=Ge+Ve*m+Ze*g+He*f+Le*(5*Z)+Q*(5*L);Ge=rt>>>13,rt&=8191,rt+=oe*(5*B)+Y*(5*A)+Ce*(5*_)+je*(5*k)+Je*(5*b),Ge+=rt>>>13,rt&=8191;let _t=Ge+Ve*b+Ze*m+He*g+Le*f+Q*(5*Z);Ge=_t>>>13,_t&=8191,_t+=oe*(5*L)+Y*(5*B)+Ce*(5*A)+je*(5*_)+Je*(5*k),Ge+=_t>>>13,_t&=8191;let ht=Ge+Ve*k+Ze*b+He*m+Le*g+Q*f;Ge=ht>>>13,ht&=8191,ht+=oe*(5*Z)+Y*(5*L)+Ce*(5*B)+je*(5*A)+Je*(5*_),Ge+=ht>>>13,ht&=8191;let ot=Ge+Ve*_+Ze*k+He*b+Le*m+Q*g;Ge=ot>>>13,ot&=8191,ot+=oe*f+Y*(5*Z)+Ce*(5*L)+je*(5*B)+Je*(5*A),Ge+=ot>>>13,ot&=8191;let xt=Ge+Ve*A+Ze*_+He*k+Le*b+Q*m;Ge=xt>>>13,xt&=8191,xt+=oe*g+Y*f+Ce*(5*Z)+je*(5*L)+Je*(5*B),Ge+=xt>>>13,xt&=8191;let St=Ge+Ve*B+Ze*A+He*_+Le*k+Q*b;Ge=St>>>13,St&=8191,St+=oe*m+Y*g+Ce*f+je*(5*Z)+Je*(5*L),Ge+=St>>>13,St&=8191;let Mt=Ge+Ve*L+Ze*B+He*A+Le*_+Q*k;Ge=Mt>>>13,Mt&=8191,Mt+=oe*b+Y*m+Ce*g+je*f+Je*(5*Z),Ge+=Mt>>>13,Mt&=8191;let Bt=Ge+Ve*Z+Ze*L+He*B+Le*A+Q*_;Ge=Bt>>>13,Bt&=8191,Bt+=oe*k+Y*b+Ce*m+je*g+Je*f,Ge+=Bt>>>13,Bt&=8191,Ge=(Ge<<2)+Ge|0,Ge=Ge+Xe|0,Xe=Ge&8191,Ge=Ge>>>13,Qe+=Ge,a[0]=Xe,a[1]=Qe,a[2]=rt,a[3]=_t,a[4]=ht,a[5]=ot,a[6]=xt,a[7]=St,a[8]=Mt,a[9]=Bt}finalize(){const{h:t,pad:r}=this,s=new Uint16Array(10);let o=t[1]>>>13;t[1]&=8191;for(let f=2;f<10;f++)t[f]+=o,o=t[f]>>>13,t[f]&=8191;t[0]+=o*5,o=t[0]>>>13,t[0]&=8191,t[1]+=o,o=t[1]>>>13,t[1]&=8191,t[2]+=o,s[0]=t[0]+5,o=s[0]>>>13,s[0]&=8191;for(let f=1;f<10;f++)s[f]=t[f]+o,o=s[f]>>>13,s[f]&=8191;s[9]-=8192;let a=(o^1)-1;for(let f=0;f<10;f++)s[f]&=a;a=~a;for(let f=0;f<10;f++)t[f]=t[f]&a|s[f];t[0]=(t[0]|t[1]<<13)&65535,t[1]=(t[1]>>>3|t[2]<<10)&65535,t[2]=(t[2]>>>6|t[3]<<7)&65535,t[3]=(t[3]>>>9|t[4]<<4)&65535,t[4]=(t[4]>>>12|t[5]<<1|t[6]<<14)&65535,t[5]=(t[6]>>>2|t[7]<<11)&65535,t[6]=(t[7]>>>5|t[8]<<8)&65535,t[7]=(t[8]>>>8|t[9]<<5)&65535;let c=t[0]+r[0];t[0]=c&65535;for(let f=1;f<8;f++)c=(t[f]+r[f]|0)+(c>>>16)|0,t[f]=c&65535}update(t){exists(this);const{buffer:r,blockLen:s}=this;t=toBytes$1(t);const o=t.length;for(let a=0;a<o;){const c=Math.min(s-this.pos,o-a);if(c===s){for(;s<=o-a;a+=s)this.process(t,a);continue}r.set(t.subarray(a,a+c),this.pos),this.pos+=c,a+=c,this.pos===s&&(this.process(r,0,!1),this.pos=0)}return this}destroy(){this.h.fill(0),this.r.fill(0),this.buffer.fill(0),this.pad.fill(0)}digestInto(t){exists(this),output(t,this),this.finished=!0;const{buffer:r,h:s}=this;let{pos:o}=this;if(o){for(r[o++]=1;o<16;o++)r[o]=0;this.process(r,0,!0)}this.finalize();let a=0;for(let c=0;c<8;c++)t[a++]=s[c]>>>0,t[a++]=s[c]>>>8;return t}digest(){const{buffer:t,outputLen:r}=this;this.digestInto(t);const s=t.slice(0,r);return this.destroy(),s}}function wrapConstructorWithKey(n){const t=(s,o)=>n(o).update(toBytes$1(s)).digest(),r=n(new Uint8Array(32));return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=s=>n(s),t}const poly1305=wrapConstructorWithKey(n=>new Poly1305(n)),_utf8ToBytes=n=>Uint8Array.from(n.split("").map(t=>t.charCodeAt(0))),sigma16=_utf8ToBytes("expand 16-byte k"),sigma32=_utf8ToBytes("expand 32-byte k"),sigma16_32=u32(sigma16),sigma32_32=u32(sigma32);sigma32_32.slice();function rotl$2(n,t){return n<<t|n>>>32-t}function isAligned32(n){return n.byteOffset%4===0}const BLOCK_LEN=64,BLOCK_LEN32=16,MAX_COUNTER=2**32-1,U32_EMPTY=new Uint32Array;function runCipher(n,t,r,s,o,a,c,f){const g=o.length,m=new Uint8Array(BLOCK_LEN),b=u32(m),k=isAligned32(o)&&isAligned32(a),_=k?u32(o):U32_EMPTY,A=k?u32(a):U32_EMPTY;for(let B=0;B<g;c++){if(n(t,r,s,b,c,f),c>=MAX_COUNTER)throw new Error("arx: counter overflow");const L=Math.min(BLOCK_LEN,g-B);if(k&&L===BLOCK_LEN){const Z=B/4;if(B%4!==0)throw new Error("arx: invalid block position");for(let ve=0,We;ve<BLOCK_LEN32;ve++)We=Z+ve,A[We]=_[We]^b[ve];B+=BLOCK_LEN;continue}for(let Z=0,ve;Z<L;Z++)ve=B+Z,a[ve]=o[ve]^m[Z];B+=L}}function createCipher(n,t){const{allowShortKeys:r,extendNonceFn:s,counterLength:o,counterRight:a,rounds:c}=checkOpts({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},t);if(typeof n!="function")throw new Error("core must be a function");return number(o),number(c),bool(a),bool(r),(f,g,m,b,k=0)=>{bytes$1(f),bytes$1(g),bytes$1(m);const _=m.length;if(b||(b=new Uint8Array(_)),bytes$1(b),number(k),k<0||k>=MAX_COUNTER)throw new Error("arx: counter overflow");if(b.length<_)throw new Error(`arx: output (${b.length}) is shorter than data (${_})`);const A=[];let B=f.length,L,Z;if(B===32)L=f.slice(),A.push(L),Z=sigma32_32;else if(B===16&&r)L=new Uint8Array(32),L.set(f),L.set(f,16),Z=sigma16_32,A.push(L);else throw new Error(`arx: invalid 32-byte key, got length=${B}`);isAligned32(g)||(g=g.slice(),A.push(g));const ve=u32(L);if(s){if(g.length!==24)throw new Error("arx: extended nonce must be 24 bytes");s(Z,ve,u32(g.subarray(0,16)),ve),g=g.subarray(16)}const We=16-o;if(We!==g.length)throw new Error(`arx: nonce must be ${We} or 16 bytes`);if(We!==12){const ze=new Uint8Array(12);ze.set(g,a?0:12-g.length),g=ze,A.push(g)}const re=u32(g);for(runCipher(n,Z,ve,re,m,b,k,c);A.length>0;)A.pop().fill(0);return b}}function chachaCore(n,t,r,s,o,a=20){let c=n[0],f=n[1],g=n[2],m=n[3],b=t[0],k=t[1],_=t[2],A=t[3],B=t[4],L=t[5],Z=t[6],ve=t[7],We=o,re=r[0],ze=r[1],se=r[2],ne=c,X=f,$e=g,Ve=m,Ze=b,He=k,Le=_,Q=A,oe=B,Y=L,Ce=Z,je=ve,Je=We,Ge=re,Xe=ze,Qe=se;for(let _t=0;_t<a;_t+=2)ne=ne+Ze|0,Je=rotl$2(Je^ne,16),oe=oe+Je|0,Ze=rotl$2(Ze^oe,12),ne=ne+Ze|0,Je=rotl$2(Je^ne,8),oe=oe+Je|0,Ze=rotl$2(Ze^oe,7),X=X+He|0,Ge=rotl$2(Ge^X,16),Y=Y+Ge|0,He=rotl$2(He^Y,12),X=X+He|0,Ge=rotl$2(Ge^X,8),Y=Y+Ge|0,He=rotl$2(He^Y,7),$e=$e+Le|0,Xe=rotl$2(Xe^$e,16),Ce=Ce+Xe|0,Le=rotl$2(Le^Ce,12),$e=$e+Le|0,Xe=rotl$2(Xe^$e,8),Ce=Ce+Xe|0,Le=rotl$2(Le^Ce,7),Ve=Ve+Q|0,Qe=rotl$2(Qe^Ve,16),je=je+Qe|0,Q=rotl$2(Q^je,12),Ve=Ve+Q|0,Qe=rotl$2(Qe^Ve,8),je=je+Qe|0,Q=rotl$2(Q^je,7),ne=ne+He|0,Qe=rotl$2(Qe^ne,16),Ce=Ce+Qe|0,He=rotl$2(He^Ce,12),ne=ne+He|0,Qe=rotl$2(Qe^ne,8),Ce=Ce+Qe|0,He=rotl$2(He^Ce,7),X=X+Le|0,Je=rotl$2(Je^X,16),je=je+Je|0,Le=rotl$2(Le^je,12),X=X+Le|0,Je=rotl$2(Je^X,8),je=je+Je|0,Le=rotl$2(Le^je,7),$e=$e+Q|0,Ge=rotl$2(Ge^$e,16),oe=oe+Ge|0,Q=rotl$2(Q^oe,12),$e=$e+Q|0,Ge=rotl$2(Ge^$e,8),oe=oe+Ge|0,Q=rotl$2(Q^oe,7),Ve=Ve+Ze|0,Xe=rotl$2(Xe^Ve,16),Y=Y+Xe|0,Ze=rotl$2(Ze^Y,12),Ve=Ve+Ze|0,Xe=rotl$2(Xe^Ve,8),Y=Y+Xe|0,Ze=rotl$2(Ze^Y,7);let rt=0;s[rt++]=c+ne|0,s[rt++]=f+X|0,s[rt++]=g+$e|0,s[rt++]=m+Ve|0,s[rt++]=b+Ze|0,s[rt++]=k+He|0,s[rt++]=_+Le|0,s[rt++]=A+Q|0,s[rt++]=B+oe|0,s[rt++]=L+Y|0,s[rt++]=Z+Ce|0,s[rt++]=ve+je|0,s[rt++]=We+Je|0,s[rt++]=re+Ge|0,s[rt++]=ze+Xe|0,s[rt++]=se+Qe|0}function hchacha(n,t,r,s){let o=n[0],a=n[1],c=n[2],f=n[3],g=t[0],m=t[1],b=t[2],k=t[3],_=t[4],A=t[5],B=t[6],L=t[7],Z=r[0],ve=r[1],We=r[2],re=r[3];for(let se=0;se<20;se+=2)o=o+g|0,Z=rotl$2(Z^o,16),_=_+Z|0,g=rotl$2(g^_,12),o=o+g|0,Z=rotl$2(Z^o,8),_=_+Z|0,g=rotl$2(g^_,7),a=a+m|0,ve=rotl$2(ve^a,16),A=A+ve|0,m=rotl$2(m^A,12),a=a+m|0,ve=rotl$2(ve^a,8),A=A+ve|0,m=rotl$2(m^A,7),c=c+b|0,We=rotl$2(We^c,16),B=B+We|0,b=rotl$2(b^B,12),c=c+b|0,We=rotl$2(We^c,8),B=B+We|0,b=rotl$2(b^B,7),f=f+k|0,re=rotl$2(re^f,16),L=L+re|0,k=rotl$2(k^L,12),f=f+k|0,re=rotl$2(re^f,8),L=L+re|0,k=rotl$2(k^L,7),o=o+m|0,re=rotl$2(re^o,16),B=B+re|0,m=rotl$2(m^B,12),o=o+m|0,re=rotl$2(re^o,8),B=B+re|0,m=rotl$2(m^B,7),a=a+b|0,Z=rotl$2(Z^a,16),L=L+Z|0,b=rotl$2(b^L,12),a=a+b|0,Z=rotl$2(Z^a,8),L=L+Z|0,b=rotl$2(b^L,7),c=c+k|0,ve=rotl$2(ve^c,16),_=_+ve|0,k=rotl$2(k^_,12),c=c+k|0,ve=rotl$2(ve^c,8),_=_+ve|0,k=rotl$2(k^_,7),f=f+g|0,We=rotl$2(We^f,16),A=A+We|0,g=rotl$2(g^A,12),f=f+g|0,We=rotl$2(We^f,8),A=A+We|0,g=rotl$2(g^A,7);let ze=0;s[ze++]=o,s[ze++]=a,s[ze++]=c,s[ze++]=f,s[ze++]=Z,s[ze++]=ve,s[ze++]=We,s[ze++]=re}const chacha20=createCipher(chachaCore,{counterRight:!1,counterLength:4,allowShortKeys:!1}),xchacha20=createCipher(chachaCore,{counterRight:!1,counterLength:8,extendNonceFn:hchacha,allowShortKeys:!1}),ZEROS16=new Uint8Array(16),updatePadded=(n,t)=>{n.update(t);const r=t.length%16;r&&n.update(ZEROS16.subarray(r))},ZEROS32=new Uint8Array(32);function computeTag(n,t,r,s,o){const a=n(t,r,ZEROS32),c=poly1305.create(a);o&&updatePadded(c,o),updatePadded(c,s);const f=new Uint8Array(16),g=createView$1(f);setBigUint64$1(g,0,BigInt(o?o.length:0),!0),setBigUint64$1(g,8,BigInt(s.length),!0),c.update(f);const m=c.digest();return a.fill(0),m}const _poly1305_aead=n=>(t,r,s)=>(bytes$1(t,32),bytes$1(r),{encrypt:(a,c)=>{const f=a.length,g=f+16;c?bytes$1(c,g):c=new Uint8Array(g),n(t,r,a,c,1);const m=computeTag(n,t,r,c.subarray(0,-16),s);return c.set(m,f),c},decrypt:(a,c)=>{const f=a.length,g=f-16;if(f<16)throw new Error("encrypted data must be at least 16 bytes");c?bytes$1(c,g):c=new Uint8Array(g);const m=a.subarray(0,-16),b=a.subarray(-16),k=computeTag(n,t,r,m,s);if(!equalBytes(b,k))throw new Error("invalid tag");return n(t,r,m,c,1),c}}),xchacha20poly1305=wrapCipher({blockSize:64,nonceLength:24,tagLength:16},_poly1305_aead(xchacha20));let HMAC$1=class extends Hash$1{constructor(t,r){super(),this.finished=!1,this.destroyed=!1,assert.hash(t);const s=toBytes$2(r);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,a=new Uint8Array(o);a.set(s.length>o?t.create().update(s).digest():s);for(let c=0;c<a.length;c++)a[c]^=54;this.iHash.update(a),this.oHash=t.create();for(let c=0;c<a.length;c++)a[c]^=106;this.oHash.update(a),a.fill(0)}update(t){return assert.exists(this),this.iHash.update(t),this}digestInto(t){assert.exists(this),assert.bytes(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:r,iHash:s,finished:o,destroyed:a,blockLen:c,outputLen:f}=this;return t=t,t.finished=o,t.destroyed=a,t.blockLen=c,t.outputLen=f,t.oHash=r._cloneInto(t.oHash),t.iHash=s._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}};const hmac$1=(n,t,r)=>new HMAC$1(n,t).update(r).digest();hmac$1.create=(n,t)=>new HMAC$1(n,t);function extract(n,t,r){return assert.hash(n),hmac$1(n,toBytes$2(r),toBytes$2(t))}const HKDF_COUNTER=new Uint8Array([0]),EMPTY_BUFFER=new Uint8Array;function expand(n,t,r,s=32){if(assert.hash(n),assert.number(s),s>255*n.outputLen)throw new Error("Length should be <= 255*HashLen");const o=Math.ceil(s/n.outputLen);r===void 0&&(r=EMPTY_BUFFER);const a=new Uint8Array(o*n.outputLen),c=hmac$1.create(n,t),f=c._cloneInto(),g=new Uint8Array(c.outputLen);for(let m=0;m<o;m++)HKDF_COUNTER[0]=m+1,f.update(m===0?EMPTY_BUFFER:g).update(r).update(HKDF_COUNTER).digestInto(g),a.set(g,n.outputLen*m),c._cloneInto(f);return c.destroy(),f.destroy(),g.fill(0),HKDF_COUNTER.fill(0),a.slice(0,s)}var __defProp$1=Object.defineProperty,__export=(n,t)=>{for(var r in t)__defProp$1(n,r,{get:t[r],enumerable:!0})},verifiedSymbol=Symbol("verified"),isRecord=n=>n instanceof Object;function validateEvent(n){if(!isRecord(n)||typeof n.kind!="number"||typeof n.content!="string"||typeof n.created_at!="number"||typeof n.pubkey!="string"||!n.pubkey.match(/^[a-f0-9]{64}$/)||!Array.isArray(n.tags))return!1;for(let t=0;t<n.tags.length;t++){let r=n.tags[t];if(!Array.isArray(r))return!1;for(let s=0;s<r.length;s++)if(typeof r[s]!="string")return!1}return!0}var utils_exports={};__export(utils_exports,{Queue:()=>Queue$1,QueueNode:()=>QueueNode,binarySearch:()=>binarySearch,bytesToHex:()=>bytesToHex$2,hexToBytes:()=>hexToBytes$2,insertEventIntoAscendingList:()=>insertEventIntoAscendingList,insertEventIntoDescendingList:()=>insertEventIntoDescendingList,normalizeURL:()=>normalizeURL,utf8Decoder:()=>utf8Decoder$1,utf8Encoder:()=>utf8Encoder$1});var utf8Decoder$1=new TextDecoder("utf-8"),utf8Encoder$1=new TextEncoder;function normalizeURL(n){try{n.indexOf("://")===-1&&(n="wss://"+n);let t=new URL(n);return t.pathname=t.pathname.replace(/\/+/g,"/"),t.pathname.endsWith("/")&&(t.pathname=t.pathname.slice(0,-1)),(t.port==="80"&&t.protocol==="ws:"||t.port==="443"&&t.protocol==="wss:")&&(t.port=""),t.searchParams.sort(),t.hash="",t.toString()}catch{throw new Error(`Invalid URL: ${n}`)}}function insertEventIntoDescendingList(n,t){const[r,s]=binarySearch(n,o=>t.id===o.id?0:t.created_at===o.created_at?-1:o.created_at-t.created_at);return s||n.splice(r,0,t),n}function insertEventIntoAscendingList(n,t){const[r,s]=binarySearch(n,o=>t.id===o.id?0:t.created_at===o.created_at?-1:t.created_at-o.created_at);return s||n.splice(r,0,t),n}function binarySearch(n,t){let r=0,s=n.length-1;for(;r<=s;){const o=Math.floor((r+s)/2),a=t(n[o]);if(a===0)return[o,!0];a<0?s=o-1:r=o+1}return[r,!1]}var QueueNode=class{value;next=null;prev=null;constructor(n){this.value=n}},Queue$1=class{first;last;constructor(){this.first=null,this.last=null}enqueue(t){const r=new QueueNode(t);return this.last?this.last===this.first?(this.last=r,this.last.prev=this.first,this.first.next=r):(r.prev=this.last,this.last.next=r,this.last=r):(this.first=r,this.last=r),!0}dequeue(){if(!this.first)return null;if(this.first===this.last){const r=this.first;return this.first=null,this.last=null,r.value}const t=this.first;return this.first=t.next,this.first&&(this.first.prev=null),t.value}},JS=class{generateSecretKey(){return schnorr$1.utils.randomPrivateKey()}getPublicKey(n){return bytesToHex$2(schnorr$1.getPublicKey(n))}finalizeEvent(n,t){const r=n;return r.pubkey=bytesToHex$2(schnorr$1.getPublicKey(t)),r.id=getEventHash$1(r),r.sig=bytesToHex$2(schnorr$1.sign(getEventHash$1(r),t)),r[verifiedSymbol]=!0,r}verifyEvent(n){if(typeof n[verifiedSymbol]=="boolean")return n[verifiedSymbol];const t=getEventHash$1(n);if(t!==n.id)return n[verifiedSymbol]=!1,!1;try{const r=schnorr$1.verify(n.sig,t,n.pubkey);return n[verifiedSymbol]=r,r}catch{return n[verifiedSymbol]=!1,!1}}};function serializeEvent(n){if(!validateEvent(n))throw new Error("can't serialize event with wrong or missing properties");return JSON.stringify([0,n.pubkey,n.created_at,n.kind,n.tags,n.content])}function getEventHash$1(n){let t=sha256$2(utf8Encoder$1.encode(serializeEvent(n)));return bytesToHex$2(t)}var i$1=new JS,generateSecretKey=i$1.generateSecretKey,getPublicKey=i$1.getPublicKey,finalizeEvent=i$1.finalizeEvent,verifyEvent=i$1.verifyEvent,kinds_exports={};__export(kinds_exports,{Application:()=>Application,BadgeAward:()=>BadgeAward,BadgeDefinition:()=>BadgeDefinition,BlockedRelaysList:()=>BlockedRelaysList,BookmarkList:()=>BookmarkList,Bookmarksets:()=>Bookmarksets,Calendar:()=>Calendar,CalendarEventRSVP:()=>CalendarEventRSVP,ChannelCreation:()=>ChannelCreation,ChannelHideMessage:()=>ChannelHideMessage,ChannelMessage:()=>ChannelMessage,ChannelMetadata:()=>ChannelMetadata,ChannelMuteUser:()=>ChannelMuteUser,ClassifiedListing:()=>ClassifiedListing,ClientAuth:()=>ClientAuth,CommunitiesList:()=>CommunitiesList,CommunityDefinition:()=>CommunityDefinition,CommunityPostApproval:()=>CommunityPostApproval,Contacts:()=>Contacts,CreateOrUpdateProduct:()=>CreateOrUpdateProduct,CreateOrUpdateStall:()=>CreateOrUpdateStall,Curationsets:()=>Curationsets,Date:()=>Date2,DirectMessageRelaysList:()=>DirectMessageRelaysList,DraftClassifiedListing:()=>DraftClassifiedListing,DraftLong:()=>DraftLong,Emojisets:()=>Emojisets,EncryptedDirectMessage:()=>EncryptedDirectMessage,EventDeletion:()=>EventDeletion,FileMetadata:()=>FileMetadata,FileServerPreference:()=>FileServerPreference,Followsets:()=>Followsets,GenericRepost:()=>GenericRepost,Genericlists:()=>Genericlists,GiftWrap:()=>GiftWrap,HTTPAuth:()=>HTTPAuth,Handlerinformation:()=>Handlerinformation,Handlerrecommendation:()=>Handlerrecommendation,Highlights:()=>Highlights,InterestsList:()=>InterestsList,Interestsets:()=>Interestsets,JobFeedback:()=>JobFeedback,JobRequest:()=>JobRequest,JobResult:()=>JobResult,Label:()=>Label,LightningPubRPC:()=>LightningPubRPC,LiveChatMessage:()=>LiveChatMessage,LiveEvent:()=>LiveEvent,LongFormArticle:()=>LongFormArticle,Metadata:()=>Metadata,Mutelist:()=>Mutelist,NWCWalletInfo:()=>NWCWalletInfo,NWCWalletRequest:()=>NWCWalletRequest,NWCWalletResponse:()=>NWCWalletResponse,NostrConnect:()=>NostrConnect,OpenTimestamps:()=>OpenTimestamps,Pinlist:()=>Pinlist,PrivateDirectMessage:()=>PrivateDirectMessage,ProblemTracker:()=>ProblemTracker,ProfileBadges:()=>ProfileBadges,PublicChatsList:()=>PublicChatsList,Reaction:()=>Reaction,RecommendRelay:()=>RecommendRelay,RelayList:()=>RelayList,Relaysets:()=>Relaysets,Report:()=>Report,Reporting:()=>Reporting,Repost:()=>Repost,Seal:()=>Seal,SearchRelaysList:()=>SearchRelaysList,ShortTextNote:()=>ShortTextNote,Time:()=>Time,UserEmojiList:()=>UserEmojiList,UserStatuses:()=>UserStatuses,Zap:()=>Zap,ZapGoal:()=>ZapGoal,ZapRequest:()=>ZapRequest,classifyKind:()=>classifyKind,isAddressableKind:()=>isAddressableKind,isEphemeralKind:()=>isEphemeralKind,isKind:()=>isKind,isRegularKind:()=>isRegularKind,isReplaceableKind:()=>isReplaceableKind});function isRegularKind(n){return 1e3<=n&&n<1e4||[1,2,4,5,6,7,8,16,40,41,42,43,44].includes(n)}function isReplaceableKind(n){return[0,3].includes(n)||1e4<=n&&n<2e4}function isEphemeralKind(n){return 2e4<=n&&n<3e4}function isAddressableKind(n){return 3e4<=n&&n<4e4}function classifyKind(n){return isRegularKind(n)?"regular":isReplaceableKind(n)?"replaceable":isEphemeralKind(n)?"ephemeral":isAddressableKind(n)?"parameterized":"unknown"}function isKind(n,t){const r=t instanceof Array?t:[t];return validateEvent(n)&&r.includes(n.kind)||!1}var Metadata=0,ShortTextNote=1,RecommendRelay=2,Contacts=3,EncryptedDirectMessage=4,EventDeletion=5,Repost=6,Reaction=7,BadgeAward=8,Seal=13,PrivateDirectMessage=14,GenericRepost=16,ChannelCreation=40,ChannelMetadata=41,ChannelMessage=42,ChannelHideMessage=43,ChannelMuteUser=44,OpenTimestamps=1040,GiftWrap=1059,FileMetadata=1063,LiveChatMessage=1311,ProblemTracker=1971,Report=1984,Reporting=1984,Label=1985,CommunityPostApproval=4550,JobRequest=5999,JobResult=6999,JobFeedback=7e3,ZapGoal=9041,ZapRequest=9734,Zap=9735,Highlights=9802,Mutelist=1e4,Pinlist=10001,RelayList=10002,BookmarkList=10003,CommunitiesList=10004,PublicChatsList=10005,BlockedRelaysList=10006,SearchRelaysList=10007,InterestsList=10015,UserEmojiList=10030,DirectMessageRelaysList=10050,FileServerPreference=10096,NWCWalletInfo=13194,LightningPubRPC=21e3,ClientAuth=22242,NWCWalletRequest=23194,NWCWalletResponse=23195,NostrConnect=24133,HTTPAuth=27235,Followsets=3e4,Genericlists=30001,Relaysets=30002,Bookmarksets=30003,Curationsets=30004,ProfileBadges=30008,BadgeDefinition=30009,Interestsets=30015,CreateOrUpdateStall=30017,CreateOrUpdateProduct=30018,LongFormArticle=30023,DraftLong=30024,Emojisets=30030,Application=30078,LiveEvent=30311,UserStatuses=30315,ClassifiedListing=30402,DraftClassifiedListing=30403,Date2=31922,Time=31923,Calendar=31924,CalendarEventRSVP=31925,Handlerrecommendation=31989,Handlerinformation=31990,CommunityDefinition=34550;function matchFilter(n,t){if(n.ids&&n.ids.indexOf(t.id)===-1||n.kinds&&n.kinds.indexOf(t.kind)===-1||n.authors&&n.authors.indexOf(t.pubkey)===-1)return!1;for(let r in n)if(r[0]==="#"){let s=r.slice(1),o=n[`#${s}`];if(o&&!t.tags.find(([a,c])=>a===r.slice(1)&&o.indexOf(c)!==-1))return!1}return!(n.since&&t.created_at<n.since||n.until&&t.created_at>n.until)}function matchFilters(n,t){for(let r=0;r<n.length;r++)if(matchFilter(n[r],t))return!0;return!1}var fakejson_exports={};__export(fakejson_exports,{getHex64:()=>getHex64,getInt:()=>getInt,getSubscriptionId:()=>getSubscriptionId,matchEventId:()=>matchEventId,matchEventKind:()=>matchEventKind,matchEventPubkey:()=>matchEventPubkey});function getHex64(n,t){let r=t.length+3,s=n.indexOf(`"${t}":`)+r,o=n.slice(s).indexOf('"')+s+1;return n.slice(o,o+64)}function getInt(n,t){let r=t.length,s=n.indexOf(`"${t}":`)+r+3,o=n.slice(s),a=Math.min(o.indexOf(","),o.indexOf("}"));return parseInt(o.slice(0,a),10)}function getSubscriptionId(n){let t=n.slice(0,22).indexOf('"EVENT"');if(t===-1)return null;let r=n.slice(t+7+1).indexOf('"');if(r===-1)return null;let s=t+7+1+r,o=n.slice(s+1,80).indexOf('"');if(o===-1)return null;let a=s+1+o;return n.slice(s+1,a)}function matchEventId(n,t){return t===getHex64(n,"id")}function matchEventPubkey(n,t){return t===getHex64(n,"pubkey")}function matchEventKind(n,t){return t===getInt(n,"kind")}var nip42_exports={};__export(nip42_exports,{makeAuthEvent:()=>makeAuthEvent});function makeAuthEvent(n,t){return{kind:ClientAuth,created_at:Math.floor(Date.now()/1e3),tags:[["relay",n],["challenge",t]],content:""}}var _WebSocket;try{_WebSocket=WebSocket}catch{}var _WebSocket2;try{_WebSocket2=WebSocket}catch{}var nip19_exports$1={};__export(nip19_exports$1,{BECH32_REGEX:()=>BECH32_REGEX$2,Bech32MaxSize:()=>Bech32MaxSize$2,NostrTypeGuard:()=>NostrTypeGuard$1,decode:()=>decode$1,decodeNostrURI:()=>decodeNostrURI$1,encodeBytes:()=>encodeBytes$2,naddrEncode:()=>naddrEncode$1,neventEncode:()=>neventEncode$1,noteEncode:()=>noteEncode$1,nprofileEncode:()=>nprofileEncode$1,npubEncode:()=>npubEncode$1,nsecEncode:()=>nsecEncode$1});var NostrTypeGuard$1={isNProfile:n=>/^nprofile1[a-z\d]+$/.test(n||""),isNEvent:n=>/^nevent1[a-z\d]+$/.test(n||""),isNAddr:n=>/^naddr1[a-z\d]+$/.test(n||""),isNSec:n=>/^nsec1[a-z\d]{58}$/.test(n||""),isNPub:n=>/^npub1[a-z\d]{58}$/.test(n||""),isNote:n=>/^note1[a-z\d]+$/.test(n||""),isNcryptsec:n=>/^ncryptsec1[a-z\d]+$/.test(n||"")},Bech32MaxSize$2=5e3,BECH32_REGEX$2=/[\x21-\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;function integerToUint8Array$1(n){const t=new Uint8Array(4);return t[0]=n>>24&255,t[1]=n>>16&255,t[2]=n>>8&255,t[3]=n&255,t}function decodeNostrURI$1(n){try{return n.startsWith("nostr:")&&(n=n.substring(6)),decode$1(n)}catch{return{type:"invalid",data:null}}}function decode$1(n){let{prefix:t,words:r}=bech32$2.decode(n,Bech32MaxSize$2),s=new Uint8Array(bech32$2.fromWords(r));switch(t){case"nprofile":{let o=parseTLV$1(s);if(!o[0]?.[0])throw new Error("missing TLV 0 for nprofile");if(o[0][0].length!==32)throw new Error("TLV 0 should be 32 bytes");return{type:"nprofile",data:{pubkey:bytesToHex$2(o[0][0]),relays:o[1]?o[1].map(a=>utf8Decoder$1.decode(a)):[]}}}case"nevent":{let o=parseTLV$1(s);if(!o[0]?.[0])throw new Error("missing TLV 0 for nevent");if(o[0][0].length!==32)throw new Error("TLV 0 should be 32 bytes");if(o[2]&&o[2][0].length!==32)throw new Error("TLV 2 should be 32 bytes");if(o[3]&&o[3][0].length!==4)throw new Error("TLV 3 should be 4 bytes");return{type:"nevent",data:{id:bytesToHex$2(o[0][0]),relays:o[1]?o[1].map(a=>utf8Decoder$1.decode(a)):[],author:o[2]?.[0]?bytesToHex$2(o[2][0]):void 0,kind:o[3]?.[0]?parseInt(bytesToHex$2(o[3][0]),16):void 0}}}case"naddr":{let o=parseTLV$1(s);if(!o[0]?.[0])throw new Error("missing TLV 0 for naddr");if(!o[2]?.[0])throw new Error("missing TLV 2 for naddr");if(o[2][0].length!==32)throw new Error("TLV 2 should be 32 bytes");if(!o[3]?.[0])throw new Error("missing TLV 3 for naddr");if(o[3][0].length!==4)throw new Error("TLV 3 should be 4 bytes");return{type:"naddr",data:{identifier:utf8Decoder$1.decode(o[0][0]),pubkey:bytesToHex$2(o[2][0]),kind:parseInt(bytesToHex$2(o[3][0]),16),relays:o[1]?o[1].map(a=>utf8Decoder$1.decode(a)):[]}}}case"nsec":return{type:t,data:s};case"npub":case"note":return{type:t,data:bytesToHex$2(s)};default:throw new Error(`unknown prefix ${t}`)}}function parseTLV$1(n){let t={},r=n;for(;r.length>0;){let s=r[0],o=r[1],a=r.slice(2,2+o);if(r=r.slice(2+o),a.length<o)throw new Error(`not enough data to read on TLV ${s}`);t[s]=t[s]||[],t[s].push(a)}return t}function nsecEncode$1(n){return encodeBytes$2("nsec",n)}function npubEncode$1(n){return encodeBytes$2("npub",hexToBytes$2(n))}function noteEncode$1(n){return encodeBytes$2("note",hexToBytes$2(n))}function encodeBech32$2(n,t){let r=bech32$2.toWords(t);return bech32$2.encode(n,r,Bech32MaxSize$2)}function encodeBytes$2(n,t){return encodeBech32$2(n,t)}function nprofileEncode$1(n){let t=encodeTLV$1({0:[hexToBytes$2(n.pubkey)],1:(n.relays||[]).map(r=>utf8Encoder$1.encode(r))});return encodeBech32$2("nprofile",t)}function neventEncode$1(n){let t;n.kind!==void 0&&(t=integerToUint8Array$1(n.kind));let r=encodeTLV$1({0:[hexToBytes$2(n.id)],1:(n.relays||[]).map(s=>utf8Encoder$1.encode(s)),2:n.author?[hexToBytes$2(n.author)]:[],3:t?[new Uint8Array(t)]:[]});return encodeBech32$2("nevent",r)}function naddrEncode$1(n){let t=new ArrayBuffer(4);new DataView(t).setUint32(0,n.kind,!1);let r=encodeTLV$1({0:[utf8Encoder$1.encode(n.identifier)],1:(n.relays||[]).map(s=>utf8Encoder$1.encode(s)),2:[hexToBytes$2(n.pubkey)],3:[new Uint8Array(t)]});return encodeBech32$2("naddr",r)}function encodeTLV$1(n){let t=[];return Object.entries(n).reverse().forEach(([r,s])=>{s.forEach(o=>{let a=new Uint8Array(o.length+2);a.set([parseInt(r)],0),a.set([o.length],1),a.set(o,2),t.push(a)})}),concatBytes$1(...t)}var nip04_exports={};__export(nip04_exports,{decrypt:()=>decrypt$2,encrypt:()=>encrypt$2});function encrypt$2(n,t,r){const s=n instanceof Uint8Array?bytesToHex$2(n):n,o=secp256k1$1.getSharedSecret(s,"02"+t),a=getNormalizedX(o);let c=Uint8Array.from(randomBytes$1(16)),f=utf8Encoder$1.encode(r),g=cbc(a,c).encrypt(f),m=base64$1.encode(new Uint8Array(g)),b=base64$1.encode(new Uint8Array(c.buffer));return`${m}?iv=${b}`}function decrypt$2(n,t,r){const s=n instanceof Uint8Array?bytesToHex$2(n):n;let[o,a]=r.split("?iv="),c=secp256k1$1.getSharedSecret(s,"02"+t),f=getNormalizedX(c),g=base64$1.decode(a),m=base64$1.decode(o),b=cbc(f,g).decrypt(m);return utf8Decoder$1.decode(b)}function getNormalizedX(n){return n.slice(1,33)}var nip05_exports={};__export(nip05_exports,{NIP05_REGEX:()=>NIP05_REGEX$1,isNip05:()=>isNip05,isValid:()=>isValid,queryProfile:()=>queryProfile,searchDomain:()=>searchDomain,useFetchImplementation:()=>useFetchImplementation});var NIP05_REGEX$1=/^(?:([\w.+-]+)@)?([\w_-]+(\.[\w_-]+)+)$/,isNip05=n=>NIP05_REGEX$1.test(n||""),_fetch;try{_fetch=fetch}catch(n){}function useFetchImplementation(n){_fetch=n}async function searchDomain(n,t=""){try{const r=`https://${n}/.well-known/nostr.json?name=${t}`,s=await _fetch(r,{redirect:"manual"});if(s.status!==200)throw Error("Wrong response code");return(await s.json()).names}catch{return{}}}async function queryProfile(n){const t=n.match(NIP05_REGEX$1);if(!t)return null;const[,r="_",s]=t;try{const o=`https://${s}/.well-known/nostr.json?name=${r}`,a=await _fetch(o,{redirect:"manual"});if(a.status!==200)throw Error("Wrong response code");const c=await a.json(),f=c.names[r];return f?{pubkey:f,relays:c.relays?.[f]}:null}catch{return null}}async function isValid(n,t){const r=await queryProfile(t);return r?r.pubkey===n:!1}var nip10_exports={};__export(nip10_exports,{parse:()=>parse});function parse(n){const t={reply:void 0,root:void 0,mentions:[],profiles:[],quotes:[]};let r,s;for(let o=n.tags.length-1;o>=0;o--){const a=n.tags[o];if(a[0]==="e"&&a[1]){const[c,f,g,m,b]=a,k={id:f,relays:g?[g]:[],author:b};if(m==="root"){t.root=k;continue}if(m==="reply"){t.reply=k;continue}if(m==="mention"){t.mentions.push(k);continue}r?s=k:r=k,t.mentions.push(k);continue}if(a[0]==="q"&&a[1]){const[c,f,g]=a;t.quotes.push({id:f,relays:g?[g]:[]})}if(a[0]==="p"&&a[1]){t.profiles.push({pubkey:a[1],relays:a[2]?[a[2]]:[]});continue}}return t.root||(t.root=s||r||t.reply),t.reply||(t.reply=r||t.root),[t.reply,t.root].forEach(o=>{if(!o)return;let a=t.mentions.indexOf(o);if(a!==-1&&t.mentions.splice(a,1),o.author){let c=t.profiles.find(f=>f.pubkey===o.author);c&&c.relays&&(o.relays||(o.relays=[]),c.relays.forEach(f=>{o.relays?.indexOf(f)===-1&&o.relays.push(f)}),c.relays=o.relays)}}),t.mentions.forEach(o=>{if(o.author){let a=t.profiles.find(c=>c.pubkey===o.author);a&&a.relays&&(o.relays||(o.relays=[]),a.relays.forEach(c=>{o.relays.indexOf(c)===-1&&o.relays.push(c)}),a.relays=o.relays)}}),t}var nip11_exports={};__export(nip11_exports,{fetchRelayInformation:()=>fetchRelayInformation$1,useFetchImplementation:()=>useFetchImplementation2});var _fetch2;try{_fetch2=fetch}catch{}function useFetchImplementation2(n){_fetch2=n}async function fetchRelayInformation$1(n){return await(await fetch(n.replace("ws://","http://").replace("wss://","https://"),{headers:{Accept:"application/nostr+json"}})).json()}var nip13_exports={};__export(nip13_exports,{fastEventHash:()=>fastEventHash,getPow:()=>getPow,minePow:()=>minePow});function getPow(n){let t=0;for(let r=0;r<64;r+=8){const s=parseInt(n.substring(r,r+8),16);if(s===0)t+=32;else{t+=Math.clz32(s);break}}return t}function minePow(n,t){let r=0;const s=n,o=["nonce",r.toString(),t.toString()];for(s.tags.push(o);;){const a=Math.floor(new Date().getTime()/1e3);if(a!==s.created_at&&(r=0,s.created_at=a),o[1]=(++r).toString(),s.id=fastEventHash(s),getPow(s.id)>=t)break}return s}function fastEventHash(n){return bytesToHex$2(sha256$2(utf8Encoder$1.encode(JSON.stringify([0,n.pubkey,n.created_at,n.kind,n.tags,n.content]))))}var nip17_exports={};__export(nip17_exports,{unwrapEvent:()=>unwrapEvent2,unwrapManyEvents:()=>unwrapManyEvents2,wrapEvent:()=>wrapEvent2,wrapManyEvents:()=>wrapManyEvents2});var nip59_exports={};__export(nip59_exports,{createRumor:()=>createRumor,createSeal:()=>createSeal,createWrap:()=>createWrap,unwrapEvent:()=>unwrapEvent,unwrapManyEvents:()=>unwrapManyEvents,wrapEvent:()=>wrapEvent$1,wrapManyEvents:()=>wrapManyEvents});var nip44_exports={};__export(nip44_exports,{decrypt:()=>decrypt2,encrypt:()=>encrypt2,getConversationKey:()=>getConversationKey,v2:()=>v2});var minPlaintextSize=1,maxPlaintextSize=65535;function getConversationKey(n,t){const r=secp256k1$1.getSharedSecret(n,"02"+t).subarray(1,33);return extract(sha256$2,r,"nip44-v2")}function getMessageKeys(n,t){const r=expand(sha256$2,n,t,76);return{chacha_key:r.subarray(0,32),chacha_nonce:r.subarray(32,44),hmac_key:r.subarray(44,76)}}function calcPaddedLen(n){if(!Number.isSafeInteger(n)||n<1)throw new Error("expected positive integer");if(n<=32)return 32;const t=1<<Math.floor(Math.log2(n-1))+1,r=t<=256?32:t/8;return r*(Math.floor((n-1)/r)+1)}function writeU16BE(n){if(!Number.isSafeInteger(n)||n<minPlaintextSize||n>maxPlaintextSize)throw new Error("invalid plaintext size: must be between 1 and 65535 bytes");const t=new Uint8Array(2);return new DataView(t.buffer).setUint16(0,n,!1),t}function pad(n){const t=utf8Encoder$1.encode(n),r=t.length,s=writeU16BE(r),o=new Uint8Array(calcPaddedLen(r)-r);return concatBytes$1(s,t,o)}function unpad(n){const t=new DataView(n.buffer).getUint16(0),r=n.subarray(2,2+t);if(t<minPlaintextSize||t>maxPlaintextSize||r.length!==t||n.length!==2+calcPaddedLen(t))throw new Error("invalid padding");return utf8Decoder$1.decode(r)}function hmacAad(n,t,r){if(r.length!==32)throw new Error("AAD associated data must be 32 bytes");const s=concatBytes$1(r,t);return hmac$1(sha256$2,n,s)}function decodePayload(n){if(typeof n!="string")throw new Error("payload must be a valid string");const t=n.length;if(t<132||t>87472)throw new Error("invalid payload length: "+t);if(n[0]==="#")throw new Error("unknown encryption version");let r;try{r=base64$1.decode(n)}catch(a){throw new Error("invalid base64: "+a.message)}const s=r.length;if(s<99||s>65603)throw new Error("invalid data length: "+s);const o=r[0];if(o!==2)throw new Error("unknown encryption version "+o);return{nonce:r.subarray(1,33),ciphertext:r.subarray(33,-32),mac:r.subarray(-32)}}function encrypt2(n,t,r=randomBytes$1(32)){const{chacha_key:s,chacha_nonce:o,hmac_key:a}=getMessageKeys(t,r),c=pad(n),f=chacha20(s,o,c),g=hmacAad(a,f,r);return base64$1.encode(concatBytes$1(new Uint8Array([2]),r,f,g))}function decrypt2(n,t){const{nonce:r,ciphertext:s,mac:o}=decodePayload(n),{chacha_key:a,chacha_nonce:c,hmac_key:f}=getMessageKeys(t,r),g=hmacAad(f,s,r);if(!equalBytes(g,o))throw new Error("invalid MAC");const m=chacha20(a,c,s);return unpad(m)}var v2={utils:{getConversationKey,calcPaddedLen},encrypt:encrypt2,decrypt:decrypt2},TWO_DAYS=2880*60,now=()=>Math.round(Date.now()/1e3),randomNow=()=>Math.round(now()-Math.random()*TWO_DAYS),nip44ConversationKey=(n,t)=>getConversationKey(n,t),nip44Encrypt=(n,t,r)=>encrypt2(JSON.stringify(n),nip44ConversationKey(t,r)),nip44Decrypt=(n,t)=>JSON.parse(decrypt2(n.content,nip44ConversationKey(t,n.pubkey)));function createRumor(n,t){const r={created_at:now(),content:"",tags:[],...n,pubkey:getPublicKey(t)};return r.id=getEventHash$1(r),r}function createSeal(n,t,r){return finalizeEvent({kind:Seal,content:nip44Encrypt(n,t,r),created_at:randomNow(),tags:[]},t)}function createWrap(n,t){const r=generateSecretKey();return finalizeEvent({kind:GiftWrap,content:nip44Encrypt(n,r,t),created_at:randomNow(),tags:[["p",t]]},r)}function wrapEvent$1(n,t,r){const s=createRumor(n,t),o=createSeal(s,t,r);return createWrap(o,r)}function wrapManyEvents(n,t,r){if(!r||r.length===0)throw new Error("At least one recipient is required.");const s=getPublicKey(t),o=[wrapEvent$1(n,t,s)];return r.forEach(a=>{o.push(wrapEvent$1(n,t,a))}),o}function unwrapEvent(n,t){const r=nip44Decrypt(n,t);return nip44Decrypt(r,t)}function unwrapManyEvents(n,t){let r=[];return n.forEach(s=>{r.push(unwrapEvent(s,t))}),r.sort((s,o)=>s.created_at-o.created_at),r}function createEvent(n,t,r,s){const o={created_at:Math.ceil(Date.now()/1e3),kind:PrivateDirectMessage,tags:[],content:t};return(Array.isArray(n)?n:[n]).forEach(({publicKey:c,relayUrl:f})=>{o.tags.push(f?["p",c,f]:["p",c])}),s&&o.tags.push(["e",s.eventId,s.relayUrl||"","reply"]),r&&o.tags.push(["subject",r]),o}function wrapEvent2(n,t,r,s,o){const a=createEvent(t,r,s,o);return wrapEvent$1(a,n,t.publicKey)}function wrapManyEvents2(n,t,r,s,o){if(!t||t.length===0)throw new Error("At least one recipient is required.");return[{publicKey:getPublicKey(n)},...t].map(c=>wrapEvent2(n,c,r,s,o))}var unwrapEvent2=unwrapEvent,unwrapManyEvents2=unwrapManyEvents,nip18_exports={};__export(nip18_exports,{finishRepostEvent:()=>finishRepostEvent,getRepostedEvent:()=>getRepostedEvent,getRepostedEventPointer:()=>getRepostedEventPointer});function finishRepostEvent(n,t,r,s){let o;const a=[...n.tags??[],["e",t.id,r],["p",t.pubkey]];return t.kind===ShortTextNote?o=Repost:(o=GenericRepost,a.push(["k",String(t.kind)])),finalizeEvent({kind:o,tags:a,content:n.content===""||t.tags?.find(c=>c[0]==="-")?"":JSON.stringify(t),created_at:n.created_at},s)}function getRepostedEventPointer(n){if(![Repost,GenericRepost].includes(n.kind))return;let t,r;for(let s=n.tags.length-1;s>=0&&(t===void 0||r===void 0);s--){const o=n.tags[s];o.length>=2&&(o[0]==="e"&&t===void 0?t=o:o[0]==="p"&&r===void 0&&(r=o))}if(t!==void 0)return{id:t[1],relays:[t[2],r?.[2]].filter(s=>typeof s=="string"),author:r?.[1]}}function getRepostedEvent(n,{skipVerification:t}={}){const r=getRepostedEventPointer(n);if(r===void 0||n.content==="")return;let s;try{s=JSON.parse(n.content)}catch{return}if(s.id===r.id&&!(!t&&!verifyEvent(s)))return s}var nip21_exports={};__export(nip21_exports,{NOSTR_URI_REGEX:()=>NOSTR_URI_REGEX,parse:()=>parse2,test:()=>test});var NOSTR_URI_REGEX=new RegExp(`nostr:(${BECH32_REGEX$2.source})`);function test(n){return typeof n=="string"&&new RegExp(`^${NOSTR_URI_REGEX.source}$`).test(n)}function parse2(n){const t=n.match(new RegExp(`^${NOSTR_URI_REGEX.source}$`));if(!t)throw new Error(`Invalid Nostr URI: ${n}`);return{uri:t[0],value:t[1],decoded:decode$1(t[1])}}var nip25_exports={};__export(nip25_exports,{finishReactionEvent:()=>finishReactionEvent,getReactedEventPointer:()=>getReactedEventPointer});function finishReactionEvent(n,t,r){const s=t.tags.filter(o=>o.length>=2&&(o[0]==="e"||o[0]==="p"));return finalizeEvent({...n,kind:Reaction,tags:[...n.tags??[],...s,["e",t.id],["p",t.pubkey]],content:n.content??"+"},r)}function getReactedEventPointer(n){if(n.kind!==Reaction)return;let t,r;for(let s=n.tags.length-1;s>=0&&(t===void 0||r===void 0);s--){const o=n.tags[s];o.length>=2&&(o[0]==="e"&&t===void 0?t=o:o[0]==="p"&&r===void 0&&(r=o))}if(!(t===void 0||r===void 0))return{id:t[1],relays:[t[2],r[2]].filter(s=>s!==void 0),author:r[1]}}var nip27_exports={};__export(nip27_exports,{parse:()=>parse3});var noCharacter=/\W/m,noURLCharacter=/\W |\W$|$|,| /m;function*parse3(n){const t=n.length;let r=0,s=0;for(;s<t;){let o=n.indexOf(":",s);if(o===-1)break;if(n.substring(o-5,o)==="nostr"){const a=n.substring(o+60).match(noCharacter),c=a?o+60+a.index:t;try{let f,{data:g,type:m}=decode$1(n.substring(o+1,c));switch(m){case"npub":f={pubkey:g};break;case"nsec":case"note":s=c+1;continue;default:f=g}r!==o-5&&(yield{type:"text",text:n.substring(r,o-5)}),yield{type:"reference",pointer:f},s=c,r=s;continue}catch{s=o+1;continue}}else if(n.substring(o-5,o)==="https"||n.substring(o-4,o)==="http"){const a=n.substring(o+4).match(noURLCharacter),c=a?o+4+a.index:t,f=n[o-1]==="s"?5:4;try{let g=new URL(n.substring(o-f,c));if(g.hostname.indexOf(".")===-1)throw new Error("invalid url");if(r!==o-f&&(yield{type:"text",text:n.substring(r,o-f)}),/\.(png|jpe?g|gif|webp)$/i.test(g.pathname)){yield{type:"image",url:g.toString()},s=c,r=s;continue}if(/\.(mp4|avi|webm|mkv)$/i.test(g.pathname)){yield{type:"video",url:g.toString()},s=c,r=s;continue}if(/\.(mp3|aac|ogg|opus)$/i.test(g.pathname)){yield{type:"audio",url:g.toString()},s=c,r=s;continue}yield{type:"url",url:g.toString()},s=c,r=s;continue}catch{s=c+1;continue}}else if(n.substring(o-3,o)==="wss"||n.substring(o-2,o)==="ws"){const a=n.substring(o+4).match(noURLCharacter),c=a?o+4+a.index:t,f=n[o-1]==="s"?3:2;try{let g=new URL(n.substring(o-f,c));if(g.hostname.indexOf(".")===-1)throw new Error("invalid ws url");r!==o-f&&(yield{type:"text",text:n.substring(r,o-f)}),yield{type:"relay",url:g.toString()},s=c,r=s;continue}catch{s=c+1;continue}}else{s=o+1;continue}}r!==t&&(yield{type:"text",text:n.substring(r)})}var nip28_exports={};__export(nip28_exports,{channelCreateEvent:()=>channelCreateEvent,channelHideMessageEvent:()=>channelHideMessageEvent,channelMessageEvent:()=>channelMessageEvent,channelMetadataEvent:()=>channelMetadataEvent,channelMuteUserEvent:()=>channelMuteUserEvent});var channelCreateEvent=(n,t)=>{let r;if(typeof n.content=="object")r=JSON.stringify(n.content);else if(typeof n.content=="string")r=n.content;else return;return finalizeEvent({kind:ChannelCreation,tags:[...n.tags??[]],content:r,created_at:n.created_at},t)},channelMetadataEvent=(n,t)=>{let r;if(typeof n.content=="object")r=JSON.stringify(n.content);else if(typeof n.content=="string")r=n.content;else return;return finalizeEvent({kind:ChannelMetadata,tags:[["e",n.channel_create_event_id],...n.tags??[]],content:r,created_at:n.created_at},t)},channelMessageEvent=(n,t)=>{const r=[["e",n.channel_create_event_id,n.relay_url,"root"]];return n.reply_to_channel_message_event_id&&r.push(["e",n.reply_to_channel_message_event_id,n.relay_url,"reply"]),finalizeEvent({kind:ChannelMessage,tags:[...r,...n.tags??[]],content:n.content,created_at:n.created_at},t)},channelHideMessageEvent=(n,t)=>{let r;if(typeof n.content=="object")r=JSON.stringify(n.content);else if(typeof n.content=="string")r=n.content;else return;return finalizeEvent({kind:ChannelHideMessage,tags:[["e",n.channel_message_event_id],...n.tags??[]],content:r,created_at:n.created_at},t)},channelMuteUserEvent=(n,t)=>{let r;if(typeof n.content=="object")r=JSON.stringify(n.content);else if(typeof n.content=="string")r=n.content;else return;return finalizeEvent({kind:ChannelMuteUser,tags:[["p",n.pubkey_to_mute],...n.tags??[]],content:r,created_at:n.created_at},t)},nip30_exports={};__export(nip30_exports,{EMOJI_SHORTCODE_REGEX:()=>EMOJI_SHORTCODE_REGEX,matchAll:()=>matchAll,regex:()=>regex,replaceAll:()=>replaceAll});var EMOJI_SHORTCODE_REGEX=/:(\w+):/,regex=()=>new RegExp(`\\B${EMOJI_SHORTCODE_REGEX.source}\\B`,"g");function*matchAll(n){const t=n.matchAll(regex());for(const r of t)try{const[s,o]=r;yield{shortcode:s,name:o,start:r.index,end:r.index+s.length}}catch{}}function replaceAll(n,t){return n.replaceAll(regex(),(r,s)=>t({shortcode:r,name:s}))}var nip39_exports={};__export(nip39_exports,{useFetchImplementation:()=>useFetchImplementation3,validateGithub:()=>validateGithub});var _fetch3;try{_fetch3=fetch}catch{}function useFetchImplementation3(n){_fetch3=n}async function validateGithub(n,t,r){try{return await(await _fetch3(`https://gist.github.com/${t}/${r}/raw`)).text()===`Verifying that I control the following Nostr public key: ${n}`}catch{return!1}}var nip47_exports={};__export(nip47_exports,{makeNwcRequestEvent:()=>makeNwcRequestEvent,parseConnectionString:()=>parseConnectionString});function parseConnectionString(n){const{host:t,pathname:r,searchParams:s}=new URL(n),o=r||t,a=s.get("relay"),c=s.get("secret");if(!o||!a||!c)throw new Error("invalid connection string");return{pubkey:o,relay:a,secret:c}}async function makeNwcRequestEvent(n,t,r){const o=encrypt$2(t,n,JSON.stringify({method:"pay_invoice",params:{invoice:r}})),a={kind:NWCWalletRequest,created_at:Math.round(Date.now()/1e3),content:o,tags:[["p",n]]};return finalizeEvent(a,t)}var nip54_exports={};__export(nip54_exports,{normalizeIdentifier:()=>normalizeIdentifier});function normalizeIdentifier(n){return n=n.trim().toLowerCase(),n=n.normalize("NFKC"),Array.from(n).map(t=>new RegExp("\\p{Letter}","u").test(t)||new RegExp("\\p{Number}","u").test(t)?t:"-").join("")}var nip57_exports={};__export(nip57_exports,{getSatoshisAmountFromBolt11:()=>getSatoshisAmountFromBolt11,getZapEndpoint:()=>getZapEndpoint,makeZapReceipt:()=>makeZapReceipt,makeZapRequest:()=>makeZapRequest,useFetchImplementation:()=>useFetchImplementation4,validateZapRequest:()=>validateZapRequest});var _fetch4;try{_fetch4=fetch}catch{}function useFetchImplementation4(n){_fetch4=n}async function getZapEndpoint(n){try{let t="",{lud06:r,lud16:s}=JSON.parse(n.content);if(s){let[c,f]=s.split("@");t=new URL(`/.well-known/lnurlp/${c}`,`https://${f}`).toString()}else if(r){let{words:c}=bech32$2.decode(r,1e3),f=bech32$2.fromWords(c);t=utf8Decoder$1.decode(f)}else return null;let a=await(await _fetch4(t)).json();if(a.allowsNostr&&a.nostrPubkey)return a.callback}catch{}return null}function makeZapRequest(n){let t={kind:9734,created_at:Math.round(Date.now()/1e3),content:n.comment||"",tags:[["p","pubkey"in n?n.pubkey:n.event.pubkey],["amount",n.amount.toString()],["relays",...n.relays]]};if("event"in n){if(t.tags.push(["e",n.event.id]),isReplaceableKind(n.event.kind)){const r=["a",`${n.event.kind}:${n.event.pubkey}:`];t.tags.push(r)}else if(isAddressableKind(n.event.kind)){let r=n.event.tags.find(([o,a])=>o==="d"&&a);if(!r)throw new Error("d tag not found or is empty");const s=["a",`${n.event.kind}:${n.event.pubkey}:${r[1]}`];t.tags.push(s)}t.tags.push(["k",n.event.kind.toString()])}return t}function validateZapRequest(n){let t;try{t=JSON.parse(n)}catch{return"Invalid zap request JSON."}if(!validateEvent(t))return"Zap request is not a valid Nostr event.";if(!verifyEvent(t))return"Invalid signature on zap request.";let r=t.tags.find(([a,c])=>a==="p"&&c);if(!r)return"Zap request doesn't have a 'p' tag.";if(!r[1].match(/^[a-f0-9]{64}$/))return"Zap request 'p' tag is not valid hex.";let s=t.tags.find(([a,c])=>a==="e"&&c);return s&&!s[1].match(/^[a-f0-9]{64}$/)?"Zap request 'e' tag is not valid hex.":t.tags.find(([a,c])=>a==="relays"&&c)?null:"Zap request doesn't have a 'relays' tag."}function makeZapReceipt({zapRequest:n,preimage:t,bolt11:r,paidAt:s}){let o=JSON.parse(n),a=o.tags.filter(([f])=>f==="e"||f==="p"||f==="a"),c={kind:9735,created_at:Math.round(s.getTime()/1e3),content:"",tags:[...a,["P",o.pubkey],["bolt11",r],["description",n]]};return t&&c.tags.push(["preimage",t]),c}function getSatoshisAmountFromBolt11(n){if(n.length<50)return 0;n=n.substring(0,50);const t=n.lastIndexOf("1");if(t===-1)return 0;const r=n.substring(0,t);if(!r.startsWith("lnbc"))return 0;const s=r.substring(4);if(s.length<1)return 0;const o=s[s.length-1],a=o.charCodeAt(0)-48,c=a>=0&&a<=9;let f=s.length-1;if(c&&f++,f<1)return 0;const g=parseInt(s.substring(0,f));switch(o){case"m":return g*1e5;case"u":return g*100;case"n":return g/10;case"p":return g/1e4;default:return g*1e8}}var nip98_exports={};__export(nip98_exports,{getToken:()=>getToken,hashPayload:()=>hashPayload,unpackEventFromToken:()=>unpackEventFromToken,validateEvent:()=>validateEvent2,validateEventKind:()=>validateEventKind,validateEventMethodTag:()=>validateEventMethodTag,validateEventPayloadTag:()=>validateEventPayloadTag,validateEventTimestamp:()=>validateEventTimestamp,validateEventUrlTag:()=>validateEventUrlTag,validateToken:()=>validateToken});var _authorizationScheme="Nostr ";async function getToken(n,t,r,s=!1,o){const a={kind:HTTPAuth,tags:[["u",n],["method",t]],created_at:Math.round(new Date().getTime()/1e3),content:""};o&&a.tags.push(["payload",hashPayload(o)]);const c=await r(a);return(s?_authorizationScheme:"")+base64$1.encode(utf8Encoder$1.encode(JSON.stringify(c)))}async function validateToken(n,t,r){const s=await unpackEventFromToken(n).catch(a=>{throw a});return await validateEvent2(s,t,r).catch(a=>{throw a})}async function unpackEventFromToken(n){if(!n)throw new Error("Missing token");n=n.replace(_authorizationScheme,"");const t=utf8Decoder$1.decode(base64$1.decode(n));if(!t||t.length===0||!t.startsWith("{"))throw new Error("Invalid token");return JSON.parse(t)}function validateEventTimestamp(n){return n.created_at?Math.round(new Date().getTime()/1e3)-n.created_at<60:!1}function validateEventKind(n){return n.kind===HTTPAuth}function validateEventUrlTag(n,t){const r=n.tags.find(s=>s[0]==="u");return r?r.length>0&&r[1]===t:!1}function validateEventMethodTag(n,t){const r=n.tags.find(s=>s[0]==="method");return r?r.length>0&&r[1].toLowerCase()===t.toLowerCase():!1}function hashPayload(n){const t=sha256$2(utf8Encoder$1.encode(JSON.stringify(n)));return bytesToHex$2(t)}function validateEventPayloadTag(n,t){const r=n.tags.find(o=>o[0]==="payload");if(!r)return!1;const s=hashPayload(t);return r.length>0&&r[1]===s}async function validateEvent2(n,t,r,s){if(!verifyEvent(n))throw new Error("Invalid nostr event, signature invalid");if(!validateEventKind(n))throw new Error("Invalid nostr event, kind invalid");if(!validateEventTimestamp(n))throw new Error("Invalid nostr event, created_at timestamp invalid");if(!validateEventUrlTag(n,t))throw new Error("Invalid nostr event, url tag invalid");if(!validateEventMethodTag(n,r))throw new Error("Invalid nostr event, method tag invalid");if(s&&typeof s=="object"&&Object.keys(s).length>0&&!validateEventPayloadTag(n,s))throw new Error("Invalid nostr event, payload tag does not match request body hash");return!0}const crypto$1=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;function isBytes$1(n){return n instanceof Uint8Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint8Array"}function anumber$1(n){if(!Number.isSafeInteger(n)||n<0)throw new Error("positive integer expected, got "+n)}function abytes(n,...t){if(!isBytes$1(n))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(n.length))throw new Error("Uint8Array expected of length "+t+", got length="+n.length)}function ahash(n){if(typeof n!="function"||typeof n.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");anumber$1(n.outputLen),anumber$1(n.blockLen)}function aexists(n,t=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(t&&n.finished)throw new Error("Hash#digest() has already been called")}function aoutput(n,t){abytes(n);const r=t.outputLen;if(n.length<r)throw new Error("digestInto() expects output buffer of length at least "+r)}function clean(...n){for(let t=0;t<n.length;t++)n[t].fill(0)}function createView(n){return new DataView(n.buffer,n.byteOffset,n.byteLength)}function rotr(n,t){return n<<32-t|n>>>t}function rotl$1(n,t){return n<<t|n>>>32-t>>>0}const hasHexBuiltin=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",hexes=Array.from({length:256},(n,t)=>t.toString(16).padStart(2,"0"));function bytesToHex$1(n){if(abytes(n),hasHexBuiltin)return n.toHex();let t="";for(let r=0;r<n.length;r++)t+=hexes[n[r]];return t}const asciis={_0:48,_9:57,A:65,F:70,a:97,f:102};function asciiToBase16(n){if(n>=asciis._0&&n<=asciis._9)return n-asciis._0;if(n>=asciis.A&&n<=asciis.F)return n-(asciis.A-10);if(n>=asciis.a&&n<=asciis.f)return n-(asciis.a-10)}function hexToBytes$1(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);if(hasHexBuiltin)return Uint8Array.fromHex(n);const t=n.length,r=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const s=new Uint8Array(r);for(let o=0,a=0;o<r;o++,a+=2){const c=asciiToBase16(n.charCodeAt(a)),f=asciiToBase16(n.charCodeAt(a+1));if(c===void 0||f===void 0){const g=n[a]+n[a+1];throw new Error('hex string expected, got non-hex character "'+g+'" at index '+a)}s[o]=c*16+f}return s}function utf8ToBytes(n){if(typeof n!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(n))}function toBytes(n){return typeof n=="string"&&(n=utf8ToBytes(n)),abytes(n),n}function concatBytes(...n){let t=0;for(let s=0;s<n.length;s++){const o=n[s];abytes(o),t+=o.length}const r=new Uint8Array(t);for(let s=0,o=0;s<n.length;s++){const a=n[s];r.set(a,o),o+=a.length}return r}class Hash{}function createHasher(n){const t=s=>n().update(toBytes(s)).digest(),r=n();return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=()=>n(),t}function randomBytes(n=32){if(crypto$1&&typeof crypto$1.getRandomValues=="function")return crypto$1.getRandomValues(new Uint8Array(n));if(crypto$1&&typeof crypto$1.randomBytes=="function")return Uint8Array.from(crypto$1.randomBytes(n));throw new Error("crypto.getRandomValues must be defined")}function setBigUint64(n,t,r,s){if(typeof n.setBigUint64=="function")return n.setBigUint64(t,r,s);const o=BigInt(32),a=BigInt(4294967295),c=Number(r>>o&a),f=Number(r&a),g=s?4:0,m=s?0:4;n.setUint32(t+g,c,s),n.setUint32(t+m,f,s)}function Chi(n,t,r){return n&t^~n&r}function Maj(n,t,r){return n&t^n&r^t&r}class HashMD extends Hash{constructor(t,r,s,o){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=t,this.outputLen=r,this.padOffset=s,this.isLE=o,this.buffer=new Uint8Array(t),this.view=createView(this.buffer)}update(t){aexists(this),t=toBytes(t),abytes(t);const{view:r,buffer:s,blockLen:o}=this,a=t.length;for(let c=0;c<a;){const f=Math.min(o-this.pos,a-c);if(f===o){const g=createView(t);for(;o<=a-c;c+=o)this.process(g,c);continue}s.set(t.subarray(c,c+f),this.pos),this.pos+=f,c+=f,this.pos===o&&(this.process(r,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){aexists(this),aoutput(t,this),this.finished=!0;const{buffer:r,view:s,blockLen:o,isLE:a}=this;let{pos:c}=this;r[c++]=128,clean(this.buffer.subarray(c)),this.padOffset>o-c&&(this.process(s,0),c=0);for(let k=c;k<o;k++)r[k]=0;setBigUint64(s,o-8,BigInt(this.length*8),a),this.process(s,0);const f=createView(t),g=this.outputLen;if(g%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const m=g/4,b=this.get();if(m>b.length)throw new Error("_sha2: outputLen bigger than state");for(let k=0;k<m;k++)f.setUint32(4*k,b[k],a)}digest(){const{buffer:t,outputLen:r}=this;this.digestInto(t);const s=t.slice(0,r);return this.destroy(),s}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:r,buffer:s,length:o,finished:a,destroyed:c,pos:f}=this;return t.destroyed=c,t.finished=a,t.length=o,t.pos=f,o%r&&t.buffer.set(s),t}clone(){return this._cloneInto()}}const SHA256_IV=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA512_IV=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),U32_MASK64=BigInt(2**32-1),_32n=BigInt(32);function fromBig(n,t=!1){return t?{h:Number(n&U32_MASK64),l:Number(n>>_32n&U32_MASK64)}:{h:Number(n>>_32n&U32_MASK64)|0,l:Number(n&U32_MASK64)|0}}function split(n,t=!1){const r=n.length;let s=new Uint32Array(r),o=new Uint32Array(r);for(let a=0;a<r;a++){const{h:c,l:f}=fromBig(n[a],t);[s[a],o[a]]=[c,f]}return[s,o]}const shrSH=(n,t,r)=>n>>>r,shrSL=(n,t,r)=>n<<32-r|t>>>r,rotrSH=(n,t,r)=>n>>>r|t<<32-r,rotrSL=(n,t,r)=>n<<32-r|t>>>r,rotrBH=(n,t,r)=>n<<64-r|t>>>r-32,rotrBL=(n,t,r)=>n>>>r-32|t<<64-r;function add(n,t,r,s){const o=(t>>>0)+(s>>>0);return{h:n+r+(o/2**32|0)|0,l:o|0}}const add3L=(n,t,r)=>(n>>>0)+(t>>>0)+(r>>>0),add3H=(n,t,r,s)=>t+r+s+(n/2**32|0)|0,add4L=(n,t,r,s)=>(n>>>0)+(t>>>0)+(r>>>0)+(s>>>0),add4H=(n,t,r,s,o)=>t+r+s+o+(n/2**32|0)|0,add5L=(n,t,r,s,o)=>(n>>>0)+(t>>>0)+(r>>>0)+(s>>>0)+(o>>>0),add5H=(n,t,r,s,o,a)=>t+r+s+o+a+(n/2**32|0)|0,SHA256_K=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),SHA256_W=new Uint32Array(64);class SHA256 extends HashMD{constructor(t=32){super(64,t,8,!1),this.A=SHA256_IV[0]|0,this.B=SHA256_IV[1]|0,this.C=SHA256_IV[2]|0,this.D=SHA256_IV[3]|0,this.E=SHA256_IV[4]|0,this.F=SHA256_IV[5]|0,this.G=SHA256_IV[6]|0,this.H=SHA256_IV[7]|0}get(){const{A:t,B:r,C:s,D:o,E:a,F:c,G:f,H:g}=this;return[t,r,s,o,a,c,f,g]}set(t,r,s,o,a,c,f,g){this.A=t|0,this.B=r|0,this.C=s|0,this.D=o|0,this.E=a|0,this.F=c|0,this.G=f|0,this.H=g|0}process(t,r){for(let k=0;k<16;k++,r+=4)SHA256_W[k]=t.getUint32(r,!1);for(let k=16;k<64;k++){const _=SHA256_W[k-15],A=SHA256_W[k-2],B=rotr(_,7)^rotr(_,18)^_>>>3,L=rotr(A,17)^rotr(A,19)^A>>>10;SHA256_W[k]=L+SHA256_W[k-7]+B+SHA256_W[k-16]|0}let{A:s,B:o,C:a,D:c,E:f,F:g,G:m,H:b}=this;for(let k=0;k<64;k++){const _=rotr(f,6)^rotr(f,11)^rotr(f,25),A=b+_+Chi(f,g,m)+SHA256_K[k]+SHA256_W[k]|0,L=(rotr(s,2)^rotr(s,13)^rotr(s,22))+Maj(s,o,a)|0;b=m,m=g,g=f,f=c+A|0,c=a,a=o,o=s,s=A+L|0}s=s+this.A|0,o=o+this.B|0,a=a+this.C|0,c=c+this.D|0,f=f+this.E|0,g=g+this.F|0,m=m+this.G|0,b=b+this.H|0,this.set(s,o,a,c,f,g,m,b)}roundClean(){clean(SHA256_W)}destroy(){this.set(0,0,0,0,0,0,0,0),clean(this.buffer)}}const K512=split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(n=>BigInt(n))),SHA512_Kh=K512[0],SHA512_Kl=K512[1],SHA512_W_H=new Uint32Array(80),SHA512_W_L=new Uint32Array(80);class SHA512 extends HashMD{constructor(t=64){super(128,t,16,!1),this.Ah=SHA512_IV[0]|0,this.Al=SHA512_IV[1]|0,this.Bh=SHA512_IV[2]|0,this.Bl=SHA512_IV[3]|0,this.Ch=SHA512_IV[4]|0,this.Cl=SHA512_IV[5]|0,this.Dh=SHA512_IV[6]|0,this.Dl=SHA512_IV[7]|0,this.Eh=SHA512_IV[8]|0,this.El=SHA512_IV[9]|0,this.Fh=SHA512_IV[10]|0,this.Fl=SHA512_IV[11]|0,this.Gh=SHA512_IV[12]|0,this.Gl=SHA512_IV[13]|0,this.Hh=SHA512_IV[14]|0,this.Hl=SHA512_IV[15]|0}get(){const{Ah:t,Al:r,Bh:s,Bl:o,Ch:a,Cl:c,Dh:f,Dl:g,Eh:m,El:b,Fh:k,Fl:_,Gh:A,Gl:B,Hh:L,Hl:Z}=this;return[t,r,s,o,a,c,f,g,m,b,k,_,A,B,L,Z]}set(t,r,s,o,a,c,f,g,m,b,k,_,A,B,L,Z){this.Ah=t|0,this.Al=r|0,this.Bh=s|0,this.Bl=o|0,this.Ch=a|0,this.Cl=c|0,this.Dh=f|0,this.Dl=g|0,this.Eh=m|0,this.El=b|0,this.Fh=k|0,this.Fl=_|0,this.Gh=A|0,this.Gl=B|0,this.Hh=L|0,this.Hl=Z|0}process(t,r){for(let re=0;re<16;re++,r+=4)SHA512_W_H[re]=t.getUint32(r),SHA512_W_L[re]=t.getUint32(r+=4);for(let re=16;re<80;re++){const ze=SHA512_W_H[re-15]|0,se=SHA512_W_L[re-15]|0,ne=rotrSH(ze,se,1)^rotrSH(ze,se,8)^shrSH(ze,se,7),X=rotrSL(ze,se,1)^rotrSL(ze,se,8)^shrSL(ze,se,7),$e=SHA512_W_H[re-2]|0,Ve=SHA512_W_L[re-2]|0,Ze=rotrSH($e,Ve,19)^rotrBH($e,Ve,61)^shrSH($e,Ve,6),He=rotrSL($e,Ve,19)^rotrBL($e,Ve,61)^shrSL($e,Ve,6),Le=add4L(X,He,SHA512_W_L[re-7],SHA512_W_L[re-16]),Q=add4H(Le,ne,Ze,SHA512_W_H[re-7],SHA512_W_H[re-16]);SHA512_W_H[re]=Q|0,SHA512_W_L[re]=Le|0}let{Ah:s,Al:o,Bh:a,Bl:c,Ch:f,Cl:g,Dh:m,Dl:b,Eh:k,El:_,Fh:A,Fl:B,Gh:L,Gl:Z,Hh:ve,Hl:We}=this;for(let re=0;re<80;re++){const ze=rotrSH(k,_,14)^rotrSH(k,_,18)^rotrBH(k,_,41),se=rotrSL(k,_,14)^rotrSL(k,_,18)^rotrBL(k,_,41),ne=k&A^~k&L,X=_&B^~_&Z,$e=add5L(We,se,X,SHA512_Kl[re],SHA512_W_L[re]),Ve=add5H($e,ve,ze,ne,SHA512_Kh[re],SHA512_W_H[re]),Ze=$e|0,He=rotrSH(s,o,28)^rotrBH(s,o,34)^rotrBH(s,o,39),Le=rotrSL(s,o,28)^rotrBL(s,o,34)^rotrBL(s,o,39),Q=s&a^s&f^a&f,oe=o&c^o&g^c&g;ve=L|0,We=Z|0,L=A|0,Z=B|0,A=k|0,B=_|0,{h:k,l:_}=add(m|0,b|0,Ve|0,Ze|0),m=f|0,b=g|0,f=a|0,g=c|0,a=s|0,c=o|0;const Y=add3L(Ze,Le,oe);s=add3H(Y,Ve,He,Q),o=Y|0}({h:s,l:o}=add(this.Ah|0,this.Al|0,s|0,o|0)),{h:a,l:c}=add(this.Bh|0,this.Bl|0,a|0,c|0),{h:f,l:g}=add(this.Ch|0,this.Cl|0,f|0,g|0),{h:m,l:b}=add(this.Dh|0,this.Dl|0,m|0,b|0),{h:k,l:_}=add(this.Eh|0,this.El|0,k|0,_|0),{h:A,l:B}=add(this.Fh|0,this.Fl|0,A|0,B|0),{h:L,l:Z}=add(this.Gh|0,this.Gl|0,L|0,Z|0),{h:ve,l:We}=add(this.Hh|0,this.Hl|0,ve|0,We|0),this.set(s,o,a,c,f,g,m,b,k,_,A,B,L,Z,ve,We)}roundClean(){clean(SHA512_W_H,SHA512_W_L)}destroy(){clean(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const sha256$1=createHasher(()=>new SHA256),sha512=createHasher(()=>new SHA512);class HMAC extends Hash{constructor(t,r){super(),this.finished=!1,this.destroyed=!1,ahash(t);const s=toBytes(r);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,a=new Uint8Array(o);a.set(s.length>o?t.create().update(s).digest():s);for(let c=0;c<a.length;c++)a[c]^=54;this.iHash.update(a),this.oHash=t.create();for(let c=0;c<a.length;c++)a[c]^=106;this.oHash.update(a),clean(a)}update(t){return aexists(this),this.iHash.update(t),this}digestInto(t){aexists(this),abytes(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:r,iHash:s,finished:o,destroyed:a,blockLen:c,outputLen:f}=this;return t=t,t.finished=o,t.destroyed=a,t.blockLen=c,t.outputLen=f,t.oHash=r._cloneInto(t.oHash),t.iHash=s._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const hmac=(n,t,r)=>new HMAC(n,t).update(r).digest();hmac.create=(n,t)=>new HMAC(n,t);const _0n$4=BigInt(0),_1n$4=BigInt(1);function _abool2(n,t=""){if(typeof n!="boolean"){const r=t&&`"${t}"`;throw new Error(r+"expected boolean, got type="+typeof n)}return n}function _abytes2(n,t,r=""){const s=isBytes$1(n),o=n?.length,a=t!==void 0;if(!s||a&&o!==t){const c=r&&`"${r}" `,f=a?` of length ${t}`:"",g=s?`length=${o}`:`type=${typeof n}`;throw new Error(c+"expected Uint8Array"+f+", got "+g)}return n}function numberToHexUnpadded(n){const t=n.toString(16);return t.length&1?"0"+t:t}function hexToNumber(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return n===""?_0n$4:BigInt("0x"+n)}function bytesToNumberBE(n){return hexToNumber(bytesToHex$1(n))}function bytesToNumberLE(n){return abytes(n),hexToNumber(bytesToHex$1(Uint8Array.from(n).reverse()))}function numberToBytesBE(n,t){return hexToBytes$1(n.toString(16).padStart(t*2,"0"))}function numberToBytesLE(n,t){return numberToBytesBE(n,t).reverse()}function ensureBytes(n,t,r){let s;if(typeof t=="string")try{s=hexToBytes$1(t)}catch(a){throw new Error(n+" must be hex string or Uint8Array, cause: "+a)}else if(isBytes$1(t))s=Uint8Array.from(t);else throw new Error(n+" must be hex string or Uint8Array");const o=s.length;if(typeof r=="number"&&o!==r)throw new Error(n+" of length "+r+" expected, got "+o);return s}const isPosBig=n=>typeof n=="bigint"&&_0n$4<=n;function inRange(n,t,r){return isPosBig(n)&&isPosBig(t)&&isPosBig(r)&&t<=n&&n<r}function aInRange(n,t,r,s){if(!inRange(t,r,s))throw new Error("expected valid "+n+": "+r+" <= n < "+s+", got "+t)}function bitLen(n){let t;for(t=0;n>_0n$4;n>>=_1n$4,t+=1);return t}const bitMask=n=>(_1n$4<<BigInt(n))-_1n$4;function createHmacDrbg(n,t,r){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof r!="function")throw new Error("hmacFn must be a function");const s=A=>new Uint8Array(A),o=A=>Uint8Array.of(A);let a=s(n),c=s(n),f=0;const g=()=>{a.fill(1),c.fill(0),f=0},m=(...A)=>r(c,a,...A),b=(A=s(0))=>{c=m(o(0),A),a=m(),A.length!==0&&(c=m(o(1),A),a=m())},k=()=>{if(f++>=1e3)throw new Error("drbg: tried 1000 values");let A=0;const B=[];for(;A<t;){a=m();const L=a.slice();B.push(L),A+=a.length}return concatBytes(...B)};return(A,B)=>{g(),b(A);let L;for(;!(L=B(k()));)b();return g(),L}}function _validateObject(n,t,r={}){if(!n||typeof n!="object")throw new Error("expected valid options object");function s(o,a,c){const f=n[o];if(c&&f===void 0)return;const g=typeof f;if(g!==a||f===null)throw new Error(`param "${o}" is invalid: expected ${a}, got ${g}`)}Object.entries(t).forEach(([o,a])=>s(o,a,!1)),Object.entries(r).forEach(([o,a])=>s(o,a,!0))}function memoized(n){const t=new WeakMap;return(r,...s)=>{const o=t.get(r);if(o!==void 0)return o;const a=n(r,...s);return t.set(r,a),a}}const _0n$3=BigInt(0),_1n$3=BigInt(1),_2n$2=BigInt(2),_3n$1=BigInt(3),_4n$1=BigInt(4),_5n=BigInt(5),_7n=BigInt(7),_8n=BigInt(8),_9n=BigInt(9),_16n=BigInt(16);function mod(n,t){const r=n%t;return r>=_0n$3?r:t+r}function pow2(n,t,r){let s=n;for(;t-- >_0n$3;)s*=s,s%=r;return s}function invert(n,t){if(n===_0n$3)throw new Error("invert: expected non-zero number");if(t<=_0n$3)throw new Error("invert: expected positive modulus, got "+t);let r=mod(n,t),s=t,o=_0n$3,a=_1n$3;for(;r!==_0n$3;){const f=s/r,g=s%r,m=o-a*f;s=r,r=g,o=a,a=m}if(s!==_1n$3)throw new Error("invert: does not exist");return mod(o,t)}function assertIsSquare(n,t,r){if(!n.eql(n.sqr(t),r))throw new Error("Cannot find square root")}function sqrt3mod4(n,t){const r=(n.ORDER+_1n$3)/_4n$1,s=n.pow(t,r);return assertIsSquare(n,s,t),s}function sqrt5mod8(n,t){const r=(n.ORDER-_5n)/_8n,s=n.mul(t,_2n$2),o=n.pow(s,r),a=n.mul(t,o),c=n.mul(n.mul(a,_2n$2),o),f=n.mul(a,n.sub(c,n.ONE));return assertIsSquare(n,f,t),f}function sqrt9mod16(n){const t=Field(n),r=tonelliShanks(n),s=r(t,t.neg(t.ONE)),o=r(t,s),a=r(t,t.neg(s)),c=(n+_7n)/_16n;return(f,g)=>{let m=f.pow(g,c),b=f.mul(m,s);const k=f.mul(m,o),_=f.mul(m,a),A=f.eql(f.sqr(b),g),B=f.eql(f.sqr(k),g);m=f.cmov(m,b,A),b=f.cmov(_,k,B);const L=f.eql(f.sqr(b),g),Z=f.cmov(m,b,L);return assertIsSquare(f,Z,g),Z}}function tonelliShanks(n){if(n<_3n$1)throw new Error("sqrt is not defined for small field");let t=n-_1n$3,r=0;for(;t%_2n$2===_0n$3;)t/=_2n$2,r++;let s=_2n$2;const o=Field(n);for(;FpLegendre(o,s)===1;)if(s++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(r===1)return sqrt3mod4;let a=o.pow(s,t);const c=(t+_1n$3)/_2n$2;return function(g,m){if(g.is0(m))return m;if(FpLegendre(g,m)!==1)throw new Error("Cannot find square root");let b=r,k=g.mul(g.ONE,a),_=g.pow(m,t),A=g.pow(m,c);for(;!g.eql(_,g.ONE);){if(g.is0(_))return g.ZERO;let B=1,L=g.sqr(_);for(;!g.eql(L,g.ONE);)if(B++,L=g.sqr(L),B===b)throw new Error("Cannot find square root");const Z=_1n$3<<BigInt(b-B-1),ve=g.pow(k,Z);b=B,k=g.sqr(ve),_=g.mul(_,k),A=g.mul(A,ve)}return A}}function FpSqrt(n){return n%_4n$1===_3n$1?sqrt3mod4:n%_8n===_5n?sqrt5mod8:n%_16n===_9n?sqrt9mod16(n):tonelliShanks(n)}const FIELD_FIELDS=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function validateField(n){const t={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},r=FIELD_FIELDS.reduce((s,o)=>(s[o]="function",s),t);return _validateObject(n,r),n}function FpPow(n,t,r){if(r<_0n$3)throw new Error("invalid exponent, negatives unsupported");if(r===_0n$3)return n.ONE;if(r===_1n$3)return t;let s=n.ONE,o=t;for(;r>_0n$3;)r&_1n$3&&(s=n.mul(s,o)),o=n.sqr(o),r>>=_1n$3;return s}function FpInvertBatch(n,t,r=!1){const s=new Array(t.length).fill(r?n.ZERO:void 0),o=t.reduce((c,f,g)=>n.is0(f)?c:(s[g]=c,n.mul(c,f)),n.ONE),a=n.inv(o);return t.reduceRight((c,f,g)=>n.is0(f)?c:(s[g]=n.mul(c,s[g]),n.mul(c,f)),a),s}function FpLegendre(n,t){const r=(n.ORDER-_1n$3)/_2n$2,s=n.pow(t,r),o=n.eql(s,n.ONE),a=n.eql(s,n.ZERO),c=n.eql(s,n.neg(n.ONE));if(!o&&!a&&!c)throw new Error("invalid Legendre symbol result");return o?1:a?0:-1}function nLength(n,t){t!==void 0&&anumber$1(t);const r=t!==void 0?t:n.toString(2).length,s=Math.ceil(r/8);return{nBitLength:r,nByteLength:s}}function Field(n,t,r=!1,s={}){if(n<=_0n$3)throw new Error("invalid field: expected ORDER > 0, got "+n);let o,a,c=!1,f;if(typeof t=="object"&&t!=null){if(s.sqrt||r)throw new Error("cannot specify opts in two arguments");const _=t;_.BITS&&(o=_.BITS),_.sqrt&&(a=_.sqrt),typeof _.isLE=="boolean"&&(r=_.isLE),typeof _.modFromBytes=="boolean"&&(c=_.modFromBytes),f=_.allowedLengths}else typeof t=="number"&&(o=t),s.sqrt&&(a=s.sqrt);const{nBitLength:g,nByteLength:m}=nLength(n,o);if(m>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let b;const k=Object.freeze({ORDER:n,isLE:r,BITS:g,BYTES:m,MASK:bitMask(g),ZERO:_0n$3,ONE:_1n$3,allowedLengths:f,create:_=>mod(_,n),isValid:_=>{if(typeof _!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof _);return _0n$3<=_&&_<n},is0:_=>_===_0n$3,isValidNot0:_=>!k.is0(_)&&k.isValid(_),isOdd:_=>(_&_1n$3)===_1n$3,neg:_=>mod(-_,n),eql:(_,A)=>_===A,sqr:_=>mod(_*_,n),add:(_,A)=>mod(_+A,n),sub:(_,A)=>mod(_-A,n),mul:(_,A)=>mod(_*A,n),pow:(_,A)=>FpPow(k,_,A),div:(_,A)=>mod(_*invert(A,n),n),sqrN:_=>_*_,addN:(_,A)=>_+A,subN:(_,A)=>_-A,mulN:(_,A)=>_*A,inv:_=>invert(_,n),sqrt:a||(_=>(b||(b=FpSqrt(n)),b(k,_))),toBytes:_=>r?numberToBytesLE(_,m):numberToBytesBE(_,m),fromBytes:(_,A=!0)=>{if(f){if(!f.includes(_.length)||_.length>m)throw new Error("Field.fromBytes: expected "+f+" bytes, got "+_.length);const L=new Uint8Array(m);L.set(_,r?0:L.length-_.length),_=L}if(_.length!==m)throw new Error("Field.fromBytes: expected "+m+" bytes, got "+_.length);let B=r?bytesToNumberLE(_):bytesToNumberBE(_);if(c&&(B=mod(B,n)),!A&&!k.isValid(B))throw new Error("invalid field element: outside of range 0..ORDER");return B},invertBatch:_=>FpInvertBatch(k,_),cmov:(_,A,B)=>B?A:_});return Object.freeze(k)}function getFieldBytesLength(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const t=n.toString(2).length;return Math.ceil(t/8)}function getMinHashLength(n){const t=getFieldBytesLength(n);return t+Math.ceil(t/2)}function mapHashToField(n,t,r=!1){const s=n.length,o=getFieldBytesLength(t),a=getMinHashLength(t);if(s<16||s<a||s>1024)throw new Error("expected "+a+"-1024 bytes of input, got "+s);const c=r?bytesToNumberLE(n):bytesToNumberBE(n),f=mod(c,t-_1n$3)+_1n$3;return r?numberToBytesLE(f,o):numberToBytesBE(f,o)}const _0n$2=BigInt(0),_1n$2=BigInt(1);function negateCt(n,t){const r=t.negate();return n?r:t}function normalizeZ(n,t){const r=FpInvertBatch(n.Fp,t.map(s=>s.Z));return t.map((s,o)=>n.fromAffine(s.toAffine(r[o])))}function validateW(n,t){if(!Number.isSafeInteger(n)||n<=0||n>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+n)}function calcWOpts(n,t){validateW(n,t);const r=Math.ceil(t/n)+1,s=2**(n-1),o=2**n,a=bitMask(n),c=BigInt(n);return{windows:r,windowSize:s,mask:a,maxNumber:o,shiftBy:c}}function calcOffsets(n,t,r){const{windowSize:s,mask:o,maxNumber:a,shiftBy:c}=r;let f=Number(n&o),g=n>>c;f>s&&(f-=a,g+=_1n$2);const m=t*s,b=m+Math.abs(f)-1,k=f===0,_=f<0,A=t%2!==0;return{nextN:g,offset:b,isZero:k,isNeg:_,isNegF:A,offsetF:m}}function validateMSMPoints(n,t){if(!Array.isArray(n))throw new Error("array expected");n.forEach((r,s)=>{if(!(r instanceof t))throw new Error("invalid point at index "+s)})}function validateMSMScalars(n,t){if(!Array.isArray(n))throw new Error("array of scalars expected");n.forEach((r,s)=>{if(!t.isValid(r))throw new Error("invalid scalar at index "+s)})}const pointPrecomputes=new WeakMap,pointWindowSizes=new WeakMap;function getW(n){return pointWindowSizes.get(n)||1}function assert0(n){if(n!==_0n$2)throw new Error("invalid wNAF")}class wNAF{constructor(t,r){this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=r}_unsafeLadder(t,r,s=this.ZERO){let o=t;for(;r>_0n$2;)r&_1n$2&&(s=s.add(o)),o=o.double(),r>>=_1n$2;return s}precomputeWindow(t,r){const{windows:s,windowSize:o}=calcWOpts(r,this.bits),a=[];let c=t,f=c;for(let g=0;g<s;g++){f=c,a.push(f);for(let m=1;m<o;m++)f=f.add(c),a.push(f);c=f.double()}return a}wNAF(t,r,s){if(!this.Fn.isValid(s))throw new Error("invalid scalar");let o=this.ZERO,a=this.BASE;const c=calcWOpts(t,this.bits);for(let f=0;f<c.windows;f++){const{nextN:g,offset:m,isZero:b,isNeg:k,isNegF:_,offsetF:A}=calcOffsets(s,f,c);s=g,b?a=a.add(negateCt(_,r[A])):o=o.add(negateCt(k,r[m]))}return assert0(s),{p:o,f:a}}wNAFUnsafe(t,r,s,o=this.ZERO){const a=calcWOpts(t,this.bits);for(let c=0;c<a.windows&&s!==_0n$2;c++){const{nextN:f,offset:g,isZero:m,isNeg:b}=calcOffsets(s,c,a);if(s=f,!m){const k=r[g];o=o.add(b?k.negate():k)}}return assert0(s),o}getPrecomputes(t,r,s){let o=pointPrecomputes.get(r);return o||(o=this.precomputeWindow(r,t),t!==1&&(typeof s=="function"&&(o=s(o)),pointPrecomputes.set(r,o))),o}cached(t,r,s){const o=getW(t);return this.wNAF(o,this.getPrecomputes(o,t,s),r)}unsafe(t,r,s,o){const a=getW(t);return a===1?this._unsafeLadder(t,r,o):this.wNAFUnsafe(a,this.getPrecomputes(a,t,s),r,o)}createCache(t,r){validateW(r,this.bits),pointWindowSizes.set(t,r),pointPrecomputes.delete(t)}hasCache(t){return getW(t)!==1}}function mulEndoUnsafe(n,t,r,s){let o=t,a=n.ZERO,c=n.ZERO;for(;r>_0n$2||s>_0n$2;)r&_1n$2&&(a=a.add(o)),s&_1n$2&&(c=c.add(o)),o=o.double(),r>>=_1n$2,s>>=_1n$2;return{p1:a,p2:c}}function pippenger(n,t,r,s){validateMSMPoints(r,n),validateMSMScalars(s,t);const o=r.length,a=s.length;if(o!==a)throw new Error("arrays of points and scalars must have equal length");const c=n.ZERO,f=bitLen(BigInt(o));let g=1;f>12?g=f-3:f>4?g=f-2:f>0&&(g=2);const m=bitMask(g),b=new Array(Number(m)+1).fill(c),k=Math.floor((t.BITS-1)/g)*g;let _=c;for(let A=k;A>=0;A-=g){b.fill(c);for(let L=0;L<a;L++){const Z=s[L],ve=Number(Z>>BigInt(A)&m);b[ve]=b[ve].add(r[L])}let B=c;for(let L=b.length-1,Z=c;L>0;L--)Z=Z.add(b[L]),B=B.add(Z);if(_=_.add(B),A!==0)for(let L=0;L<g;L++)_=_.double()}return _}function createField(n,t,r){if(t){if(t.ORDER!==n)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return validateField(t),t}else return Field(n,{isLE:r})}function _createCurveFields(n,t,r={},s){if(s===void 0&&(s=n==="edwards"),!t||typeof t!="object")throw new Error(`expected valid ${n} CURVE object`);for(const g of["p","n","h"]){const m=t[g];if(!(typeof m=="bigint"&&m>_0n$2))throw new Error(`CURVE.${g} must be positive bigint`)}const o=createField(t.p,r.Fp,s),a=createField(t.n,r.Fn,s),f=["Gx","Gy","a","b"];for(const g of f)if(!o.isValid(t[g]))throw new Error(`CURVE.${g} must be valid field element of CURVE.Fp`);return t=Object.freeze(Object.assign({},t)),{CURVE:t,Fp:o,Fn:a}}const divNearest=(n,t)=>(n+(n>=0?t:-t)/_2n$1)/t;function _splitEndoScalar(n,t,r){const[[s,o],[a,c]]=t,f=divNearest(c*n,r),g=divNearest(-o*n,r);let m=n-f*s-g*a,b=-f*o-g*c;const k=m<_0n$1,_=b<_0n$1;k&&(m=-m),_&&(b=-b);const A=bitMask(Math.ceil(bitLen(r)/2))+_1n$1;if(m<_0n$1||m>=A||b<_0n$1||b>=A)throw new Error("splitScalar (endomorphism): failed, k="+n);return{k1neg:k,k1:m,k2neg:_,k2:b}}function validateSigFormat(n){if(!["compact","recovered","der"].includes(n))throw new Error('Signature format must be "compact", "recovered", or "der"');return n}function validateSigOpts(n,t){const r={};for(let s of Object.keys(t))r[s]=n[s]===void 0?t[s]:n[s];return _abool2(r.lowS,"lowS"),_abool2(r.prehash,"prehash"),r.format!==void 0&&validateSigFormat(r.format),r}class DERErr extends Error{constructor(t=""){super(t)}}const DER={Err:DERErr,_tlv:{encode:(n,t)=>{const{Err:r}=DER;if(n<0||n>256)throw new r("tlv.encode: wrong tag");if(t.length&1)throw new r("tlv.encode: unpadded data");const s=t.length/2,o=numberToHexUnpadded(s);if(o.length/2&128)throw new r("tlv.encode: long form length too big");const a=s>127?numberToHexUnpadded(o.length/2|128):"";return numberToHexUnpadded(n)+a+o+t},decode(n,t){const{Err:r}=DER;let s=0;if(n<0||n>256)throw new r("tlv.encode: wrong tag");if(t.length<2||t[s++]!==n)throw new r("tlv.decode: wrong tlv");const o=t[s++],a=!!(o&128);let c=0;if(!a)c=o;else{const g=o&127;if(!g)throw new r("tlv.decode(long): indefinite length not supported");if(g>4)throw new r("tlv.decode(long): byte length is too big");const m=t.subarray(s,s+g);if(m.length!==g)throw new r("tlv.decode: length bytes not complete");if(m[0]===0)throw new r("tlv.decode(long): zero leftmost byte");for(const b of m)c=c<<8|b;if(s+=g,c<128)throw new r("tlv.decode(long): not minimal encoding")}const f=t.subarray(s,s+c);if(f.length!==c)throw new r("tlv.decode: wrong value length");return{v:f,l:t.subarray(s+c)}}},_int:{encode(n){const{Err:t}=DER;if(n<_0n$1)throw new t("integer: negative integers are not allowed");let r=numberToHexUnpadded(n);if(Number.parseInt(r[0],16)&8&&(r="00"+r),r.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return r},decode(n){const{Err:t}=DER;if(n[0]&128)throw new t("invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return bytesToNumberBE(n)}},toSig(n){const{Err:t,_int:r,_tlv:s}=DER,o=ensureBytes("signature",n),{v:a,l:c}=s.decode(48,o);if(c.length)throw new t("invalid signature: left bytes after parsing");const{v:f,l:g}=s.decode(2,a),{v:m,l:b}=s.decode(2,g);if(b.length)throw new t("invalid signature: left bytes after parsing");return{r:r.decode(f),s:r.decode(m)}},hexFromSig(n){const{_tlv:t,_int:r}=DER,s=t.encode(2,r.encode(n.r)),o=t.encode(2,r.encode(n.s)),a=s+o;return t.encode(48,a)}},_0n$1=BigInt(0),_1n$1=BigInt(1),_2n$1=BigInt(2),_3n=BigInt(3),_4n=BigInt(4);function _normFnElement(n,t){const{BYTES:r}=n;let s;if(typeof t=="bigint")s=t;else{let o=ensureBytes("private key",t);try{s=n.fromBytes(o)}catch{throw new Error(`invalid private key: expected ui8a of size ${r}, got ${typeof t}`)}}if(!n.isValidNot0(s))throw new Error("invalid private key: out of range [1..N-1]");return s}function weierstrassN(n,t={}){const r=_createCurveFields("weierstrass",n,t),{Fp:s,Fn:o}=r;let a=r.CURVE;const{h:c,n:f}=a;_validateObject(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:g}=t;if(g&&(!s.is0(a.a)||typeof g.beta!="bigint"||!Array.isArray(g.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const m=getWLengths(s,o);function b(){if(!s.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function k(Le,Q,oe){const{x:Y,y:Ce}=Q.toAffine(),je=s.toBytes(Y);if(_abool2(oe,"isCompressed"),oe){b();const Je=!s.isOdd(Ce);return concatBytes(pprefix(Je),je)}else return concatBytes(Uint8Array.of(4),je,s.toBytes(Ce))}function _(Le){_abytes2(Le,void 0,"Point");const{publicKey:Q,publicKeyUncompressed:oe}=m,Y=Le.length,Ce=Le[0],je=Le.subarray(1);if(Y===Q&&(Ce===2||Ce===3)){const Je=s.fromBytes(je);if(!s.isValid(Je))throw new Error("bad point: is not on curve, wrong x");const Ge=L(Je);let Xe;try{Xe=s.sqrt(Ge)}catch(_t){const ht=_t instanceof Error?": "+_t.message:"";throw new Error("bad point: is not on curve, sqrt error"+ht)}b();const Qe=s.isOdd(Xe);return(Ce&1)===1!==Qe&&(Xe=s.neg(Xe)),{x:Je,y:Xe}}else if(Y===oe&&Ce===4){const Je=s.BYTES,Ge=s.fromBytes(je.subarray(0,Je)),Xe=s.fromBytes(je.subarray(Je,Je*2));if(!Z(Ge,Xe))throw new Error("bad point: is not on curve");return{x:Ge,y:Xe}}else throw new Error(`bad point: got length ${Y}, expected compressed=${Q} or uncompressed=${oe}`)}const A=t.toBytes||k,B=t.fromBytes||_;function L(Le){const Q=s.sqr(Le),oe=s.mul(Q,Le);return s.add(s.add(oe,s.mul(Le,a.a)),a.b)}function Z(Le,Q){const oe=s.sqr(Q),Y=L(Le);return s.eql(oe,Y)}if(!Z(a.Gx,a.Gy))throw new Error("bad curve params: generator point");const ve=s.mul(s.pow(a.a,_3n),_4n),We=s.mul(s.sqr(a.b),BigInt(27));if(s.is0(s.add(ve,We)))throw new Error("bad curve params: a or b");function re(Le,Q,oe=!1){if(!s.isValid(Q)||oe&&s.is0(Q))throw new Error(`bad point coordinate ${Le}`);return Q}function ze(Le){if(!(Le instanceof Ve))throw new Error("ProjectivePoint expected")}function se(Le){if(!g||!g.basises)throw new Error("no endo");return _splitEndoScalar(Le,g.basises,o.ORDER)}const ne=memoized((Le,Q)=>{const{X:oe,Y,Z:Ce}=Le;if(s.eql(Ce,s.ONE))return{x:oe,y:Y};const je=Le.is0();Q==null&&(Q=je?s.ONE:s.inv(Ce));const Je=s.mul(oe,Q),Ge=s.mul(Y,Q),Xe=s.mul(Ce,Q);if(je)return{x:s.ZERO,y:s.ZERO};if(!s.eql(Xe,s.ONE))throw new Error("invZ was invalid");return{x:Je,y:Ge}}),X=memoized(Le=>{if(Le.is0()){if(t.allowInfinityPoint&&!s.is0(Le.Y))return;throw new Error("bad point: ZERO")}const{x:Q,y:oe}=Le.toAffine();if(!s.isValid(Q)||!s.isValid(oe))throw new Error("bad point: x or y not field elements");if(!Z(Q,oe))throw new Error("bad point: equation left != right");if(!Le.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function $e(Le,Q,oe,Y,Ce){return oe=new Ve(s.mul(oe.X,Le),oe.Y,oe.Z),Q=negateCt(Y,Q),oe=negateCt(Ce,oe),Q.add(oe)}class Ve{constructor(Q,oe,Y){this.X=re("x",Q),this.Y=re("y",oe,!0),this.Z=re("z",Y),Object.freeze(this)}static CURVE(){return a}static fromAffine(Q){const{x:oe,y:Y}=Q||{};if(!Q||!s.isValid(oe)||!s.isValid(Y))throw new Error("invalid affine point");if(Q instanceof Ve)throw new Error("projective point not allowed");return s.is0(oe)&&s.is0(Y)?Ve.ZERO:new Ve(oe,Y,s.ONE)}static fromBytes(Q){const oe=Ve.fromAffine(B(_abytes2(Q,void 0,"point")));return oe.assertValidity(),oe}static fromHex(Q){return Ve.fromBytes(ensureBytes("pointHex",Q))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(Q=8,oe=!0){return He.createCache(this,Q),oe||this.multiply(_3n),this}assertValidity(){X(this)}hasEvenY(){const{y:Q}=this.toAffine();if(!s.isOdd)throw new Error("Field doesn't support isOdd");return!s.isOdd(Q)}equals(Q){ze(Q);const{X:oe,Y,Z:Ce}=this,{X:je,Y:Je,Z:Ge}=Q,Xe=s.eql(s.mul(oe,Ge),s.mul(je,Ce)),Qe=s.eql(s.mul(Y,Ge),s.mul(Je,Ce));return Xe&&Qe}negate(){return new Ve(this.X,s.neg(this.Y),this.Z)}double(){const{a:Q,b:oe}=a,Y=s.mul(oe,_3n),{X:Ce,Y:je,Z:Je}=this;let Ge=s.ZERO,Xe=s.ZERO,Qe=s.ZERO,rt=s.mul(Ce,Ce),_t=s.mul(je,je),ht=s.mul(Je,Je),ot=s.mul(Ce,je);return ot=s.add(ot,ot),Qe=s.mul(Ce,Je),Qe=s.add(Qe,Qe),Ge=s.mul(Q,Qe),Xe=s.mul(Y,ht),Xe=s.add(Ge,Xe),Ge=s.sub(_t,Xe),Xe=s.add(_t,Xe),Xe=s.mul(Ge,Xe),Ge=s.mul(ot,Ge),Qe=s.mul(Y,Qe),ht=s.mul(Q,ht),ot=s.sub(rt,ht),ot=s.mul(Q,ot),ot=s.add(ot,Qe),Qe=s.add(rt,rt),rt=s.add(Qe,rt),rt=s.add(rt,ht),rt=s.mul(rt,ot),Xe=s.add(Xe,rt),ht=s.mul(je,Je),ht=s.add(ht,ht),rt=s.mul(ht,ot),Ge=s.sub(Ge,rt),Qe=s.mul(ht,_t),Qe=s.add(Qe,Qe),Qe=s.add(Qe,Qe),new Ve(Ge,Xe,Qe)}add(Q){ze(Q);const{X:oe,Y,Z:Ce}=this,{X:je,Y:Je,Z:Ge}=Q;let Xe=s.ZERO,Qe=s.ZERO,rt=s.ZERO;const _t=a.a,ht=s.mul(a.b,_3n);let ot=s.mul(oe,je),xt=s.mul(Y,Je),St=s.mul(Ce,Ge),Mt=s.add(oe,Y),Bt=s.add(je,Je);Mt=s.mul(Mt,Bt),Bt=s.add(ot,xt),Mt=s.sub(Mt,Bt),Bt=s.add(oe,Ce);let Ut=s.add(je,Ge);return Bt=s.mul(Bt,Ut),Ut=s.add(ot,St),Bt=s.sub(Bt,Ut),Ut=s.add(Y,Ce),Xe=s.add(Je,Ge),Ut=s.mul(Ut,Xe),Xe=s.add(xt,St),Ut=s.sub(Ut,Xe),rt=s.mul(_t,Bt),Xe=s.mul(ht,St),rt=s.add(Xe,rt),Xe=s.sub(xt,rt),rt=s.add(xt,rt),Qe=s.mul(Xe,rt),xt=s.add(ot,ot),xt=s.add(xt,ot),St=s.mul(_t,St),Bt=s.mul(ht,Bt),xt=s.add(xt,St),St=s.sub(ot,St),St=s.mul(_t,St),Bt=s.add(Bt,St),ot=s.mul(xt,Bt),Qe=s.add(Qe,ot),ot=s.mul(Ut,Bt),Xe=s.mul(Mt,Xe),Xe=s.sub(Xe,ot),ot=s.mul(Mt,xt),rt=s.mul(Ut,rt),rt=s.add(rt,ot),new Ve(Xe,Qe,rt)}subtract(Q){return this.add(Q.negate())}is0(){return this.equals(Ve.ZERO)}multiply(Q){const{endo:oe}=t;if(!o.isValidNot0(Q))throw new Error("invalid scalar: out of range");let Y,Ce;const je=Je=>He.cached(this,Je,Ge=>normalizeZ(Ve,Ge));if(oe){const{k1neg:Je,k1:Ge,k2neg:Xe,k2:Qe}=se(Q),{p:rt,f:_t}=je(Ge),{p:ht,f:ot}=je(Qe);Ce=_t.add(ot),Y=$e(oe.beta,rt,ht,Je,Xe)}else{const{p:Je,f:Ge}=je(Q);Y=Je,Ce=Ge}return normalizeZ(Ve,[Y,Ce])[0]}multiplyUnsafe(Q){const{endo:oe}=t,Y=this;if(!o.isValid(Q))throw new Error("invalid scalar: out of range");if(Q===_0n$1||Y.is0())return Ve.ZERO;if(Q===_1n$1)return Y;if(He.hasCache(this))return this.multiply(Q);if(oe){const{k1neg:Ce,k1:je,k2neg:Je,k2:Ge}=se(Q),{p1:Xe,p2:Qe}=mulEndoUnsafe(Ve,Y,je,Ge);return $e(oe.beta,Xe,Qe,Ce,Je)}else return He.unsafe(Y,Q)}multiplyAndAddUnsafe(Q,oe,Y){const Ce=this.multiplyUnsafe(oe).add(Q.multiplyUnsafe(Y));return Ce.is0()?void 0:Ce}toAffine(Q){return ne(this,Q)}isTorsionFree(){const{isTorsionFree:Q}=t;return c===_1n$1?!0:Q?Q(Ve,this):He.unsafe(this,f).is0()}clearCofactor(){const{clearCofactor:Q}=t;return c===_1n$1?this:Q?Q(Ve,this):this.multiplyUnsafe(c)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}toBytes(Q=!0){return _abool2(Q,"isCompressed"),this.assertValidity(),A(Ve,this,Q)}toHex(Q=!0){return bytesToHex$1(this.toBytes(Q))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(Q=!0){return this.toBytes(Q)}_setWindowSize(Q){this.precompute(Q)}static normalizeZ(Q){return normalizeZ(Ve,Q)}static msm(Q,oe){return pippenger(Ve,o,Q,oe)}static fromPrivateKey(Q){return Ve.BASE.multiply(_normFnElement(o,Q))}}Ve.BASE=new Ve(a.Gx,a.Gy,s.ONE),Ve.ZERO=new Ve(s.ZERO,s.ONE,s.ZERO),Ve.Fp=s,Ve.Fn=o;const Ze=o.BITS,He=new wNAF(Ve,t.endo?Math.ceil(Ze/2):Ze);return Ve.BASE.precompute(8),Ve}function pprefix(n){return Uint8Array.of(n?2:3)}function getWLengths(n,t){return{secretKey:t.BYTES,publicKey:1+n.BYTES,publicKeyUncompressed:1+2*n.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function ecdh(n,t={}){const{Fn:r}=n,s=t.randomBytes||randomBytes,o=Object.assign(getWLengths(n.Fp,r),{seed:getMinHashLength(r.ORDER)});function a(A){try{return!!_normFnElement(r,A)}catch{return!1}}function c(A,B){const{publicKey:L,publicKeyUncompressed:Z}=o;try{const ve=A.length;return B===!0&&ve!==L||B===!1&&ve!==Z?!1:!!n.fromBytes(A)}catch{return!1}}function f(A=s(o.seed)){return mapHashToField(_abytes2(A,o.seed,"seed"),r.ORDER)}function g(A,B=!0){return n.BASE.multiply(_normFnElement(r,A)).toBytes(B)}function m(A){const B=f(A);return{secretKey:B,publicKey:g(B)}}function b(A){if(typeof A=="bigint")return!1;if(A instanceof n)return!0;const{secretKey:B,publicKey:L,publicKeyUncompressed:Z}=o;if(r.allowedLengths||B===L)return;const ve=ensureBytes("key",A).length;return ve===L||ve===Z}function k(A,B,L=!0){if(b(A)===!0)throw new Error("first arg must be private key");if(b(B)===!1)throw new Error("second arg must be public key");const Z=_normFnElement(r,A);return n.fromHex(B).multiply(Z).toBytes(L)}return Object.freeze({getPublicKey:g,getSharedSecret:k,keygen:m,Point:n,utils:{isValidSecretKey:a,isValidPublicKey:c,randomSecretKey:f,isValidPrivateKey:a,randomPrivateKey:f,normPrivateKeyToScalar:A=>_normFnElement(r,A),precompute(A=8,B=n.BASE){return B.precompute(A,!1)}},lengths:o})}function ecdsa(n,t,r={}){ahash(t),_validateObject(r,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const s=r.randomBytes||randomBytes,o=r.hmac||((oe,...Y)=>hmac(t,oe,concatBytes(...Y))),{Fp:a,Fn:c}=n,{ORDER:f,BITS:g}=c,{keygen:m,getPublicKey:b,getSharedSecret:k,utils:_,lengths:A}=ecdh(n,r),B={prehash:!1,lowS:typeof r.lowS=="boolean"?r.lowS:!1,format:void 0,extraEntropy:!1},L="compact";function Z(oe){const Y=f>>_1n$1;return oe>Y}function ve(oe,Y){if(!c.isValidNot0(Y))throw new Error(`invalid signature ${oe}: out of range 1..Point.Fn.ORDER`);return Y}function We(oe,Y){validateSigFormat(Y);const Ce=A.signature,je=Y==="compact"?Ce:Y==="recovered"?Ce+1:void 0;return _abytes2(oe,je,`${Y} signature`)}class re{constructor(Y,Ce,je){this.r=ve("r",Y),this.s=ve("s",Ce),je!=null&&(this.recovery=je),Object.freeze(this)}static fromBytes(Y,Ce=L){We(Y,Ce);let je;if(Ce==="der"){const{r:Qe,s:rt}=DER.toSig(_abytes2(Y));return new re(Qe,rt)}Ce==="recovered"&&(je=Y[0],Ce="compact",Y=Y.subarray(1));const Je=c.BYTES,Ge=Y.subarray(0,Je),Xe=Y.subarray(Je,Je*2);return new re(c.fromBytes(Ge),c.fromBytes(Xe),je)}static fromHex(Y,Ce){return this.fromBytes(hexToBytes$1(Y),Ce)}addRecoveryBit(Y){return new re(this.r,this.s,Y)}recoverPublicKey(Y){const Ce=a.ORDER,{r:je,s:Je,recovery:Ge}=this;if(Ge==null||![0,1,2,3].includes(Ge))throw new Error("recovery id invalid");if(f*_2n$1<Ce&&Ge>1)throw new Error("recovery id is ambiguous for h>1 curve");const Qe=Ge===2||Ge===3?je+f:je;if(!a.isValid(Qe))throw new Error("recovery id 2 or 3 invalid");const rt=a.toBytes(Qe),_t=n.fromBytes(concatBytes(pprefix((Ge&1)===0),rt)),ht=c.inv(Qe),ot=se(ensureBytes("msgHash",Y)),xt=c.create(-ot*ht),St=c.create(Je*ht),Mt=n.BASE.multiplyUnsafe(xt).add(_t.multiplyUnsafe(St));if(Mt.is0())throw new Error("point at infinify");return Mt.assertValidity(),Mt}hasHighS(){return Z(this.s)}toBytes(Y=L){if(validateSigFormat(Y),Y==="der")return hexToBytes$1(DER.hexFromSig(this));const Ce=c.toBytes(this.r),je=c.toBytes(this.s);if(Y==="recovered"){if(this.recovery==null)throw new Error("recovery bit must be present");return concatBytes(Uint8Array.of(this.recovery),Ce,je)}return concatBytes(Ce,je)}toHex(Y){return bytesToHex$1(this.toBytes(Y))}assertValidity(){}static fromCompact(Y){return re.fromBytes(ensureBytes("sig",Y),"compact")}static fromDER(Y){return re.fromBytes(ensureBytes("sig",Y),"der")}normalizeS(){return this.hasHighS()?new re(this.r,c.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return bytesToHex$1(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return bytesToHex$1(this.toBytes("compact"))}}const ze=r.bits2int||function(Y){if(Y.length>8192)throw new Error("input is too large");const Ce=bytesToNumberBE(Y),je=Y.length*8-g;return je>0?Ce>>BigInt(je):Ce},se=r.bits2int_modN||function(Y){return c.create(ze(Y))},ne=bitMask(g);function X(oe){return aInRange("num < 2^"+g,oe,_0n$1,ne),c.toBytes(oe)}function $e(oe,Y){return _abytes2(oe,void 0,"message"),Y?_abytes2(t(oe),void 0,"prehashed message"):oe}function Ve(oe,Y,Ce){if(["recovered","canonical"].some(xt=>xt in Ce))throw new Error("sign() legacy options not supported");const{lowS:je,prehash:Je,extraEntropy:Ge}=validateSigOpts(Ce,B);oe=$e(oe,Je);const Xe=se(oe),Qe=_normFnElement(c,Y),rt=[X(Qe),X(Xe)];if(Ge!=null&&Ge!==!1){const xt=Ge===!0?s(A.secretKey):Ge;rt.push(ensureBytes("extraEntropy",xt))}const _t=concatBytes(...rt),ht=Xe;function ot(xt){const St=ze(xt);if(!c.isValidNot0(St))return;const Mt=c.inv(St),Bt=n.BASE.multiply(St).toAffine(),Ut=c.create(Bt.x);if(Ut===_0n$1)return;const Jt=c.create(Mt*c.create(ht+Ut*Qe));if(Jt===_0n$1)return;let Ft=(Bt.x===Ut?0:2)|Number(Bt.y&_1n$1),Xt=Jt;return je&&Z(Jt)&&(Xt=c.neg(Jt),Ft^=1),new re(Ut,Xt,Ft)}return{seed:_t,k2sig:ot}}function Ze(oe,Y,Ce={}){oe=ensureBytes("message",oe);const{seed:je,k2sig:Je}=Ve(oe,Y,Ce);return createHmacDrbg(t.outputLen,c.BYTES,o)(je,Je)}function He(oe){let Y;const Ce=typeof oe=="string"||isBytes$1(oe),je=!Ce&&oe!==null&&typeof oe=="object"&&typeof oe.r=="bigint"&&typeof oe.s=="bigint";if(!Ce&&!je)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(je)Y=new re(oe.r,oe.s);else if(Ce){try{Y=re.fromBytes(ensureBytes("sig",oe),"der")}catch(Je){if(!(Je instanceof DER.Err))throw Je}if(!Y)try{Y=re.fromBytes(ensureBytes("sig",oe),"compact")}catch{return!1}}return Y||!1}function Le(oe,Y,Ce,je={}){const{lowS:Je,prehash:Ge,format:Xe}=validateSigOpts(je,B);if(Ce=ensureBytes("publicKey",Ce),Y=$e(ensureBytes("message",Y),Ge),"strict"in je)throw new Error("options.strict was renamed to lowS");const Qe=Xe===void 0?He(oe):re.fromBytes(ensureBytes("sig",oe),Xe);if(Qe===!1)return!1;try{const rt=n.fromBytes(Ce);if(Je&&Qe.hasHighS())return!1;const{r:_t,s:ht}=Qe,ot=se(Y),xt=c.inv(ht),St=c.create(ot*xt),Mt=c.create(_t*xt),Bt=n.BASE.multiplyUnsafe(St).add(rt.multiplyUnsafe(Mt));return Bt.is0()?!1:c.create(Bt.x)===_t}catch{return!1}}function Q(oe,Y,Ce={}){const{prehash:je}=validateSigOpts(Ce,B);return Y=$e(Y,je),re.fromBytes(oe,"recovered").recoverPublicKey(Y).toBytes()}return Object.freeze({keygen:m,getPublicKey:b,getSharedSecret:k,utils:_,lengths:A,Point:n,sign:Ze,verify:Le,recoverPublicKey:Q,Signature:re,hash:t})}function _weierstrass_legacy_opts_to_new(n){const t={a:n.a,b:n.b,p:n.Fp.ORDER,n:n.n,h:n.h,Gx:n.Gx,Gy:n.Gy},r=n.Fp;let s=n.allowedPrivateKeyLengths?Array.from(new Set(n.allowedPrivateKeyLengths.map(c=>Math.ceil(c/2)))):void 0;const o=Field(t.n,{BITS:n.nBitLength,allowedLengths:s,modFromBytes:n.wrapPrivateKey}),a={Fp:r,Fn:o,allowInfinityPoint:n.allowInfinityPoint,endo:n.endo,isTorsionFree:n.isTorsionFree,clearCofactor:n.clearCofactor,fromBytes:n.fromBytes,toBytes:n.toBytes};return{CURVE:t,curveOpts:a}}function _ecdsa_legacy_opts_to_new(n){const{CURVE:t,curveOpts:r}=_weierstrass_legacy_opts_to_new(n),s={hmac:n.hmac,randomBytes:n.randomBytes,lowS:n.lowS,bits2int:n.bits2int,bits2int_modN:n.bits2int_modN};return{CURVE:t,curveOpts:r,hash:n.hash,ecdsaOpts:s}}function _ecdsa_new_output_to_legacy(n,t){const r=t.Point;return Object.assign({},t,{ProjectivePoint:r,CURVE:Object.assign({},n,nLength(r.Fn.ORDER,r.Fn.BITS))})}function weierstrass(n){const{CURVE:t,curveOpts:r,hash:s,ecdsaOpts:o}=_ecdsa_legacy_opts_to_new(n),a=weierstrassN(t,r),c=ecdsa(a,s,o);return _ecdsa_new_output_to_legacy(n,c)}function createCurve(n,t){const r=s=>weierstrass({...n,hash:s});return{...r(t),create:r}}const secp256k1_CURVE={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},secp256k1_ENDO={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},_0n=BigInt(0),_1n=BigInt(1),_2n=BigInt(2);function sqrtMod(n){const t=secp256k1_CURVE.p,r=BigInt(3),s=BigInt(6),o=BigInt(11),a=BigInt(22),c=BigInt(23),f=BigInt(44),g=BigInt(88),m=n*n*n%t,b=m*m*n%t,k=pow2(b,r,t)*b%t,_=pow2(k,r,t)*b%t,A=pow2(_,_2n,t)*m%t,B=pow2(A,o,t)*A%t,L=pow2(B,a,t)*B%t,Z=pow2(L,f,t)*L%t,ve=pow2(Z,g,t)*Z%t,We=pow2(ve,f,t)*L%t,re=pow2(We,r,t)*b%t,ze=pow2(re,c,t)*B%t,se=pow2(ze,s,t)*m%t,ne=pow2(se,_2n,t);if(!Fpk1.eql(Fpk1.sqr(ne),n))throw new Error("Cannot find square root");return ne}const Fpk1=Field(secp256k1_CURVE.p,{sqrt:sqrtMod}),secp256k1=createCurve({...secp256k1_CURVE,Fp:Fpk1,lowS:!0,endo:secp256k1_ENDO},sha256$1),TAGGED_HASH_PREFIXES={};function taggedHash(n,...t){let r=TAGGED_HASH_PREFIXES[n];if(r===void 0){const s=sha256$1(utf8ToBytes(n));r=concatBytes(s,s),TAGGED_HASH_PREFIXES[n]=r}return sha256$1(concatBytes(r,...t))}const pointToBytes=n=>n.toBytes(!0).slice(1),Pointk1=secp256k1.Point,hasEven=n=>n%_2n===_0n;function schnorrGetExtPubKey(n){const{Fn:t,BASE:r}=Pointk1,s=_normFnElement(t,n),o=r.multiply(s);return{scalar:hasEven(o.y)?s:t.neg(s),bytes:pointToBytes(o)}}function lift_x(n){const t=Fpk1;if(!t.isValidNot0(n))throw new Error("invalid x: Fail if x  p");const r=t.create(n*n),s=t.create(r*n+BigInt(7));let o=t.sqrt(s);hasEven(o)||(o=t.neg(o));const a=Pointk1.fromAffine({x:n,y:o});return a.assertValidity(),a}const num=bytesToNumberBE;function challenge(...n){return Pointk1.Fn.create(num(taggedHash("BIP0340/challenge",...n)))}function schnorrGetPublicKey(n){return schnorrGetExtPubKey(n).bytes}function schnorrSign(n,t,r=randomBytes(32)){const{Fn:s}=Pointk1,o=ensureBytes("message",n),{bytes:a,scalar:c}=schnorrGetExtPubKey(t),f=ensureBytes("auxRand",r,32),g=s.toBytes(c^num(taggedHash("BIP0340/aux",f))),m=taggedHash("BIP0340/nonce",g,a,o),{bytes:b,scalar:k}=schnorrGetExtPubKey(m),_=challenge(b,a,o),A=new Uint8Array(64);if(A.set(b,0),A.set(s.toBytes(s.create(k+_*c)),32),!schnorrVerify(A,o,a))throw new Error("sign: Invalid signature produced");return A}function schnorrVerify(n,t,r){const{Fn:s,BASE:o}=Pointk1,a=ensureBytes("signature",n,64),c=ensureBytes("message",t),f=ensureBytes("publicKey",r,32);try{const g=lift_x(num(f)),m=num(a.subarray(0,32));if(!inRange(m,_1n,secp256k1_CURVE.p))return!1;const b=num(a.subarray(32,64));if(!inRange(b,_1n,secp256k1_CURVE.n))return!1;const k=challenge(s.toBytes(m),pointToBytes(g),c),_=o.multiplyUnsafe(b).add(g.multiplyUnsafe(s.neg(k))),{x:A,y:B}=_.toAffine();return!(_.is0()||!hasEven(B)||A!==m)}catch{return!1}}const schnorr=(()=>{const r=(o=randomBytes(48))=>mapHashToField(o,secp256k1_CURVE.n);secp256k1.utils.randomSecretKey;function s(o){const a=r(o);return{secretKey:a,publicKey:schnorrGetPublicKey(a)}}return{keygen:s,getPublicKey:schnorrGetPublicKey,sign:schnorrSign,verify:schnorrVerify,Point:Pointk1,utils:{randomSecretKey:r,randomPrivateKey:r,taggedHash,lift_x,pointToBytes,numberToBytesBE,bytesToNumberBE,mod},lengths:{secretKey:32,publicKey:32,publicKeyHasPrefix:!1,signature:64,seed:48}}})(),sha256=sha256$1;var dist={},LRUCache={},LRUCacheNode={},hasRequiredLRUCacheNode;function requireLRUCacheNode(){if(hasRequiredLRUCacheNode)return LRUCacheNode;hasRequiredLRUCacheNode=1,Object.defineProperty(LRUCacheNode,"__esModule",{value:!0}),LRUCacheNode.LRUCacheNode=void 0;let n=class{constructor(r,s,o){const{entryExpirationTimeInMS:a=null,next:c=null,prev:f=null,onEntryEvicted:g,onEntryMarkedAsMostRecentlyUsed:m,clone:b,cloneFn:k}=o??{};if(typeof a=="number"&&(a<=0||Number.isNaN(a)))throw new Error("entryExpirationTimeInMS must either be null (no expiry) or greater than 0");this.clone=b??!1,this.cloneFn=k??this.defaultClone,this.key=r,this.internalValue=this.clone?this.cloneFn(s):s,this.created=Date.now(),this.entryExpirationTimeInMS=a,this.next=c,this.prev=f,this.onEntryEvicted=g,this.onEntryMarkedAsMostRecentlyUsed=m}get value(){return this.clone?this.cloneFn(this.internalValue):this.internalValue}get isExpired(){return typeof this.entryExpirationTimeInMS=="number"&&Date.now()-this.created>this.entryExpirationTimeInMS}invokeOnEvicted(){if(this.onEntryEvicted){const{key:r,value:s,isExpired:o}=this;this.onEntryEvicted({key:r,value:s,isExpired:o})}}invokeOnEntryMarkedAsMostRecentlyUsed(){if(this.onEntryMarkedAsMostRecentlyUsed){const{key:r,value:s}=this;this.onEntryMarkedAsMostRecentlyUsed({key:r,value:s})}}defaultClone(r){return typeof r=="boolean"||typeof r=="string"||typeof r=="number"?r:JSON.parse(JSON.stringify(r))}};return LRUCacheNode.LRUCacheNode=n,LRUCacheNode}var hasRequiredLRUCache;function requireLRUCache(){if(hasRequiredLRUCache)return LRUCache;hasRequiredLRUCache=1,Object.defineProperty(LRUCache,"__esModule",{value:!0}),LRUCache.LRUCache=void 0;const n=requireLRUCacheNode();let t=class{constructor(s){this.lookupTable=new Map,this.head=null,this.tail=null;const{maxSize:o=25,entryExpirationTimeInMS:a=null,onEntryEvicted:c,onEntryMarkedAsMostRecentlyUsed:f,cloneFn:g,clone:m}=s??{};if(Number.isNaN(o)||o<=0)throw new Error("maxSize must be greater than 0.");if(typeof a=="number"&&(a<=0||Number.isNaN(a)))throw new Error("entryExpirationTimeInMS must either be null (no expiry) or greater than 0");this.maxSizeInternal=o,this.entryExpirationTimeInMS=a,this.onEntryEvicted=c,this.onEntryMarkedAsMostRecentlyUsed=f,this.clone=m,this.cloneFn=g}get size(){return this.cleanCache(),this.lookupTable.size}get remainingSize(){return this.maxSizeInternal-this.size}get newest(){return this.head?this.head.isExpired?(this.removeNodeFromListAndLookupTable(this.head),this.newest):this.mapNodeToEntry(this.head):null}get oldest(){return this.tail?this.tail.isExpired?(this.removeNodeFromListAndLookupTable(this.tail),this.oldest):this.mapNodeToEntry(this.tail):null}get maxSize(){return this.maxSizeInternal}set maxSize(s){if(Number.isNaN(s)||s<=0)throw new Error("maxSize must be greater than 0.");this.maxSizeInternal=s,this.enforceSizeLimit()}set(s,o,a){const c=this.lookupTable.get(s);c&&this.removeNodeFromListAndLookupTable(c);const f=new n.LRUCacheNode(s,o,{entryExpirationTimeInMS:this.entryExpirationTimeInMS,onEntryEvicted:this.onEntryEvicted,onEntryMarkedAsMostRecentlyUsed:this.onEntryMarkedAsMostRecentlyUsed,clone:this.clone,cloneFn:this.cloneFn,...a});return this.setNodeAsHead(f),this.lookupTable.set(s,f),this.enforceSizeLimit(),this}get(s){const o=this.lookupTable.get(s);return o?o.isExpired?(this.removeNodeFromListAndLookupTable(o),null):(this.setNodeAsHead(o),o.value):null}peek(s){const o=this.lookupTable.get(s);return o?o.isExpired?(this.removeNodeFromListAndLookupTable(o),null):o.value:null}delete(s){const o=this.lookupTable.get(s);return o?this.removeNodeFromListAndLookupTable(o):!1}has(s){const o=this.lookupTable.get(s);return o?o.isExpired?(this.removeNodeFromListAndLookupTable(o),!1):!0:!1}clear(){this.head=null,this.tail=null,this.lookupTable.clear()}find(s){let o=this.head;for(;o;){if(o.isExpired){const c=o.next;this.removeNodeFromListAndLookupTable(o),o=c;continue}const a=this.mapNodeToEntry(o);if(s(a))return this.setNodeAsHead(o),a;o=o.next}return null}forEach(s){let o=this.head,a=0;for(;o;){if(o.isExpired){const c=o.next;this.removeNodeFromListAndLookupTable(o),o=c;continue}s(o.value,o.key,a),o=o.next,a++}}*values(){let s=this.head;for(;s;){if(s.isExpired){const o=s.next;this.removeNodeFromListAndLookupTable(s),s=o;continue}yield s.value,s=s.next}}*keys(){let s=this.head;for(;s;){if(s.isExpired){const o=s.next;this.removeNodeFromListAndLookupTable(s),s=o;continue}yield s.key,s=s.next}}*entries(){let s=this.head;for(;s;){if(s.isExpired){const o=s.next;this.removeNodeFromListAndLookupTable(s),s=o;continue}yield this.mapNodeToEntry(s),s=s.next}}*[Symbol.iterator](){let s=this.head;for(;s;){if(s.isExpired){const o=s.next;this.removeNodeFromListAndLookupTable(s),s=o;continue}yield this.mapNodeToEntry(s),s=s.next}}enforceSizeLimit(){let s=this.tail;for(;s!==null&&this.size>this.maxSizeInternal;){const o=s.prev;this.removeNodeFromListAndLookupTable(s),s=o}}mapNodeToEntry({key:s,value:o}){return{key:s,value:o}}setNodeAsHead(s){this.removeNodeFromList(s),this.head?(s.next=this.head,this.head.prev=s,this.head=s):(this.head=s,this.tail=s),s.invokeOnEntryMarkedAsMostRecentlyUsed()}removeNodeFromList(s){s.prev!==null&&(s.prev.next=s.next),s.next!==null&&(s.next.prev=s.prev),this.head===s&&(this.head=s.next),this.tail===s&&(this.tail=s.prev),s.next=null,s.prev=null}removeNodeFromListAndLookupTable(s){return s.invokeOnEvicted(),this.removeNodeFromList(s),this.lookupTable.delete(s.key)}cleanCache(){if(!this.entryExpirationTimeInMS)return;const s=[];for(const o of this.lookupTable.values())o.isExpired&&s.push(o);s.forEach(o=>this.removeNodeFromListAndLookupTable(o))}};return LRUCache.LRUCache=t,LRUCache}var hasRequiredDist;function requireDist(){return hasRequiredDist||(hasRequiredDist=1,(function(n){var t=dist&&dist.__createBinding||(Object.create?(function(s,o,a,c){c===void 0&&(c=a);var f=Object.getOwnPropertyDescriptor(o,a);(!f||("get"in f?!o.__esModule:f.writable||f.configurable))&&(f={enumerable:!0,get:function(){return o[a]}}),Object.defineProperty(s,c,f)}):(function(s,o,a,c){c===void 0&&(c=a),s[c]=o[a]})),r=dist&&dist.__exportStar||function(s,o){for(var a in s)a!=="default"&&!Object.prototype.hasOwnProperty.call(o,a)&&t(o,s,a)};Object.defineProperty(n,"__esModule",{value:!0}),r(requireLRUCache(),n)})(dist)),dist}var distExports=requireDist();function pbkdf2Init(n,t,r,s){assert.hash(n);const o=checkOpts$1({dkLen:32,asyncTick:10},s),{c:a,dkLen:c,asyncTick:f}=o;if(assert.number(a),assert.number(c),assert.number(f),a<1)throw new Error("PBKDF2: iterations (c) should be >= 1");const g=toBytes$2(t),m=toBytes$2(r),b=new Uint8Array(c),k=hmac$1.create(n,g),_=k._cloneInto().update(m);return{c:a,dkLen:c,asyncTick:f,DK:b,PRF:k,PRFSalt:_}}function pbkdf2Output(n,t,r,s,o){return n.destroy(),t.destroy(),s&&s.destroy(),o.fill(0),r}function pbkdf2(n,t,r,s){const{c:o,dkLen:a,DK:c,PRF:f,PRFSalt:g}=pbkdf2Init(n,t,r,s);let m;const b=new Uint8Array(4),k=createView$2(b),_=new Uint8Array(f.outputLen);for(let A=1,B=0;B<a;A++,B+=f.outputLen){const L=c.subarray(B,B+f.outputLen);k.setInt32(0,A,!1),(m=g._cloneInto(m)).update(b).digestInto(_),L.set(_.subarray(0,L.length));for(let Z=1;Z<o;Z++){f._cloneInto(m).update(_).digestInto(_);for(let ve=0;ve<L.length;ve++)L[ve]^=_[ve]}}return pbkdf2Output(f,g,c,m,_)}const rotl=(n,t)=>n<<t|n>>>32-t;function XorAndSalsa(n,t,r,s,o,a){let c=n[t++]^r[s++],f=n[t++]^r[s++],g=n[t++]^r[s++],m=n[t++]^r[s++],b=n[t++]^r[s++],k=n[t++]^r[s++],_=n[t++]^r[s++],A=n[t++]^r[s++],B=n[t++]^r[s++],L=n[t++]^r[s++],Z=n[t++]^r[s++],ve=n[t++]^r[s++],We=n[t++]^r[s++],re=n[t++]^r[s++],ze=n[t++]^r[s++],se=n[t++]^r[s++],ne=c,X=f,$e=g,Ve=m,Ze=b,He=k,Le=_,Q=A,oe=B,Y=L,Ce=Z,je=ve,Je=We,Ge=re,Xe=ze,Qe=se;for(let rt=0;rt<8;rt+=2)Ze^=rotl(ne+Je|0,7),oe^=rotl(Ze+ne|0,9),Je^=rotl(oe+Ze|0,13),ne^=rotl(Je+oe|0,18),Y^=rotl(He+X|0,7),Ge^=rotl(Y+He|0,9),X^=rotl(Ge+Y|0,13),He^=rotl(X+Ge|0,18),Xe^=rotl(Ce+Le|0,7),$e^=rotl(Xe+Ce|0,9),Le^=rotl($e+Xe|0,13),Ce^=rotl(Le+$e|0,18),Ve^=rotl(Qe+je|0,7),Q^=rotl(Ve+Qe|0,9),je^=rotl(Q+Ve|0,13),Qe^=rotl(je+Q|0,18),X^=rotl(ne+Ve|0,7),$e^=rotl(X+ne|0,9),Ve^=rotl($e+X|0,13),ne^=rotl(Ve+$e|0,18),Le^=rotl(He+Ze|0,7),Q^=rotl(Le+He|0,9),Ze^=rotl(Q+Le|0,13),He^=rotl(Ze+Q|0,18),je^=rotl(Ce+Y|0,7),oe^=rotl(je+Ce|0,9),Y^=rotl(oe+je|0,13),Ce^=rotl(Y+oe|0,18),Je^=rotl(Qe+Xe|0,7),Ge^=rotl(Je+Qe|0,9),Xe^=rotl(Ge+Je|0,13),Qe^=rotl(Xe+Ge|0,18);o[a++]=c+ne|0,o[a++]=f+X|0,o[a++]=g+$e|0,o[a++]=m+Ve|0,o[a++]=b+Ze|0,o[a++]=k+He|0,o[a++]=_+Le|0,o[a++]=A+Q|0,o[a++]=B+oe|0,o[a++]=L+Y|0,o[a++]=Z+Ce|0,o[a++]=ve+je|0,o[a++]=We+Je|0,o[a++]=re+Ge|0,o[a++]=ze+Xe|0,o[a++]=se+Qe|0}function BlockMix(n,t,r,s,o){let a=s+0,c=s+16*o;for(let f=0;f<16;f++)r[c+f]=n[t+(2*o-1)*16+f];for(let f=0;f<o;f++,a+=16,t+=16)XorAndSalsa(r,c,n,t,r,a),f>0&&(c+=16),XorAndSalsa(r,a,n,t+=16,r,c)}function scryptInit(n,t,r){const s=checkOpts$1({dkLen:32,asyncTick:10,maxmem:1073742848},r),{N:o,r:a,p:c,dkLen:f,asyncTick:g,maxmem:m,onProgress:b}=s;if(assert.number(o),assert.number(a),assert.number(c),assert.number(f),assert.number(g),assert.number(m),b!==void 0&&typeof b!="function")throw new Error("progressCb should be function");const k=128*a,_=k/4;if(o<=1||(o&o-1)!==0||o>=2**(k/8)||o>2**32)throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");if(c<0||c>(2**32-1)*32/k)throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");if(f<0||f>(2**32-1)*32)throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");const A=k*(o+c);if(A>m)throw new Error(`Scrypt: parameters too large, ${A} (128 * r * (N + p)) > ${m} (maxmem)`);const B=pbkdf2(sha256$2,n,t,{c:1,dkLen:k*c}),L=u32$1(B),Z=u32$1(new Uint8Array(k*o)),ve=u32$1(new Uint8Array(k));let We=()=>{};if(b){const re=2*o*c,ze=Math.max(Math.floor(re/1e4),1);let se=0;We=()=>{se++,b&&(!(se%ze)||se===re)&&b(se/re)}}return{N:o,r:a,p:c,dkLen:f,blockSize32:_,V:Z,B32:L,B,tmp:ve,blockMixCb:We,asyncTick:g}}function scryptOutput(n,t,r,s,o){const a=pbkdf2(sha256$2,n,r,{c:1,dkLen:t});return r.fill(0),s.fill(0),o.fill(0),a}function scrypt(n,t,r){const{N:s,r:o,p:a,dkLen:c,blockSize32:f,V:g,B32:m,B:b,tmp:k,blockMixCb:_}=scryptInit(n,t,r);for(let A=0;A<a;A++){const B=f*A;for(let L=0;L<f;L++)g[L]=m[B+L];for(let L=0,Z=0;L<s-1;L++)BlockMix(g,Z,g,Z+=f,o),_();BlockMix(g,(s-1)*f,m,B,o),_();for(let L=0;L<s;L++){const Z=m[B+f-16]%s;for(let ve=0;ve<f;ve++)k[ve]=m[B+ve]^g[Z*f+ve];BlockMix(k,0,m,B,o),_()}}return scryptOutput(n,c,b,g,k)}var Bech32MaxSize$1=5e3;function encodeBech32$1(n,t){let r=bech32$2.toWords(t);return bech32$2.encode(n,r,Bech32MaxSize$1)}function encodeBytes$1(n,t){return encodeBech32$1(n,t)}function encrypt$1(n,t,r=16,s=2){let o=randomBytes$1(16),a=2**r,c=scrypt(t.normalize("NFKC"),o,{N:a,r:8,p:1,dkLen:32}),f=randomBytes$1(24),g=Uint8Array.from([s]),b=xchacha20poly1305(c,f,g).encrypt(n),k=concatBytes$1(Uint8Array.from([2]),Uint8Array.from([r]),o,f,g,b);return encodeBytes$1("ncryptsec",k)}function decrypt$1(n,t){let{prefix:r,words:s}=bech32$2.decode(n,Bech32MaxSize$1);if(r!=="ncryptsec")throw new Error(`invalid prefix ${r}, expected 'ncryptsec'`);let o=new Uint8Array(bech32$2.fromWords(s)),a=o[0];if(a!==2)throw new Error(`invalid version ${a}, expected 0x02`);let f=2**o[1],g=o.slice(2,18),m=o.slice(18,42),b=o[42],k=Uint8Array.from([b]),_=o.slice(43),A=scrypt(t.normalize("NFKC"),g,{N:f,r:8,p:1,dkLen:32});return xchacha20poly1305(A,m,k).decrypt(_)}const nip49_star=Object.freeze(Object.defineProperty({__proto__:null,decrypt:decrypt$1,encrypt:encrypt$1},Symbol.toStringTag,{value:"Module"}));function assertNumber(n){if(!Number.isSafeInteger(n))throw new Error(`Wrong integer: ${n}`)}function chain$1(...n){const t=(o,a)=>c=>o(a(c)),r=Array.from(n).reverse().reduce((o,a)=>o?t(o,a.encode):a.encode,void 0),s=n.reduce((o,a)=>o?t(o,a.decode):a.decode,void 0);return{encode:r,decode:s}}function alphabet$1(n){return{encode:t=>{if(!Array.isArray(t)||t.length&&typeof t[0]!="number")throw new Error("alphabet.encode input should be an array of numbers");return t.map(r=>{if(assertNumber(r),r<0||r>=n.length)throw new Error(`Digit index outside alphabet: ${r} (alphabet: ${n.length})`);return n[r]})},decode:t=>{if(!Array.isArray(t)||t.length&&typeof t[0]!="string")throw new Error("alphabet.decode input should be array of strings");return t.map(r=>{if(typeof r!="string")throw new Error(`alphabet.decode: not string element=${r}`);const s=n.indexOf(r);if(s===-1)throw new Error(`Unknown letter: "${r}". Allowed: ${n}`);return s})}}}function join$1(n=""){if(typeof n!="string")throw new Error("join separator should be string");return{encode:t=>{if(!Array.isArray(t)||t.length&&typeof t[0]!="string")throw new Error("join.encode input should be array of strings");for(let r of t)if(typeof r!="string")throw new Error(`join.encode: non-string input=${r}`);return t.join(n)},decode:t=>{if(typeof t!="string")throw new Error("join.decode input should be string");return t.split(n)}}}function padding(n,t="="){if(assertNumber(n),typeof t!="string")throw new Error("padding chr should be string");return{encode(r){if(!Array.isArray(r)||r.length&&typeof r[0]!="string")throw new Error("padding.encode input should be array of strings");for(let s of r)if(typeof s!="string")throw new Error(`padding.encode: non-string input=${s}`);for(;r.length*n%8;)r.push(t);return r},decode(r){if(!Array.isArray(r)||r.length&&typeof r[0]!="string")throw new Error("padding.encode input should be array of strings");for(let o of r)if(typeof o!="string")throw new Error(`padding.decode: non-string input=${o}`);let s=r.length;if(s*n%8)throw new Error("Invalid padding: string should have whole number of bytes");for(;s>0&&r[s-1]===t;s--)if(!((s-1)*n%8))throw new Error("Invalid padding: string has too much padding");return r.slice(0,s)}}}function normalize$1(n){if(typeof n!="function")throw new Error("normalize fn should be function");return{encode:t=>t,decode:t=>n(t)}}function convertRadix$1(n,t,r){if(t<2)throw new Error(`convertRadix: wrong from=${t}, base cannot be less than 2`);if(r<2)throw new Error(`convertRadix: wrong to=${r}, base cannot be less than 2`);if(!Array.isArray(n))throw new Error("convertRadix: data should be array");if(!n.length)return[];let s=0;const o=[],a=Array.from(n);for(a.forEach(c=>{if(assertNumber(c),c<0||c>=t)throw new Error(`Wrong integer: ${c}`)});;){let c=0,f=!0;for(let g=s;g<a.length;g++){const m=a[g],b=t*c+m;if(!Number.isSafeInteger(b)||t*c/t!==c||b-m!==t*c)throw new Error("convertRadix: carry overflow");if(c=b%r,a[g]=Math.floor(b/r),!Number.isSafeInteger(a[g])||a[g]*r+c!==b)throw new Error("convertRadix: carry overflow");if(f)a[g]?f=!1:s=g;else continue}if(o.push(c),f)break}for(let c=0;c<n.length-1&&n[c]===0;c++)o.push(0);return o.reverse()}const gcd$1=(n,t)=>t?gcd$1(t,n%t):n,radix2carry$1=(n,t)=>n+(t-gcd$1(n,t));function convertRadix2$1(n,t,r,s){if(!Array.isArray(n))throw new Error("convertRadix2: data should be array");if(t<=0||t>32)throw new Error(`convertRadix2: wrong from=${t}`);if(r<=0||r>32)throw new Error(`convertRadix2: wrong to=${r}`);if(radix2carry$1(t,r)>32)throw new Error(`convertRadix2: carry overflow from=${t} to=${r} carryBits=${radix2carry$1(t,r)}`);let o=0,a=0;const c=2**r-1,f=[];for(const g of n){if(assertNumber(g),g>=2**t)throw new Error(`convertRadix2: invalid data word=${g} from=${t}`);if(o=o<<t|g,a+t>32)throw new Error(`convertRadix2: carry overflow pos=${a} from=${t}`);for(a+=t;a>=r;a-=r)f.push((o>>a-r&c)>>>0);o&=2**a-1}if(o=o<<r-a&c,!s&&a>=t)throw new Error("Excess padding");if(!s&&o)throw new Error(`Non-zero padding: ${o}`);return s&&a>0&&f.push(o>>>0),f}function radix$1(n){return assertNumber(n),{encode:t=>{if(!(t instanceof Uint8Array))throw new Error("radix.encode input should be Uint8Array");return convertRadix$1(Array.from(t),2**8,n)},decode:t=>{if(!Array.isArray(t)||t.length&&typeof t[0]!="number")throw new Error("radix.decode input should be array of strings");return Uint8Array.from(convertRadix$1(t,n,2**8))}}}function radix2$1(n,t=!1){if(assertNumber(n),n<=0||n>32)throw new Error("radix2: bits should be in (0..32]");if(radix2carry$1(8,n)>32||radix2carry$1(n,8)>32)throw new Error("radix2: carry overflow");return{encode:r=>{if(!(r instanceof Uint8Array))throw new Error("radix2.encode input should be Uint8Array");return convertRadix2$1(Array.from(r),8,n,!t)},decode:r=>{if(!Array.isArray(r)||r.length&&typeof r[0]!="number")throw new Error("radix2.decode input should be array of strings");return Uint8Array.from(convertRadix2$1(r,n,8,t))}}}function unsafeWrapper$1(n){if(typeof n!="function")throw new Error("unsafeWrapper fn should be function");return function(...t){try{return n.apply(null,t)}catch{}}}function checksum$1(n,t){if(assertNumber(n),typeof t!="function")throw new Error("checksum fn should be function");return{encode(r){if(!(r instanceof Uint8Array))throw new Error("checksum.encode: input should be Uint8Array");const s=t(r).slice(0,n),o=new Uint8Array(r.length+n);return o.set(r),o.set(s,r.length),o},decode(r){if(!(r instanceof Uint8Array))throw new Error("checksum.decode: input should be Uint8Array");const s=r.slice(0,-n),o=t(s).slice(0,n),a=r.slice(-n);for(let c=0;c<n;c++)if(o[c]!==a[c])throw new Error("Invalid checksum");return s}}}const utils={alphabet:alphabet$1,chain:chain$1,checksum:checksum$1,radix:radix$1,radix2:radix2$1,join:join$1,padding},base16=chain$1(radix2$1(4),alphabet$1("0123456789ABCDEF"),join$1("")),base32=chain$1(radix2$1(5),alphabet$1("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),padding(5),join$1("")),base32hex=chain$1(radix2$1(5),alphabet$1("0123456789ABCDEFGHIJKLMNOPQRSTUV"),padding(5),join$1("")),base32crockford=chain$1(radix2$1(5),alphabet$1("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),join$1(""),normalize$1(n=>n.toUpperCase().replace(/O/g,"0").replace(/[IL]/g,"1"))),base64=chain$1(radix2$1(6),alphabet$1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),padding(6),join$1("")),base64url=chain$1(radix2$1(6),alphabet$1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),padding(6),join$1("")),genBase58$1=n=>chain$1(radix$1(58),alphabet$1(n),join$1("")),base58$1=genBase58$1("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),base58flickr=genBase58$1("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"),base58xrp=genBase58$1("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz"),XMR_BLOCK_LEN=[0,2,3,5,6,7,9,10,11],base58xmr={encode(n){let t="";for(let r=0;r<n.length;r+=8){const s=n.subarray(r,r+8);t+=base58$1.encode(s).padStart(XMR_BLOCK_LEN[s.length],"1")}return t},decode(n){let t=[];for(let r=0;r<n.length;r+=11){const s=n.slice(r,r+11),o=XMR_BLOCK_LEN.indexOf(s.length),a=base58$1.decode(s);for(let c=0;c<a.length-o;c++)if(a[c]!==0)throw new Error("base58xmr: wrong padding");t=t.concat(Array.from(a.slice(a.length-o)))}return Uint8Array.from(t)}},base58check$1=n=>chain$1(checksum$1(4,t=>n(n(t))),base58$1),BECH_ALPHABET$1=chain$1(alphabet$1("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),join$1("")),POLYMOD_GENERATORS$1=[996825010,642813549,513874426,1027748829,705979059];function bech32Polymod$1(n){const t=n>>25;let r=(n&33554431)<<5;for(let s=0;s<POLYMOD_GENERATORS$1.length;s++)(t>>s&1)===1&&(r^=POLYMOD_GENERATORS$1[s]);return r}function bechChecksum$1(n,t,r=1){const s=n.length;let o=1;for(let a=0;a<s;a++){const c=n.charCodeAt(a);if(c<33||c>126)throw new Error(`Invalid prefix (${n})`);o=bech32Polymod$1(o)^c>>5}o=bech32Polymod$1(o);for(let a=0;a<s;a++)o=bech32Polymod$1(o)^n.charCodeAt(a)&31;for(let a of t)o=bech32Polymod$1(o)^a;for(let a=0;a<6;a++)o=bech32Polymod$1(o);return o^=r,BECH_ALPHABET$1.encode(convertRadix2$1([o%2**30],30,5,!1))}function genBech32$1(n){const t=n==="bech32"?1:734539939,r=radix2$1(5),s=r.decode,o=r.encode,a=unsafeWrapper$1(s);function c(b,k,_=90){if(typeof b!="string")throw new Error(`bech32.encode prefix should be string, not ${typeof b}`);if(!Array.isArray(k)||k.length&&typeof k[0]!="number")throw new Error(`bech32.encode words should be array of numbers, not ${typeof k}`);const A=b.length+7+k.length;if(_!==!1&&A>_)throw new TypeError(`Length ${A} exceeds limit ${_}`);return b=b.toLowerCase(),`${b}1${BECH_ALPHABET$1.encode(k)}${bechChecksum$1(b,k,t)}`}function f(b,k=90){if(typeof b!="string")throw new Error(`bech32.decode input should be string, not ${typeof b}`);if(b.length<8||k!==!1&&b.length>k)throw new TypeError(`Wrong string length: ${b.length} (${b}). Expected (8..${k})`);const _=b.toLowerCase();if(b!==_&&b!==b.toUpperCase())throw new Error("String must be lowercase or uppercase");b=_;const A=b.lastIndexOf("1");if(A===0||A===-1)throw new Error('Letter "1" must be present between prefix and data only');const B=b.slice(0,A),L=b.slice(A+1);if(L.length<6)throw new Error("Data must be at least 6 characters long");const Z=BECH_ALPHABET$1.decode(L).slice(0,-6),ve=bechChecksum$1(B,Z,t);if(!L.endsWith(ve))throw new Error(`Invalid checksum in ${b}: expected "${ve}"`);return{prefix:B,words:Z}}const g=unsafeWrapper$1(f);function m(b){const{prefix:k,words:_}=f(b,!1);return{prefix:k,words:_,bytes:s(_)}}return{encode:c,decode:f,decodeToBytes:m,decodeUnsafe:g,fromWords:s,fromWordsUnsafe:a,toWords:o}}const bech32$1=genBech32$1("bech32"),bech32m=genBech32$1("bech32m"),utf8={encode:n=>new TextDecoder().decode(n),decode:n=>new TextEncoder().encode(n)},hex=chain$1(radix2$1(4),alphabet$1("0123456789abcdef"),join$1(""),normalize$1(n=>{if(typeof n!="string"||n.length%2)throw new TypeError(`hex.decode: expected string, got ${typeof n} with length ${n.length}`);return n.toLowerCase()})),CODERS={utf8,hex,base16,base32,base64,base64url,base58:base58$1,base58xmr},coderTypeError=`Invalid encoding type. Available types: ${Object.keys(CODERS).join(", ")}`,bytesToString=(n,t)=>{if(typeof n!="string"||!CODERS.hasOwnProperty(n))throw new TypeError(coderTypeError);if(!(t instanceof Uint8Array))throw new TypeError("bytesToString() expects Uint8Array");return CODERS[n].encode(t)},str=bytesToString,stringToBytes=(n,t)=>{if(!CODERS.hasOwnProperty(n))throw new TypeError(coderTypeError);if(typeof t!="string")throw new TypeError("stringToBytes() expects string");return CODERS[n].decode(t)},bytes=stringToBytes,esm=Object.freeze(Object.defineProperty({__proto__:null,assertNumber,base16,base32,base32crockford,base32hex,base58:base58$1,base58check:base58check$1,base58flickr,base58xmr,base58xrp,base64,base64url,bech32:bech32$1,bech32m,bytes,bytesToString,hex,str,stringToBytes,utf8,utils},Symbol.toStringTag,{value:"Module"})),require$$0=getAugmentedNamespace(esm);var bolt11,hasRequiredBolt11;function requireBolt11(){if(hasRequiredBolt11)return bolt11;hasRequiredBolt11=1;const{bech32:n,hex:t,utf8:r}=require$$0,s={bech32:"bc",pubKeyHash:0,scriptHash:5,validWitnessVersions:[0]},o={bech32:"tb",pubKeyHash:111,scriptHash:196,validWitnessVersions:[0]},a={bech32:"tbs",pubKeyHash:111,scriptHash:196,validWitnessVersions:[0]},c={bech32:"bcrt",pubKeyHash:111,scriptHash:196,validWitnessVersions:[0]},f={bech32:"sb",pubKeyHash:63,scriptHash:123,validWitnessVersions:[0]},g=["option_data_loss_protect","initial_routing_sync","option_upfront_shutdown_script","gossip_queries","var_onion_optin","gossip_queries_ex","option_static_remotekey","payment_secret","basic_mpp","option_support_large_channel"],m={m:BigInt(1e3),u:BigInt(1e6),n:BigInt(1e9),p:BigInt(1e12)},b=BigInt("2100000000000000000"),k=BigInt(1e11),_={payment_hash:1,payment_secret:16,description:13,payee:19,description_hash:23,expiry:6,min_final_cltv_expiry:24,fallback_address:9,route_hint:3,feature_bits:5,metadata:27},A={};for(let se=0,ne=Object.keys(_);se<ne.length;se++){const X=ne[se],$e=_[ne[se]].toString();A[$e]=X}const B={1:se=>t.encode(n.fromWordsUnsafe(se)),16:se=>t.encode(n.fromWordsUnsafe(se)),13:se=>r.encode(n.fromWordsUnsafe(se)),19:se=>t.encode(n.fromWordsUnsafe(se)),23:se=>t.encode(n.fromWordsUnsafe(se)),27:se=>t.encode(n.fromWordsUnsafe(se)),6:Z,24:Z,3:ve,5:We};function L(se){return ne=>({tagCode:parseInt(se),words:n.encode("unknown",ne,Number.MAX_SAFE_INTEGER)})}function Z(se){return se.reverse().reduce((ne,X,$e)=>ne+X*Math.pow(32,$e),0)}function ve(se){const ne=[];let X,$e,Ve,Ze,He,Le=n.fromWordsUnsafe(se);for(;Le.length>0;)X=t.encode(Le.slice(0,33)),$e=t.encode(Le.slice(33,41)),Ve=parseInt(t.encode(Le.slice(41,45)),16),Ze=parseInt(t.encode(Le.slice(45,49)),16),He=parseInt(t.encode(Le.slice(49,51)),16),Le=Le.slice(51),ne.push({pubkey:X,short_channel_id:$e,fee_base_msat:Ve,fee_proportional_millionths:Ze,cltv_expiry_delta:He});return ne}function We(se){const ne=se.slice().reverse().map(Ve=>[!!(Ve&1),!!(Ve&2),!!(Ve&4),!!(Ve&8),!!(Ve&16)]).reduce((Ve,Ze)=>Ve.concat(Ze),[]);for(;ne.length<g.length*2;)ne.push(!1);const X={};g.forEach((Ve,Ze)=>{let He;ne[Ze*2]?He="required":ne[Ze*2+1]?He="supported":He="unsupported",X[Ve]=He});const $e=ne.slice(g.length*2);return X.extra_bits={start_bit:g.length*2,bits:$e,has_required:$e.reduce((Ve,Ze,He)=>He%2!==0?Ve||!1:Ve||Ze,!1)},X}function re(se,ne){let X,$e;if(se.slice(-1).match(/^[munp]$/))X=se.slice(-1),$e=se.slice(0,-1);else{if(se.slice(-1).match(/^[^munp0-9]$/))throw new Error("Not a valid multiplier for the amount");$e=se}if(!$e.match(/^\d+$/))throw new Error("Not a valid human readable amount");const Ve=BigInt($e),Ze=X?Ve*k/m[X]:Ve*k;if(X==="p"&&Ve%BigInt(10)!==BigInt(0)||Ze>b)throw new Error("Amount is outside of valid range");return ne?Ze.toString():Ze}function ze(se,ne){if(typeof se!="string")throw new Error("Lightning Payment Request must be string");if(se.slice(0,2).toLowerCase()!=="ln")throw new Error("Not a proper lightning payment request");const X=[],$e=n.decode(se,Number.MAX_SAFE_INTEGER);se=se.toLowerCase();const Ve=$e.prefix;let Ze=$e.words,He=se.slice(Ve.length+1),Le=Ze.slice(-104);Ze=Ze.slice(0,-104);let Q=Ve.match(/^ln(\S+?)(\d*)([a-zA-Z]?)$/);if(Q&&!Q[2]&&(Q=Ve.match(/^ln(\S+)$/)),!Q)throw new Error("Not a proper lightning payment request");X.push({name:"lightning_network",letters:"ln"});const oe=Q[1];let Y;if(ne){if(ne.bech32===void 0||ne.pubKeyHash===void 0||ne.scriptHash===void 0||!Array.isArray(ne.validWitnessVersions))throw new Error("Invalid network");Y=ne}else switch(oe){case s.bech32:Y=s;break;case o.bech32:Y=o;break;case a.bech32:Y=a;break;case c.bech32:Y=c;break;case f.bech32:Y=f;break}if(!Y||Y.bech32!==oe)throw new Error("Unknown coin bech32 prefix");X.push({name:"coin_network",letters:oe,value:Y});const Ce=Q[2];let je;if(Ce){const ot=Q[3];je=re(Ce+ot,!0),X.push({name:"amount",letters:Q[2]+Q[3],value:je})}else je=null;X.push({name:"separator",letters:"1"});const Je=Z(Ze.slice(0,7));Ze=Ze.slice(7),X.push({name:"timestamp",letters:He.slice(0,7),value:Je}),He=He.slice(7);let Ge,Xe,Qe,rt;for(;Ze.length>0;){const ot=Ze[0].toString();Ge=A[ot]||"unknown_tag",Xe=B[ot]||L(ot),Ze=Ze.slice(1),Qe=Z(Ze.slice(0,2)),Ze=Ze.slice(2),rt=Ze.slice(0,Qe),Ze=Ze.slice(Qe),X.push({name:Ge,tag:He[0],letters:He.slice(0,3+Qe),value:Xe(rt)}),He=He.slice(3+Qe)}X.push({name:"signature",letters:He.slice(0,104),value:t.encode(n.fromWordsUnsafe(Le))}),He=He.slice(104),X.push({name:"checksum",letters:He});let _t={paymentRequest:se,sections:X,get expiry(){let ot=X.find(xt=>xt.name==="expiry");if(ot)return ht("timestamp")+ot.value},get route_hints(){return X.filter(ot=>ot.name==="route_hint").map(ot=>ot.value)}};for(let ot in _)ot!=="route_hint"&&Object.defineProperty(_t,ot,{get(){return ht(ot)}});return _t;function ht(ot){let xt=X.find(St=>St.name===ot);return xt?xt.value:void 0}}return bolt11={decode:ze,hrpToMillisat:re},bolt11}var bolt11Exports=requireBolt11(),utf8Decoder=new TextDecoder("utf-8"),utf8Encoder=new TextEncoder,NostrTypeGuard={isNProfile:n=>/^nprofile1[a-z\d]+$/.test(n||""),isNEvent:n=>/^nevent1[a-z\d]+$/.test(n||""),isNAddr:n=>/^naddr1[a-z\d]+$/.test(n||""),isNSec:n=>/^nsec1[a-z\d]{58}$/.test(n||""),isNPub:n=>/^npub1[a-z\d]{58}$/.test(n||""),isNote:n=>/^note1[a-z\d]+$/.test(n||""),isNcryptsec:n=>/^ncryptsec1[a-z\d]+$/.test(n||"")},Bech32MaxSize=5e3,BECH32_REGEX$1=/[\x21-\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;function integerToUint8Array(n){const t=new Uint8Array(4);return t[0]=n>>24&255,t[1]=n>>16&255,t[2]=n>>8&255,t[3]=n&255,t}function decodeNostrURI(n){try{return n.startsWith("nostr:")&&(n=n.substring(6)),decode(n)}catch{return{type:"invalid",data:null}}}function decode(n){let{prefix:t,words:r}=bech32$2.decode(n,Bech32MaxSize),s=new Uint8Array(bech32$2.fromWords(r));switch(t){case"nprofile":{let o=parseTLV(s);if(!o[0]?.[0])throw new Error("missing TLV 0 for nprofile");if(o[0][0].length!==32)throw new Error("TLV 0 should be 32 bytes");return{type:"nprofile",data:{pubkey:bytesToHex$2(o[0][0]),relays:o[1]?o[1].map(a=>utf8Decoder.decode(a)):[]}}}case"nevent":{let o=parseTLV(s);if(!o[0]?.[0])throw new Error("missing TLV 0 for nevent");if(o[0][0].length!==32)throw new Error("TLV 0 should be 32 bytes");if(o[2]&&o[2][0].length!==32)throw new Error("TLV 2 should be 32 bytes");if(o[3]&&o[3][0].length!==4)throw new Error("TLV 3 should be 4 bytes");return{type:"nevent",data:{id:bytesToHex$2(o[0][0]),relays:o[1]?o[1].map(a=>utf8Decoder.decode(a)):[],author:o[2]?.[0]?bytesToHex$2(o[2][0]):void 0,kind:o[3]?.[0]?parseInt(bytesToHex$2(o[3][0]),16):void 0}}}case"naddr":{let o=parseTLV(s);if(!o[0]?.[0])throw new Error("missing TLV 0 for naddr");if(!o[2]?.[0])throw new Error("missing TLV 2 for naddr");if(o[2][0].length!==32)throw new Error("TLV 2 should be 32 bytes");if(!o[3]?.[0])throw new Error("missing TLV 3 for naddr");if(o[3][0].length!==4)throw new Error("TLV 3 should be 4 bytes");return{type:"naddr",data:{identifier:utf8Decoder.decode(o[0][0]),pubkey:bytesToHex$2(o[2][0]),kind:parseInt(bytesToHex$2(o[3][0]),16),relays:o[1]?o[1].map(a=>utf8Decoder.decode(a)):[]}}}case"nsec":return{type:t,data:s};case"npub":case"note":return{type:t,data:bytesToHex$2(s)};default:throw new Error(`unknown prefix ${t}`)}}function parseTLV(n){let t={},r=n;for(;r.length>0;){let s=r[0],o=r[1],a=r.slice(2,2+o);if(r=r.slice(2+o),a.length<o)throw new Error(`not enough data to read on TLV ${s}`);t[s]=t[s]||[],t[s].push(a)}return t}function nsecEncode(n){return encodeBytes("nsec",n)}function npubEncode(n){return encodeBytes("npub",hexToBytes$2(n))}function noteEncode(n){return encodeBytes("note",hexToBytes$2(n))}function encodeBech32(n,t){let r=bech32$2.toWords(t);return bech32$2.encode(n,r,Bech32MaxSize)}function encodeBytes(n,t){return encodeBech32(n,t)}function nprofileEncode(n){let t=encodeTLV({0:[hexToBytes$2(n.pubkey)],1:(n.relays||[]).map(r=>utf8Encoder.encode(r))});return encodeBech32("nprofile",t)}function neventEncode(n){let t;n.kind!==void 0&&(t=integerToUint8Array(n.kind));let r=encodeTLV({0:[hexToBytes$2(n.id)],1:(n.relays||[]).map(s=>utf8Encoder.encode(s)),2:n.author?[hexToBytes$2(n.author)]:[],3:t?[new Uint8Array(t)]:[]});return encodeBech32("nevent",r)}function naddrEncode(n){let t=new ArrayBuffer(4);new DataView(t).setUint32(0,n.kind,!1);let r=encodeTLV({0:[utf8Encoder.encode(n.identifier)],1:(n.relays||[]).map(s=>utf8Encoder.encode(s)),2:[hexToBytes$2(n.pubkey)],3:[new Uint8Array(t)]});return encodeBech32("naddr",r)}function encodeTLV(n){let t=[];return Object.entries(n).reverse().forEach(([r,s])=>{s.forEach(o=>{let a=new Uint8Array(o.length+2);a.set([parseInt(r)],0),a.set([o.length],1),a.set(o,2),t.push(a)})}),concatBytes$1(...t)}const nip19_star=Object.freeze(Object.defineProperty({__proto__:null,BECH32_REGEX:BECH32_REGEX$1,Bech32MaxSize,NostrTypeGuard,decode,decodeNostrURI,encodeBytes,naddrEncode,neventEncode,noteEncode,nprofileEncode,npubEncode,nsecEncode},Symbol.toStringTag,{value:"Module"}));function isBytes(n){return n instanceof Uint8Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint8Array"}function isArrayOf(n,t){return Array.isArray(t)?t.length===0?!0:n?t.every(r=>typeof r=="string"):t.every(r=>Number.isSafeInteger(r)):!1}function afn(n){if(typeof n!="function")throw new Error("function expected");return!0}function astr(n,t){if(typeof t!="string")throw new Error(`${n}: string expected`);return!0}function anumber(n){if(!Number.isSafeInteger(n))throw new Error(`invalid integer: ${n}`)}function aArr(n){if(!Array.isArray(n))throw new Error("array expected")}function astrArr(n,t){if(!isArrayOf(!0,t))throw new Error(`${n}: array of strings expected`)}function anumArr(n,t){if(!isArrayOf(!1,t))throw new Error(`${n}: array of numbers expected`)}function chain(...n){const t=a=>a,r=(a,c)=>f=>a(c(f)),s=n.map(a=>a.encode).reduceRight(r,t),o=n.map(a=>a.decode).reduce(r,t);return{encode:s,decode:o}}function alphabet(n){const t=typeof n=="string"?n.split(""):n,r=t.length;astrArr("alphabet",t);const s=new Map(t.map((o,a)=>[o,a]));return{encode:o=>(aArr(o),o.map(a=>{if(!Number.isSafeInteger(a)||a<0||a>=r)throw new Error(`alphabet.encode: digit index outside alphabet "${a}". Allowed: ${n}`);return t[a]})),decode:o=>(aArr(o),o.map(a=>{astr("alphabet.decode",a);const c=s.get(a);if(c===void 0)throw new Error(`Unknown letter: "${a}". Allowed: ${n}`);return c}))}}function join(n=""){return astr("join",n),{encode:t=>(astrArr("join.decode",t),t.join(n)),decode:t=>(astr("join.decode",t),t.split(n))}}function convertRadix(n,t,r){if(t<2)throw new Error(`convertRadix: invalid from=${t}, base cannot be less than 2`);if(r<2)throw new Error(`convertRadix: invalid to=${r}, base cannot be less than 2`);if(aArr(n),!n.length)return[];let s=0;const o=[],a=Array.from(n,f=>{if(anumber(f),f<0||f>=t)throw new Error(`invalid integer: ${f}`);return f}),c=a.length;for(;;){let f=0,g=!0;for(let m=s;m<c;m++){const b=a[m],k=t*f,_=k+b;if(!Number.isSafeInteger(_)||k/t!==f||_-b!==k)throw new Error("convertRadix: carry overflow");const A=_/r;f=_%r;const B=Math.floor(A);if(a[m]=B,!Number.isSafeInteger(B)||B*r+f!==_)throw new Error("convertRadix: carry overflow");if(g)B?g=!1:s=m;else continue}if(o.push(f),g)break}for(let f=0;f<n.length-1&&n[f]===0;f++)o.push(0);return o.reverse()}const gcd=(n,t)=>t===0?n:gcd(t,n%t),radix2carry=(n,t)=>n+(t-gcd(n,t)),powers=(()=>{let n=[];for(let t=0;t<40;t++)n.push(2**t);return n})();function convertRadix2(n,t,r,s){if(aArr(n),t<=0||t>32)throw new Error(`convertRadix2: wrong from=${t}`);if(r<=0||r>32)throw new Error(`convertRadix2: wrong to=${r}`);if(radix2carry(t,r)>32)throw new Error(`convertRadix2: carry overflow from=${t} to=${r} carryBits=${radix2carry(t,r)}`);let o=0,a=0;const c=powers[t],f=powers[r]-1,g=[];for(const m of n){if(anumber(m),m>=c)throw new Error(`convertRadix2: invalid data word=${m} from=${t}`);if(o=o<<t|m,a+t>32)throw new Error(`convertRadix2: carry overflow pos=${a} from=${t}`);for(a+=t;a>=r;a-=r)g.push((o>>a-r&f)>>>0);const b=powers[a];if(b===void 0)throw new Error("invalid carry");o&=b-1}if(o=o<<r-a&f,!s&&a>=t)throw new Error("Excess padding");if(!s&&o>0)throw new Error(`Non-zero padding: ${o}`);return s&&a>0&&g.push(o>>>0),g}function radix(n){anumber(n);const t=2**8;return{encode:r=>{if(!isBytes(r))throw new Error("radix.encode input should be Uint8Array");return convertRadix(Array.from(r),t,n)},decode:r=>(anumArr("radix.decode",r),Uint8Array.from(convertRadix(r,n,t)))}}function radix2(n,t=!1){if(anumber(n),n<=0||n>32)throw new Error("radix2: bits should be in (0..32]");if(radix2carry(8,n)>32||radix2carry(n,8)>32)throw new Error("radix2: carry overflow");return{encode:r=>{if(!isBytes(r))throw new Error("radix2.encode input should be Uint8Array");return convertRadix2(Array.from(r),8,n,!t)},decode:r=>(anumArr("radix2.decode",r),Uint8Array.from(convertRadix2(r,n,8,t)))}}function unsafeWrapper(n){return afn(n),function(...t){try{return n.apply(null,t)}catch{}}}function checksum(n,t){return anumber(n),afn(t),{encode(r){if(!isBytes(r))throw new Error("checksum.encode: input should be Uint8Array");const s=t(r).slice(0,n),o=new Uint8Array(r.length+n);return o.set(r),o.set(s,r.length),o},decode(r){if(!isBytes(r))throw new Error("checksum.decode: input should be Uint8Array");const s=r.slice(0,-n),o=r.slice(-n),a=t(s).slice(0,n);for(let c=0;c<n;c++)if(a[c]!==o[c])throw new Error("Invalid checksum");return s}}}const genBase58=n=>chain(radix(58),alphabet(n),join("")),base58=genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),createBase58check=n=>chain(checksum(4,t=>n(n(t))),base58),BECH_ALPHABET=chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),join("")),POLYMOD_GENERATORS=[996825010,642813549,513874426,1027748829,705979059];function bech32Polymod(n){const t=n>>25;let r=(n&33554431)<<5;for(let s=0;s<POLYMOD_GENERATORS.length;s++)(t>>s&1)===1&&(r^=POLYMOD_GENERATORS[s]);return r}function bechChecksum(n,t,r=1){const s=n.length;let o=1;for(let a=0;a<s;a++){const c=n.charCodeAt(a);if(c<33||c>126)throw new Error(`Invalid prefix (${n})`);o=bech32Polymod(o)^c>>5}o=bech32Polymod(o);for(let a=0;a<s;a++)o=bech32Polymod(o)^n.charCodeAt(a)&31;for(let a of t)o=bech32Polymod(o)^a;for(let a=0;a<6;a++)o=bech32Polymod(o);return o^=r,BECH_ALPHABET.encode(convertRadix2([o%powers[30]],30,5,!1))}function genBech32(n){const t=n==="bech32"?1:734539939,r=radix2(5),s=r.decode,o=r.encode,a=unsafeWrapper(s);function c(k,_,A=90){astr("bech32.encode prefix",k),isBytes(_)&&(_=Array.from(_)),anumArr("bech32.encode",_);const B=k.length;if(B===0)throw new TypeError(`Invalid prefix length ${B}`);const L=B+7+_.length;if(A!==!1&&L>A)throw new TypeError(`Length ${L} exceeds limit ${A}`);const Z=k.toLowerCase(),ve=bechChecksum(Z,_,t);return`${Z}1${BECH_ALPHABET.encode(_)}${ve}`}function f(k,_=90){astr("bech32.decode input",k);const A=k.length;if(A<8||_!==!1&&A>_)throw new TypeError(`invalid string length: ${A} (${k}). Expected (8..${_})`);const B=k.toLowerCase();if(k!==B&&k!==k.toUpperCase())throw new Error("String must be lowercase or uppercase");const L=B.lastIndexOf("1");if(L===0||L===-1)throw new Error('Letter "1" must be present between prefix and data only');const Z=B.slice(0,L),ve=B.slice(L+1);if(ve.length<6)throw new Error("Data must be at least 6 characters long");const We=BECH_ALPHABET.decode(ve).slice(0,-6),re=bechChecksum(Z,We,t);if(!ve.endsWith(re))throw new Error(`Invalid checksum in ${k}: expected "${re}"`);return{prefix:Z,words:We}}const g=unsafeWrapper(f);function m(k){const{prefix:_,words:A}=f(k,!1);return{prefix:_,words:A,bytes:s(A)}}function b(k,_){return c(k,o(_))}return{encode:c,decode:f,encodeFromBytes:b,decodeToBytes:m,decodeUnsafe:g,fromWords:s,fromWordsUnsafe:a,toWords:o}}const bech32=genBech32("bech32");var __defProp=Object.defineProperty,__getOwnPropDesc=Object.getOwnPropertyDescriptor,__getOwnPropNames=Object.getOwnPropertyNames,__hasOwnProp=Object.prototype.hasOwnProperty,__copyProps=(n,t,r,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of __getOwnPropNames(t))!__hasOwnProp.call(n,o)&&o!==r&&__defProp(n,o,{get:()=>t[o],enumerable:!(s=__getOwnPropDesc(t,o))||s.enumerable});return n},__reExport=(n,t,r)=>(__copyProps(n,t,"default"),r),NDKKind=(n=>(n[n.Metadata=0]="Metadata",n[n.Text=1]="Text",n[n.RecommendRelay=2]="RecommendRelay",n[n.Contacts=3]="Contacts",n[n.EncryptedDirectMessage=4]="EncryptedDirectMessage",n[n.EventDeletion=5]="EventDeletion",n[n.Repost=6]="Repost",n[n.Reaction=7]="Reaction",n[n.BadgeAward=8]="BadgeAward",n[n.GroupChat=9]="GroupChat",n[n.Thread=11]="Thread",n[n.GroupReply=12]="GroupReply",n[n.GiftWrapSeal=13]="GiftWrapSeal",n[n.PrivateDirectMessage=14]="PrivateDirectMessage",n[n.Image=20]="Image",n[n.Video=21]="Video",n[n.ShortVideo=22]="ShortVideo",n[n.Story=23]="Story",n[n.Vanish=62]="Vanish",n[n.CashuWalletBackup=375]="CashuWalletBackup",n[n.GiftWrap=1059]="GiftWrap",n[n.GenericRepost=16]="GenericRepost",n[n.ChannelCreation=40]="ChannelCreation",n[n.ChannelMetadata=41]="ChannelMetadata",n[n.ChannelMessage=42]="ChannelMessage",n[n.ChannelHideMessage=43]="ChannelHideMessage",n[n.ChannelMuteUser=44]="ChannelMuteUser",n[n.WikiMergeRequest=818]="WikiMergeRequest",n[n.GenericReply=1111]="GenericReply",n[n.Media=1063]="Media",n[n.VoiceMessage=1222]="VoiceMessage",n[n.VoiceReply=1244]="VoiceReply",n[n.DraftCheckpoint=1234]="DraftCheckpoint",n[n.Task=1934]="Task",n[n.Report=1984]="Report",n[n.Label=1985]="Label",n[n.DVMReqTextExtraction=5e3]="DVMReqTextExtraction",n[n.DVMReqTextSummarization=5001]="DVMReqTextSummarization",n[n.DVMReqTextTranslation=5002]="DVMReqTextTranslation",n[n.DVMReqTextGeneration=5050]="DVMReqTextGeneration",n[n.DVMReqImageGeneration=5100]="DVMReqImageGeneration",n[n.DVMReqTextToSpeech=5250]="DVMReqTextToSpeech",n[n.DVMReqDiscoveryNostrContent=5300]="DVMReqDiscoveryNostrContent",n[n.DVMReqDiscoveryNostrPeople=5301]="DVMReqDiscoveryNostrPeople",n[n.DVMReqTimestamping=5900]="DVMReqTimestamping",n[n.DVMEventSchedule=5905]="DVMEventSchedule",n[n.DVMJobFeedback=7e3]="DVMJobFeedback",n[n.Subscribe=7001]="Subscribe",n[n.Unsubscribe=7002]="Unsubscribe",n[n.SubscriptionReceipt=7003]="SubscriptionReceipt",n[n.CashuReserve=7373]="CashuReserve",n[n.CashuQuote=7374]="CashuQuote",n[n.CashuToken=7375]="CashuToken",n[n.CashuWalletTx=7376]="CashuWalletTx",n[n.GroupAdminAddUser=9e3]="GroupAdminAddUser",n[n.GroupAdminRemoveUser=9001]="GroupAdminRemoveUser",n[n.GroupAdminEditMetadata=9002]="GroupAdminEditMetadata",n[n.GroupAdminEditStatus=9006]="GroupAdminEditStatus",n[n.GroupAdminCreateGroup=9007]="GroupAdminCreateGroup",n[n.GroupAdminRequestJoin=9021]="GroupAdminRequestJoin",n[n.MuteList=1e4]="MuteList",n[n.PinList=10001]="PinList",n[n.RelayList=10002]="RelayList",n[n.BookmarkList=10003]="BookmarkList",n[n.CommunityList=10004]="CommunityList",n[n.PublicChatList=10005]="PublicChatList",n[n.BlockRelayList=10006]="BlockRelayList",n[n.SearchRelayList=10007]="SearchRelayList",n[n.SimpleGroupList=10009]="SimpleGroupList",n[n.RelayFeedList=10012]="RelayFeedList",n[n.InterestList=10015]="InterestList",n[n.CashuMintList=10019]="CashuMintList",n[n.EmojiList=10030]="EmojiList",n[n.DirectMessageReceiveRelayList=10050]="DirectMessageReceiveRelayList",n[n.BlossomList=10063]="BlossomList",n[n.NostrWaletConnectInfo=13194]="NostrWaletConnectInfo",n[n.TierList=17e3]="TierList",n[n.CashuWallet=17375]="CashuWallet",n[n.FollowSet=3e4]="FollowSet",n[n.CategorizedPeopleList=3e4]="CategorizedPeopleList",n[n.CategorizedBookmarkList=30001]="CategorizedBookmarkList",n[n.RelaySet=30002]="RelaySet",n[n.CategorizedRelayList=30002]="CategorizedRelayList",n[n.BookmarkSet=30003]="BookmarkSet",n[n.CurationSet=30004]="CurationSet",n[n.ArticleCurationSet=30004]="ArticleCurationSet",n[n.VideoCurationSet=30005]="VideoCurationSet",n[n.ImageCurationSet=30006]="ImageCurationSet",n[n.InterestSet=30015]="InterestSet",n[n.InterestsList=30015]="InterestsList",n[n.ProjectTemplate=30717]="ProjectTemplate",n[n.EmojiSet=30030]="EmojiSet",n[n.ModularArticle=30040]="ModularArticle",n[n.ModularArticleItem=30041]="ModularArticleItem",n[n.Wiki=30818]="Wiki",n[n.Draft=31234]="Draft",n[n.Project=31933]="Project",n[n.SubscriptionTier=37001]="SubscriptionTier",n[n.EcashMintRecommendation=38e3]="EcashMintRecommendation",n[n.CashuMintAnnouncement=38172]="CashuMintAnnouncement",n[n.FedimintMintAnnouncement=38173]="FedimintMintAnnouncement",n[n.HighlightSet=39802]="HighlightSet",n[n.CategorizedHighlightList=39802]="CategorizedHighlightList",n[n.Nutzap=9321]="Nutzap",n[n.ZapRequest=9734]="ZapRequest",n[n.Zap=9735]="Zap",n[n.Highlight=9802]="Highlight",n[n.ClientAuth=22242]="ClientAuth",n[n.NostrWalletConnectReq=23194]="NostrWalletConnectReq",n[n.NostrWalletConnectRes=23195]="NostrWalletConnectRes",n[n.NostrConnect=24133]="NostrConnect",n[n.BlossomUpload=24242]="BlossomUpload",n[n.HttpAuth=27235]="HttpAuth",n[n.ProfileBadge=30008]="ProfileBadge",n[n.BadgeDefinition=30009]="BadgeDefinition",n[n.MarketStall=30017]="MarketStall",n[n.MarketProduct=30018]="MarketProduct",n[n.Article=30023]="Article",n[n.AppSpecificData=30078]="AppSpecificData",n[n.Classified=30402]="Classified",n[n.HorizontalVideo=34235]="HorizontalVideo",n[n.VerticalVideo=34236]="VerticalVideo",n[n.GroupMetadata=39e3]="GroupMetadata",n[n.GroupAdmins=39001]="GroupAdmins",n[n.GroupMembers=39002]="GroupMembers",n[n.FollowPack=39089]="FollowPack",n[n.MediaFollowPack=39092]="MediaFollowPack",n[n.AppRecommendation=31989]="AppRecommendation",n[n.AppHandler=31990]="AppHandler",n))(NDKKind||{});function getRelaysForSync(n,t,r="write"){if(!n.outboxTracker)return;const s=n.outboxTracker.data.get(t);if(s)return r==="write"?s.writeRelays:s.readRelays}async function getWriteRelaysFor(n,t,r="write"){if(n.outboxTracker)return n.outboxTracker.data.has(t)||await n.outboxTracker.trackUsers([t]),getRelaysForSync(n,t,r)}function getTopRelaysForAuthors(n,t){const r=new Map;return t.forEach(o=>{const a=getRelaysForSync(n,o);a&&a.forEach(c=>{const f=r.get(c)||0;r.set(c,f+1)})}),Array.from(r.entries()).sort((o,a)=>a[1]-o[1]).map(o=>o[0])}function getAllRelaysForAllPubkeys(n,t,r="read"){const s=new Map,o=new Set;return t.forEach(a=>{const c=getRelaysForSync(n,a,r);c&&c.size>0?(c.forEach(f=>{(s.get(f)||new Set).add(a)}),s.set(a,c)):o.add(a)}),{pubkeysToRelays:s,authorsMissingRelays:o}}function chooseRelayCombinationForPubkeys(n,t,r,{count:s,preferredRelays:o}={}){s??=2,o??=new Set;const a=n.pool,c=a.connectedRelays();c.forEach(_=>{o?.add(_.url)});const f=new Map,{pubkeysToRelays:g,authorsMissingRelays:m}=getAllRelaysForAllPubkeys(n,t,r),b=getTopRelaysForAuthors(n,t),k=(_,A)=>{const B=f.get(A)||[];B.push(_),f.set(A,B)};for(const[_,A]of g.entries()){let B=s;const L=new Set;for(const Z of c)A.has(Z.url)&&(k(_,Z.url),L.add(Z.url),B--);for(const Z of A)L.has(Z)||f.has(Z)&&(k(_,Z),L.add(Z),B--);if(!(B<=0))for(const Z of b){if(B<=0)break;L.has(Z)||A.has(Z)&&(k(_,Z),L.add(Z),B--)}}for(const _ of m)a.permanentAndConnectedRelays().forEach(A=>{const B=f.get(A.url)||[];B.push(_),f.set(A.url,B)});return f}function getRelaysForFilterWithAuthors(n,t,r=2){return chooseRelayCombinationForPubkeys(n,t,"write",{count:r})}function tryNormalizeRelayUrl(n){try{return normalizeRelayUrl(n)}catch{return}}function normalizeRelayUrl(n){let t=normalizeUrl(n,{stripAuthentication:!1,stripWWW:!1,stripHash:!0});return t.endsWith("/")||(t+="/"),t}function normalize(n){const t=new Set;for(const r of n)try{t.add(normalizeRelayUrl(r))}catch{}return Array.from(t)}var DATA_URL_DEFAULT_MIME_TYPE="text/plain",DATA_URL_DEFAULT_CHARSET="us-ascii",testParameter=(n,t)=>t.some(r=>r instanceof RegExp?r.test(n):r===n),supportedProtocols=new Set(["https:","http:","file:"]),hasCustomProtocol=n=>{try{const{protocol:t}=new URL(n);return t.endsWith(":")&&!t.includes(".")&&!supportedProtocols.has(t)}catch{return!1}},normalizeDataURL=(n,{stripHash:t})=>{const r=/^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(n);if(!r)throw new Error(`Invalid URL: ${n}`);const s=r.groups?.type??"",o=r.groups?.data??"";let a=r.groups?.hash??"";const c=s.split(";");a=t?"":a;let f=!1;c[c.length-1]==="base64"&&(c.pop(),f=!0);const g=c.shift()?.toLowerCase()??"",b=[...c.map(k=>{let[_,A=""]=k.split("=").map(B=>B.trim());return _==="charset"&&(A=A.toLowerCase(),A===DATA_URL_DEFAULT_CHARSET)?"":`${_}${A?`=${A}`:""}`}).filter(Boolean)];return f&&b.push("base64"),(b.length>0||g&&g!==DATA_URL_DEFAULT_MIME_TYPE)&&b.unshift(g),`data:${b.join(";")},${f?o.trim():o}${a?`#${a}`:""}`};function normalizeUrl(n,t={}){if(t={defaultProtocol:"http",normalizeProtocol:!0,forceHttp:!1,forceHttps:!1,stripAuthentication:!0,stripHash:!1,stripTextFragment:!0,stripWWW:!0,removeQueryParameters:[/^utm_\w+/i],removeTrailingSlash:!0,removeSingleSlash:!0,removeDirectoryIndex:!1,removeExplicitPort:!1,sortQueryParameters:!0,...t},typeof t.defaultProtocol=="string"&&!t.defaultProtocol.endsWith(":")&&(t.defaultProtocol=`${t.defaultProtocol}:`),n=n.trim(),/^data:/i.test(n))return normalizeDataURL(n,t);if(hasCustomProtocol(n))return n;const r=n.startsWith("//");!r&&/^\.*\//.test(n)||(n=n.replace(/^(?!(?:\w+:)?\/\/)|^\/\//,t.defaultProtocol));const o=new URL(n);if(o.hostname=o.hostname.toLowerCase(),t.forceHttp&&t.forceHttps)throw new Error("The `forceHttp` and `forceHttps` options cannot be used together");if(t.forceHttp&&o.protocol==="https:"&&(o.protocol="http:"),t.forceHttps&&o.protocol==="http:"&&(o.protocol="https:"),t.stripAuthentication&&(o.username="",o.password=""),t.stripHash?o.hash="":t.stripTextFragment&&(o.hash=o.hash.replace(/#?:~:text.*?$/i,"")),o.pathname){const c=/\b[a-z][a-z\d+\-.]{1,50}:\/\//g;let f=0,g="";for(;;){const b=c.exec(o.pathname);if(!b)break;const k=b[0],_=b.index,A=o.pathname.slice(f,_);g+=A.replace(/\/{2,}/g,"/"),g+=k,f=_+k.length}const m=o.pathname.slice(f,o.pathname.length);g+=m.replace(/\/{2,}/g,"/"),o.pathname=g}if(o.pathname)try{o.pathname=decodeURI(o.pathname)}catch{}if(t.removeDirectoryIndex===!0&&(t.removeDirectoryIndex=[/^index\.[a-z]+$/]),Array.isArray(t.removeDirectoryIndex)&&t.removeDirectoryIndex.length>0){let c=o.pathname.split("/");const f=c[c.length-1];testParameter(f,t.removeDirectoryIndex)&&(c=c.slice(0,-1),o.pathname=`${c.slice(1).join("/")}/`)}if(o.hostname&&(o.hostname=o.hostname.replace(/\.$/,""),t.stripWWW&&/^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(o.hostname)&&(o.hostname=o.hostname.replace(/^www\./,""))),Array.isArray(t.removeQueryParameters))for(const c of[...o.searchParams.keys()])testParameter(c,t.removeQueryParameters)&&o.searchParams.delete(c);if(!Array.isArray(t.keepQueryParameters)&&t.removeQueryParameters===!0&&(o.search=""),Array.isArray(t.keepQueryParameters)&&t.keepQueryParameters.length>0)for(const c of[...o.searchParams.keys()])testParameter(c,t.keepQueryParameters)||o.searchParams.delete(c);if(t.sortQueryParameters){o.searchParams.sort();try{o.search=decodeURIComponent(o.search)}catch{}}t.removeTrailingSlash&&(o.pathname=o.pathname.replace(/\/$/,"")),t.removeExplicitPort&&o.port&&(o.port="");const a=n;return n=o.toString(),!t.removeSingleSlash&&o.pathname==="/"&&!a.endsWith("/")&&o.hash===""&&(n=n.replace(/\/$/,"")),(t.removeTrailingSlash||o.pathname==="/")&&o.hash===""&&t.removeSingleSlash&&(n=n.replace(/\/$/,"")),r&&!t.normalizeProtocol&&(n=n.replace(/^http:\/\//,"//")),t.stripProtocol&&(n=n.replace(/^(?:https?:)?\/\//,"")),n}var NDKRelayKeepalive=class{constructor(n=3e4,t){this.onSilenceDetected=t,this.timeout=n}lastActivity=Date.now();timer;timeout;isRunning=!1;recordActivity(){this.lastActivity=Date.now(),this.isRunning&&this.resetTimer()}start(){this.isRunning||(this.isRunning=!0,this.lastActivity=Date.now(),this.resetTimer())}stop(){this.isRunning=!1,this.timer&&(clearTimeout(this.timer),this.timer=void 0)}resetTimer(){this.timer&&clearTimeout(this.timer),this.timer=setTimeout(()=>{const n=Date.now()-this.lastActivity;if(n>=this.timeout)this.onSilenceDetected();else{const t=this.timeout-n;this.timer=setTimeout(()=>{this.onSilenceDetected()},t)}},this.timeout)}};async function probeRelayConnection(n){const t=`probe-${Math.random().toString(36).substring(7)}`;return new Promise(r=>{let s=!1;const o=setTimeout(()=>{s||(s=!0,n.send(["CLOSE",t]),r(!1))},5e3),a=()=>{s||(s=!0,clearTimeout(o),n.send(["CLOSE",t]),r(!0))};n.once("message",a),n.send(["REQ",t,{kinds:[99999],limit:0}])})}var MAX_RECONNECT_ATTEMPTS=5,FLAPPING_THRESHOLD_MS=1e3,NDKRelayConnectivity=class{ndkRelay;ws;_status;timeoutMs;connectedAt;_connectionStats={attempts:0,success:0,durations:[]};debug;netDebug;connectTimeout;reconnectTimeout;ndk;openSubs=new Map;openCountRequests=new Map;openEventPublishes=new Map;pendingAuthPublishes=new Map;serial=0;baseEoseTimeout=4400;keepalive;wsStateMonitor;sleepDetector;lastSleepCheck=Date.now();lastMessageSent=Date.now();wasIdle=!1;constructor(n,t){this.ndkRelay=n,this._status=1;const r=Math.floor(Math.random()*1e3);this.debug=this.ndkRelay.debug.extend(`connectivity${r}`),this.ndk=t,this.setupMonitoring()}setupMonitoring(){this.keepalive=new NDKRelayKeepalive(12e4,async()=>{this.debug("Relay silence detected, probing connection"),await probeRelayConnection({send:t=>this.send(JSON.stringify(t)),once:(t,r)=>{const s=o=>{try{const a=JSON.parse(o.data);(a[0]==="EOSE"||a[0]==="EVENT"||a[0]==="NOTICE")&&(r(),this.ws?.removeEventListener("message",s))}catch{}};this.ws?.addEventListener("message",s)}})||(this.debug("Probe failed, connection is stale"),this.handleStaleConnection())}),this.wsStateMonitor=setInterval(()=>{this._status===5&&(!this.ws||this.ws.readyState!==WebSocket.OPEN)&&(this.debug("WebSocket died silently, reconnecting"),this.handleStaleConnection())},5e3),this.sleepDetector=setInterval(()=>{const n=Date.now(),t=n-this.lastSleepCheck;t>15e3&&(this.debug(`Detected possible sleep/wake (${t}ms gap)`),this.handlePossibleWake()),this.lastSleepCheck=n},1e4)}handleStaleConnection(){this._status=1,this.wasIdle=!0,this.onDisconnect()}handlePossibleWake(){this.debug("System wake detected, checking all connections"),this.wasIdle=!0,this._status>=5&&(!this.ws||this.ws.readyState!==WebSocket.OPEN?this.handleStaleConnection():probeRelayConnection({send:n=>this.send(JSON.stringify(n)),once:(n,t)=>{const r=s=>{try{const o=JSON.parse(s.data);(o[0]==="EOSE"||o[0]==="EVENT"||o[0]==="NOTICE")&&(t(),this.ws?.removeEventListener("message",r))}catch{}};this.ws?.addEventListener("message",r)}}).then(n=>{n||this.handleStaleConnection()}))}resetReconnectionState(){this.wasIdle=!0,this.reconnectTimeout&&(clearTimeout(this.reconnectTimeout),this.reconnectTimeout=void 0)}async connect(n,t=!0){if(this.ws&&this.ws.readyState!==WebSocket.OPEN&&this.ws.readyState!==WebSocket.CONNECTING){this.debug("Cleaning up stale WebSocket connection");try{this.ws.close()}catch{}this.ws=void 0,this._status=1}if(this._status!==2&&this._status!==1||this.reconnectTimeout){this.debug("Relay requested to be connected but was in state %s or it had a reconnect timeout",this._status);return}this.reconnectTimeout&&(clearTimeout(this.reconnectTimeout),this.reconnectTimeout=void 0),this.connectTimeout&&(clearTimeout(this.connectTimeout),this.connectTimeout=void 0),n??=this.timeoutMs,!this.timeoutMs&&n&&(this.timeoutMs=n),this.timeoutMs&&(this.connectTimeout=setTimeout(()=>this.onConnectionError(t),this.timeoutMs));try{this.updateConnectionStats.attempt(),this._status===1?this._status=4:this._status=2,this.ws=new WebSocket(this.ndkRelay.url),this.ws.onopen=this.onConnect.bind(this),this.ws.onclose=this.onDisconnect.bind(this),this.ws.onmessage=this.onMessage.bind(this),this.ws.onerror=this.onError.bind(this)}catch(r){throw this.debug(`Failed to connect to ${this.ndkRelay.url}`,r),this._status=1,t?this.handleReconnection():this.ndkRelay.emit("delayed-connect",2880*60*1e3),r}}disconnect(){this._status=0,this.keepalive?.stop(),this.wsStateMonitor&&(clearInterval(this.wsStateMonitor),this.wsStateMonitor=void 0),this.sleepDetector&&(clearInterval(this.sleepDetector),this.sleepDetector=void 0);try{this.ws?.close()}catch(n){this.debug("Failed to disconnect",n),this._status=1}}onConnectionError(n){this.debug(`Error connecting to ${this.ndkRelay.url}`,this.timeoutMs),n&&!this.reconnectTimeout&&this.handleReconnection()}onConnect(){this.netDebug?.("connected",this.ndkRelay),this.reconnectTimeout&&(clearTimeout(this.reconnectTimeout),this.reconnectTimeout=void 0),this.connectTimeout&&(clearTimeout(this.connectTimeout),this.connectTimeout=void 0),this.updateConnectionStats.connected(),this._status=5,this.keepalive?.start(),this.wasIdle=!1,this.ndkRelay.emit("connect"),this.ndkRelay.emit("ready")}onDisconnect(){this.netDebug?.("disconnected",this.ndkRelay),this.updateConnectionStats.disconnected(),this.keepalive?.stop(),this.clearPendingPublishes(new Error(`Relay ${this.ndkRelay.url} disconnected`)),this._status===5&&this.handleReconnection(),this._status=1,this.ndkRelay.emit("disconnect")}onMessage(n){this.netDebug?.(n.data,this.ndkRelay,"recv"),this.keepalive?.recordActivity();try{const t=JSON.parse(n.data),[r,s,...o]=t,a=this.ndkRelay.getProtocolHandler(r);if(a){a(this.ndkRelay,t);return}switch(r){case"EVENT":{const c=this.openSubs.get(s),f=t[2];if(!c){this.debug(`Received event for unknown subscription ${s}`);return}c.onevent(f);return}case"COUNT":{const c=t[2],f=this.openCountRequests.get(s);f&&(f.resolve(c.count),this.openCountRequests.delete(s));return}case"EOSE":{const c=this.openSubs.get(s);if(!c)return;c.oneose(s);return}case"OK":{const c=t[2],f=t[3],g=this.openEventPublishes.get(s),m=g?.pop();if(!g||!m){this.debug("Received OK for unknown event publish",s);return}c?(m.resolve(f),this.pendingAuthPublishes.delete(s)):f&&(f.toLowerCase().includes("auth-required")||f.toLowerCase().includes("not authorized")||f.toLowerCase().includes("blocked: not authorized"))?this.pendingAuthPublishes.get(s)?(this.debug("Publish failed due to auth-required, will retry after auth",s),g.push(m),this.openEventPublishes.set(s,g)):m.reject(new Error(f)):(m.reject(new Error(f)),this.pendingAuthPublishes.delete(s)),g.length===0?this.openEventPublishes.delete(s):!c&&!(f?.toLowerCase().includes("auth-required")||f?.toLowerCase().includes("not authorized")||f?.toLowerCase().includes("blocked: not authorized"))&&this.openEventPublishes.set(s,g);return}case"CLOSED":{const c=this.openSubs.get(s);if(!c)return;c.onclosed(t[2]);return}case"NOTICE":this.onNotice(t[1]);return;case"AUTH":{this.onAuthRequested(t[1]);return}}}catch(t){this.debug(`Error parsing message from ${this.ndkRelay.url}: ${t.message}`,t?.stack);return}}async onAuthRequested(n){const t=this.ndkRelay.authPolicy??this.ndk?.relayAuthDefaultPolicy;if(this.debug("Relay requested authentication",{havePolicy:!!t}),this._status===7){this.debug("Already authenticating, ignoring");return}if(this._status=6,t){if(this._status>=5){this._status=7;let r;try{r=await t(this.ndkRelay,n)}catch(s){this.debug("Authentication policy threw an error",s),r=!1}if(this.debug("Authentication policy returned",!!r),r instanceof NDKEvent||r===!0){r instanceof NDKEvent&&await this.auth(r);const s=async()=>{if(this._status>=5&&this._status<8){const o=new NDKEvent(this.ndk);o.kind=22242,o.tags=[["relay",this.ndkRelay.url],["challenge",n]],await o.sign(),this.auth(o).then(()=>{this._status=8,this.ndkRelay.emit("authed"),this.debug("Authentication successful"),this.retryPendingAuthPublishes()}).catch(a=>{this._status=6,this.ndkRelay.emit("auth:failed",a),this.debug("Authentication failed",a),this.rejectPendingAuthPublishes(a)})}else this.debug("Authentication failed, it changed status, status is %d",this._status)};r===!0&&(this.ndk?.signer?s().catch(o=>{console.error("Error authenticating",o)}):(this.debug("No signer available for authentication localhost"),this.ndk?.once("signer:ready",s))),this._status=5,this.ndkRelay.emit("authed")}}}else this.ndkRelay.emit("auth",n)}onError(n){this.debug(`WebSocket error on ${this.ndkRelay.url}:`,n)}get status(){return this._status}isAvailable(){return this._status===5}isFlapping(){const n=this._connectionStats.durations;if(n.length%3!==0)return!1;const r=n.reduce((c,f)=>c+f,0)/n.length,s=n.map(c=>(c-r)**2).reduce((c,f)=>c+f,0)/n.length;return Math.sqrt(s)<FLAPPING_THRESHOLD_MS}async onNotice(n){this.ndkRelay.emit("notice",n)}handleReconnection(n=0){if(this.reconnectTimeout)return;if(this.isFlapping()){this.ndkRelay.emit("flapping",this._connectionStats),this._status=3;return}let t;if(this.wasIdle){const r=[0,1e3,2e3,5e3,1e4,3e4];t=r[Math.min(n,r.length-1)],this.debug(`Using aggressive reconnect after idle, attempt ${n}, delay ${t}ms`)}else this.connectedAt?t=Math.max(0,6e4-(Date.now()-this.connectedAt)):(t=Math.min(1e3*2**n,3e4),this.debug(`Using standard backoff, attempt ${n}, delay ${t}ms`));this.reconnectTimeout=setTimeout(()=>{this.reconnectTimeout=void 0,this._status=2,this.connect().catch(r=>{n<MAX_RECONNECT_ATTEMPTS?this.handleReconnection(n+1):(this.debug("Max reconnect attempts reached"),this.wasIdle=!1)})},t),this.ndkRelay.emit("delayed-connect",t),this.debug("Reconnecting in",t),this._connectionStats.nextReconnectAt=Date.now()+t}async send(n){Date.now()-this.lastMessageSent>12e4&&(this.wasIdle=!0),this._status>=5&&this.ws?.readyState===WebSocket.OPEN?(this.ws?.send(n),this.netDebug?.(n,this.ndkRelay,"send"),this.lastMessageSent=Date.now()):(this.debug(`Not connected to ${this.ndkRelay.url} (%d), not sending message ${n}`,this._status),this._status>=5&&this.ws?.readyState!==WebSocket.OPEN&&(this.debug(`Stale connection detected, WebSocket state: ${this.ws?.readyState}`),this.handleStaleConnection()))}async auth(n){const t=new Promise((r,s)=>{const o=this.openEventPublishes.get(n.id)??[];o.push({resolve:r,reject:s}),this.openEventPublishes.set(n.id,o)});return this.send(`["AUTH",${JSON.stringify(n.rawEvent())}]`),t}clearPendingPublishes(n){this.rejectPendingAuthPublishes(n);for(const[t,r]of this.openEventPublishes.entries()){for(;r.length>0;){const s=r.shift();s&&s.reject(n)}this.openEventPublishes.delete(t)}}retryPendingAuthPublishes(){if(this.pendingAuthPublishes.size!==0){this.debug(`Retrying ${this.pendingAuthPublishes.size} pending publishes after auth`);for(const[n,t]of this.pendingAuthPublishes.entries())this.debug(`Retrying publish for event ${n}`),this.send(`["EVENT",${JSON.stringify(t)}]`);this.pendingAuthPublishes.clear()}}rejectPendingAuthPublishes(n){if(this.pendingAuthPublishes.size!==0){this.debug(`Rejecting ${this.pendingAuthPublishes.size} pending publishes due to auth failure`);for(const[t]of this.pendingAuthPublishes.entries()){const r=this.openEventPublishes.get(t);if(r&&r.length>0){const s=r.pop();s&&s.reject(new Error(`Authentication failed: ${n.message}`)),r.length===0&&this.openEventPublishes.delete(t)}}this.pendingAuthPublishes.clear()}}async publish(n){const t=new Promise((r,s)=>{const o=this.openEventPublishes.get(n.id)??[];o.length>0&&console.warn(`Duplicate event publishing detected, you are publishing event ${n.id} twice`),o.push({resolve:r,reject:s}),this.openEventPublishes.set(n.id,o)});return this.pendingAuthPublishes.set(n.id,n),this.send(`["EVENT",${JSON.stringify(n)}]`),t}async count(n,t){this.serial++;const r=t?.id||`count:${this.serial}`,s=new Promise((o,a)=>{this.openCountRequests.set(r,{resolve:o,reject:a})});return this.send(`["COUNT","${r}",${JSON.stringify(n).substring(1)}`),s}close(n,t){this.send(`["CLOSE","${n}"]`);const r=this.openSubs.get(n);this.openSubs.delete(n),r&&r.onclose(t)}req(n){`${this.send(`["REQ","${n.subId}",${JSON.stringify(n.executeFilters).substring(1)}`)}`,this.openSubs.set(n.subId,n)}updateConnectionStats={connected:()=>{this._connectionStats.success++,this._connectionStats.connectedAt=Date.now()},disconnected:()=>{this._connectionStats.connectedAt&&(this._connectionStats.durations.push(Date.now()-this._connectionStats.connectedAt),this._connectionStats.durations.length>100&&this._connectionStats.durations.shift()),this._connectionStats.connectedAt=void 0},attempt:()=>{this._connectionStats.attempts++,this._connectionStats.connectedAt=Date.now()}};get connectionStats(){return this._connectionStats}get url(){return this.ndkRelay.url}get connected(){return this._status>=5&&this.ws?.readyState===WebSocket.OPEN}};async function fetchRelayInformation(n){const t=n.replace(/^wss:\/\//,"https://").replace(/^ws:\/\//,"http://"),r=await fetch(t,{headers:{Accept:"application/nostr+json"}});if(!r.ok)throw new Error(`Failed to fetch relay information: ${r.status} ${r.statusText}`);return await r.json()}var NDKRelayPublisher=class{ndkRelay;debug;constructor(n){this.ndkRelay=n,this.debug=n.debug.extend("publisher")}async publish(n,t=2500){let r;const s=()=>new Promise((b,k)=>{try{this.publishEvent(n).then(_=>{this.ndkRelay.emit("published",n),n.emit("relay:published",this.ndkRelay),b(!0)}).catch(k)}catch(_){k(_)}}),o=new Promise((b,k)=>{r=setTimeout(()=>{r=void 0,k(new Error(`Timeout: ${t}ms`))},t)}),a=()=>{s().then(b=>c(b)).catch(b=>f(b))};let c,f;const g=b=>{throw this.ndkRelay.debug("Publish failed",b,n.id),this.ndkRelay.emit("publish:failed",n,b),n.emit("relay:publish:failed",this.ndkRelay,b),b},m=()=>{r&&clearTimeout(r),this.ndkRelay.removeListener("connect",a)};return this.ndkRelay.status>=5?Promise.race([s(),o]).catch(g).finally(m):(this.ndkRelay.status<=1?(console.warn("Relay is disconnected, trying to connect to publish an event",this.ndkRelay.url),this.ndkRelay.connect()):console.warn("Relay not connected, waiting for connection to publish an event",this.ndkRelay.url),Promise.race([new Promise((b,k)=>{c=b,f=k,this.ndkRelay.on("connect",a)}),o]).catch(g).finally(m))}async publishEvent(n){return this.ndkRelay.connectivity.publish(n.rawEvent())}};function filterFingerprint(n,t){const r=[];for(const o of n){const a=Object.entries(o||{}).map(([c,f])=>["since","until"].includes(c)?`${c}:${f}`:c).sort().join("-");r.push(a)}let s=t?"+":"";return s+=r.join("|"),s}function mergeFilters(n){const t=[],r={};return n.filter(s=>!!s.limit).forEach(s=>t.push(s)),n=n.filter(s=>!s.limit),n.length===0?t:(n.forEach(s=>{Object.entries(s).forEach(([o,a])=>{Array.isArray(a)?r[o]===void 0?r[o]=[...a]:r[o]=Array.from(new Set([...r[o],...a])):r[o]=a})}),[...t,r])}var MAX_ITEMS=3;function formatArray(n,t){const s=(t?n.slice(0,MAX_ITEMS).map(t):n.slice(0,MAX_ITEMS)).join(",");return n.length>MAX_ITEMS?`${s}+${n.length-MAX_ITEMS}`:s}function formatFilters(n){return n.map(t=>{const r=[];t.ids?.length&&r.push(`ids:[${formatArray(t.ids,s=>String(s).slice(0,8))}]`),t.kinds?.length&&r.push(`kinds:[${formatArray(t.kinds)}]`),t.authors?.length&&r.push(`authors:[${formatArray(t.authors,s=>String(s).slice(0,8))}]`),t.since&&r.push(`since:${t.since}`),t.until&&r.push(`until:${t.until}`),t.limit&&r.push(`limit:${t.limit}`),t.search&&r.push(`search:"${String(t.search).slice(0,20)}"`);for(const[s,o]of Object.entries(t))s.startsWith("#")&&Array.isArray(o)&&o.length>0&&r.push(`${s}:[${formatArray(o,a=>String(a).slice(0,8))}]`);return`{${r.join(" ")}}`}).join(", ")}var NDKRelaySubscription=class{fingerprint;items=new Map;topSubManager;debug;status=0;onClose;relay;eosed=!1;executionTimer;fireTime;delayType;executeFilters;id=Math.random().toString(36).substring(7);constructor(n,t,r){this.relay=n,this.topSubManager=r,this.debug=n.debug.extend(`sub[${this.id}]`),this.fingerprint=t||Math.random().toString(36).substring(7)}_subId;get subId(){return this._subId?this._subId:(this._subId=this.fingerprint.slice(0,15),this._subId)}subIdParts=new Set;addSubIdPart(n){this.subIdParts.add(n)}addItem(n,t){if(!this.items.has(n.internalId))switch(n.on("close",this.removeItem.bind(this,n)),this.items.set(n.internalId,{subscription:n,filters:t}),this.status!==3&&n.subId&&(!this._subId||this._subId.length<25)&&(this.status===0||this.status===1)&&this.addSubIdPart(n.subId),this.status){case 0:this.evaluateExecutionPlan(n);break;case 3:break;case 1:this.evaluateExecutionPlan(n);break;case 4:throw this.debug("Subscription is closed, cannot add new items",{filters:formatFilters(t),subId:n.subId,internalId:n.internalId}),new Error("Cannot add new items to a closed subscription")}}removeItem(n){if(this.items.delete(n.internalId),this.items.size===0){if(this.status===0||this.status===1){this.status=4,this.cleanup();return}if(!this.eosed)return;this.close(),this.cleanup()}}close(){if(this.status===4)return;const n=this.status;if(this.status=4,n===3)try{this.relay.close(this.subId)}catch(t){this.debug("Error closing subscription",t,this)}else this.debug("Subscription wanted to close but it wasn't running, this is probably ok",{subId:this.subId,prevStatus:n,sub:this});this.cleanup()}cleanup(){this.executionTimer&&clearTimeout(this.executionTimer),this.relay.off("ready",this.executeOnRelayReady),this.relay.off("authed",this.reExecuteAfterAuth),this.onClose&&this.onClose(this)}evaluateExecutionPlan(n){if(!n.isGroupable()){this.status=1,this.execute();return}if(n.filters.find(s=>!!s.limit)&&(this.executeFilters=this.compileFilters(),this.executeFilters.length>=10)){this.status=1,this.execute();return}const t=n.groupableDelay,r=n.groupableDelayType;if(!t)throw new Error("Cannot group a subscription without a delay");if(this.status===0)this.schedule(t,r);else{const s=this.delayType,o=this.fireTime-Date.now();if(s==="at-least"&&r==="at-least")o<t&&(this.executionTimer&&clearTimeout(this.executionTimer),this.schedule(t,r));else if(s==="at-least"&&r==="at-most")o>t&&(this.executionTimer&&clearTimeout(this.executionTimer),this.schedule(t,r));else if(s==="at-most"&&r==="at-most")o>t&&(this.executionTimer&&clearTimeout(this.executionTimer),this.schedule(t,r));else if(s==="at-most"&&r==="at-least")o>t&&(this.executionTimer&&clearTimeout(this.executionTimer),this.schedule(t,r));else throw new Error(`Unknown delay type combination ${s} ${r}`)}}schedule(n,t){this.status=1;const r=Date.now();this.fireTime=r+n,this.delayType=t;const s=setTimeout(()=>{this.execute()},n);t==="at-least"&&(this.executionTimer=s)}executeOnRelayReady=()=>{if(this.status===2){if(this.items.size===0){this.debug("No items to execute; this relay was probably too slow to respond and the caller gave up",{status:this.status,fingerprint:this.fingerprint,id:this.id,subId:this.subId}),this.cleanup();return}this.debug("Executing on relay ready",{status:this.status,fingerprint:this.fingerprint,itemsSize:this.items.size,filters:formatFilters(this.compileFilters())}),this.status=1,this.execute()}};finalizeSubId(){if(this.subIdParts.size>0){let t=Array.from(this.subIdParts).map(r=>r.substring(0,10)).join("-");t.length>20&&(t=t.substring(0,20)),this._subId=t}else this._subId=this.fingerprint.slice(0,15);this._subId+=`-${Math.random().toString(36).substring(2,7)}`}reExecuteAfterAuth=(()=>{const n=this.subId;this.debug("Re-executing after auth",this.items.size),this.eosed?this.relay.close(this.subId):this.debug("We are abandoning an opened subscription, once it EOSE's, the handler will close it",{oldSubId:n}),this._subId=void 0,this.status=1,this.execute(),this.debug("Re-executed after auth %s  %s",n,this.subId)}).bind(this);execute(){if(this.status===1){if(!this.relay.connected){this.status=2,this.debug("Waiting for relay to be ready",{status:this.status,id:this.subId,fingerprint:this.fingerprint,itemsSize:this.items.size}),this.relay.once("ready",this.executeOnRelayReady);return}this.relay.status<8&&this.relay.once("authed",this.reExecuteAfterAuth),this.status=3,this.finalizeSubId(),this.executeFilters=this.compileFilters(),this.relay.req(this)}}onstart(){}onevent(n){this.topSubManager.dispatchEvent(n,this.relay)}oneose(n){if(this.eosed=!0,n!==this.subId){this.debug("Received EOSE for an abandoned subscription",n,this.subId),this.relay.close(n);return}this.items.size===0&&this.close();for(const{subscription:t}of this.items.values())t.eoseReceived(this.relay),t.closeOnEose&&this.removeItem(t)}onclose(n){this.status=4}onclosed(n){if(n)for(const{subscription:t}of this.items.values())t.closedReceived(this.relay,n)}compileFilters(){const n=[],t=Array.from(this.items.values()).map(s=>s.filters);if(!t[0])return this.debug(" No filters to merge",{itemsSize:this.items.size}),[];const r=t[0].length;for(let s=0;s<r;s++){const o=t.map(c=>c[s]),a=mergeFilters(o);n.push(...a)}return n}},NDKRelaySubscriptionManager=class{relay;subscriptions;generalSubManager;constructor(n,t){this.relay=n,this.subscriptions=new Map,this.generalSubManager=t}addSubscription(n,t){let r;if(!n.isGroupable())r=this.createSubscription(n,t);else{const s=filterFingerprint(t,n.closeOnEose);s&&(r=(this.subscriptions.get(s)||[]).find(a=>a.status<3)),r??=this.createSubscription(n,t,s)}r.addItem(n,t)}createSubscription(n,t,r){const s=new NDKRelaySubscription(this.relay,r||null,this.generalSubManager);s.onClose=this.onRelaySubscriptionClose.bind(this);const o=this.subscriptions.get(s.fingerprint)??[];return this.subscriptions.set(s.fingerprint,[...o,s]),s}onRelaySubscriptionClose(n){let t=this.subscriptions.get(n.fingerprint)??[];t?t.length===1?this.subscriptions.delete(n.fingerprint):(t=t.filter(r=>r.id!==n.id),this.subscriptions.set(n.fingerprint,t)):console.warn("Unexpectedly did not find a subscription with fingerprint",n.fingerprint)}},NDKRelayStatus=(n=>(n[n.DISCONNECTING=0]="DISCONNECTING",n[n.DISCONNECTED=1]="DISCONNECTED",n[n.RECONNECTING=2]="RECONNECTING",n[n.FLAPPING=3]="FLAPPING",n[n.CONNECTING=4]="CONNECTING",n[n.CONNECTED=5]="CONNECTED",n[n.AUTH_REQUESTED=6]="AUTH_REQUESTED",n[n.AUTHENTICATING=7]="AUTHENTICATING",n[n.AUTHENTICATED=8]="AUTHENTICATED",n))(NDKRelayStatus||{}),NDKRelay=class sr extends libExports.EventEmitter{url;scores;connectivity;subs;publisher;authPolicy;protocolHandlers=new Map;_relayInfo;lowestValidationRatio;targetValidationRatio;validationRatioFn;validatedEventCount=0;nonValidatedEventCount=0;trusted=!1;complaining=!1;debug;static defaultValidationRatioUpdateFn=(t,r,s)=>{if(t.lowestValidationRatio===void 0||t.targetValidationRatio===void 0)return 1;let o=t.validationRatio;if(t.validationRatio>t.targetValidationRatio){const a=r/100;o=Math.max(t.lowestValidationRatio,t.validationRatio-a)}return o<t.validationRatio?o:t.validationRatio};constructor(t,r,s){super(),this.url=normalizeRelayUrl(t),this.scores=new Map,this.debug=debug$1(`ndk:relay:${t}`),this.connectivity=new NDKRelayConnectivity(this,s),this.connectivity.netDebug=s?.netDebug,this.req=this.connectivity.req.bind(this.connectivity),this.close=this.connectivity.close.bind(this.connectivity),this.subs=new NDKRelaySubscriptionManager(this,s.subManager),this.publisher=new NDKRelayPublisher(this),this.authPolicy=r,this.targetValidationRatio=s?.initialValidationRatio,this.lowestValidationRatio=s?.lowestValidationRatio,this.validationRatioFn=(s?.validationRatioFn??sr.defaultValidationRatioUpdateFn).bind(this),this.updateValidationRatio(),s||console.trace("relay created without ndk")}updateValidationRatio(){if(this.validationRatioFn&&this.validatedEventCount>0){const t=this.validationRatioFn(this,this.validatedEventCount,this.nonValidatedEventCount);this.targetValidationRatio=t}setTimeout(()=>{this.updateValidationRatio()},3e4)}get status(){return this.connectivity.status}get connectionStats(){return this.connectivity.connectionStats}async connect(t,r=!0){return this.connectivity.connect(t,r)}disconnect(){this.status!==1&&this.connectivity.disconnect()}subscribe(t,r){this.subs.addSubscription(t,r)}async publish(t,r=2500){return this.publisher.publish(t,r)}referenceTags(){return[["r",this.url]]}addValidatedEvent(){this.validatedEventCount++}addNonValidatedEvent(){this.nonValidatedEventCount++}get validationRatio(){return this.nonValidatedEventCount===0?1:this.validatedEventCount/(this.validatedEventCount+this.nonValidatedEventCount)}shouldValidateEvent(){return this.trusted?!1:this.targetValidationRatio===void 0||this.targetValidationRatio>=1?!0:Math.random()<this.targetValidationRatio}get connected(){return this.connectivity.connected}req;close;registerProtocolHandler(t,r){this.protocolHandlers.set(t,r)}unregisterProtocolHandler(t){this.protocolHandlers.delete(t)}getProtocolHandler(t){return this.protocolHandlers.get(t)}async fetchInfo(t=!1){const s=this.connectivity.ndk;if(!t&&s?.cacheAdapter?.getRelayStatus){const o=await s.cacheAdapter.getRelayStatus(this.url);if(o?.nip11&&Date.now()-o.nip11.fetchedAt<864e5)return this._relayInfo=o.nip11.data,o.nip11.data}return!t&&this._relayInfo?this._relayInfo:(this._relayInfo=await fetchRelayInformation(this.url),s?.cacheAdapter?.updateRelayStatus&&await s.cacheAdapter.updateRelayStatus(this.url,{nip11:{data:this._relayInfo,fetchedAt:Date.now()}}),this._relayInfo)}get info(){return this._relayInfo}},NDKPublishError=class extends Error{errors;publishedToRelays;intendedRelaySet;constructor(n,t,r,s){super(n),this.errors=t,this.publishedToRelays=r,this.intendedRelaySet=s}get relayErrors(){const n=[];for(const[t,r]of this.errors)n.push(`${t.url}: ${r}`);return n.join(`
`)}},NDKRelaySet=class ir{relays;debug;ndk;pool;constructor(t,r,s){this.relays=t,this.ndk=r,this.pool=s??r.pool,this.debug=r.debug.extend("relayset")}addRelay(t){this.relays.add(t)}get relayUrls(){return Array.from(this.relays).map(t=>t.url)}static fromRelayUrls(t,r,s=!0,o){if(o=o??r.pool,!o)throw new Error("No pool provided");const a=new Set;for(const c of t){const f=o.relays.get(normalizeRelayUrl(c));if(f)f.status<5&&s&&f.connect(),a.add(f);else{const g=new NDKRelay(normalizeRelayUrl(c),r?.relayAuthDefaultPolicy,r);o.useTemporaryRelay(g,void 0,`requested from fromRelayUrls ${t}`),a.add(g)}}return new ir(new Set(a),r,o)}async publish(t,r,s=1){const o=new Set,a=new Map,c=t.isEphemeral();t.publishStatus="pending";const f=g=>{o.add(g)};t.on("relay:published",f);try{const g=Array.from(this.relays).map(m=>new Promise(b=>{const k=r?setTimeout(()=>{o.has(m)||(a.set(m,new Error(`Publish timeout after ${r}ms`)),b(!1))},r):null;m.publish(t,r).then(_=>{k&&clearTimeout(k),_?(o.add(m),b(!0)):b(!1)}).catch(_=>{k&&clearTimeout(k),c||a.set(m,_),b(!1)})}));if(await Promise.all(g),o.size<s){if(!c){const m=new NDKPublishError("Not enough relays received the event ("+o.size+" published, "+s+" required)",a,o,this);throw t.publishStatus="error",t.publishError=m,this.ndk?.emit("event:publish-failed",t,m,this.relayUrls),m}}else t.publishStatus="success",t.emit("published",{relaySet:this,publishedToRelays:o});return o}finally{t.off("relay:published",f)}}get size(){return this.relays.size}},d$4=debug$1("ndk:outbox:calculate");async function calculateRelaySetFromEvent(n,t,r){const s=new Set,o=await getWriteRelaysFor(n,t.pubkey);o&&o.forEach(f=>{const g=n.pool?.getRelay(f);g&&s.add(g)});let a=t.tags.filter(f=>["a","e"].includes(f[0])).map(f=>f[2]).filter(f=>f?.startsWith("wss://")).filter(f=>{try{return new URL(f),!0}catch{return!1}}).map(f=>normalizeRelayUrl(f));a=Array.from(new Set(a)).slice(0,5),a.forEach(f=>{const g=n.pool?.getRelay(f,!0,!0);g&&(d$4("Adding relay hint %s",f),s.add(g))});const c=t.getMatchingTags("p").map(f=>f[1]);return c.length<5?Array.from(chooseRelayCombinationForPubkeys(n,c,"read",{preferredRelays:new Set(o)}).keys()).forEach(g=>{const m=n.pool?.getRelay(g,!1,!0);m&&(d$4("Adding p-tagged relay %s",g),s.add(m))}):d$4("Too many p-tags to consider %d",c.length),n.pool?.permanentAndConnectedRelays().forEach(f=>s.add(f)),r&&s.size<r&&n.explicitRelayUrls?.filter(g=>!Array.from(s).some(m=>m.url===g)).slice(0,r-s.size)?.forEach(g=>{const m=n.pool?.getRelay(g,!1,!0);m&&(d$4("Adding explicit relay %s",g),s.add(m))}),new NDKRelaySet(s,n)}function calculateRelaySetsFromFilter(n,t,r,s){const o=new Map,a=new Set;if(t.forEach(c=>{c.authors&&c.authors.forEach(f=>a.add(f))}),a.size>0){const c=getRelaysForFilterWithAuthors(n,Array.from(a),s);for(const f of c.keys())o.set(f,[]);for(const f of t)if(f.authors)for(const[g,m]of c.entries()){const b=f.authors.filter(k=>m.includes(k));o.set(g,[...o.get(g),{...f,authors:b}])}else for(const g of c.keys())o.set(g,[...o.get(g),f])}else n.explicitRelayUrls&&n.explicitRelayUrls.forEach(c=>{o.set(c,t)});return o.size===0&&r.permanentAndConnectedRelays().slice(0,5).forEach(c=>{o.set(c.url,t)}),o}function calculateRelaySetsFromFilters(n,t,r,s){return calculateRelaySetsFromFilter(n,t,r,s)}function isValidHex64(n){if(typeof n!="string"||n.length!==64)return!1;for(let t=0;t<64;t++){const r=n.charCodeAt(t);if(!(r>=48&&r<=57||r>=97&&r<=102||r>=65&&r<=70))return!1}return!0}function isValidPubkey(n){return isValidHex64(n)}function isValidNip05(n){if(typeof n!="string")return!1;for(let t=0;t<n.length;t++)if(n.charCodeAt(t)===46)return!0;return!1}function mergeTags(n,t){const r=new Map,s=c=>c.join(","),o=(c,f)=>c.every((g,m)=>g===f[m]),a=c=>{for(const[f,g]of r)if(o(g,c)||o(c,g)){c.length>=g.length&&r.set(f,c);return}r.set(s(c),c)};return n.concat(t).forEach(a),Array.from(r.values())}var hashtagRegex=new RegExp(`(?<=\\s|^)(#[^\\s!@#$%^&*()=+./,[{\\]};:'"?><]+)`,"g");function generateHashtags(n){const t=n.match(hashtagRegex),r=new Set,s=new Set;if(t)for(const o of t)r.has(o.slice(1))||(s.add(o.slice(1)),r.add(o.slice(1)));return Array.from(s)}async function generateContentTags(n,t=[],r,s){if(r?.skipContentTagging)return{content:n,tags:t};const o=/(@|nostr:)(npub|nprofile|note|nevent|naddr)[a-zA-Z0-9]+/g,a=[],c=f=>{t.find(g=>["q",f[0]].includes(g[0])&&g[1]===f[1])||t.push(f)};if(n=n.replace(o,f=>{try{const g=f.split(/(@|nostr:)/)[2],{type:m,data:b}=nip19_exports$1.decode(g);let k;if(r?.filters){const _=!r.filters.includeTypes||r.filters.includeTypes.includes(m),A=r.filters.excludeTypes?.includes(m);if(!_||A)return f}switch(m){case"npub":r?.pTags!==!1&&(k=["p",b]);break;case"nprofile":r?.pTags!==!1&&(k=["p",b.pubkey]);break;case"note":a.push(new Promise(async _=>{const A=await maybeGetEventRelayUrl(g);c(["q",b,A]),_()}));break;case"nevent":a.push(new Promise(async _=>{const{id:A,author:B}=b;let{relays:L}=b;(!L||L.length===0)&&(L=[await maybeGetEventRelayUrl(g)]),c(["q",A,L[0]]),B&&r?.pTags!==!1&&r?.pTagOnQTags!==!1&&c(["p",B]),_()}));break;case"naddr":a.push(new Promise(async _=>{const A=[b.kind,b.pubkey,b.identifier].join(":");let B=b.relays??[];B.length===0&&(B=[await maybeGetEventRelayUrl(g)]),c(["q",A,B[0]]),r?.pTags!==!1&&r?.pTagOnQTags!==!1&&r?.pTagOnATags!==!1&&c(["p",b.pubkey]),_()}));break;default:return f}return k&&c(k),`nostr:${g}`}catch{return f}}),await Promise.all(a),!r?.filters?.excludeTypes?.includes("hashtag")){const f=generateHashtags(n).map(g=>["t",g]);t=mergeTags(t,f)}if(r?.pTags!==!1&&r?.copyPTagsFromTarget&&s){const f=s.getMatchingTags("p");for(const g of f)!g[1]||!isValidPubkey(g[1])||t.find(m=>m[0]==="p"&&m[1]===g[1])||t.push(g)}return{content:n,tags:t}}async function maybeGetEventRelayUrl(n){return""}async function encrypt(n,t,r="nip44"){let s;if(!this.ndk)throw new Error("No NDK instance found!");let o=t;if(o||(this.ndk.assertSigner(),o=this.ndk.signer),!o)throw new Error("no NDK signer");const a=n||(()=>{const c=this.getMatchingTags("p");if(c.length!==1)throw new Error("No recipient could be determined and no explicit recipient was provided");return this.ndk.getUser({pubkey:c[0][1]})})();if(r==="nip44"&&await isEncryptionEnabled(o,"nip44")&&(s=await o.encrypt(a,this.content,"nip44")),(!s||r==="nip04")&&await isEncryptionEnabled(o,"nip04")&&(s=await o.encrypt(a,this.content,"nip04")),!s)throw new Error("Failed to encrypt event.");this.content=s}async function decrypt(n,t,r){if(this.ndk?.cacheAdapter?.getDecryptedEvent){const f=await this.ndk.cacheAdapter.getDecryptedEvent(this.id);if(f){this.content=f.content;return}}let s;if(!this.ndk)throw new Error("No NDK instance found!");let o=t;if(o||(this.ndk.assertSigner(),o=this.ndk.signer),!o)throw new Error("no NDK signer");const a=n||this.author;if(!a)throw new Error("No sender provided and no author available");const c=r||(this.content.match(/\\?iv=/)?"nip04":"nip44");if((c==="nip04"||this.kind===4)&&await isEncryptionEnabled(o,"nip04")&&this.content.search("\\?iv=")&&(s=await o.decrypt(a,this.content,"nip04")),!s&&c==="nip44"&&await isEncryptionEnabled(o,"nip44")&&(s=await o.decrypt(a,this.content,"nip44")),!s)throw new Error("Failed to decrypt event.");this.content=s,this.ndk?.cacheAdapter?.addDecryptedEvent&&this.ndk.cacheAdapter.addDecryptedEvent(this.id,this)}async function isEncryptionEnabled(n,t){return n.encryptionEnabled?t?!!await n.encryptionEnabled(t):!0:!1}function eventHasETagMarkers(n){for(const t of n.tags)if(t[0]==="e"&&(t[3]??"").length>0)return!0;return!1}function getRootTag(n,t){t??=n.tagType();const r=n.tags.find(isTagRootTag);if(!r){if(eventHasETagMarkers(n))return;const s=n.getMatchingTags(t);if(s.length<3)return s[0]}return r}var nip22RootTags=new Set(["A","E","I"]),nip22ReplyTags=new Set(["a","e","i"]);function getReplyTag(n,t){if(n.kind===1111){let o;for(const a of n.tags)if(nip22RootTags.has(a[0]))o=a;else if(nip22ReplyTags.has(a[0])){o=a;break}return o}t??=n.tagType();let r=!1,s;for(const o of n.tags)if(o[0]===t){if((o[3]??"").length>0&&(r=!0),r&&o[3]==="reply")return o;r&&o[3]==="root"&&(s=o),r||(s=o)}return s}function isTagRootTag(n){return n[0]==="E"||n[3]==="root"}async function fetchTaggedEvent(n,t){if(!this.ndk)throw new Error("NDK instance not found");const r=this.getMatchingTags(n,t);if(r.length===0)return;const[s,o,a]=r[0],c=a!==""?this.ndk.pool.getRelay(a):void 0;return await this.ndk.fetchEvent(o,{},c)}async function fetchRootEvent(n){if(!this.ndk)throw new Error("NDK instance not found");const t=getRootTag(this);if(t)return this.ndk.fetchEventFromTag(t,this,n)}async function fetchReplyEvent(n){if(!this.ndk)throw new Error("NDK instance not found");const t=getReplyTag(this);if(t)return this.ndk.fetchEventFromTag(t,this,n)}function isReplaceable(){if(this.kind===void 0)throw new Error("Kind not set");return[0,3].includes(this.kind)||this.kind>=1e4&&this.kind<2e4||this.kind>=3e4&&this.kind<4e4}function isEphemeral(){if(this.kind===void 0)throw new Error("Kind not set");return this.kind>=2e4&&this.kind<3e4}function isParamReplaceable(){if(this.kind===void 0)throw new Error("Kind not set");return this.kind>=3e4&&this.kind<4e4}var DEFAULT_RELAY_COUNT=2;function encode(n=DEFAULT_RELAY_COUNT){let t=[];return this.onRelays.length>0?t=this.onRelays.map(r=>r.url):this.relay&&(t=[this.relay.url]),t.length>n&&(t=t.slice(0,n)),this.isParamReplaceable()?nip19_exports$1.naddrEncode({kind:this.kind,pubkey:this.pubkey,identifier:this.replaceableDTag(),relays:t}):t.length>0?nip19_exports$1.neventEncode({id:this.tagId(),relays:t,author:this.pubkey}):nip19_exports$1.noteEncode(this.tagId())}async function repost(n=!0,t){if(!t&&n){if(!this.ndk)throw new Error("No NDK instance found");this.ndk.assertSigner(),t=this.ndk.signer}const r=new NDKEvent(this.ndk,{kind:getKind(this)});return this.isProtected||(r.content=JSON.stringify(this.rawEvent())),r.tag(this),this.kind!==1&&r.tags.push(["k",`${this.kind}`]),t&&await r.sign(t),n&&await r.publish(),r}function getKind(n){return n.kind===1?6:16}function getEventDetails(n){return"inspect"in n&&typeof n.inspect=="string"?n.inspect:JSON.stringify(n)}function validateForSerialization(n){if(typeof n.kind!="number")throw new Error(`Can't serialize event with invalid properties: kind (must be number, got ${typeof n.kind}). Event: ${getEventDetails(n)}`);if(typeof n.content!="string")throw new Error(`Can't serialize event with invalid properties: content (must be string, got ${typeof n.content}). Event: ${getEventDetails(n)}`);if(typeof n.created_at!="number")throw new Error(`Can't serialize event with invalid properties: created_at (must be number, got ${typeof n.created_at}). Event: ${getEventDetails(n)}`);if(typeof n.pubkey!="string")throw new Error(`Can't serialize event with invalid properties: pubkey (must be string, got ${typeof n.pubkey}). Event: ${getEventDetails(n)}`);if(!Array.isArray(n.tags))throw new Error(`Can't serialize event with invalid properties: tags (must be array, got ${typeof n.tags}). Event: ${getEventDetails(n)}`);for(let t=0;t<n.tags.length;t++){const r=n.tags[t];if(!Array.isArray(r))throw new Error(`Can't serialize event with invalid properties: tags[${t}] (must be array, got ${typeof r}). Event: ${getEventDetails(n)}`);for(let s=0;s<r.length;s++)if(typeof r[s]!="string")throw new Error(`Can't serialize event with invalid properties: tags[${t}][${s}] (must be string, got ${typeof r[s]}). Event: ${getEventDetails(n)}`)}}function serialize(n=!1,t=!1){validateForSerialization(this);const r=[0,this.pubkey,this.created_at,this.kind,this.tags,this.content];return n&&r.push(this.sig),t&&r.push(this.id),JSON.stringify(r)}function deserialize(n){const t=JSON.parse(n),r={pubkey:t[1],created_at:t[2],kind:t[3],tags:t[4],content:t[5]};if(t.length>=7){const s=t[6],o=t[7];s&&s.length===128?(r.sig=s,o&&o.length===64&&(r.id=o)):s&&s.length===64&&(r.id=s,o&&o.length===128&&(r.sig=o))}return r}var worker,processingQueue={};function signatureVerificationInit(n){worker=n,worker.onmessage=t=>{if(!Array.isArray(t.data)||t.data.length!==2){console.error("[NDK]  Signature verification worker received incompatible message format.",`

 Expected format: [eventId, boolean]`,`
 Received:`,t.data,`

 This likely means:`,`
  1. You have a STALE worker.js file that needs updating`,`
  2. Version mismatch between @nostr-dev-kit/ndk and deployed worker`,`
  3. Wrong worker is being used for signature verification`,`

 Solution: Update your worker files:`,`
  cp node_modules/@nostr-dev-kit/ndk/dist/workers/sig-verification.js public/`,`
  cp node_modules/@nostr-dev-kit/cache-sqlite-wasm/dist/worker.js public/`,`

 Or use Vite/bundler imports instead of static files:`,`
  import SigWorker from "@nostr-dev-kit/ndk/workers/sig-verification?worker"`);return}const[r,s]=t.data,o=processingQueue[r];if(!o){console.error("No record found for event",r);return}delete processingQueue[r];for(const a of o.resolves)a(s)}}async function verifySignatureAsync(n,t,r){const s=n.ndk,o=Date.now();let a;return s.signatureVerificationFunction?a=await s.signatureVerificationFunction(n):a=await new Promise(c=>{const f=n.serialize();let g=!1;processingQueue[n.id]||(processingQueue[n.id]={event:n,resolves:[],relay:r},g=!0),processingQueue[n.id].resolves.push(c),g&&worker?.postMessage({serialized:f,id:n.id,sig:n.sig,pubkey:n.pubkey})}),s.signatureVerificationTimeMs+=Date.now()-o,a}var PUBKEY_REGEX=/^[a-f0-9]{64}$/;function validate(){if(typeof this.kind!="number"||typeof this.content!="string"||typeof this.created_at!="number"||typeof this.pubkey!="string"||!this.pubkey.match(PUBKEY_REGEX)||!Array.isArray(this.tags))return!1;for(let n=0;n<this.tags.length;n++){const t=this.tags[n];if(!Array.isArray(t))return!1;for(let r=0;r<t.length;r++)if(typeof t[r]=="object")return!1}return!0}var verifiedSignatures=new distExports.LRUCache({maxSize:1e3,entryExpirationTimeInMS:6e4});function verifySignature(n){if(typeof this.signatureVerified=="boolean")return this.signatureVerified;const t=verifiedSignatures.get(this.id);if(t!==null)return this.signatureVerified=!!t,this.signatureVerified;try{if(this.ndk?.asyncSigVerification){const r=this.relay;verifySignatureAsync(this,n,r).then(s=>{n&&(this.signatureVerified=s,s&&verifiedSignatures.set(this.id,this.sig)),s?r&&r.addValidatedEvent():(r?this.ndk?.reportInvalidSignature(this,r):this.ndk?.reportInvalidSignature(this),verifiedSignatures.set(this.id,!1))}).catch(s=>{console.error("signature verification error",this.id,s)})}else{const r=sha256(new TextEncoder().encode(this.serialize())),s=schnorr.verify(this.sig,r,this.pubkey);return s?verifiedSignatures.set(this.id,this.sig):verifiedSignatures.set(this.id,!1),this.signatureVerified=s,s}}catch{return this.signatureVerified=!1,!1}}function getEventHash(){return getEventHashFromSerializedEvent(this.serialize())}function getEventHashFromSerializedEvent(n){const t=sha256(new TextEncoder().encode(n));return bytesToHex$1(t)}var skipClientTagOnKinds=new Set([0,4,1059,13,3,9734,5]),NDKEvent=class ln extends libExports.EventEmitter{ndk;created_at;content="";tags=[];kind;id="";sig;pubkey="";signatureVerified;_author=void 0;relay;get onRelays(){let t=[];return this.ndk?t=this.ndk.subManager.seenEvents.get(this.id)||[]:this.relay&&t.push(this.relay),t}publishStatus="success";publishError;constructor(t,r){super(),this.ndk=t,this.created_at=r?.created_at,this.content=r?.content||"",this.tags=r?.tags||[],this.id=r?.id||"",this.sig=r?.sig,this.pubkey=r?.pubkey||"",this.kind=r?.kind,r instanceof ln&&(this.relay&&(this.relay=r.relay,this.ndk?.subManager.seenEvent(r.id,this.relay)),this.publishStatus=r.publishStatus,this.publishError=r.publishError)}static deserialize(t,r){return new ln(t,deserialize(r))}rawEvent(){return{created_at:this.created_at,content:this.content,tags:this.tags,kind:this.kind,pubkey:this.pubkey,id:this.id,sig:this.sig}}set author(t){this.pubkey=t.pubkey,this._author=t,this._author.ndk??=this.ndk}get author(){if(this._author)return this._author;if(!this.ndk)throw new Error("No NDK instance found");const t=this.ndk.getUser({pubkey:this.pubkey});return this._author=t,t}tagExternal(t,r,s){const o=["i"],a=["k"];switch(r){case"url":{const c=new URL(t);c.hash="",o.push(c.toString()),a.push(`${c.protocol}//${c.host}`);break}case"hashtag":o.push(`#${t.toLowerCase()}`),a.push("#");break;case"geohash":o.push(`geo:${t.toLowerCase()}`),a.push("geo");break;case"isbn":o.push(`isbn:${t.replace(/-/g,"")}`),a.push("isbn");break;case"podcast:guid":o.push(`podcast:guid:${t}`),a.push("podcast:guid");break;case"podcast:item:guid":o.push(`podcast:item:guid:${t}`),a.push("podcast:item:guid");break;case"podcast:publisher:guid":o.push(`podcast:publisher:guid:${t}`),a.push("podcast:publisher:guid");break;case"isan":o.push(`isan:${t.split("-").slice(0,4).join("-")}`),a.push("isan");break;case"doi":o.push(`doi:${t.toLowerCase()}`),a.push("doi");break;default:throw new Error(`Unsupported NIP-73 entity type: ${r}`)}s&&o.push(s),this.tags.push(o),this.tags.push(a)}tag(t,r,s,o,a){let c=[];if(t.fetchProfile!==void 0){if(o??="p",o==="p"&&a?.pTags===!1)return;const g=[o,t.pubkey];r&&g.push("",r),c.push(g)}else if(t instanceof ln){const g=t;if(s??=g?.pubkey===this.pubkey,c=g.referenceTags(r,s,o,a),a?.pTags!==!1)for(const m of g.getMatchingTags("p"))!m[1]||!isValidPubkey(m[1])||m[1]!==this.pubkey&&(this.tags.find(b=>b[0]==="p"&&b[1]===m[1])||this.tags.push(["p",m[1]]))}else if(Array.isArray(t))c=[t];else throw new Error("Invalid argument",t);this.tags=mergeTags(this.tags,c)}async toNostrEvent(t,r){if(!t&&this.pubkey===""){const a=await this.ndk?.signer?.user();this.pubkey=a?.pubkey||""}this.created_at||(this.created_at=Math.floor(Date.now()/1e3));const{content:s,tags:o}=await this.generateTags(r);this.content=s||"",this.tags=o;try{this.id=this.getEventHash()}catch{}return this.rawEvent()}serialize=serialize.bind(this);getEventHash=getEventHash.bind(this);validate=validate.bind(this);verifySignature=verifySignature.bind(this);isReplaceable=isReplaceable.bind(this);isEphemeral=isEphemeral.bind(this);isDvm=()=>this.kind&&this.kind>=5e3&&this.kind<=7e3;isParamReplaceable=isParamReplaceable.bind(this);encode=encode.bind(this);encrypt=encrypt.bind(this);decrypt=decrypt.bind(this);getMatchingTags(t,r){const s=this.tags.filter(o=>o[0]===t);return r===void 0?s:s.filter(o=>o[3]===r)}hasTag(t,r){return this.tags.some(s=>s[0]===t&&(!r||s[3]===r))}tagValue(t,r){const s=this.getMatchingTags(t,r);if(s.length!==0)return s[0][1]}get alt(){return this.tagValue("alt")}set alt(t){this.removeTag("alt"),t&&this.tags.push(["alt",t])}get dTag(){return this.tagValue("d")}set dTag(t){this.removeTag("d"),t&&this.tags.push(["d",t])}removeTag(t,r){const s=Array.isArray(t)?t:[t];this.tags=this.tags.filter(o=>{const a=s.includes(o[0]),c=r?o[3]===r:!0;return!(a&&c)})}replaceTag(t){this.removeTag(t[0]),this.tags.push(t)}async sign(t,r){this.ndk?.aiGuardrails?.event?.signing(this),t?this.author=await t.user():(this.ndk?.assertSigner(),t=this.ndk?.signer);const s=await this.toNostrEvent(void 0,r);return this.sig=await t.sign(s),this.sig}async publishReplaceable(t,r,s){return this.id="",this.created_at=Math.floor(Date.now()/1e3),this.sig="",this.publish(t,r,s)}async publish(t,r,s,o){if(s||(s=1),this.sig||await this.sign(void 0,o),!this.ndk)throw new Error("NDKEvent must be associated with an NDK instance to publish");if(this.ndk.aiGuardrails?.event?.publishing(this),(!t||t.size===0)&&(t=this.ndk.devWriteRelaySet||await calculateRelaySetFromEvent(this.ndk,this,s)),this.kind===5&&this.ndk.cacheAdapter?.deleteEventIds){const f=this.getMatchingTags("e").map(g=>g[1]);this.ndk.cacheAdapter.deleteEventIds(f)}const a=this.rawEvent();if(this.ndk.cacheAdapter?.addUnpublishedEvent&&shouldTrackUnpublishedEvent(this))try{this.ndk.cacheAdapter.addUnpublishedEvent(this,t.relayUrls)}catch(f){console.error("Error adding unpublished event to cache",f)}this.kind===5&&this.ndk.cacheAdapter?.deleteEventIds&&this.ndk.cacheAdapter.deleteEventIds(this.getMatchingTags("e").map(f=>f[1])),this.ndk.subManager.dispatchEvent(a,void 0,!0);const c=await t.publish(this,r,s);return c.forEach(f=>this.ndk?.subManager.seenEvent(this.id,f)),c}async generateTags(t){let r=[];const s=await generateContentTags(this.content,this.tags,t,this),o=s.content;if(r=s.tags,this.kind&&this.isParamReplaceable()&&!this.getMatchingTags("d")[0]){const c=this.tagValue("title");let g=[...Array(c?6:16)].map(()=>Math.random().toString(36)[2]).join("");c&&c.length>0&&(g=`${c.replace(/[^a-z0-9]+/gi,"-").replace(/^-|-$/g,"")}-${g}`),r.push(["d",g])}if(this.shouldAddClientTag){const a=["client",this.ndk?.clientName??""];this.ndk?.clientNip89&&a.push(this.ndk?.clientNip89),r.push(a)}else this.shouldStripClientTag&&(r=r.filter(a=>a[0]!=="client"));return{content:o||"",tags:r}}get shouldAddClientTag(){return!(!this.ndk?.clientName&&!this.ndk?.clientNip89||skipClientTagOnKinds.has(this.kind)||this.isEphemeral()||this.isReplaceable()&&!this.isParamReplaceable()||this.isDvm()||this.hasTag("client"))}get shouldStripClientTag(){return skipClientTagOnKinds.has(this.kind)}muted(){return this.ndk?.muteFilter&&this.ndk.muteFilter(this)?"muted":null}replaceableDTag(){if(this.kind&&this.kind>=3e4&&this.kind<=4e4){const t=this.getMatchingTags("d")[0];return t?t[1]:""}throw new Error("Event is not a parameterized replaceable event")}deduplicationKey(){return this.kind===0||this.kind===3||this.kind&&this.kind>=1e4&&this.kind<2e4?`${this.kind}:${this.pubkey}`:this.tagId()}tagId(){return this.isParamReplaceable()?this.tagAddress():this.id}tagAddress(){if(this.isParamReplaceable()){const t=this.dTag??"";return`${this.kind}:${this.pubkey}:${t}`}if(this.isReplaceable())return`${this.kind}:${this.pubkey}:`;throw new Error("Event is not a replaceable event")}tagType(){return this.isParamReplaceable()?"a":"e"}tagReference(t){let r;return this.isParamReplaceable()?r=["a",this.tagAddress()]:r=["e",this.tagId()],this.relay?r.push(this.relay.url):r.push(""),r.push(t??""),this.isParamReplaceable()||r.push(this.pubkey),r}referenceTags(t,r,s,o){let a=[];return this.isParamReplaceable()?a=[[s??"a",this.tagAddress()],[s??"e",this.id]]:a=[[s??"e",this.id]],a=a.map(c=>(c[0]==="e"||t?c.push(this.relay?.url??""):this.relay?.url&&c.push(this.relay?.url),c)),a.forEach(c=>{c[0]==="e"?(c.push(t??""),c.push(this.pubkey)):t&&c.push(t)}),a=[...a,...this.getMatchingTags("h")],!r&&o?.pTags!==!1&&a.push(...this.author.referenceTags()),a}filter(){return this.isParamReplaceable()?{"#a":[this.tagId()]}:{"#e":[this.tagId()]}}nip22Filter(){return this.isParamReplaceable()?{"#A":[this.tagId()]}:{"#E":[this.tagId()]}}async delete(t,r=!0){if(!this.ndk)throw new Error("No NDK instance found");this.ndk.assertSigner();const s=new ln(this.ndk,{kind:5,content:t||""});return s.tag(this,void 0,!0),s.tags.push(["k",this.kind?.toString()]),r&&(this.emit("deleted"),await s.publish()),s}set isProtected(t){this.removeTag("-"),t&&this.tags.push(["-"])}get isProtected(){return this.hasTag("-")}fetchTaggedEvent=fetchTaggedEvent.bind(this);fetchRootEvent=fetchRootEvent.bind(this);fetchReplyEvent=fetchReplyEvent.bind(this);repost=repost.bind(this);async react(t,r=!0){if(!this.ndk)throw new Error("No NDK instance found");this.ndk.assertSigner();const s=new ln(this.ndk,{kind:7,content:t});return s.tag(this),this.kind!==1&&s.tags.push(["k",`${this.kind}`]),r&&await s.publish(),s}get isValid(){return this.validate()}get inspect(){return JSON.stringify(this.rawEvent(),null,4)}dump(){console.debug(JSON.stringify(this.rawEvent(),null,4)),console.debug("Event on relays:",this.onRelays.map(t=>t.url).join(", "))}reply(t,r){const s=new ln(this.ndk);if(this.ndk?.aiGuardrails?.event?.creatingReply(s),this.kind===1&&!t)s.kind=1,this.hasTag("e")?s.tags=[...s.tags,...this.getMatchingTags("e"),...this.getMatchingTags("p"),...this.getMatchingTags("a"),...this.referenceTags("reply",!1,void 0,r)]:s.tag(this,"root",!1,void 0,r);else{s.kind=1111;const o=["A","E","I","P"],a=this.tags.filter(c=>o.includes(c[0]));if(a.length>0){const c=this.tagValue("K");s.tags.push(...a),c&&s.tags.push(["K",c]);let f;if(this.isParamReplaceable()){f=["a",this.tagAddress()];const g=this.relay?.url??"";g&&f.push(g)}else{f=["e",this.tagId()];const g=this.relay?.url??"";f.push(g),f.push(this.pubkey)}s.tags.push(f)}else{let c,f;const g=this.relay?.url??"";this.isParamReplaceable()?(c=["a",this.tagAddress(),g],f=["A",this.tagAddress(),g]):(c=["e",this.tagId(),g,this.pubkey],f=["E",this.tagId(),g,this.pubkey]),s.tags.push(c),s.tags.push(f),s.tags.push(["K",this.kind?.toString()]),r?.pTags!==!1&&r?.pTagOnATags!==!1&&s.tags.push(["P",this.pubkey])}s.tags.push(["k",this.kind?.toString()]),r?.pTags!==!1&&(s.tags.push(...this.getMatchingTags("p")),s.tags.push(["p",this.pubkey]))}return s}},untrackedUnpublishedEvents=new Set([24133,13194,23194,23195]);function shouldTrackUnpublishedEvent(n){return!untrackedUnpublishedEvents.has(n.kind)}var NDKPool=class extends libExports.EventEmitter{_relays=new Map;status="idle";autoConnectRelays=new Set;debug;temporaryRelayTimers=new Map;flappingRelays=new Set;backoffTimes=new Map;ndk;disconnectionTimes=new Map;systemEventDetector;constructor(n,t,{debug:r,name:s}={}){super(),this.debug=r??t.debug.extend("pool"),s&&(this._name=s),this.ndk=t,this.relayUrls=n,this.ndk.pools&&this.ndk.pools.push(this)}get relays(){return this._relays}set relayUrls(n){this._relays.clear();for(const t of n){const r=new NDKRelay(t,void 0,this.ndk);r.connectivity.netDebug=this.ndk.netDebug,this.addRelay(r)}}_name="unnamed";get name(){return this._name}set name(n){this._name=n,this.debug=this.debug.extend(n)}useTemporaryRelay(n,t=3e4,r){const s=this.relays.has(n.url);s||(this.addRelay(n),this.debug("Adding temporary relay %s for filters %o",n.url,r));const o=this.temporaryRelayTimers.get(n.url);if(o&&clearTimeout(o),!s||o){const a=setTimeout(()=>{this.ndk.explicitRelayUrls?.includes(n.url)||this.removeRelay(n.url)},t);this.temporaryRelayTimers.set(n.url,a)}}addRelay(n,t=!0){const r=this.relays.has(n.url),s=n.url.includes("/npub1");let o=!0;const a=n.url;if(r)return;if(this.ndk.relayConnectionFilter&&!this.ndk.relayConnectionFilter(a)){this.debug(`Refusing to add relay ${a}: blocked by relayConnectionFilter`);return}if(s){this.debug(`Refusing to add relay ${a}: is a filter relay`);return}if(this.ndk.cacheAdapter?.getRelayStatus){const A=this.ndk.cacheAdapter.getRelayStatus(a),B=A instanceof Promise?void 0:A;if(B?.dontConnectBefore){if(B.dontConnectBefore>Date.now()){const L=B.dontConnectBefore-Date.now();this.debug(`Refusing to add relay ${a}: delayed connect for ${L}ms`),setTimeout(()=>{this.addRelay(n,t)},L);return}o=!1}}const c=A=>this.emit("notice",n,A),f=()=>this.handleRelayConnect(a),g=()=>this.handleRelayReady(n),m=()=>{this.recordDisconnection(n),this.emit("relay:disconnect",n)},b=()=>this.handleFlapping(n),k=A=>this.emit("relay:auth",n,A),_=()=>this.emit("relay:authed",n);n.off("notice",c),n.off("connect",f),n.off("ready",g),n.off("disconnect",m),n.off("flapping",b),n.off("auth",k),n.off("authed",_),n.on("notice",c),n.on("connect",f),n.on("ready",g),n.on("disconnect",m),n.on("flapping",b),n.on("auth",k),n.on("authed",_),n.on("delayed-connect",A=>{this.ndk.cacheAdapter?.updateRelayStatus&&this.ndk.cacheAdapter.updateRelayStatus(n.url,{dontConnectBefore:Date.now()+A})}),this._relays.set(a,n),t&&this.autoConnectRelays.add(a),t&&this.status==="active"&&(this.emit("relay:connecting",n),n.connect(void 0,o).catch(A=>{this.debug(`Failed to connect to relay ${a}`,A)}))}removeRelay(n){const t=this.relays.get(n);if(t)return t.disconnect(),this.relays.delete(n),this.autoConnectRelays.delete(n),this.emit("relay:disconnect",t),!0;const r=this.temporaryRelayTimers.get(n);return r&&(clearTimeout(r),this.temporaryRelayTimers.delete(n)),!1}isRelayConnected(n){const t=normalizeRelayUrl(n),r=this.relays.get(t);return r?r.status===5:!1}getRelay(n,t=!0,r=!1,s){let o=this.relays.get(normalizeRelayUrl(n));return o||(o=new NDKRelay(n,void 0,this.ndk),o.connectivity.netDebug=this.ndk.netDebug,r?this.useTemporaryRelay(o,3e4,s):this.addRelay(o,t)),o}handleRelayConnect(n){const t=this.relays.get(n);if(!t){console.error("NDK BUG: relay not found in pool",{relayUrl:n});return}this.emit("relay:connect",t),this.stats().connected===this.relays.size&&this.emit("connect")}handleRelayReady(n){this.emit("relay:ready",n)}async connect(n){this.status="active",this.debug(`Connecting to ${this.relays.size} relays${n?`, timeout ${n}ms`:""}...`);const t=Array.from(this.autoConnectRelays.keys()).map(a=>this.relays.get(a)).filter(a=>!!a);for(const a of t)a.status!==5&&a.status!==4&&(this.emit("relay:connecting",a),a.connect().catch(c=>{this.debug(`Failed to connect to relay ${a.url}: ${c??"No reason specified"}`)}));const r=()=>t.every(a=>a.status===5),s=new Promise(a=>{if(r()){a();return}const c=[];for(const f of t){const g=()=>{if(r()){for(let m=0;m<t.length;m++)t[m].off("connect",c[m]);a()}};c.push(g),f.on("connect",g)}}),o=typeof n=="number"?new Promise(a=>setTimeout(a,n)):new Promise(()=>{});await Promise.race([s,o])}checkOnFlappingRelays(){const n=this.flappingRelays.size,t=this.relays.size;if(n/t>=.8)for(const r of this.flappingRelays)this.backoffTimes.set(r,0)}recordDisconnection(n){const t=Date.now();this.disconnectionTimes.set(n.url,t);for(const[r,s]of this.disconnectionTimes.entries())t-s>1e4&&this.disconnectionTimes.delete(r);this.checkForSystemWideDisconnection()}checkForSystemWideDisconnection(){const n=Date.now(),t=[];for(const r of this.disconnectionTimes.values())n-r<5e3&&t.push(r);t.length>this.relays.size/2&&this.relays.size>1&&(this.debug(`System-wide disconnection detected: ${t.length}/${this.relays.size} relays disconnected`),this.handleSystemWideReconnection())}handleSystemWideReconnection(){if(this.systemEventDetector){this.debug("System-wide reconnection already in progress, skipping");return}this.debug("Initiating system-wide reconnection with reset backoff"),this.systemEventDetector=setTimeout(()=>{this.systemEventDetector=void 0},1e4);for(const n of this.relays.values())n.connectivity&&(n.connectivity.resetReconnectionState(),n.status!==5&&n.status!==4&&n.connect().catch(t=>{this.debug(`Failed to reconnect relay ${n.url} after system event: ${t}`)}));this.disconnectionTimes.clear()}handleFlapping(n){this.debug(`Relay ${n.url} is flapping`);let t=this.backoffTimes.get(n.url)||5e3;t=t*2,this.backoffTimes.set(n.url,t),this.debug(`Backoff time for ${n.url} is ${t}ms`),setTimeout(()=>{this.debug(`Attempting to reconnect to ${n.url}`),this.emit("relay:connecting",n),n.connect(),this.checkOnFlappingRelays()},t),n.disconnect(),this.emit("flapping",n)}size(){return this.relays.size}stats(){const n={total:0,connected:0,disconnected:0,connecting:0};for(const t of this.relays.values())n.total++,t.status===5?n.connected++:t.status===1?n.disconnected++:t.status===4&&n.connecting++;return n}connectedRelays(){return Array.from(this.relays.values()).filter(n=>n.status>=5)}permanentAndConnectedRelays(){return Array.from(this.relays.values()).filter(n=>n.status>=5&&!this.temporaryRelayTimers.has(n.url))}urls(){return Array.from(this.relays.keys())}},NDKDVMJobFeedback=class or extends NDKEvent{static kind=7e3;static kinds=[7e3];constructor(t,r){super(t,r),this.kind??=7e3}static async from(t){const r=new or(t.ndk,t.rawEvent());return r.encrypted&&await r.dvmDecrypt(),r}get status(){return this.tagValue("status")}set status(t){this.removeTag("status"),t!==void 0&&this.tags.push(["status",t])}get encrypted(){return!!this.getMatchingTags("encrypted")[0]}async dvmDecrypt(){await this.decrypt();const t=JSON.parse(this.content);this.tags.push(...t)}},NDKCashuMintList=class ar extends NDKEvent{static kind=10019;static kinds=[10019];_p2pk;constructor(t,r){super(t,r),this.kind??=10019}static from(t){return new ar(t.ndk,t)}set relays(t){this.tags=this.tags.filter(r=>r[0]!=="relay");for(const r of t)this.tags.push(["relay",r])}get relays(){const t=[];for(const r of this.tags)r[0]==="relay"&&t.push(r[1]);return t}set mints(t){this.tags=this.tags.filter(r=>r[0]!=="mint");for(const r of t)this.tags.push(["mint",r])}get mints(){const t=[];for(const r of this.tags)r[0]==="mint"&&t.push(r[1]);return Array.from(new Set(t))}get p2pk(){return this._p2pk?this._p2pk:(this._p2pk=this.tagValue("pubkey")??this.pubkey,this._p2pk)}set p2pk(t){this._p2pk=t,this.removeTag("pubkey"),t&&this.tags.push(["pubkey",t])}get relaySet(){return NDKRelaySet.fromRelayUrls(this.relays,this.ndk)}},NDKArticle=class cr extends NDKEvent{static kind=30023;static kinds=[30023];constructor(t,r){super(t,r),this.kind??=30023}static from(t){return new cr(t.ndk,t)}get title(){return this.tagValue("title")}set title(t){this.removeTag("title"),t&&this.tags.push(["title",t])}get image(){return this.tagValue("image")}set image(t){this.removeTag("image"),t&&this.tags.push(["image",t])}get summary(){return this.tagValue("summary")}set summary(t){this.removeTag("summary"),t&&this.tags.push(["summary",t])}get published_at(){const t=this.tagValue("published_at");if(t){let r=Number.parseInt(t);return r>1e12&&(r=Math.floor(r/1e3)),r}}set published_at(t){this.removeTag("published_at"),t!==void 0&&this.tags.push(["published_at",t.toString()])}async generateTags(){return super.generateTags(),this.published_at||(this.published_at=this.created_at),super.generateTags()}get url(){return this.tagValue("url")}set url(t){t?this.tags.push(["url",t]):this.removeTag("url")}},NDKBlossomList=class lr extends NDKEvent{static kind=10063;static kinds=[10063];constructor(t,r){super(t,r),this.kind??=10063}static from(t){return new lr(t.ndk,t.rawEvent())}get servers(){return this.tags.filter(t=>t[0]==="server").map(t=>t[1])}set servers(t){this.tags=this.tags.filter(r=>r[0]!=="server");for(const r of t)this.tags.push(["server",r])}get default(){const t=this.servers;return t.length>0?t[0]:void 0}set default(t){if(!t)return;const s=this.servers.filter(o=>o!==t);this.servers=[t,...s]}addServer(t){if(!t)return;const r=this.servers;r.includes(t)||(this.servers=[...r,t])}removeServer(t){if(!t)return;const r=this.servers;this.servers=r.filter(s=>s!==t)}},NDKFedimintMint=class ur extends NDKEvent{static kind=38173;static kinds=[38173];constructor(t,r){super(t,r),this.kind??=38173}static async from(t){return new ur(t.ndk,t)}get identifier(){return this.tagValue("d")}set identifier(t){this.removeTag("d"),t&&this.tags.push(["d",t])}get inviteCodes(){return this.getMatchingTags("u").map(t=>t[1])}set inviteCodes(t){this.removeTag("u");for(const r of t)this.tags.push(["u",r])}get modules(){return this.getMatchingTags("modules").map(t=>t[1])}set modules(t){this.removeTag("modules");for(const r of t)this.tags.push(["modules",r])}get network(){return this.tagValue("n")}set network(t){this.removeTag("n"),t&&this.tags.push(["n",t])}get metadata(){if(this.content)try{return JSON.parse(this.content)}catch{return}}set metadata(t){t?this.content=JSON.stringify(t):this.content=""}},NDKCashuMintAnnouncement=class hr extends NDKEvent{static kind=38172;static kinds=[38172];constructor(t,r){super(t,r),this.kind??=38172}static async from(t){return new hr(t.ndk,t)}get identifier(){return this.tagValue("d")}set identifier(t){this.removeTag("d"),t&&this.tags.push(["d",t])}get url(){return this.tagValue("u")}set url(t){this.removeTag("u"),t&&this.tags.push(["u",t])}get nuts(){return this.getMatchingTags("nuts").map(t=>t[1])}set nuts(t){this.removeTag("nuts");for(const r of t)this.tags.push(["nuts",r])}get network(){return this.tagValue("n")}set network(t){this.removeTag("n"),t&&this.tags.push(["n",t])}get metadata(){if(this.content)try{return JSON.parse(this.content)}catch{return}}set metadata(t){t?this.content=JSON.stringify(t):this.content=""}},NDKMintRecommendation=class dr extends NDKEvent{static kind=38e3;static kinds=[38e3];constructor(t,r){super(t,r),this.kind??=38e3}static async from(t){return new dr(t.ndk,t)}get recommendedKind(){const t=this.tagValue("k");return t?Number(t):void 0}set recommendedKind(t){this.removeTag("k"),t&&this.tags.push(["k",t.toString()])}get identifier(){return this.tagValue("d")}set identifier(t){this.removeTag("d"),t&&this.tags.push(["d",t])}get urls(){return this.getMatchingTags("u").map(t=>t[1])}set urls(t){this.removeTag("u");for(const r of t)this.tags.push(["u",r])}get mintEventPointers(){return this.getMatchingTags("a").map(t=>({kind:Number(t[1].split(":")[0]),identifier:t[1].split(":")[2],relay:t[2]}))}addMintEventPointer(t,r,s,o){const a=["a",`${t}:${r}:${s}`];o&&a.push(o),this.tags.push(a)}get review(){return this.content}set review(t){this.content=t}},NDKClassified=class gr extends NDKEvent{static kind=30402;static kinds=[30402];constructor(t,r){super(t,r),this.kind??=30402}static from(t){return new gr(t.ndk,t)}get title(){return this.tagValue("title")}set title(t){this.removeTag("title"),t&&this.tags.push(["title",t])}get summary(){return this.tagValue("summary")}set summary(t){this.removeTag("summary"),t&&this.tags.push(["summary",t])}get published_at(){const t=this.tagValue("published_at");if(t)return Number.parseInt(t)}set published_at(t){this.removeTag("published_at"),t!==void 0&&this.tags.push(["published_at",t.toString()])}get location(){return this.tagValue("location")}set location(t){this.removeTag("location"),t&&this.tags.push(["location",t])}get price(){const t=this.tags.find(r=>r[0]==="price");if(t)return{amount:Number.parseFloat(t[1]),currency:t[2],frequency:t[3]}}set price(t){if(typeof t=="string"&&(t={amount:Number.parseFloat(t)}),t?.amount){const r=["price",t.amount.toString()];t.currency&&r.push(t.currency),t.frequency&&r.push(t.frequency),this.tags.push(r)}else this.removeTag("price")}async generateTags(){return super.generateTags(),this.published_at||(this.published_at=this.created_at),super.generateTags()}},NDKDraft=class yr extends NDKEvent{_event;static kind=31234;static kinds=[31234,1234];counterparty;constructor(t,r){super(t,r),this.kind??=31234}static from(t){return new yr(t.ndk,t)}set identifier(t){this.removeTag("d"),this.tags.push(["d",t])}get identifier(){return this.dTag}set event(t){t instanceof NDKEvent?this._event=t:this._event=new NDKEvent(void 0,t),this.prepareEvent()}set checkpoint(t){t?(this.tags.push(t.tagReference()),this.kind=1234):(this.removeTag("a"),this.kind=31234)}get isCheckpoint(){return this.kind===1234}get isProposal(){const t=this.tagValue("p");return!!t&&t!==this.pubkey}async getEvent(t){if(this._event)return this._event;if(t??=this.ndk?.signer,!t)throw new Error("No signer available");if(this.content&&this.content.length>0)try{const r=t.pubkey,o=[this.tagValue("p"),this.pubkey].filter(Boolean).find(f=>f!==r);let a;a=new NDKUser({pubkey:o??r}),await this.decrypt(a,t);const c=JSON.parse(this.content);return this._event=await wrapEvent(new NDKEvent(this.ndk,c)),this._event}catch(r){console.error(r);return}else return null}prepareEvent(){if(!this._event)throw new Error("No event has been provided");this.removeTag("k"),this._event.kind&&this.tags.push(["k",this._event.kind.toString()]),this.content=JSON.stringify(this._event.rawEvent())}async save({signer:t,publish:r,relaySet:s}){if(t??=this.ndk?.signer,!t)throw new Error("No signer available");const o=this.counterparty||await t.user();if(await this.encrypt(o,t),this.counterparty){const a=this.counterparty.pubkey;this.removeTag("p"),this.tags.push(["p",a])}if(r!==!1)return this.publishReplaceable(s)}};function mapImetaTag(n){const t={};if(n.length===2){const s=n[1].split(" ");for(let o=0;o<s.length;o+=2){const a=s[o],c=s[o+1];a==="fallback"?(t.fallback||(t.fallback=[]),t.fallback.push(c)):t[a]=c}return t}const r=n.slice(1);for(const s of r){const o=s.split(" "),a=o[0],c=o.slice(1).join(" ");a==="fallback"?(t.fallback||(t.fallback=[]),t.fallback.push(c)):t[a]=c}return t}function imetaTagToTag(n){const t=["imeta"];for(const[r,s]of Object.entries(n))if(Array.isArray(s))for(const o of s)t.push(`${r} ${o}`);else s&&t.push(`${r} ${s}`);return t}var NDKFollowPack=class mr extends NDKEvent{static kind=39089;static kinds=[39089,39092];constructor(t,r){super(t,r),this.kind??=39089}static from(t){return new mr(t.ndk,t)}get title(){return this.tagValue("title")}set title(t){this.removeTag("title"),t&&this.tags.push(["title",t])}get image(){const t=this.tags.find(r=>r[0]==="imeta");if(t){const r=mapImetaTag(t);if(r.url)return r.url}return this.tagValue("image")}set image(t){this.tags=this.tags.filter(r=>r[0]!=="imeta"&&r[0]!=="image"),typeof t=="string"?t!==void 0&&this.tags.push(["image",t]):t&&typeof t=="object"&&(this.tags.push(imetaTagToTag(t)),t.url&&this.tags.push(["image",t.url]))}get pubkeys(){return Array.from(new Set(this.tags.filter(t=>t[0]==="p"&&t[1]&&isValidPubkey(t[1])).map(t=>t[1])))}set pubkeys(t){this.tags=this.tags.filter(r=>r[0]!=="p");for(const r of t)this.tags.push(["p",r])}get description(){return this.tagValue("description")}set description(t){this.removeTag("description"),t&&this.tags.push(["description",t])}},NDKHighlight=class wr extends NDKEvent{_article;static kind=9802;static kinds=[9802];constructor(t,r){super(t,r),this.kind??=9802}static from(t){return new wr(t.ndk,t)}get url(){return this.tagValue("r")}set context(t){t===void 0?this.tags=this.tags.filter(([r,s])=>r!=="context"):(this.tags=this.tags.filter(([r,s])=>r!=="context"),this.tags.push(["context",t]))}get context(){return this.tags.find(([t,r])=>t==="context")?.[1]??void 0}get article(){return this._article}set article(t){this._article=t,typeof t=="string"?this.tags.push(["r",t]):this.tag(t)}getArticleTag(){return this.getMatchingTags("a")[0]||this.getMatchingTags("e")[0]||this.getMatchingTags("r")[0]}async getArticle(){if(this._article!==void 0)return this._article;let t;const r=this.getArticleTag();if(r){switch(r[0]){case"a":{const[s,o,a]=r[1].split(":");t=nip19_exports$1.naddrEncode({kind:Number.parseInt(s),pubkey:o,identifier:a});break}case"e":t=nip19_exports$1.noteEncode(r[1]);break;case"r":this._article=r[1];break}if(t){let s=await this.ndk?.fetchEvent(t);s&&(s.kind===30023&&(s=NDKArticle.from(s)),this._article=s)}return this._article}}},NDKImage=class vr extends NDKEvent{static kind=20;static kinds=[20];_imetas;constructor(t,r){super(t,r),this.kind??=20}static from(t){return new vr(t.ndk,t.rawEvent())}get isValid(){return this.imetas.length>0}get imetas(){return this._imetas?this._imetas:(this._imetas=this.tags.filter(t=>t[0]==="imeta").map(mapImetaTag).filter(t=>!!t.url),this._imetas)}set imetas(t){this._imetas=t,this.tags=this.tags.filter(r=>r[0]!=="imeta"),this.tags.push(...t.map(imetaTagToTag))}},NDKList=class Er extends NDKEvent{_encryptedTags;static kind=30001;static kinds=[30001,10004,10050,10030,10015,10001,10002,10007,10006,10003,10012];encryptedTagsLength;constructor(t,r){super(t,r),this.kind??=30001}static from(t){return new Er(t.ndk,t)}get title(){const t=this.tagValue("title")||this.tagValue("name");return t||(this.kind===3?"Contacts":this.kind===1e4?"Mute":this.kind===10001?"Pinned Notes":this.kind===10002?"Relay Metadata":this.kind===10003?"Bookmarks":this.kind===10004?"Communities":this.kind===10005?"Public Chats":this.kind===10006?"Blocked Relays":this.kind===10007?"Search Relays":this.kind===10050?"Direct Message Receive Relays":this.kind===10012?"Relay Feeds":this.kind===10015?"Interests":this.kind===10030?"Emojis":this.tagValue("d"))}set title(t){this.removeTag(["title","name"]),t&&this.tags.push(["title",t])}get name(){return this.title}set name(t){this.title=t}get description(){return this.tagValue("description")}set description(t){this.removeTag("description"),t&&this.tags.push(["description",t])}get image(){return this.tagValue("image")}set image(t){this.removeTag("image"),t&&this.tags.push(["image",t])}isEncryptedTagsCacheValid(){return!!(this._encryptedTags&&this.encryptedTagsLength===this.content.length)}async encryptedTags(t=!0){if(t&&this.isEncryptedTagsCacheValid())return this._encryptedTags;if(!this.ndk)throw new Error("NDK instance not set");if(!this.ndk.signer)throw new Error("NDK signer not set");const r=await this.ndk.signer.user();try{if(this.content.length>0)try{const s=await this.ndk.signer.decrypt(r,this.content),o=JSON.parse(s);return o?.[0]?(this.encryptedTagsLength=this.content.length,this._encryptedTags=o):(this.encryptedTagsLength=this.content.length,this._encryptedTags=[])}catch{}}catch{}return[]}validateTag(t){return!0}getItems(t){return this.tags.filter(r=>r[0]===t)}get items(){return this.tags.filter(t=>!["d","L","l","title","name","description","published_at","summary","image","thumb","alt","expiration","subject","client"].includes(t[0]))}async addItem(t,r=void 0,s=!1,o="bottom"){if(!this.ndk)throw new Error("NDK instance not set");if(!this.ndk.signer)throw new Error("NDK signer not set");let a;if(t instanceof NDKEvent)a=[t.tagReference(r)];else if(t instanceof NDKUser)a=t.referenceTags();else if(t instanceof NDKRelay)a=t.referenceTags();else if(Array.isArray(t))a=[t];else throw new Error("Invalid object type");if(r&&a[0].push(r),s){const c=await this.ndk.signer.user(),f=await this.encryptedTags();o==="top"?f.unshift(...a):f.push(...a),this._encryptedTags=f,this.encryptedTagsLength=this.content.length,this.content=JSON.stringify(f),await this.encrypt(c)}else o==="top"?this.tags.unshift(...a):this.tags.push(...a);this.created_at=Math.floor(Date.now()/1e3),this.emit("change")}async removeItemByValue(t,r=!0){if(!this.ndk)throw new Error("NDK instance not set");if(!this.ndk.signer)throw new Error("NDK signer not set");const s=this.tags.findIndex(f=>f[1]===t);s>=0&&this.tags.splice(s,1);const o=await this.ndk.signer.user(),a=await this.encryptedTags(),c=a.findIndex(f=>f[1]===t);if(c>=0&&(a.splice(c,1),this._encryptedTags=a,this.encryptedTagsLength=this.content.length,this.content=JSON.stringify(a),await this.encrypt(o)),r)return this.publishReplaceable();this.created_at=Math.floor(Date.now()/1e3),this.emit("change")}async removeItem(t,r){if(!this.ndk)throw new Error("NDK instance not set");if(!this.ndk.signer)throw new Error("NDK signer not set");if(r){const s=await this.ndk.signer.user(),o=await this.encryptedTags();o.splice(t,1),this._encryptedTags=o,this.encryptedTagsLength=this.content.length,this.content=JSON.stringify(o),await this.encrypt(s)}else this.tags.splice(t,1);return this.created_at=Math.floor(Date.now()/1e3),this.emit("change"),this}has(t){return this.items.some(r=>r[1]===t)}filterForItems(){const t=new Set,r=new Map,s=[];for(const o of this.items)if(o[0]==="e"&&o[1])t.add(o[1]);else if(o[0]==="a"&&o[1]){const[a,c,f]=o[1].split(":");if(!a||!c)continue;const g=`${a}:${c}`,m=r.get(g)||[];m.push(f||""),r.set(g,m)}if(t.size>0&&s.push({ids:Array.from(t)}),r.size>0)for(const[o,a]of r.entries()){const[c,f]=o.split(":");s.push({kinds:[Number.parseInt(c)],authors:[f],"#d":a})}return s}},NDKAppHandlerEvent=class _r extends NDKEvent{profile;static kind=31990;static kinds=[31990];constructor(t,r){super(t,r),this.kind??=31990}static from(t){const r=new _r(t.ndk,t.rawEvent());return r.isValid?r:null}get isValid(){const t=new Map,r=o=>[o[0],o[2]].join(":").toLowerCase(),s=["web","android","ios"];for(const o of this.tags)if(s.includes(o[0])){const a=r(o);if(t.has(a)&&t.get(a)!==o[1].toLowerCase())return!1;t.set(a,o[1].toLowerCase())}return!0}async fetchProfile(){if(this.profile===void 0&&this.content.length>0)try{const t=JSON.parse(this.content);if(t?.name)return t;this.profile=null}catch{this.profile=null}return new Promise((t,r)=>{const s=this.author;s.fetchProfile().then(()=>{t(s.profile)}).catch(r)})}},SEVERITY_MAP={NO_PROOFS:"ERROR",INVALID_PROOF_COUNT:"ERROR",MULTIPLE_RECIPIENTS:"ERROR",NO_RECIPIENT:"ERROR",MULTIPLE_MINTS:"ERROR",NO_MINT:"ERROR",MULTIPLE_EVENT_TAGS:"ERROR",MALFORMED_PROOF_SECRET:"ERROR",MISSING_EVENT_TAG_IN_PROOF:"WARNING",MISMATCHED_EVENT_TAG_IN_PROOF:"WARNING",MISSING_SENDER_TAG_IN_PROOF:"WARNING",MISMATCHED_SENDER_TAG_IN_PROOF:"WARNING",NO_EVENT_TAG_IN_EVENT:"WARNING"},ERROR_MESSAGES={NO_PROOFS:"Nutzap must contain at least one proof",INVALID_PROOF_COUNT:"Invalid proof count",MULTIPLE_RECIPIENTS:"Nutzap must have exactly one recipient (p tag)",NO_RECIPIENT:"Nutzap must have a recipient (p tag)",MULTIPLE_MINTS:"Nutzap must specify exactly one mint (u tag)",NO_MINT:"Nutzap must specify a mint (u tag)",MULTIPLE_EVENT_TAGS:"Nutzap must have at most one event tag (e tag)",MALFORMED_PROOF_SECRET:"Proof secret is malformed and cannot be parsed",MISSING_EVENT_TAG_IN_PROOF:"Proof secret missing 'e' tag for replay protection",MISMATCHED_EVENT_TAG_IN_PROOF:"Proof secret 'e' tag does not match event being zapped",MISSING_SENDER_TAG_IN_PROOF:"Proof secret missing 'P' tag for sender verification",MISMATCHED_SENDER_TAG_IN_PROOF:"Proof secret 'P' tag does not match sender pubkey",NO_EVENT_TAG_IN_EVENT:"Nutzap event missing 'e' tag (recommended for replay protection)"};function createValidationIssue(n,t){return{code:n,severity:SEVERITY_MAP[n],message:ERROR_MESSAGES[n],proofIndex:t}}var NDKNutzap=class bn extends NDKEvent{debug;_proofs=[];static kind=9321;static kinds=[bn.kind];constructor(t,r){super(t,r),this.kind??=9321,this.debug=t?.debug.extend("nutzap")??debug$1("ndk:nutzap"),this.alt||(this.alt="This is a nutzap");try{const s=this.getMatchingTags("proof");s.length?this._proofs=s.map(o=>JSON.parse(o[1])):this._proofs=JSON.parse(this.content)}catch{return}}static from(t){const r=new bn(t.ndk,t);if(!(!r._proofs||!r._proofs.length))return r}set comment(t){this.content=t??""}get comment(){const t=this.tagValue("comment");return t||this.content}set proofs(t){this._proofs=t,this.tags=this.tags.filter(r=>r[0]!=="proof");for(const r of t)this.tags.push(["proof",JSON.stringify(r)])}get proofs(){return this._proofs}get rawP2pk(){const t=this.proofs[0];try{const r=JSON.parse(t.secret);let s;if(typeof r=="string"?(s=JSON.parse(r),this.debug("stringified payload",t.secret)):typeof r=="object"&&(s=r),Array.isArray(s)&&s[0]==="P2PK"&&s.length>1&&typeof s[1]=="object"&&s[1]!==null||typeof s=="object"&&s!==null&&typeof s[1]?.data=="string")return s[1].data}catch(r){this.debug("error parsing p2pk pubkey",r,this.proofs[0])}}get p2pk(){const t=this.rawP2pk;if(t)return t.startsWith("02")?t.slice(2):t}get mint(){return this.tagValue("u")}set mint(t){this.replaceTag(["u",t])}get unit(){let t=this.tagValue("unit")??"sat";return t?.startsWith("msat")&&(t="sat"),t}set unit(t){if(this.removeTag("unit"),t?.startsWith("msat"))throw new Error("msat is not allowed, use sat denomination instead");t&&this.tag(["unit",t])}get amount(){return this.proofs.reduce((r,s)=>r+s.amount,0)}sender=this.author;set target(t){this.tags=this.tags.filter(r=>r[0]!=="p"),t instanceof NDKEvent&&this.tags.push(t.tagReference())}set recipientPubkey(t){this.removeTag("p"),this.tag(["p",t])}get recipientPubkey(){return this.tagValue("p")}get recipient(){const t=this.recipientPubkey;return this.ndk?this.ndk.getUser({pubkey:t}):new NDKUser({pubkey:t})}async toNostrEvent(){this.unit==="msat"&&(this.unit="sat"),this.removeTag("amount"),this.tags.push(["amount",this.amount.toString()]);const t=await super.toNostrEvent();return t.content=this.comment,t}get isValid(){return this.validateNIP61().valid}validateNIP61(){const t=[];let r=0,s=0,o=0;for(const g of this.tags)g[0]==="e"&&r++,g[0]==="p"&&s++,g[0]==="u"&&o++;this.proofs.length===0&&t.push(createValidationIssue("NO_PROOFS")),s===0?t.push(createValidationIssue("NO_RECIPIENT")):s>1&&t.push(createValidationIssue("MULTIPLE_RECIPIENTS")),o===0?t.push(createValidationIssue("NO_MINT")):o>1&&t.push(createValidationIssue("MULTIPLE_MINTS")),r>1&&t.push(createValidationIssue("MULTIPLE_EVENT_TAGS"));const a=this.tagValue("e"),c=this.pubkey;for(let g=0;g<this.proofs.length;g++){const m=this.proofs[g];try{const b=JSON.parse(m.secret),k=typeof b=="string"?JSON.parse(b):b;if(Array.isArray(k)&&k[0]==="P2PK"&&k[1]){const _=k[1].tags;if(a)if(!_)t.push(createValidationIssue("MISSING_EVENT_TAG_IN_PROOF",g));else{const A=_.find(B=>B[0]==="e");A?A[1]!==a&&t.push(createValidationIssue("MISMATCHED_EVENT_TAG_IN_PROOF",g)):t.push(createValidationIssue("MISSING_EVENT_TAG_IN_PROOF",g))}if(!_)t.push(createValidationIssue("MISSING_SENDER_TAG_IN_PROOF",g));else{const A=_.find(B=>B[0]==="P");A?A[1]!==c&&t.push(createValidationIssue("MISMATCHED_SENDER_TAG_IN_PROOF",g)):t.push(createValidationIssue("MISSING_SENDER_TAG_IN_PROOF",g))}}}catch{t.push(createValidationIssue("MALFORMED_PROOF_SECRET",g))}}return!a&&this.proofs.length>0&&t.push(createValidationIssue("NO_EVENT_TAG_IN_EVENT")),{valid:!t.some(g=>g.severity==="ERROR"),issues:t}}},NDKProject=class Sr extends NDKEvent{static kind=31933;static kinds=[31933];_signer;constructor(t,r){super(t,r),this.kind=31933}static from(t){return new Sr(t.ndk,t.rawEvent())}set repo(t){this.removeTag("repo"),t&&this.tags.push(["repo",t])}set hashtags(t){this.removeTag("hashtags"),t.filter(r=>r.length>0).length&&this.tags.push(["hashtags",...t])}get hashtags(){const t=this.tags.find(r=>r[0]==="hashtags");return t?t.slice(1):[]}get repo(){return this.tagValue("repo")}get title(){return this.tagValue("title")}set title(t){this.removeTag("title"),t&&this.tags.push(["title",t])}get picture(){return this.tagValue("picture")}set picture(t){this.removeTag("picture"),t&&this.tags.push(["picture",t])}set description(t){this.content=t}get description(){return this.content}get slug(){return this.dTag??"empty-dtag"}async getSigner(){if(this._signer)return this._signer;const t=this.tagValue("key");if(!t)this._signer=NDKPrivateKeySigner.generate(),await this.encryptAndSaveNsec();else{const r=await this.ndk?.signer?.decrypt(this.ndk.activeUser,t);if(!r)throw new Error("Failed to decrypt project key or missing signer context.");this._signer=new NDKPrivateKeySigner(r)}return this._signer}async getNsec(){return(await this.getSigner()).privateKey}async setNsec(t){this._signer=new NDKPrivateKeySigner(t),await this.encryptAndSaveNsec()}async encryptAndSaveNsec(){if(!this._signer)throw new Error("Signer is not set.");const t=this._signer.privateKey,r=await this.ndk?.signer?.encrypt(this.ndk.activeUser,t);r&&(this.removeTag("key"),this.tags.push(["key",r]))}},NDKProjectTemplate=class Tr extends NDKEvent{static kind=30717;static kinds=[30717];constructor(t,r){super(t,r),this.kind=30717}static from(t){return new Tr(t.ndk,t.rawEvent())}get templateId(){return this.dTag??""}set templateId(t){this.dTag=t}get name(){return this.tagValue("title")??""}set name(t){this.removeTag("title"),t&&this.tags.push(["title",t])}get description(){return this.tagValue("description")??""}set description(t){this.removeTag("description"),t&&this.tags.push(["description",t])}get repoUrl(){return this.tagValue("uri")??""}set repoUrl(t){this.removeTag("uri"),t&&this.tags.push(["uri",t])}get image(){return this.tagValue("image")}set image(t){this.removeTag("image"),t&&this.tags.push(["image",t])}get command(){return this.tagValue("command")}set command(t){this.removeTag("command"),t&&this.tags.push(["command",t])}get agentConfig(){const t=this.tagValue("agent");if(t)try{return JSON.parse(t)}catch{return}}set agentConfig(t){this.removeTag("agent"),t&&this.tags.push(["agent",JSON.stringify(t)])}get templateTags(){return this.getMatchingTags("t").map(t=>t[1]).filter(Boolean)}set templateTags(t){this.tags=this.tags.filter(r=>r[0]!=="t"),t.forEach(r=>{r&&this.tags.push(["t",r])})}},READ_MARKER="read",WRITE_MARKER="write",NDKRelayList=class Ar extends NDKEvent{static kind=10002;static kinds=[10002];constructor(t,r){super(t,r),this.kind??=10002}static from(t){return new Ar(t.ndk,t.rawEvent())}get readRelayUrls(){return this.tags.filter(t=>t[0]==="r"||t[0]==="relay").filter(t=>!t[2]||t[2]&&t[2]===READ_MARKER).map(t=>tryNormalizeRelayUrl(t[1])).filter(t=>!!t)}set readRelayUrls(t){for(const r of t)this.tags.push(["r",r,READ_MARKER])}get writeRelayUrls(){return this.tags.filter(t=>t[0]==="r"||t[0]==="relay").filter(t=>!t[2]||t[2]&&t[2]===WRITE_MARKER).map(t=>tryNormalizeRelayUrl(t[1])).filter(t=>!!t)}set writeRelayUrls(t){for(const r of t)this.tags.push(["r",r,WRITE_MARKER])}get bothRelayUrls(){return this.tags.filter(t=>t[0]==="r"||t[0]==="relay").filter(t=>!t[2]).map(t=>t[1])}set bothRelayUrls(t){for(const r of t)this.tags.push(["r",r])}get relays(){return this.tags.filter(t=>t[0]==="r"||t[0]==="relay").map(t=>t[1])}get relaySet(){if(!this.ndk)throw new Error("NDKRelayList has no NDK instance");return new NDKRelaySet(new Set(this.relays.map(t=>this.ndk?.pool.getRelay(t)).filter(t=>!!t)),this.ndk)}};function relayListFromKind3(n,t){try{const r=JSON.parse(t.content),s=new NDKRelayList(n),o=new Set,a=new Set;for(let[c,f]of Object.entries(r)){try{c=normalizeRelayUrl(c)}catch{continue}if(!f)o.add(c),a.add(c);else{const g=f;g.write&&a.add(c),g.read&&o.add(c)}}return s.readRelayUrls=Array.from(o),s.writeRelayUrls=Array.from(a),s}catch{}}var NDKRelayFeedList=class xr extends NDKList{static kind=10012;static kinds=[10012];constructor(t,r){super(t,r),r?.kind||(this.kind=10012)}static from(t){return new xr(t.ndk,t)}get relayUrls(){return this.getMatchingTags("relay").map(t=>t[1])}get relaySets(){return this.getMatchingTags("a").map(t=>t[1])}async addRelay(t,r,s=!1,o="bottom"){const a=["relay",t];r&&a.push(r),await this.addItem(a,void 0,s,o)}async addRelaySet(t,r,s=!1,o="bottom"){const a=["a",t];r&&a.push(r),await this.addItem(a,void 0,s,o)}async removeRelay(t,r=!0){await this.removeItemByValue(t,r)}async removeRelaySet(t,r=!0){await this.removeItemByValue(t,r)}},NDKRepost=class Rr extends NDKEvent{_repostedEvents;static kind=6;static kinds=[6,16];static from(t){return new Rr(t.ndk,t.rawEvent())}async repostedEvents(t,r){const s=[];if(!this.ndk)throw new Error("NDK instance not set");if(this._repostedEvents!==void 0)return this._repostedEvents;for(const o of this.repostedEventIds()){const a=filterForId(o),c=await this.ndk.fetchEvent(a,r);c&&s.push(t?t.from(c):c)}return s}repostedEventIds(){return this.tags.filter(t=>t[0]==="e"||t[0]==="a").map(t=>t[1])}};function filterForId(n){if(n.match(/:/)){const[t,r,s]=n.split(":");return{kinds:[Number.parseInt(t)],authors:[r],"#d":[s]}}return{ids:[n]}}var NDKSimpleGroupMemberList=class Nr extends NDKEvent{relaySet;memberSet=new Set;static kind=39002;static kinds=[39002];constructor(t,r){super(t,r),this.kind??=39002,this.memberSet=new Set(this.members)}static from(t){return new Nr(t.ndk,t)}get members(){return this.getMatchingTags("p").map(t=>t[1])}hasMember(t){return this.memberSet.has(t)}async publish(t,r,s){return t??=this.relaySet,super.publishReplaceable(t,r,s)}},NDKSimpleGroupMetadata=class Cr extends NDKEvent{static kind=39e3;static kinds=[39e3];constructor(t,r){super(t,r),this.kind??=39e3}static from(t){return new Cr(t.ndk,t)}get name(){return this.tagValue("name")}get picture(){return this.tagValue("picture")}get about(){return this.tagValue("about")}get scope(){if(this.getMatchingTags("public").length>0)return"public";if(this.getMatchingTags("public").length>0)return"private"}set scope(t){this.removeTag("public"),this.removeTag("private"),t==="public"?this.tags.push(["public",""]):t==="private"&&this.tags.push(["private",""])}get access(){if(this.getMatchingTags("open").length>0)return"open";if(this.getMatchingTags("closed").length>0)return"closed"}set access(t){this.removeTag("open"),this.removeTag("closed"),t==="open"?this.tags.push(["open",""]):t==="closed"&&this.tags.push(["closed",""])}};function strToPosition(n){const[t,r]=n.split(",").map(Number);return{x:t,y:r}}function strToDimension(n){const[t,r]=n.split("x").map(Number);return{width:t,height:r}}var NDKStorySticker=class Ir{static Text="text";static Pubkey="pubkey";static Event="event";static Prompt="prompt";static Countdown="countdown";type;value;position;dimension;properties;constructor(t){if(Array.isArray(t)){const r=t;if(r[0]!=="sticker"||r.length<5)throw new Error("Invalid sticker tag");this.type=r[1],this.value=r[2],this.position=strToPosition(r[3]),this.dimension=strToDimension(r[4]);const s={};for(let o=5;o<r.length;o++){const[a,...c]=r[o].split(" ");s[a]=c.join(" ")}Object.keys(s).length>0&&(this.properties=s)}else this.type=t,this.value=void 0,this.position={x:0,y:0},this.dimension={width:0,height:0}}static fromTag(t){try{return new Ir(t)}catch{return null}}get style(){return this.properties?.style}set style(t){t?this.properties={...this.properties,style:t}:delete this.properties?.style}get rotation(){return this.properties?.rot?Number.parseFloat(this.properties.rot):void 0}set rotation(t){t!==void 0?this.properties={...this.properties,rot:t.toString()}:delete this.properties?.rot}get isValid(){return this.hasValidDimensions()&&this.hasValidPosition()}hasValidDimensions=()=>typeof this.dimension.width=="number"&&typeof this.dimension.height=="number"&&!Number.isNaN(this.dimension.width)&&!Number.isNaN(this.dimension.height);hasValidPosition=()=>typeof this.position.x=="number"&&typeof this.position.y=="number"&&!Number.isNaN(this.position.x)&&!Number.isNaN(this.position.y);toTag(){if(!this.isValid){const s=[this.hasValidDimensions()?void 0:"dimensions is invalid",this.hasValidPosition()?void 0:"position is invalid"].filter(Boolean);throw new Error(`Invalid sticker: ${s.join(", ")}`)}let t;switch(this.type){case"event":t=this.value.tagId();break;case"pubkey":t=this.value.pubkey;break;default:t=this.value}const r=["sticker",this.type,t,coordinates(this.position),dimension(this.dimension)];if(this.properties)for(const[s,o]of Object.entries(this.properties))r.push(`${s} ${o}`);return r}},NDKStory=class Br extends NDKEvent{static kind=23;static kinds=[23];_imeta;_dimensions;constructor(t,r){if(super(t,r),this.kind??=23,r)for(const s of r.tags)switch(s[0]){case"imeta":this._imeta=mapImetaTag(s);break;case"dim":this.dimensions=strToDimension(s[1]);break}}static from(t){return new Br(t.ndk,t)}get isValid(){return!!this.imeta}get imeta(){return this._imeta}set imeta(t){this._imeta=t,this.tags=this.tags.filter(r=>r[0]!=="imeta"),t&&this.tags.push(imetaTagToTag(t))}get dimensions(){const t=this.tagValue("dim");if(t)return strToDimension(t)}set dimensions(t){this.removeTag("dim"),t&&this.tags.push(["dim",`${t.width}x${t.height}`])}get duration(){const t=this.tagValue("dur");if(t)return Number.parseInt(t)}set duration(t){this.removeTag("dur"),t!==void 0&&this.tags.push(["dur",t.toString()])}get stickers(){const t=[];for(const r of this.tags){if(r[0]!=="sticker"||r.length<5)continue;const s=NDKStorySticker.fromTag(r);s&&t.push(s)}return t}addSticker(t){let r;if(t instanceof NDKStorySticker)r=t;else{const s=["sticker",t.type,typeof t.value=="string"?t.value:"",coordinates(t.position),dimension(t.dimension)];if(t.properties)for(const[o,a]of Object.entries(t.properties))s.push(`${o} ${a}`);r=new NDKStorySticker(s),r.value=t.value}r.type==="pubkey"?this.tag(r.value):r.type==="event"&&this.tag(r.value),this.tags.push(r.toTag())}removeSticker(t){const r=this.stickers;if(t<0||t>=r.length)return;let s=0;for(let o=0;o<this.tags.length;o++)if(this.tags[o][0]==="sticker"){if(s===t){this.tags.splice(o,1);break}s++}}},coordinates=n=>`${n.x},${n.y}`,dimension=n=>`${n.width}x${n.height}`,NDKSubscriptionReceipt=class Mr extends NDKEvent{debug;static kind=7003;static kinds=[7003];constructor(t,r){super(t,r),this.kind??=7003,this.debug=t?.debug.extend("subscription-start")??debug$1("ndk:subscription-start")}static from(t){return new Mr(t.ndk,t.rawEvent())}get recipient(){const t=this.getMatchingTags("p")?.[0];return t?new NDKUser({pubkey:t[1]}):void 0}set recipient(t){this.removeTag("p"),t&&this.tags.push(["p",t.pubkey])}get subscriber(){const t=this.getMatchingTags("P")?.[0];return t?new NDKUser({pubkey:t[1]}):void 0}set subscriber(t){this.removeTag("P"),t&&this.tags.push(["P",t.pubkey])}set subscriptionStart(t){this.debug(`before setting subscription start: ${this.rawEvent}`),this.removeTag("e"),this.tag(t,"subscription",!0),this.debug(`after setting subscription start: ${this.rawEvent}`)}get tierName(){return this.getMatchingTags("tier")?.[0]?.[1]}get isValid(){const t=this.validPeriod;if(!t||t.start>t.end)return!1;const r=this.getMatchingTags("p"),s=this.getMatchingTags("P");return!(r.length!==1||s.length!==1)}get validPeriod(){const t=this.getMatchingTags("valid")?.[0];if(t)try{return{start:new Date(Number.parseInt(t[1])*1e3),end:new Date(Number.parseInt(t[2])*1e3)}}catch{return}}set validPeriod(t){this.removeTag("valid"),t&&this.tags.push(["valid",Math.floor(t.start.getTime()/1e3).toString(),Math.floor(t.end.getTime()/1e3).toString()])}get startPeriod(){return this.validPeriod?.start}get endPeriod(){return this.validPeriod?.end}isActive(t){t??=new Date;const r=this.validPeriod;return!(!r||t<r.start||t>r.end)}},possibleIntervalFrequencies=["daily","weekly","monthly","quarterly","yearly"];function newAmount(n,t,r){return["amount",n.toString(),t,r]}function parseTagToSubscriptionAmount(n){const t=Number.parseInt(n[1]);if(Number.isNaN(t)||t===void 0||t===null||t<=0)return;const r=n[2];if(r===void 0||r==="")return;const s=n[3];if(s!==void 0&&possibleIntervalFrequencies.includes(s))return{amount:t,currency:r,term:s}}var NDKSubscriptionTier=class Ur extends NDKArticle{static kind=37001;static kinds=[37001];constructor(t,r){const s=r?.kind??37001;super(t,r),this.kind=s}static from(t){return new Ur(t.ndk,t)}get perks(){return this.getMatchingTags("perk").map(t=>t[1]).filter(t=>t!==void 0)}addPerk(t){this.tags.push(["perk",t])}get amounts(){return this.getMatchingTags("amount").map(t=>parseTagToSubscriptionAmount(t)).filter(t=>t!==void 0)}addAmount(t,r,s){this.tags.push(newAmount(t,r,s))}set relayUrl(t){this.tags.push(["r",t])}get relayUrls(){return this.getMatchingTags("r").map(t=>t[1]).filter(t=>t!==void 0)}get verifierPubkey(){return this.tagValue("p")}set verifierPubkey(t){this.removeTag("p"),t&&this.tags.push(["p",t])}get isValid(){return this.title!==void 0&&this.amounts.length>0}},NDKSubscriptionStart=class Lr extends NDKEvent{debug;static kind=7001;static kinds=[7001];constructor(t,r){super(t,r),this.kind??=7001,this.debug=t?.debug.extend("subscription-start")??debug$1("ndk:subscription-start")}static from(t){return new Lr(t.ndk,t.rawEvent())}get recipient(){const t=this.getMatchingTags("p")?.[0];return t?new NDKUser({pubkey:t[1]}):void 0}set recipient(t){this.removeTag("p"),t&&this.tags.push(["p",t.pubkey])}get amount(){const t=this.getMatchingTags("amount")?.[0];if(t)return parseTagToSubscriptionAmount(t)}set amount(t){this.removeTag("amount"),t&&this.tags.push(newAmount(t.amount,t.currency,t.term))}get tierId(){const t=this.getMatchingTags("e")?.[0],r=this.getMatchingTags("a")?.[0];if(!(!t||!r))return t[1]??r[1]}set tier(t){this.removeTag("e"),this.removeTag("a"),this.removeTag("event"),t&&(this.tag(t),this.removeTag("p"),this.tags.push(["p",t.pubkey]),this.tags.push(["event",JSON.stringify(t.rawEvent())]))}async fetchTier(){const t=this.tagValue("event");if(t)try{const o=JSON.parse(t);return new NDKSubscriptionTier(this.ndk,o)}catch{this.debug("Failed to parse event tag")}const r=this.tierId;if(!r)return;const s=await this.ndk?.fetchEvent(r);if(s)return NDKSubscriptionTier.from(s)}get isValid(){return this.getMatchingTags("amount").length!==1?(this.debug("Invalid # of amount tag"),!1):this.amount?this.getMatchingTags("p").length!==1?(this.debug("Invalid # of p tag"),!1):this.recipient?!0:(this.debug("Invalid p tag"),!1):(this.debug("Invalid amount tag"),!1)}},NDKTask=class Fr extends NDKEvent{static kind=1934;static kinds=[1934];constructor(t,r){super(t,r),this.kind=1934}static from(t){return new Fr(t.ndk,t.rawEvent())}set title(t){this.removeTag("title"),t&&this.tags.push(["title",t])}get title(){return this.tagValue("title")}set project(t){this.removeTag("a"),this.tags.push(t.tagReference())}get projectSlug(){const t=this.getMatchingTags("a")[0];return t?t[1].split(/:/)?.[2]:void 0}},NDKThread=class Kr extends NDKEvent{static kind=11;static kinds=[11];constructor(t,r){super(t,r),this.kind??=11}static from(t){return new Kr(t.ndk,t)}get title(){return this.tagValue("title")}set title(t){this.removeTag("title"),t&&this.tags.push(["title",t])}},NDKVideo=class zr extends NDKEvent{static kind=21;static kinds=[34235,34236,22,21];_imetas;static from(t){return new zr(t.ndk,t.rawEvent())}get title(){return this.tagValue("title")}set title(t){this.removeTag("title"),t&&this.tags.push(["title",t])}get thumbnail(){let t;return this.imetas&&this.imetas.length>0&&(t=this.imetas[0].image?.[0]),t??this.tagValue("thumb")}get imetas(){return this._imetas?this._imetas:(this._imetas=this.tags.filter(t=>t[0]==="imeta").map(mapImetaTag),this._imetas)}set imetas(t){this._imetas=t,this.tags=this.tags.filter(r=>r[0]!=="imeta"),this.tags.push(...t.map(imetaTagToTag))}get url(){return this.imetas&&this.imetas.length>0?this.imetas[0].url:this.tagValue("url")}get published_at(){const t=this.tagValue("published_at");if(t)return Number.parseInt(t)}async generateTags(){if(super.generateTags(),!this.kind&&this.imetas?.[0]?.dim){const[t,r]=this.imetas[0].dim.split("x"),s=t&&r&&Number.parseInt(t)<Number.parseInt(r);this.duration&&this.duration<120&&s?this.kind=22:this.kind=21}return super.generateTags()}get duration(){const t=this.tagValue("duration");if(t)return Number.parseInt(t)}set duration(t){this.removeTag("duration"),t!==void 0&&this.tags.push(["duration",Math.floor(t).toString()])}},NDKWiki=class qr extends NDKArticle{static kind=30818;static kinds=[30818];static from(t){return new qr(t.ndk,t.rawEvent())}get isDefered(){return this.hasTag("a","defer")}get deferedId(){return this.tagValue("a","defer")}set defer(t){this.removeTag("a","defer"),this.tag(t,"defer")}},NDKWikiMergeRequest=class jr extends NDKEvent{static kind=818;static kinds=[818];static from(t){return new jr(t.ndk,t.rawEvent())}get targetId(){return this.tagValue("a")}set target(t){this.tags=this.tags.filter(r=>{if(r[0]==="a"||r[0]==="e"&&r[3]!=="source")return!0}),this.tag(t)}get sourceId(){return this.tagValue("e","source")}set source(t){this.removeTag("e","source"),this.tag(t,"source",!1,"e")}},registeredEventClasses=new Set;function wrapEvent(n){const t=new Map,s=[...[NDKImage,NDKVideo,NDKCashuMintList,NDKArticle,NDKHighlight,NDKDraft,NDKWiki,NDKWikiMergeRequest,NDKNutzap,NDKProject,NDKTask,NDKProjectTemplate,NDKSimpleGroupMemberList,NDKSimpleGroupMetadata,NDKSubscriptionTier,NDKSubscriptionStart,NDKSubscriptionReceipt,NDKList,NDKRelayList,NDKRelayFeedList,NDKStory,NDKBlossomList,NDKFollowPack,NDKThread,NDKRepost,NDKClassified,NDKAppHandlerEvent,NDKDVMJobFeedback,NDKCashuMintAnnouncement,NDKFedimintMint,NDKMintRecommendation],...registeredEventClasses];for(const a of s)for(const c of a.kinds)t.set(c,a);const o=t.get(n.kind);return o?o.from(n):n}function checkMissingKind(n,t){(n.kind===void 0||n.kind===null)&&t("event-missing-kind",`Cannot sign event without 'kind'.

 Event data:
    content: ${n.content?`"${n.content.substring(0,50)}${n.content.length>50?"...":""}"`:"(empty)"}
    tags: ${n.tags.length} tag${n.tags.length!==1?"s":""}
    kind: ${n.kind} 

Set event.kind before signing.`,"Example: event.kind = 1; // for text note",!1)}function checkContentIsObject(n,t){if(typeof n.content=="object"){const r=JSON.stringify(n.content,null,2).substring(0,200);t("event-content-is-object",`Event content is an object. Content must be a string.

 Your content (${typeof n.content}):
${r}${JSON.stringify(n.content).length>200?"...":""}

 event.content = { ... }  // WRONG
 event.content = JSON.stringify({ ... })  // CORRECT`,"Use JSON.stringify() for structured data: event.content = JSON.stringify(data)",!1)}}function checkCreatedAtMilliseconds(n,t){if(n.created_at&&n.created_at>1e10){const r=Math.floor(n.created_at/1e3),s=new Date(n.created_at).toISOString();t("event-created-at-milliseconds",`Event created_at is in milliseconds, not seconds.

 Your value:
    created_at: ${n.created_at} 
    Interpreted as: ${s}
    Should be: ${r} 

Nostr timestamps MUST be in seconds since Unix epoch.`,"Use Math.floor(Date.now() / 1000) instead of Date.now()",!1)}}function checkInvalidPTags(n,t){n.getMatchingTags("p").forEach((s,o)=>{if(s[1]&&!/^[0-9a-f]{64}$/i.test(s[1])){const a=JSON.stringify(s);t("tag-invalid-p-tag",`p-tag[${o}] has invalid pubkey.

 Your tag:
   ${a}

 Invalid value: "${s[1]}"
    Length: ${s[1].length} (expected 64)
    Format: ${s[1].startsWith("npub")?"bech32 (npub)":"unknown"}

p-tags MUST contain 64-character hex pubkeys.`,s[1].startsWith("npub")?`Use ndkUser.pubkey instead of npub:
    event.tags.push(['p', ndkUser.pubkey])
    event.tags.push(['p', 'npub1...'])`:"p-tags must contain valid hex pubkeys (64 characters, 0-9a-f)",!1)}})}function checkInvalidETags(n,t){n.getMatchingTags("e").forEach((s,o)=>{if(s[1]&&!/^[0-9a-f]{64}$/i.test(s[1])){const a=JSON.stringify(s),c=s[1].startsWith("note")||s[1].startsWith("nevent");t("tag-invalid-e-tag",`e-tag[${o}] has invalid event ID.

 Your tag:
   ${a}

 Invalid value: "${s[1]}"
    Length: ${s[1].length} (expected 64)
    Format: ${c?"bech32 (note/nevent)":"unknown"}

e-tags MUST contain 64-character hex event IDs.`,c?`Use event.id instead of bech32:
    event.tags.push(['e', referencedEvent.id])
    event.tags.push(['e', 'note1...'])`:"e-tags must contain valid hex event IDs (64 characters, 0-9a-f)",!1)}})}function checkManualReplyMarkers(n,t,r){if(n.kind!==1||r.has(n))return;const s=n.tags.filter(o=>o[0]==="e"&&(o[3]==="reply"||o[3]==="root"));if(s.length>0){const o=s.map((a,c)=>`   ${c+1}. ${JSON.stringify(a)}`).join(`
`);t("event-manual-reply-markers",`Event has ${s.length} e-tag(s) with manual reply/root markers.

 Your tags with markers:
${o}

  Manual reply markers detected! This will cause incorrect threading.`,`Reply events MUST be created using .reply():

    CORRECT:
   const replyEvent = originalEvent.reply();
   replyEvent.content = 'good point!';
   await replyEvent.publish();

    WRONG:
   event.tags.push(['e', eventId, '', 'reply']);

NDK handles all reply threading automatically - never add reply/root markers manually.`)}}function checkHashtagsWithPrefix(n,t){n.getMatchingTags("t").forEach((s,o)=>{if(s[1]&&s[1].startsWith("#")){const a=JSON.stringify(s);t("tag-hashtag-with-prefix",`t-tag[${o}] contains hashtag with # prefix.

 Your tag:
   ${a}

 Invalid value: "${s[1]}"

Hashtag tags should NOT include the # symbol.`,`Remove the # prefix from hashtag tags:
    event.tags.push(['t', 'nostr'])
    event.tags.push(['t', '#nostr'])`,!1)}})}function checkReplaceableWithOldTimestamp(n,t){if(n.kind===void 0||n.kind===null||!n.created_at||!n.isReplaceable())return;const r=Math.floor(Date.now()/1e3),s=r-n.created_at;if(s>10){const a=Math.floor(s/60),c=a>0?`${a} minute${a!==1?"s":""}`:`${s} seconds`;t("event-replaceable-old-timestamp",`Publishing a replaceable event with an old created_at timestamp.

 Event details:
    kind: ${n.kind} (replaceable)
    created_at: ${n.created_at}
    age: ${c} old
    current time: ${r}

  This is wrong and will be rejected by relays.`,`For replaceable events, use publishReplaceable():

    CORRECT:
   await event.publishReplaceable();
   // Automatically updates created_at to now

    WRONG:
   await event.publish();
   // Uses old created_at`)}}function signing(n,t,r,s){checkMissingKind(n,t),checkContentIsObject(n,t),checkCreatedAtMilliseconds(n,t),checkInvalidPTags(n,t),checkInvalidETags(n,t),checkHashtagsWithPrefix(n,t),checkManualReplyMarkers(n,r,s)}function publishing(n,t){checkReplaceableWithOldTimestamp(n,t)}function isNip33Pattern(n){const t=Array.isArray(n)?n:[n];if(t.length!==1)return!1;const r=t[0];return r.kinds&&Array.isArray(r.kinds)&&r.kinds.length===1&&r.authors&&Array.isArray(r.authors)&&r.authors.length===1&&r["#d"]&&Array.isArray(r["#d"])&&r["#d"].length===1}function isReplaceableEventFilter(n){const t=Array.isArray(n)?n:[n];return t.length===0?!1:t.every(r=>!r.kinds||!Array.isArray(r.kinds)||r.kinds.length===0||!r.authors||!Array.isArray(r.authors)||r.authors.length===0?!1:r.kinds.every(o=>o===0||o===3||o>=1e4&&o<=19999))}function formatFilter(n){return JSON.stringify(n,null,2).split(`
`).map((r,s)=>s===0?r:`   ${r}`).join(`
`)}function fetchingEvents(n,t,r,s,o){if(o(),t?.cacheUsage==="ONLY_CACHE")return;const a=Array.isArray(n)?n:[n],c=a.map(formatFilter).join(`

   ---

   `);if(isNip33Pattern(n))a[0],r("fetch-events-usage",`For fetching a NIP-33 addressable event, use fetchEvent() with the naddr directly.

 Your filter:
   `+c+`

   BAD:  const decoded = nip19.decode(naddr);
           const events = await ndk.fetchEvents({
             kinds: [decoded.data.kind],
             authors: [decoded.data.pubkey],
             "#d": [decoded.data.identifier]
           });
           const event = Array.from(events)[0];

   GOOD: const event = await ndk.fetchEvent(naddr);
   GOOD: const event = await ndk.fetchEvent('naddr1...');

fetchEvent() handles naddr decoding automatically and returns the event directly.`);else{if(isReplaceableEventFilter(n))return;{if(!s())return;let f="";const g=a.some(k=>k.limit!==void 0),m=new Set(a.flatMap(k=>k.kinds||[])).size,b=new Set(a.flatMap(k=>k.authors||[])).size;if(g){const k=Math.max(...a.map(_=>_.limit||0));f+=`
    Limit: ${k} event${k!==1?"s":""}`}m>0&&(f+=`
    Kinds: ${m} type${m!==1?"s":""}`),b>0&&(f+=`
    Authors: ${b} author${b!==1?"s":""}`),r("fetch-events-usage",`fetchEvents() is a BLOCKING operation that waits for EOSE.
In most cases, you should use subscribe() instead.

 Your filter`+(a.length>1?"s":"")+`:
   `+c+(f?`

 Filter analysis:`+f:"")+`

   BAD:  const events = await ndk.fetchEvents(filter);
   GOOD: ndk.subscribe(filter, { onEvent: (e) => ... });

Only use fetchEvents() when you MUST block until data arrives.`,"For one-time queries, use fetchEvent() instead of fetchEvents() when expecting a single result.")}}}var GuardrailCheckId={NDK_NO_CACHE:"ndk-no-cache",FILTER_BECH32_IN_ARRAY:"filter-bech32-in-array",FILTER_INVALID_HEX:"filter-invalid-hex",FILTER_ONLY_LIMIT:"filter-only-limit",FILTER_EMPTY:"filter-empty",FILTER_SINCE_AFTER_UNTIL:"filter-since-after-until",FILTER_INVALID_A_TAG:"filter-invalid-a-tag",FILTER_HASHTAG_WITH_PREFIX:"filter-hashtag-with-prefix"};function checkCachePresence(n,t){t(GuardrailCheckId.NDK_NO_CACHE)&&setTimeout(()=>{if(!n.cacheAdapter){const o=`
 AI_GUARDRAILS WARNING: NDK initialized without a cache adapter. Apps perform significantly better with caching.

 ${typeof window<"u"?"Consider using @nostr-dev-kit/ndk-cache-dexie or @nostr-dev-kit/ndk-cache-sqlite-wasm":"Consider using @nostr-dev-kit/ndk-cache-redis or @nostr-dev-kit/ndk-cache-sqlite"}

 To disable this check:
   ndk.aiGuardrails.skip('${GuardrailCheckId.NDK_NO_CACHE}')
   or set: ndk.aiGuardrails = { skip: new Set(['${GuardrailCheckId.NDK_NO_CACHE}']) }`;console.warn(o)}},2500)}var AIGuardrails=class{enabled=!1;skipSet=new Set;extensions=new Map;_nextCallDisabled=null;_replyEvents=new WeakSet;_fetchEventsCount=0;_subscribeCount=0;constructor(n=!1){this.setMode(n)}register(n,t){this.extensions.has(n)&&console.warn(`AIGuardrails: Extension '${n}' already registered, overwriting`);const r={};for(const[s,o]of Object.entries(t))typeof o=="function"&&(r[s]=(...a)=>{this.enabled&&o(...a,this.shouldCheck.bind(this),this.error.bind(this),this.warn.bind(this))});this.extensions.set(n,r),this[n]=r}setMode(n){typeof n=="boolean"?(this.enabled=n,this.skipSet.clear()):n&&typeof n=="object"&&(this.enabled=!0,this.skipSet=n.skip||new Set)}isEnabled(){return this.enabled}shouldCheck(n){return!(!this.enabled||this.skipSet.has(n)||this._nextCallDisabled==="all"||this._nextCallDisabled&&this._nextCallDisabled.has(n))}skip(n){this.skipSet.add(n)}enable(n){this.skipSet.delete(n)}getSkipped(){return Array.from(this.skipSet)}captureAndClearNextCallDisabled(){const n=this._nextCallDisabled;return this._nextCallDisabled=null,n}incrementFetchEventsCount(){this._fetchEventsCount++}incrementSubscribeCount(){this._subscribeCount++}shouldWarnAboutFetchEventsRatio(){const n=this._fetchEventsCount+this._subscribeCount;return n<=6?!1:this._fetchEventsCount/n>.5}error(n,t,r,s=!0){if(!this.shouldCheck(n))return;const o=this.formatMessage(n,"ERROR",t,r,s);throw console.error(o),new Error(o)}warn(n,t,r){if(!this.shouldCheck(n))return;const s=this.formatMessage(n,"WARNING",t,r,!0);throw console.error(s),new Error(s)}formatMessage(n,t,r,s,o=!0){let a=`
 AI_GUARDRAILS ${t}: ${r}`;return s&&(a+=`

 ${s}`),o&&(a+=`

 To disable this check:
   ndk.guardrailOff('${n}').yourMethod()  // For one call`,a+=`
   ndk.aiGuardrails.skip('${n}')  // Permanently`,a+=`
   or set: ndk.aiGuardrails = { skip: new Set(['${n}']) }`),a}ndkInstantiated(n){this.enabled&&checkCachePresence(n,this.shouldCheck.bind(this))}ndk={fetchingEvents:(n,t)=>{this.enabled&&fetchingEvents(n,t,this.warn.bind(this),this.shouldWarnAboutFetchEventsRatio.bind(this),this.incrementFetchEventsCount.bind(this))}};event={signing:n=>{this.enabled&&signing(n,this.error.bind(this),this.warn.bind(this),this._replyEvents)},publishing:n=>{this.enabled&&publishing(n,this.warn.bind(this))},received:(n,t)=>{this.enabled},creatingReply:n=>{this.enabled&&this._replyEvents.add(n)}};subscription={created:(n,t)=>{this.enabled&&this.incrementSubscribeCount()}};relay={connected:n=>{this.enabled}}};function processFilters(n,t="validate",r,s){if(t==="ignore")return n;const o=[],a=n.map((c,f)=>(s?.aiGuardrails.isEnabled()&&runAIGuardrailsForFilter(c,f,s),processFilter(c,t,f,o,r)));if(t==="validate"&&o.length>0)throw new Error(`Invalid filter(s) detected:
${o.join(`
`)}`);return a}function processFilter(n,t,r,s,o){const a=t==="validate",c=a?n:{...n};if(n.ids){const f=[];n.ids.forEach((g,m)=>{g===void 0?a?s.push(`Filter[${r}].ids[${m}] is undefined`):o?.(`Fixed: Removed undefined value at ids[${m}]`):typeof g!="string"?a?s.push(`Filter[${r}].ids[${m}] is not a string (got ${typeof g})`):o?.(`Fixed: Removed non-string value at ids[${m}] (was ${typeof g})`):isValidHex64(g)?f.push(g):a?s.push(`Filter[${r}].ids[${m}] is not a valid 64-char hex string: "${g}"`):o?.(`Fixed: Removed invalid hex string at ids[${m}]`)}),a||(c.ids=f.length>0?f:void 0)}if(n.authors){const f=[];n.authors.forEach((g,m)=>{g===void 0?a?s.push(`Filter[${r}].authors[${m}] is undefined`):o?.(`Fixed: Removed undefined value at authors[${m}]`):typeof g!="string"?a?s.push(`Filter[${r}].authors[${m}] is not a string (got ${typeof g})`):o?.(`Fixed: Removed non-string value at authors[${m}] (was ${typeof g})`):isValidHex64(g)?f.push(g):a?s.push(`Filter[${r}].authors[${m}] is not a valid 64-char hex pubkey: "${g}"`):o?.(`Fixed: Removed invalid hex pubkey at authors[${m}]`)}),a||(c.authors=f.length>0?f:void 0)}if(n.kinds){const f=[];n.kinds.forEach((g,m)=>{g===void 0?a?s.push(`Filter[${r}].kinds[${m}] is undefined`):o?.(`Fixed: Removed undefined value at kinds[${m}]`):typeof g!="number"?a?s.push(`Filter[${r}].kinds[${m}] is not a number (got ${typeof g})`):o?.(`Fixed: Removed non-number value at kinds[${m}] (was ${typeof g})`):Number.isInteger(g)?g<0||g>65535?a?s.push(`Filter[${r}].kinds[${m}] is out of valid range (0-65535): ${g}`):o?.(`Fixed: Removed out-of-range kind at kinds[${m}]: ${g}`):f.push(g):a?s.push(`Filter[${r}].kinds[${m}] is not an integer: ${g}`):o?.(`Fixed: Removed non-integer value at kinds[${m}]: ${g}`)}),a||(c.kinds=f.length>0?f:void 0)}for(const f in n)if(f.startsWith("#")&&f.length===2){const g=n[f];if(Array.isArray(g)){const m=[];g.forEach((b,k)=>{b===void 0?a?s.push(`Filter[${r}].${f}[${k}] is undefined`):o?.(`Fixed: Removed undefined value at ${f}[${k}]`):typeof b!="string"?a?s.push(`Filter[${r}].${f}[${k}] is not a string (got ${typeof b})`):o?.(`Fixed: Removed non-string value at ${f}[${k}] (was ${typeof b})`):(f==="#e"||f==="#p")&&!isValidHex64(b)?a?s.push(`Filter[${r}].${f}[${k}] is not a valid 64-char hex string: "${b}"`):o?.(`Fixed: Removed invalid hex string at ${f}[${k}]`):m.push(b)}),a||(c[f]=m.length>0?m:void 0)}}return a||Object.keys(c).forEach(f=>{c[f]===void 0&&delete c[f]}),c}function runAIGuardrailsForFilter(n,t,r){const s=r.aiGuardrails,o=JSON.stringify(n,null,2);if(Object.keys(n).length===1&&n.limit!==void 0&&s.error(GuardrailCheckId.FILTER_ONLY_LIMIT,`Filter[${t}] contains only 'limit' without any filtering criteria.

 Your filter:
${o}

  This will fetch random events from relays without any criteria.`,`Add filtering criteria:
    { kinds: [1], limit: 10 }
    { authors: [pubkey], limit: 10 }
    { limit: 10 }`),Object.keys(n).length===0&&s.error(GuardrailCheckId.FILTER_EMPTY,`Filter[${t}] is empty.

 Your filter:
${o}

  This will request ALL events from relays, which is never what you want.`,"Add filtering criteria like 'kinds', 'authors', or tags.",!1),n.since!==void 0&&n.until!==void 0&&n.since>n.until){const c=new Date(n.since*1e3).toISOString(),f=new Date(n.until*1e3).toISOString();s.error(GuardrailCheckId.FILTER_SINCE_AFTER_UNTIL,`Filter[${t}] has 'since' AFTER 'until'.

 Your filter:
${o}

 since: ${n.since} (${c})
 until: ${n.until} (${f})

No events can match this time range!`,"'since' must be BEFORE 'until'. Both are Unix timestamps in seconds.",!1)}const a=/^n(addr|event|ote|pub|profile)1/;n.ids&&n.ids.forEach((c,f)=>{typeof c=="string"&&(a.test(c)?s.error(GuardrailCheckId.FILTER_BECH32_IN_ARRAY,`Filter[${t}].ids[${f}] contains bech32: "${c}". IDs must be hex, not bech32.`,'Use filterFromId() to decode bech32 first: import { filterFromId } from "@nostr-dev-kit/ndk"',!1):isValidHex64(c)||s.error(GuardrailCheckId.FILTER_INVALID_HEX,`Filter[${t}].ids[${f}] is not a valid 64-char hex string: "${c}"`,`Event IDs must be 64-character hexadecimal strings. Invalid IDs often come from corrupted data in user-generated lists. Always validate hex strings before using them in filters:

   const validIds = ids.filter(id => /^[0-9a-f]{64}$/i.test(id));`,!1))}),n.authors&&n.authors.forEach((c,f)=>{typeof c=="string"&&(a.test(c)?s.error(GuardrailCheckId.FILTER_BECH32_IN_ARRAY,`Filter[${t}].authors[${f}] contains bech32: "${c}". Authors must be hex pubkeys, not npub.`,"Use ndkUser.pubkey instead. Example: { authors: [ndkUser.pubkey] }",!1):isValidHex64(c)||s.error(GuardrailCheckId.FILTER_INVALID_HEX,`Filter[${t}].authors[${f}] is not a valid 64-char hex pubkey: "${c}"`,`Kind:3 follow lists can contain invalid entries like labels ("Follow List"), partial strings ("highlig"), or other corrupted data. You MUST validate all pubkeys before using them in filters.

   Example:
   const validPubkeys = pubkeys.filter(p => /^[0-9a-f]{64}$/i.test(p));
   ndk.subscribe({ authors: validPubkeys, kinds: [1] });`,!1))});for(const c in n)if(c.startsWith("#")&&c.length===2){const f=n[c];Array.isArray(f)&&f.forEach((g,m)=>{typeof g=="string"&&(c==="#e"||c==="#p")&&(a.test(g)?s.error(GuardrailCheckId.FILTER_BECH32_IN_ARRAY,`Filter[${t}].${c}[${m}] contains bech32: "${g}". Tag values must be decoded.`,"Use filterFromId() or nip19.decode() to get the hex value first.",!1):isValidHex64(g)||s.error(GuardrailCheckId.FILTER_INVALID_HEX,`Filter[${t}].${c}[${m}] is not a valid 64-char hex string: "${g}"`,`${c==="#e"?"Event IDs":"Public keys"} in tag filters must be 64-character hexadecimal strings. Kind:3 follow lists and other user-generated content can contain invalid data. Always filter before using:

   const validValues = values.filter(v => /^[0-9a-f]{64}$/i.test(v));`,!1))})}n["#a"]&&n["#a"]?.forEach((f,g)=>{if(typeof f=="string")if(!/^\d+:[0-9a-f]{64}:.*$/.test(f))s.error(GuardrailCheckId.FILTER_INVALID_A_TAG,`Filter[${t}].#a[${g}] has invalid format: "${f}". Must be "kind:pubkey:d-tag".`,'Example: "30023:fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52:my-article"',!1);else{const m=Number.parseInt(f.split(":")[0],10);(m<3e4||m>39999)&&s.error(GuardrailCheckId.FILTER_INVALID_A_TAG,`Filter[${t}].#a[${g}] uses non-addressable kind ${m}: "${f}". #a filters are only for addressable events (kinds 30000-39999).`,`Addressable events include:
    30000-30039: Parameterized Replaceable Events (profiles, settings, etc.)
    30040-39999: Other addressable events

For regular events (kind ${m}), use:
    #e filter for specific event IDs
    kinds + authors filters for event queries`,!1)}}),n["#t"]&&n["#t"]?.forEach((f,g)=>{typeof f=="string"&&f.startsWith("#")&&s.error(GuardrailCheckId.FILTER_HASHTAG_WITH_PREFIX,`Filter[${t}].#t[${g}] contains hashtag with # prefix: "${f}". Hashtag values should NOT include the # symbol.`,`Remove the # prefix from hashtag filters:
    { "#t": ["nostr"] }
    { "#t": ["#nostr"] }`,!1)})}function queryFullyFilled(n){return!!(filterIncludesIds(n.filter)&&resultHasAllRequestedIds(n))}function filterIncludesIds(n){return!!n.ids}function resultHasAllRequestedIds(n){const t=n.filter.ids;return!!t&&t.length===n.eventFirstSeen.size}function filterFromId(n){let t;if(n.match(NIP33_A_REGEX)){const[r,s,o]=n.split(":"),a={authors:[s],kinds:[Number.parseInt(r)]};return o&&(a["#d"]=[o]),a}if(n.match(BECH32_REGEX))try{switch(t=nip19_exports$1.decode(n),t.type){case"nevent":{const r={ids:[t.data.id]};return t.data.author&&(r.authors=[t.data.author]),t.data.kind&&(r.kinds=[t.data.kind]),r}case"note":return{ids:[t.data]};case"naddr":{const r={authors:[t.data.pubkey],kinds:[t.data.kind]};return t.data.identifier&&(r["#d"]=[t.data.identifier]),r}}}catch(r){console.error("Error decoding",n,r)}return{ids:[n]}}function isNip33AValue(n){return n.match(NIP33_A_REGEX)!==null}var NIP33_A_REGEX=/^(\d+):([0-9A-Fa-f]+)(?::(.*))?$/,BECH32_REGEX=/^n(event|ote|profile|pub|addr)1[\d\w]+$/;function relaysFromBech32(n,t){try{const r=nip19_exports$1.decode(n);if(["naddr","nevent"].includes(r?.type)){const s=r.data;if(s?.relays)return s.relays.map(o=>new NDKRelay(o,t.relayAuthDefaultPolicy,t))}}catch{}return[]}var NDKSubscriptionCacheUsage=(n=>(n.ONLY_CACHE="ONLY_CACHE",n.CACHE_FIRST="CACHE_FIRST",n.PARALLEL="PARALLEL",n.ONLY_RELAY="ONLY_RELAY",n))(NDKSubscriptionCacheUsage||{}),defaultOpts={closeOnEose:!1,cacheUsage:"CACHE_FIRST",dontSaveToCache:!1,groupable:!0,groupableDelay:10,groupableDelayType:"at-most",cacheUnconstrainFilter:["limit","since","until"],includeMuted:!1},NDKSubscription=class extends libExports.EventEmitter{subId;filters;opts;pool;skipVerification=!1;skipValidation=!1;exclusiveRelay=!1;relayFilters;relaySet;ndk;debug;eventFirstSeen=new Map;eosesSeen=new Set;lastEventReceivedAt;mostRecentCacheEventTimestamp;internalId;closeOnEose;poolMonitor;skipOptimisticPublishEvent=!1;cacheUnconstrainFilter;constructor(n,t,r,s){super(),this.ndk=n,this.opts={...defaultOpts,...r||{}},this.pool=this.opts.pool||n.pool;const o=Array.isArray(t)?t:[t],a=n.filterValidationMode==="validate"?"validate":n.filterValidationMode==="fix"?"fix":"ignore";if(this.filters=processFilters(o,a,n.debug,n),this.filters.length===0)throw new Error("Subscription must have at least one filter");this.subId=s||this.opts.subId,this.internalId=Math.random().toString(36).substring(7),this.debug=n.debug.extend(`subscription[${this.opts.subId??this.internalId}]`),this.opts.relaySet?this.relaySet=this.opts.relaySet:this.opts.relayUrls&&(this.relaySet=NDKRelaySet.fromRelayUrls(this.opts.relayUrls,this.ndk)),this.skipVerification=this.opts.skipVerification||!1,this.skipValidation=this.opts.skipValidation||!1,this.closeOnEose=this.opts.closeOnEose||!1,this.skipOptimisticPublishEvent=this.opts.skipOptimisticPublishEvent||!1,this.cacheUnconstrainFilter=this.opts.cacheUnconstrainFilter,this.exclusiveRelay=this.opts.exclusiveRelay||!1,this.opts.onEvent&&this.on("event",this.opts.onEvent),this.opts.onEose&&this.on("eose",this.opts.onEose),this.opts.onClose&&this.on("close",this.opts.onClose)}relaysMissingEose(){return this.relayFilters?Array.from(this.relayFilters?.keys()).filter(t=>!this.eosesSeen.has(this.pool.getRelay(t,!1,!1))):[]}get filter(){return this.filters[0]}get groupableDelay(){if(this.isGroupable())return this.opts?.groupableDelay}get groupableDelayType(){return this.opts?.groupableDelayType||"at-most"}isGroupable(){return this.opts?.groupable||!1}shouldQueryCache(){return this.opts.addSinceFromCache?!0:this.opts?.cacheUsage==="ONLY_RELAY"?!1:(this.filters.some(t=>t.kinds?.some(r=>kindIsEphemeral(r))),!0)}shouldQueryRelays(){return this.opts?.cacheUsage!=="ONLY_CACHE"}shouldWaitForCache(){return this.opts.addSinceFromCache?!0:!!this.opts.closeOnEose&&!!this.ndk.cacheAdapter?.locking&&this.opts.cacheUsage!=="PARALLEL"}start(n=!0){let t;const r=o=>{if(o.length===0){n||(t=o);return}if(!n){let c=this.mostRecentCacheEventTimestamp||0;for(const f of o)f.ndk=this.ndk,f.created_at&&f.created_at>c&&(c=f.created_at);this.mostRecentCacheEventTimestamp=c,t=o;return}let a=this.mostRecentCacheEventTimestamp||0;for(const c of o)c.created_at&&c.created_at>a&&(a=c.created_at);this.mostRecentCacheEventTimestamp=a;for(const c of o)this.eventReceived(c,void 0,!0,!1)},s=()=>{this.shouldQueryRelays()?(this.startWithRelays(),this.startPoolMonitor()):this.emit("eose",this)};return this.shouldQueryCache()?(t=this.startWithCache(),t instanceof Promise?this.shouldWaitForCache()?(t.then(o=>{if(this.opts.onEvents){let a=this.mostRecentCacheEventTimestamp||0;for(const c of o)c.ndk=this.ndk,c.created_at&&c.created_at>a&&(a=c.created_at);this.mostRecentCacheEventTimestamp=a,this.opts.onEvents(o)}else r(o);if(queryFullyFilled(this)){this.emit("eose",this);return}s()}),null):(t.then(o=>{if(this.opts.onEvents){let a=this.mostRecentCacheEventTimestamp||0;for(const c of o)c.ndk=this.ndk,c.created_at&&c.created_at>a&&(a=c.created_at);this.mostRecentCacheEventTimestamp=a,this.opts.onEvents(o)}else r(o);this.shouldQueryRelays()||this.emit("eose",this)}),this.shouldQueryRelays()&&s(),null):(r(t),queryFullyFilled(this)?this.emit("eose",this):s(),t)):(s(),null)}startPoolMonitor(){this.debug.extend("pool-monitor"),this.poolMonitor=n=>{if(this.relayFilters?.has(n.url))return;calculateRelaySetsFromFilters(this.ndk,this.filters,this.pool,this.opts.relayGoalPerAuthor).get(n.url)&&(this.relayFilters?.set(n.url,this.filters),n.subscribe(this,this.filters))},this.pool.on("relay:connect",this.poolMonitor)}onStopped;stop(){this.emit("close",this),this.poolMonitor&&this.pool.off("relay:connect",this.poolMonitor),this.onStopped?.()}hasAuthorsFilter(){return this.filters.some(n=>n.authors?.length)}startWithCache(){return this.ndk.cacheAdapter?.query?this.ndk.cacheAdapter.query(this):[]}startWithRelays(){let n=this.filters;if(this.opts.addSinceFromCache&&this.mostRecentCacheEventTimestamp){const t=this.mostRecentCacheEventTimestamp+1;n=n.map(r=>({...r,since:Math.max(r.since||0,t)}))}if(!this.relaySet||this.relaySet.relays.size===0)this.relayFilters=calculateRelaySetsFromFilters(this.ndk,n,this.pool,this.opts.relayGoalPerAuthor);else{this.relayFilters=new Map;for(const t of this.relaySet.relays)this.relayFilters.set(t.url,n)}for(const[t,r]of this.relayFilters)this.pool.getRelay(t,!0,!0,r).subscribe(this,r)}refreshRelayConnections(){if(this.relaySet&&this.relaySet.relays.size>0)return;const n=calculateRelaySetsFromFilters(this.ndk,this.filters,this.pool,this.opts.relayGoalPerAuthor);for(const[t,r]of n)this.relayFilters?.has(t)||(this.relayFilters?.set(t,r),this.pool.getRelay(t,!0,!0,r).subscribe(this,r))}eventReceived(n,t,r=!1,s=!1){const o=n.id,a=this.eventFirstSeen.has(o);let c;if(n instanceof NDKEvent&&(c=n),a){const f=Date.now()-(this.eventFirstSeen.get(o)||0);if(this.emit("event:dup",n,t,f,this,r,s),this.opts?.onEventDup&&this.opts.onEventDup(n,t,f,this,r,s),!r&&!s&&t&&this.ndk.cacheAdapter?.setEventDup&&!this.opts.dontSaveToCache&&(c??=n instanceof NDKEvent?n:new NDKEvent(this.ndk,n),this.ndk.cacheAdapter.setEventDup(c,t)),t){const g=verifiedSignatures.get(o);if(g&&typeof g=="string")if(n.sig===g)t.addValidatedEvent();else{const m=n instanceof NDKEvent?n:new NDKEvent(this.ndk,n);this.ndk.reportInvalidSignature(m,t)}}}else{if(this.ndk.futureTimestampGrace!==void 0&&n.created_at){const f=Math.floor(Date.now()/1e3),g=n.created_at-f;if(g>this.ndk.futureTimestampGrace){this.debug("Event discarded: timestamp %d is %d seconds in the future (grace: %d seconds)",n.created_at,g,this.ndk.futureTimestampGrace);return}}if(c??=new NDKEvent(this.ndk,n),c.ndk=this.ndk,c.relay=t,!r&&!s){if(!this.skipValidation&&!c.isValid){this.debug("Event failed validation %s from relay %s",o,t?.url);return}if(t)if(t.shouldValidateEvent()&&!this.skipVerification)if(c.relay=t,this.ndk.asyncSigVerification)c.verifySignature(!0);else{if(!c.verifySignature(!0)){this.debug("Event failed signature validation",n),this.ndk.reportInvalidSignature(c,t);return}t.addValidatedEvent()}else t.addNonValidatedEvent();this.ndk.cacheAdapter&&!this.opts.dontSaveToCache&&this.ndk.cacheAdapter.setEvent(c,this.filters,t)}if(!this.opts.includeMuted&&this.ndk.muteFilter&&this.ndk.muteFilter(c)){this.debug("Event muted, skipping");return}(!s||this.skipOptimisticPublishEvent!==!0)&&(this.emitEvent(this.opts?.wrap??!1,c,t,r,s),this.eventFirstSeen.set(o,Date.now()))}this.lastEventReceivedAt=Date.now()}emitEvent(n,t,r,s,o){const a=n?wrapEvent(t):t;a instanceof Promise?a.then(c=>this.emitEvent(!1,c,r,s,o)):a&&this.emit("event",a,r,this,s,o)}closedReceived(n,t){this.emit("closed",n,t)}eoseTimeout;eosed=!1;eoseReceived(n){this.eosesSeen.add(n);let t=this.lastEventReceivedAt?Date.now()-this.lastEventReceivedAt:void 0;const r=this.eosesSeen.size===this.relayFilters?.size,s=queryFullyFilled(this),o=a=>{this.eosed||(this.eoseTimeout&&clearTimeout(this.eoseTimeout),this.emit("eose",this),this.eosed=!0,this.opts?.closeOnEose&&this.stop())};if(s||r)o();else if(this.relayFilters){let a=1e3;const c=new Set(this.pool.connectedRelays().map(m=>m.url)),f=Array.from(this.relayFilters.keys()).filter(m=>c.has(m));if(f.length===0){this.debug("No connected relays, waiting for all relays to connect",Array.from(this.relayFilters.keys()).join(", "));return}const g=this.eosesSeen.size/f.length;if(this.eosesSeen.size>=2&&g>=.5){if(a=a*(1-g),a===0){o();return}this.eoseTimeout&&clearTimeout(this.eoseTimeout);const m=()=>{t=this.lastEventReceivedAt?Date.now()-this.lastEventReceivedAt:void 0,t!==void 0&&t<20?this.eoseTimeout=setTimeout(m,a):o()};this.eoseTimeout=setTimeout(m,a)}}}},kindIsEphemeral=n=>n>=2e4&&n<3e4;async function follows(n,t,r=3){if(!this.ndk)throw new Error("NDK not set");const s=await this.ndk.fetchEvent({kinds:[r],authors:[this.pubkey]},n||{groupable:!1});if(s){const o=new Set;return s.tags.forEach(a=>{a[0]==="p"&&a[1]&&isValidPubkey(a[1])&&o.add(a[1])}),t&&this.ndk?.outboxTracker?.trackUsers(Array.from(o)),[...o].reduce((a,c)=>{const f=new NDKUser({pubkey:c});return f.ndk=this.ndk,a.add(f),a},new Set)}return new Set}var NIP05_REGEX=/^(?:([\w.+-]+)@)?([\w.-]+)$/;async function getNip05For(n,t,r=fetch,s={}){return await n.queuesNip05.add({id:t,func:async()=>{if(n.cacheAdapter?.loadNip05){const g=await n.cacheAdapter.loadNip05(t);if(g!=="missing"){if(g){const m=new NDKUser({pubkey:g.pubkey,relayUrls:g.relays,nip46Urls:g.nip46});return m.ndk=n,m}if(s.cache!=="no-cache")return null}}const o=t.match(NIP05_REGEX);if(!o)return null;const[a,c="_",f]=o;try{const g=await r(`https://${f}/.well-known/nostr.json?name=${c}`,s),{names:m,relays:b,nip46:k}=parseNIP05Result(await g.json()),_=m[c.toLowerCase()];let A=null;return _&&(A={pubkey:_,relays:b?.[_],nip46:k?.[_]}),n?.cacheAdapter?.saveNip05&&n.cacheAdapter.saveNip05(t,A),A}catch(g){return n?.cacheAdapter?.saveNip05&&n?.cacheAdapter.saveNip05(t,null),console.error("Failed to fetch NIP05 for",t,g),null}}})}function parseNIP05Result(n){const t={names:{}};for(const[r,s]of Object.entries(n.names))typeof r=="string"&&typeof s=="string"&&(t.names[r.toLowerCase()]=s);if(n.relays){t.relays={};for(const[r,s]of Object.entries(n.relays))typeof r=="string"&&Array.isArray(s)&&(t.relays[r]=s.filter(o=>typeof o=="string"))}if(n.nip46){t.nip46={};for(const[r,s]of Object.entries(n.nip46))typeof r=="string"&&Array.isArray(s)&&(t.nip46[r]=s.filter(o=>typeof o=="string"))}return t}function profileFromEvent(n){const t={};let r;try{r=JSON.parse(n.content)}catch(s){throw new Error(`Failed to parse profile event: ${s}`)}t.profileEvent=JSON.stringify(n.rawEvent());for(const s of Object.keys(r))switch(s){case"name":t.name=r.name;break;case"display_name":t.displayName=r.display_name;break;case"image":case"picture":t.picture=r.picture||r.image,t.image=t.picture;break;case"banner":t.banner=r.banner;break;case"bio":t.bio=r.bio;break;case"nip05":t.nip05=r.nip05;break;case"lud06":t.lud06=r.lud06;break;case"lud16":t.lud16=r.lud16;break;case"about":t.about=r.about;break;case"website":t.website=r.website;break;default:t[s]=r[s];break}return t.created_at=n.created_at,t}function serializeProfile(n){const t={};for(const[r,s]of Object.entries(n))switch(r){case"username":case"name":t.name=s;break;case"displayName":t.display_name=s;break;case"image":case"picture":t.picture=s;break;case"bio":case"about":t.about=s;break;default:t[r]=s;break}return JSON.stringify(t)}var NDKUser=class Zr{ndk;profile;profileEvent;_npub;_pubkey;relayUrls=[];nip46Urls=[];constructor(t){if(t.npub&&(this._npub=t.npub),t.hexpubkey&&(this._pubkey=t.hexpubkey),t.pubkey&&(this._pubkey=t.pubkey),t.relayUrls&&(this.relayUrls=t.relayUrls),t.nip46Urls&&(this.nip46Urls=t.nip46Urls),t.nprofile)try{const r=nip19_exports$1.decode(t.nprofile);r.type==="nprofile"&&(this._pubkey=r.data.pubkey,r.data.relays&&r.data.relays.length>0&&this.relayUrls.push(...r.data.relays))}catch(r){console.error("Failed to decode nprofile",r)}}get npub(){if(!this._npub){if(!this._pubkey)throw new Error("pubkey not set");this._npub=nip19_exports$1.npubEncode(this.pubkey)}return this._npub}get nprofile(){const t=this.profileEvent?.onRelays?.map(r=>r.url);return nip19_exports$1.nprofileEncode({pubkey:this.pubkey,relays:t})}set npub(t){this._npub=t}get pubkey(){if(!this._pubkey){if(!this._npub)throw new Error("npub not set");this._pubkey=nip19_exports$1.decode(this.npub).data}return this._pubkey}set pubkey(t){this._pubkey=t}filter(){return{"#p":[this.pubkey]}}async getZapInfo(t){if(!this.ndk)throw new Error("No NDK instance found");const r=async c=>{if(!t)return c;let f;const g=new Promise((m,b)=>{f=setTimeout(()=>b(new Error("Timeout")),t)});try{const m=await Promise.race([c,g]);return f&&clearTimeout(f),m}catch(m){if(m instanceof Error&&m.message==="Timeout")try{return await c}catch{return}return}},[s,o]=await Promise.all([r(this.fetchProfile()),r(this.ndk.fetchEvent({kinds:[10019],authors:[this.pubkey]}))]),a=new Map;if(o){const c=NDKCashuMintList.from(o);c.mints.length>0&&a.set("nip61",{mints:c.mints,relays:c.relays,p2pk:c.p2pk})}if(s){const{lud06:c,lud16:f}=s;a.set("nip57",{lud06:c,lud16:f})}return a}static async fromNip05(t,r,s=!1){if(!r)throw new Error("No NDK instance found");const o={};s&&(o.cache="no-cache");const a=await getNip05For(r,t,r?.httpFetch,o);if(a){const c=new Zr({pubkey:a.pubkey,relayUrls:a.relays,nip46Urls:a.nip46});return c.ndk=r,c}}async fetchProfile(t,r=!1){if(!this.ndk)throw new Error("NDK not set");let s=null;if(this.ndk.cacheAdapter&&(this.ndk.cacheAdapter.fetchProfile||this.ndk.cacheAdapter.fetchProfileSync)&&t?.cacheUsage!=="ONLY_RELAY"){let o=null;if(this.ndk.cacheAdapter.fetchProfileSync?o=this.ndk.cacheAdapter.fetchProfileSync(this.pubkey):this.ndk.cacheAdapter.fetchProfile&&(o=await this.ndk.cacheAdapter.fetchProfile(this.pubkey)),o)return this.profile=o,o}return t??={},t.cacheUsage??="ONLY_RELAY",t.closeOnEose??=!0,t.groupable??=!0,t.groupableDelay??=25,s||(s=await this.ndk.fetchEvent({kinds:[0],authors:[this.pubkey]},t)),s?(this.profile=profileFromEvent(s),r&&this.profile&&this.ndk.cacheAdapter&&this.ndk.cacheAdapter.saveProfile&&this.ndk.cacheAdapter.saveProfile(this.pubkey,this.profile),this.profile):null}follows=follows.bind(this);async followSet(t,r,s=3){const o=await this.follows(t,r,s);return new Set(Array.from(o).map(a=>a.pubkey))}tagReference(){return["p",this.pubkey]}referenceTags(t){const r=[["p",this.pubkey]];return t&&r[0].push("",t),r}async publish(){if(!this.ndk)throw new Error("No NDK instance found");if(!this.profile)throw new Error("No profile available");this.ndk.assertSigner(),await new NDKEvent(this.ndk,{kind:0,content:serializeProfile(this.profile)}).publish()}async follow(t,r,s=3){if(!this.ndk)throw new Error("No NDK instance found");this.ndk.assertSigner(),r||(r=await this.follows(void 0,void 0,s));const o=Array.isArray(t)?t:[t];let a=!1;for(const f of o){const g=typeof f=="string"?f:f.pubkey;Array.from(r).some(b=>typeof b=="string"?b===g:b.pubkey===g)||(r.add(f),a=!0)}if(!a)return!1;const c=new NDKEvent(this.ndk,{kind:s});for(const f of r)typeof f=="string"?c.tags.push(["p",f]):c.tag(f);return await c.publish(),!0}async unfollow(t,r,s=3){if(!this.ndk)throw new Error("No NDK instance found");this.ndk.assertSigner(),r||(r=await this.follows(void 0,void 0,s));const o=Array.isArray(t)?t:[t],a=new Set(o.map(m=>typeof m=="string"?m:m.pubkey)),c=new Set;let f=!1;for(const m of r){const b=typeof m=="string"?m:m.pubkey;a.has(b)?f=!0:c.add(m)}if(!f)return!1;const g=new NDKEvent(this.ndk,{kind:s});for(const m of c)typeof m=="string"?g.tags.push(["p",m]):g.tag(m);return await g.publish()}async validateNip05(t){if(!this.ndk)throw new Error("No NDK instance found");const r=await getNip05For(this.ndk,t);return r===null?null:r.pubkey===this.pubkey}},signerRegistry=new Map;function registerSigner(n,t){signerRegistry.set(n,t)}var NDKPrivateKeySigner=class pn{_user;_privateKey;_pubkey;constructor(t,r){if(typeof t=="string")if(t.startsWith("nsec1")){const{type:s,data:o}=nip19_exports$1.decode(t);if(s==="nsec")this._privateKey=o;else throw new Error("Invalid private key provided.")}else if(t.length===64)this._privateKey=hexToBytes$1(t);else throw new Error("Invalid private key provided.");else this._privateKey=t;this._pubkey=getPublicKey(this._privateKey),r&&(this._user=r.getUser({pubkey:this._pubkey})),this._user??=new NDKUser({pubkey:this._pubkey})}get privateKey(){if(!this._privateKey)throw new Error("Not ready");return bytesToHex$1(this._privateKey)}get pubkey(){if(!this._pubkey)throw new Error("Not ready");return this._pubkey}get nsec(){if(!this._privateKey)throw new Error("Not ready");return nip19_exports$1.nsecEncode(this._privateKey)}get npub(){if(!this._pubkey)throw new Error("Not ready");return nip19_exports$1.npubEncode(this._pubkey)}encryptToNcryptsec(t,r=16,s=2){if(!this._privateKey)throw new Error("Private key not available");return encrypt$1(this._privateKey,t,r,s)}static generate(){const t=generateSecretKey();return new pn(t)}static fromNcryptsec(t,r,s){const o=decrypt$1(t,r);return new pn(o,s)}async blockUntilReady(){return this._user}async user(){return this._user}get userSync(){return this._user}async sign(t){if(!this._privateKey)throw Error("Attempted to sign without a private key");return finalizeEvent(t,this._privateKey).sig}async encryptionEnabled(t){const r=[];return(!t||t==="nip04")&&r.push("nip04"),(!t||t==="nip44")&&r.push("nip44"),r}async encrypt(t,r,s){if(!this._privateKey||!this.privateKey)throw Error("Attempted to encrypt without a private key");const o=t.pubkey;if(s==="nip44"){const a=nip44_exports.v2.utils.getConversationKey(this._privateKey,o);return await nip44_exports.v2.encrypt(r,a)}return await nip04_exports.encrypt(this._privateKey,o,r)}async decrypt(t,r,s){if(!this._privateKey||!this.privateKey)throw Error("Attempted to decrypt without a private key");const o=t.pubkey;if(s==="nip44"){const a=nip44_exports.v2.utils.getConversationKey(this._privateKey,o);return await nip44_exports.v2.decrypt(r,a)}return await nip04_exports.decrypt(this._privateKey,o,r)}toPayload(){if(!this._privateKey)throw new Error("Private key not available");const t={type:"private-key",payload:this.privateKey};return JSON.stringify(t)}static async fromPayload(t,r){const s=JSON.parse(t);if(s.type!=="private-key")throw new Error(`Invalid payload type: expected 'private-key', got ${s.type}`);if(!s.payload||typeof s.payload!="string")throw new Error("Invalid payload content for private-key signer");return new pn(s.payload,r)}};registerSigner("private-key",NDKPrivateKeySigner);async function giftWrap(n,t,r,s={}){let o=r;if(s.scheme??="nip44",!o){if(!n.ndk)throw new Error("no signer available for giftWrap");o=n.ndk.signer}if(!o)throw new Error("no signer");if(!o.encryptionEnabled||!o.encryptionEnabled(s.scheme))throw new Error("signer is not able to giftWrap");if(!n.pubkey){const g=await o.user();n.pubkey=g.pubkey}n.sig&&console.warn(" NIP-17 Warning: Rumor event should not be signed. The signature will be removed during gift wrapping.");const a=getRumorEvent(n,s?.rumorKind),c=await getSealEvent(a,t,o,s.scheme),f=await getWrapEvent(c,t,s);return new NDKEvent(n.ndk,f)}async function giftUnwrap(n,t,r,s="nip44"){if(n.ndk?.cacheAdapter?.getDecryptedEvent){const c=await n.ndk.cacheAdapter.getDecryptedEvent(n.id);if(c)return c}const o=new NDKUser({pubkey:n.pubkey}),a=r||n.ndk?.signer;if(!a)throw new Error("no signer");try{const c=JSON.parse(await a.decrypt(o,n.content,s));if(!c)throw new Error("Failed to decrypt wrapper");if(!new NDKEvent(void 0,c).verifySignature(!1))throw new Error("GiftSeal signature verification failed!");const f=new NDKUser({pubkey:c.pubkey}),g=JSON.parse(await a.decrypt(f,c.content,s));if(!g)throw new Error("Failed to decrypt seal");if(g.pubkey!==c.pubkey)throw new Error("Invalid GiftWrap, sender validation failed!");const m=new NDKEvent(n.ndk,g);return n.ndk?.cacheAdapter?.addDecryptedEvent&&await n.ndk.cacheAdapter.addDecryptedEvent(n.id,m),m}catch{return Promise.reject("Got error unwrapping event! See console log.")}}function getRumorEvent(n,t){const r=n.rawEvent();return r.kind=t||r.kind||14,r.sig=void 0,r.id=getEventHash$1(r),new NDKEvent(n.ndk,r)}async function getSealEvent(n,t,r,s="nip44"){const o=new NDKEvent(n.ndk);return o.kind=13,o.created_at=approximateNow(5),o.content=JSON.stringify(n.rawEvent()),await o.encrypt(t,r,s),await o.sign(r),o}async function getWrapEvent(n,t,r,s="nip44"){const o=NDKPrivateKeySigner.generate(),a=new NDKEvent(n.ndk);return a.kind=1059,a.created_at=approximateNow(5),r?.wrapTags&&(a.tags=r.wrapTags),a.tag(t),a.content=JSON.stringify(n.rawEvent()),await a.encrypt(t,o,s),await a.sign(o),a}function approximateNow(n=0){return Math.round(Date.now()/1e3-Math.random()*10**n)}function proofsTotalBalance(n){return n.reduce((t,r)=>{if(r.amount<0)throw new Error("proof amount is negative");return t+r.amount},0)}var NDKCashuToken=class Jr extends NDKEvent{_proofs=[];_mint;static kind=7375;static kinds=[7375];_deletes=[];original;constructor(t,r){super(t,r),this.kind??=7375}static async from(t){const r=new Jr(t.ndk,t);r.original=t;try{await r.decrypt()}catch{r.content=r.original.content}try{const s=JSON.parse(r.content);if(r.proofs=s.proofs,r.mint=s.mint??r.tagValue("mint"),r.deletedTokens=s.del??[],!Array.isArray(r.proofs))return}catch{return}return r}get proofs(){return this._proofs}set proofs(t){const r=new Set;this._proofs=t.filter(s=>r.has(s.C)?(console.warn("Passed in proofs had duplicates, ignoring",s.C),!1):s.amount<0?(console.warn("Invalid proof with negative amount",s),!1):(r.add(s.C),!0)).map(this.cleanProof)}cleanProof(t){return{id:t.id,amount:t.amount,C:t.C,secret:t.secret}}async toNostrEvent(t){if(!this.ndk)throw new Error("no ndk");if(!this.ndk.signer)throw new Error("no signer");const r={proofs:this.proofs.map(this.cleanProof),mint:this.mint,del:this.deletedTokens??[]};this.content=JSON.stringify(r);const s=await this.ndk.signer.user();return await this.encrypt(s,void 0,"nip44"),super.toNostrEvent(t)}set mint(t){this._mint=t}get mint(){return this._mint}get deletedTokens(){return this._deletes}set deletedTokens(t){this._deletes=t}get amount(){return proofsTotalBalance(this.proofs)}async publish(t,r,s){return this.original?this.original.publish(t,r,s):super.publish(t,r,s)}},MARKERS={REDEEMED:"redeemed",CREATED:"created",DESTROYED:"destroyed",RESERVED:"reserved"},NDKCashuWalletTx=class Qr extends NDKEvent{static MARKERS=MARKERS;static kind=7376;static kinds=[7376];constructor(t,r){super(t,r),this.kind??=7376}static async from(t){const r=new Qr(t.ndk,t),s=r.content;try{await r.decrypt()}catch{r.content??=s}try{const o=JSON.parse(r.content);r.tags=[...o,...r.tags]}catch{return}return r}set direction(t){this.removeTag("direction"),t&&this.tags.push(["direction",t])}get direction(){return this.tagValue("direction")}set amount(t){this.removeTag("amount"),this.tags.push(["amount",t.toString()])}get amount(){const t=this.tagValue("amount");if(t!==void 0)return Number(t)}set fee(t){this.removeTag("fee"),this.tags.push(["fee",t.toString()])}get fee(){const t=this.tagValue("fee");if(t!==void 0)return Number(t)}set unit(t){this.removeTag("unit"),t&&this.tags.push(["unit",t.toString()])}get unit(){return this.tagValue("unit")}set description(t){this.removeTag("description"),t&&this.tags.push(["description",t.toString()])}get description(){return this.tagValue("description")}set mint(t){this.removeTag("mint"),t&&this.tags.push(["mint",t.toString()])}get mint(){return this.tagValue("mint")}set destroyedTokens(t){for(const r of t)this.tags.push(r.tagReference(MARKERS.DESTROYED))}set destroyedTokenIds(t){for(const r of t)this.tags.push(["e",r,"",MARKERS.DESTROYED])}set createdTokens(t){for(const r of t)this.tags.push(r.tagReference(MARKERS.CREATED))}set reservedTokens(t){for(const r of t)this.tags.push(r.tagReference(MARKERS.RESERVED))}addRedeemedNutzap(t){this.tag(t,MARKERS.REDEEMED)}async toNostrEvent(t){const r=[],s=[];for(const a of this.tags)this.shouldEncryptTag(a)?r.push(a):s.push(a);this.tags=s.filter(a=>a[0]!=="client"),this.content=JSON.stringify(r);const o=await this.ndk?.signer?.user();if(o){const a=o.pubkey;this.tags=this.tags.filter(c=>c[0]!=="p"||c[1]!==a)}return await this.encrypt(o,void 0,"nip44"),super.toNostrEvent(t)}get hasNutzapRedemption(){return this.getMatchingTags("e",MARKERS.REDEEMED).length>0}shouldEncryptTag(t){return!(["client"].includes(t[0])||t[0]==="e"&&t[3]===MARKERS.REDEEMED||t[0]==="p")}},NDKInterestList=class es extends NDKEvent{static kind=10015;static kinds=[10015];constructor(t,r){super(t,r),this.kind??=10015}static from(t){return new es(t.ndk,t.rawEvent())}get interests(){return this.tags.filter(t=>t[0]==="t").map(t=>t[1]).filter(Boolean)}set interests(t){this.tags=this.tags.filter(r=>r[0]!=="t");for(const r of t)this.tags.push(["t",r])}addInterest(t){this.hasInterest(t)||this.tags.push(["t",t])}removeInterest(t){const r=this.tags.findIndex(s=>s[0]==="t"&&s[1]===t);r>=0&&this.tags.splice(r,1)}hasInterest(t){return this.tags.some(r=>r[0]==="t"&&r[1]===t)}get interestSetReferences(){return this.tags.filter(t=>t[0]==="a").map(t=>t[1]).filter(t=>t?.startsWith("30015:"))}};function zapInvoiceFromEvent(n){const t=n.getMatchingTags("description")[0],r=n.getMatchingTags("bolt11")[0];let s,o;if(!t||!r||!r[1])return null;try{let B=t[1];if(B.startsWith("%")&&(B=decodeURIComponent(B)),B==="")return null;o=JSON.parse(B),s=bolt11Exports.decode(r[1])}catch{return null}const a=s.sections.find(B=>B.name==="amount");if(!a)return null;const c=Number.parseInt(a.value);if(!c)return null;const f=o.content,g=o.pubkey,b=n.getMatchingTags("p")[0][1];let k=n.getMatchingTags("e")[0];k||(k=n.getMatchingTags("a")[0]);const _=k?k[1]:void 0;return{id:n.id,zapper:n.pubkey,zappee:g,zapped:b,zappedEvent:_,amount:c,comment:f}}function dedup(n,t){return n.created_at>t.created_at?n:t}async function getRelayListForUser(n,t){return(await getRelayListForUsers([n],t)).get(n)}async function getRelayListForUsers(n,t,r=!1,s=1e3,o){const a=t.outboxPool||t.pool,c=new Set;for(const _ of a.relays.values())c.add(_);if(o)for(const _ of o.values())for(const A of _){const B=a.getRelay(A,!0,!0);B&&c.add(B)}const f=new Map,g=new Map,m=new NDKRelaySet(c,t);if(t.cacheAdapter?.locking&&!r){const _=await t.fetchEvents({kinds:[3,10002],authors:Array.from(new Set(n))},{cacheUsage:"ONLY_CACHE",subId:"ndk-relay-list-fetch"});for(const A of _)A.kind===10002&&f.set(A.pubkey,NDKRelayList.from(A));for(const A of _)if(A.kind===3){if(f.has(A.pubkey))continue;const B=relayListFromKind3(t,A);B&&g.set(A.pubkey,B)}n=n.filter(A=>!f.has(A)&&!g.has(A))}if(n.length===0)return f;const b=new Map,k=new Map;return new Promise(_=>{let A=!1;(async()=>{const L={closeOnEose:!0,pool:a,groupable:!0,subId:"ndk-relay-list-fetch",addSinceFromCache:!0,relaySet:m};m&&(L.relaySet=m),t.subscribe({kinds:[3,10002],authors:n},L,{onEvent:re=>{if(re.kind===10002){const ze=b.get(re.pubkey);if(ze&&ze.created_at>re.created_at)return;b.set(re.pubkey,re)}else if(re.kind===3){const ze=k.get(re.pubkey);if(ze&&ze.created_at>re.created_at)return;k.set(re.pubkey,re)}},onEose:()=>{if(!A){A=!0,t.debug(`[getRelayListForUsers] EOSE - relayListEvents: ${b.size}, contactListEvents: ${k.size}`);for(const re of b.values())f.set(re.pubkey,NDKRelayList.from(re));for(const re of n){if(f.has(re))continue;const ze=k.get(re);if(!ze)continue;const se=relayListFromKind3(t,ze);se&&f.set(re,se)}t.debug(`[getRelayListForUsers] Returning ${f.size} relay lists for ${n.length} pubkeys`),_(f)}}});const Z=Array.from(c).some(re=>re.status<=2),ve=Array.from(c).some(re=>re.status===4);let We=s;(Z||ve)&&(We=s+3e3),t.debug(`[getRelayListForUsers] Setting fallback timeout to ${We}ms (disconnected: ${Z}, connecting: ${ve})`,{pubkeys:n}),setTimeout(()=>{A||(A=!0,t.debug(`[getRelayListForUsers] Timeout reached, returning ${f.size} relay lists`),_(f))},We)})()})}var OutboxItem=class{type;relayUrlScores;readRelays;writeRelays;constructor(n){this.type=n,this.relayUrlScores=new Map,this.readRelays=new Set,this.writeRelays=new Set}},OutboxTracker=class extends libExports.EventEmitter{data;ndk;debug;constructor(n){super(),this.ndk=n,this.debug=n.debug.extend("outbox-tracker"),this.data=new distExports.LRUCache({maxSize:1e5,entryExpirationTimeInMS:120*1e3})}async trackUsers(n,t=!1){const r=[];for(let s=0;s<n.length;s+=400){const o=n.slice(s,s+400),a=o.map(f=>getKeyFromItem(f)).filter(f=>!this.data.has(f));if(a.length===0)continue;for(const f of a)this.data.set(f,new OutboxItem("user"));const c=new Map;for(const f of o)f instanceof NDKUser&&f.relayUrls.length>0&&c.set(f.pubkey,f.relayUrls);r.push(new Promise(f=>{getRelayListForUsers(a,this.ndk,t,1e3,c).then(g=>{this.debug(`Received relay lists for ${g.size} pubkeys out of ${a.length} requested`);for(const[m,b]of g){let k=this.data.get(m);if(k??=new OutboxItem("user"),b){if(k.readRelays=new Set(normalize(b.readRelayUrls)),k.writeRelays=new Set(normalize(b.writeRelayUrls)),this.ndk.relayConnectionFilter){for(const _ of k.readRelays)this.ndk.relayConnectionFilter(_)||k.readRelays.delete(_);for(const _ of k.writeRelays)this.ndk.relayConnectionFilter(_)||k.writeRelays.delete(_)}this.data.set(m,k),this.emit("user:relay-list-updated",m,k),this.debug(`Adding ${k.readRelays.size} read relays and ${k.writeRelays.size} write relays for ${m}`,b?.rawEvent())}}}).finally(f)}))}return Promise.all(r)}track(n,t,r=!0){const s=getKeyFromItem(n);t??=getTypeFromItem(n);let o=this.data.get(s);return o||(o=new OutboxItem(t),n instanceof NDKUser&&this.trackUsers([n])),o}};function getKeyFromItem(n){return n instanceof NDKUser?n.pubkey:n}function getTypeFromItem(n){return n instanceof NDKUser?"user":"kind"}function correctRelaySet(n,t){const r=t.connectedRelays();if(!Array.from(n.relays).some(o=>r.map(a=>a.url).includes(o.url)))for(const o of r)n.addRelay(o);if(r.length===0)for(const o of t.relays.values())n.addRelay(o);return n}var NDKSubscriptionManager=class{subscriptions;seenEvents=new distExports.LRUCache({maxSize:1e4,entryExpirationTimeInMS:300*1e3});constructor(){this.subscriptions=new Map}add(n){this.subscriptions.set(n.internalId,n),n.onStopped,n.onStopped=()=>{this.subscriptions.delete(n.internalId)},n.on("close",()=>{this.subscriptions.delete(n.internalId)})}seenEvent(n,t){const r=this.seenEvents.get(n)||[];r.some(s=>s.url===t.url)||r.push(t),this.seenEvents.set(n,r)}dispatchEvent(n,t,r=!1){t&&this.seenEvent(n.id,t);const s=this.subscriptions.values(),o=[];for(const a of s)matchFilters(a.filters,n)&&o.push(a);for(const a of o){if(a.exclusiveRelay&&a.relaySet){let c=!1;if(r?c=!a.skipOptimisticPublishEvent:t?c=a.relaySet.relays.has(t):c=(this.seenEvents.get(n.id)||[]).some(g=>a.relaySet.relays.has(g)),!c){a.debug.extend("exclusive-relay")("Rejected event %s from %s (relay not in exclusive set)",n.id,t?.url||(r?"optimistic":"cache"));continue}}a.eventReceived(n,t,!1,r)}}},debug6=debug$1("ndk:active-user");async function getUserRelayList(n){if(!this.autoConnectUserRelays)return;const t=await getRelayListForUser(n.pubkey,this);if(t){for(const r of t.relays){let s=this.pool.relays.get(r);s||(s=new NDKRelay(r,this.relayAuthDefaultPolicy,this),this.pool.addRelay(s))}return debug6("Connected to %d user relays",t.relays.length),t}}async function setActiveUser(n){if(!this.autoConnectUserRelays)return;const t=this.outboxPool||this.pool;t.connectedRelays.length>0?await getUserRelayList.call(this,n):t.once("connect",async()=>{await getUserRelayList.call(this,n)})}function getEntity(n){try{const t=nip19_exports$1.decode(n);return t.type==="npub"?npub(this,t.data):t.type==="nprofile"?nprofile(this,t.data):t}catch{return null}}function npub(n,t){return n.getUser({pubkey:t})}function nprofile(n,t){const r=n.getUser({pubkey:t.pubkey});return t.relays&&(r.relayUrls=t.relays),r}function isValidHint(n){if(!n||n==="")return!1;try{return new URL(n),!0}catch{return!1}}async function fetchEventFromTag(n,t,r,s={type:"timeout"}){const o=this.debug.extend("fetch-event-from-tag"),[a,c,f]=n;r={},o("fetching event from tag",n,r,s);const g=getRelaysForSync(this,t.pubkey);if(g&&g.size>0){o("fetching event from author relays %o",Array.from(g));const L=NDKRelaySet.fromRelayUrls(Array.from(g),this),Z=await this.fetchEvent(c,r,L);if(Z)return Z}else o("no author relays found for %s",t.pubkey,t);const m=calculateRelaySetsFromFilters(this,[{ids:[c]}],this.pool);o("fetching event without relay hint",m);const b=await this.fetchEvent(c,r);if(b)return b;if(f&&f!==""){const L=await this.fetchEvent(c,r,this.pool.getRelay(f,!0,!0,[{ids:[c]}]));if(L)return L}let k;const _=isValidHint(f)?this.pool.getRelay(f,!1,!0,[{ids:[c]}]):void 0,A=new Promise(L=>{this.fetchEvent(c,r,_).then(L)});if(!isValidHint(f)||s.type==="none")return A;const B=new Promise(async L=>{const Z=s.relaySet,ve=s.timeout??1500,We=new Promise(re=>setTimeout(re,ve));if(s.type==="timeout"&&await We,k)L(k);else{o("fallback fetch triggered");const re=await this.fetchEvent(c,r,Z);L(re)}});switch(s.type){case"timeout":return Promise.race([A,B]);case"eose":return k=await A,k||B}}var Queue=class{queue=[];maxConcurrency;processing=new Set;promises=new Map;constructor(n,t){this.maxConcurrency=t}add(n){if(this.promises.has(n.id))return this.promises.get(n.id);const t=new Promise((r,s)=>{this.queue.push({...n,func:()=>n.func().then(o=>(r(o),o),o=>{throw s(o),o})}),this.process()});return this.promises.set(n.id,t),t.finally(()=>{this.promises.delete(n.id),this.processing.delete(n.id),this.process()}),t}process(){if(this.processing.size>=this.maxConcurrency||this.queue.length===0)return;const n=this.queue.shift();!n||this.processing.has(n.id)||(this.processing.add(n.id),n.func())}clear(){this.queue=[]}clearProcessing(){this.processing.clear()}clearAll(){this.clear(),this.clearProcessing()}length(){return this.queue.length}},DEFAULT_OUTBOX_RELAYS=["wss://purplepag.es/","wss://nos.lol/"],NDK=class extends libExports.EventEmitter{_explicitRelayUrls;pool;outboxPool;_signer;_activeUser;cacheAdapter;debug;devWriteRelaySet;outboxTracker;muteFilter;relayConnectionFilter;clientName;clientNip89;queuesZapConfig;queuesNip05;asyncSigVerification=!1;initialValidationRatio=1;lowestValidationRatio=.1;validationRatioFn;filterValidationMode="validate";subManager;aiGuardrails;futureTimestampGrace;_signatureVerificationFunction;_signatureVerificationWorker;signatureVerificationTimeMs=0;publishingFailureHandled=!1;pools=[];relayAuthDefaultPolicy;httpFetch;netDebug;autoConnectUserRelays=!0;_wallet;walletConfig;constructor(n={}){super(),this.debug=n.debug||debug$1("ndk"),this.netDebug=n.netDebug,this._explicitRelayUrls=n.explicitRelayUrls||[],this.subManager=new NDKSubscriptionManager,this.pool=new NDKPool(n.explicitRelayUrls||[],this),this.pool.name="Main",this.pool.on("relay:auth",async(t,r)=>{this.relayAuthDefaultPolicy&&await this.relayAuthDefaultPolicy(t,r)}),this.autoConnectUserRelays=n.autoConnectUserRelays??!0,this.clientName=n.clientName,this.clientNip89=n.clientNip89,this.relayAuthDefaultPolicy=n.relayAuthDefaultPolicy,n.enableOutboxModel!==!1&&(this.outboxPool=new NDKPool(n.outboxRelayUrls||DEFAULT_OUTBOX_RELAYS,this,{debug:this.debug.extend("outbox-pool"),name:"Outbox Pool"}),this.outboxTracker=new OutboxTracker(this),this.outboxTracker.on("user:relay-list-updated",(t,r)=>{this.debug(`Outbox relay list updated for ${t}`);for(const s of this.subManager.subscriptions.values())s.filters.some(a=>a.authors?.includes(t))&&typeof s.refreshRelayConnections=="function"&&(this.debug(`Refreshing relay connections for subscription ${s.internalId}`),s.refreshRelayConnections())})),this.signer=n.signer,this.cacheAdapter=n.cacheAdapter,this.muteFilter=n.muteFilter,this.relayConnectionFilter=n.relayConnectionFilter,n.devWriteRelayUrls&&(this.devWriteRelaySet=NDKRelaySet.fromRelayUrls(n.devWriteRelayUrls,this)),this.queuesZapConfig=new Queue("zaps",3),this.queuesNip05=new Queue("nip05",10),n.signatureVerificationWorker&&(this.signatureVerificationWorker=n.signatureVerificationWorker),n.signatureVerificationFunction&&(this.signatureVerificationFunction=n.signatureVerificationFunction),this.initialValidationRatio=n.initialValidationRatio||1,this.lowestValidationRatio=n.lowestValidationRatio||.1,this.validationRatioFn=n.validationRatioFn||this.defaultValidationRatioFn,this.filterValidationMode=n.filterValidationMode||"validate",this.aiGuardrails=new AIGuardrails(n.aiGuardrails||!1),this.futureTimestampGrace=n.futureTimestampGrace,this.aiGuardrails.ndkInstantiated(this);try{this.httpFetch=fetch}catch{}}set explicitRelayUrls(n){this._explicitRelayUrls=n.map(normalizeRelayUrl),this.pool.relayUrls=n}get explicitRelayUrls(){return this._explicitRelayUrls||[]}set signatureVerificationWorker(n){this._signatureVerificationWorker=n,n?(signatureVerificationInit(n),this.asyncSigVerification=!0):this.asyncSigVerification=!1}set signatureVerificationFunction(n){this._signatureVerificationFunction=n,this.asyncSigVerification=!!n}get signatureVerificationFunction(){return this._signatureVerificationFunction}addExplicitRelay(n,t,r=!0){let s;return typeof n=="string"?s=new NDKRelay(n,t,this):s=n,this.pool.addRelay(s,r),this.explicitRelayUrls?.push(s.url),s}toJSON(){return{relayCount:this.pool.relays.size}.toString()}get activeUser(){return this._activeUser}set activeUser(n){const t=this._activeUser?.pubkey!==n?.pubkey;this._activeUser=n,t&&this.emit("activeUser:change",n),n&&t&&setActiveUser.call(this,n)}get signer(){return this._signer}set signer(n){this._signer=n,n&&this.emit("signer:ready",n),n?.user().then(t=>{t.ndk=this,this.activeUser=t})}async connect(n){this._signer&&this.autoConnectUserRelays&&(this.debug("Attempting to connect to user relays specified by signer %o",await this._signer.relays?.(this)),this._signer.relays&&(await this._signer.relays(this)).forEach(s=>this.pool.addRelay(s)));const t=[this.pool.connect(n)];return this.outboxPool&&t.push(this.outboxPool.connect(n)),this.cacheAdapter?.initializeAsync&&t.push(this.cacheAdapter.initializeAsync(this)),Promise.allSettled(t).then(()=>{})}reportInvalidSignature(n,t){this.debug(`Invalid signature detected for event ${n.id}${t?` from relay ${t.url}`:""}`),this.emit("event:invalid-sig",n,t)}defaultValidationRatioFn(n,t,r){if(t<10)return this.initialValidationRatio;const s=Math.min(t/100,1),o=this.initialValidationRatio*(1-s)+this.lowestValidationRatio*s;return Math.max(o,this.lowestValidationRatio)}getUser(n){if(typeof n=="string")if(n.startsWith("npub1")){const{type:r,data:s}=nip19_exports$1.decode(n);if(r!=="npub")throw new Error(`Invalid npub: ${n}`);return this.getUser({pubkey:s})}else if(n.startsWith("nprofile1")){const{type:r,data:s}=nip19_exports$1.decode(n);if(r!=="nprofile")throw new Error(`Invalid nprofile: ${n}`);return this.getUser({pubkey:s.pubkey,relayUrls:s.relays})}else return this.getUser({pubkey:n});const t=new NDKUser(n);return t.ndk=this,t}async getUserFromNip05(n,t=!1){return NDKUser.fromNip05(n,this,t)}async fetchUser(n,t=!1){if(isValidNip05(n))return NDKUser.fromNip05(n,this,t);if(n.startsWith("npub1")){const{type:r,data:s}=nip19_exports$1.decode(n);if(r!=="npub")throw new Error(`Invalid npub: ${n}`);const o=new NDKUser({pubkey:s});return o.ndk=this,o}else if(n.startsWith("nprofile1")){const{type:r,data:s}=nip19_exports$1.decode(n);if(r!=="nprofile")throw new Error(`Invalid nprofile: ${n}`);const o=new NDKUser({pubkey:s.pubkey,relayUrls:s.relays});return o.ndk=this,o}else{const r=new NDKUser({pubkey:n});return r.ndk=this,r}}subscribe(n,t,r=!0,s=!0){let o=t?.relaySet,a=s;r instanceof NDKRelaySet?(console.warn("relaySet is deprecated, use opts.relaySet instead. This will be removed in version v2.14.0"),o=r,a=s):(typeof r=="boolean"||typeof r=="object")&&(a=r);const c={relaySet:o,...t};a&&typeof a=="object"&&(a.onEvent&&(c.onEvent=a.onEvent),a.onEose&&(c.onEose=a.onEose),a.onClose&&(c.onClose=a.onClose),a.onEvents&&(c.onEvents=a.onEvents));const f=new NDKSubscription(this,n,c);this.subManager.add(f),this.aiGuardrails?.subscription?.created(Array.isArray(n)?n:[n],c);const g=f.pool;if(f.relaySet)for(const m of f.relaySet.relays)g.useTemporaryRelay(m,void 0,f.filters);if(this.outboxPool&&f.hasAuthorsFilter()){const m=f.filters.filter(b=>b.authors&&b.authors?.length>0).flatMap(b=>b.authors);this.outboxTracker?.trackUsers(m)}return a&&setTimeout(async()=>{this.cacheAdapter?.initializeAsync&&!this.cacheAdapter.ready&&await this.cacheAdapter.initializeAsync(this),f.start()},0),f}fetchEventFromTag=fetchEventFromTag.bind(this);fetchEventSync(n){if(!this.cacheAdapter)throw new Error("Cache adapter not set");let t;typeof n=="string"?t=[filterFromId(n)]:t=n;const r=new NDKSubscription(this,t),s=this.cacheAdapter.query(r);if(s instanceof Promise)throw new Error("Cache adapter is async");return s.map(o=>(o.ndk=this,o))}async fetchEvent(n,t,r){let s,o;if(r instanceof NDKRelay?o=new NDKRelaySet(new Set([r]),this):r instanceof NDKRelaySet&&(o=r),!r&&typeof n=="string"&&!isNip33AValue(n)){const a=relaysFromBech32(n,this);a.length>0&&(o=new NDKRelaySet(new Set(a),this),o=correctRelaySet(o,this.pool))}if(typeof n=="string"?s=[filterFromId(n)]:Array.isArray(n)?s=n:s=[n],typeof n!="string"&&this.aiGuardrails?.ndk?.fetchingEvents(s),s.length===0)throw new Error(`Invalid filter: ${JSON.stringify(n)}`);return new Promise((a,c)=>{let f=null;const g=_=>{_.ndk=this,_.isReplaceable()?(!f||f.created_at<_.created_at)&&(f=_):(clearTimeout(k),b?.stop(),this.aiGuardrails._nextCallDisabled=null,a(_))},m={...t||{},closeOnEose:!0,onEvents:_=>{for(const A of _)g(A)},onEvent:_=>{g(_)},onEose:()=>{clearTimeout(k),this.aiGuardrails._nextCallDisabled=null,a(f)}};o&&(m.relaySet=o);let b;const k=setTimeout(()=>{b.stop(),this.aiGuardrails._nextCallDisabled=null,a(f)},1e4);b=this.subscribe(s,m)})}async fetchEvents(n,t,r){return this.aiGuardrails?.ndk?.fetchingEvents(n,t),new Promise(s=>{const o=new Map,a=f=>{let g;f instanceof NDKEvent?g=f:g=new NDKEvent(void 0,f);const m=g.deduplicationKey(),b=o.get(m);b&&(g=dedup(b,g)),g.ndk=this,o.set(m,g)},c={...t||{},closeOnEose:!0,onEvents:f=>{for(const g of f)a(g)},onEvent:a,onEose:()=>{this.aiGuardrails._nextCallDisabled=null,s(new Set(o.values()))}};r&&(c.relaySet=r),this.subscribe(n,c)})}assertSigner(){if(!this.signer)throw this.emit("signer:required"),new Error("Signer required")}getEntity=getEntity.bind(this);guardrailOff(n){return n?typeof n=="string"?this.aiGuardrails._nextCallDisabled=new Set([n]):this.aiGuardrails._nextCallDisabled=new Set(n):this.aiGuardrails._nextCallDisabled="all",this}set wallet(n){if(!n){this._wallet=void 0,this.walletConfig=void 0;return}this._wallet=n,this.walletConfig??={},this.walletConfig.lnPay=n?.lnPay?.bind(n),this.walletConfig.cashuPay=n?.cashuPay?.bind(n)}get wallet(){return this._wallet}},nip19_exports={};__reExport(nip19_exports,nip19_star);var nip49_exports={};__reExport(nip49_exports,nip49_star);function disconnect(n,t){return t??=debug$1("ndk:relay:auth-policies:disconnect"),async r=>{t?.(`Relay ${r.url} requested authentication, disconnecting`),n.removeRelay(r.url)}}async function signAndAuth(n,t,r,s,o,a){try{await n.sign(r),o(n)}catch(c){s?.(`Failed to publish auth event to relay ${t.url}`,c),a(n)}}function signIn({ndk:n,signer:t,debug:r}={}){return r??=debug$1("ndk:auth-policies:signIn"),async(s,o)=>{r?.(`Relay ${s.url} requested authentication, signing in`);const a=new NDKEvent(n);return a.kind=22242,a.tags=[["relay",s.url],["challenge",o]],t??=n?.signer,new Promise(async(c,f)=>{t?await signAndAuth(a,s,t,r,c,f):n?.once("signer:ready",async g=>{await signAndAuth(a,s,g,r,c,f)})})}}var NDKRelayAuthPolicies={disconnect,signIn};async function ndkSignerFromPayload(n,t){let r;try{r=JSON.parse(n)}catch(o){console.error("Failed to parse signer payload string",n,o);return}if(!r||typeof r.type!="string"){console.error("Failed to parse signer payload string",n,new Error("Missing type field"));return}const s=signerRegistry.get(r.type);if(!s)throw new Error(`Unknown signer type: ${r.type}`);try{return await s.fromPayload(n,t)}catch(o){const a=o instanceof Error?o.message:String(o);throw new Error(`Failed to deserialize signer type ${r.type}: ${a}`)}}var NDKNip07Signer=class ts{_userPromise;encryptionQueue=[];encryptionProcessing=!1;debug;waitTimeout;_pubkey;ndk;_user;constructor(t=1e3,r){this.debug=debug$1("ndk:nip07"),this.waitTimeout=t,this.ndk=r}get pubkey(){if(!this._pubkey)throw new Error("Not ready");return this._pubkey}async blockUntilReady(){await this.waitForExtension();const t=await window.nostr?.getPublicKey();if(!t)throw new Error("User rejected access");this._pubkey=t;let r;return this.ndk?r=this.ndk.getUser({pubkey:t}):r=new NDKUser({pubkey:t}),this._user=r,r}async user(){return this._userPromise||(this._userPromise=this.blockUntilReady()),this._userPromise}get userSync(){if(!this._user)throw new Error("User not ready");return this._user}async sign(t){await this.waitForExtension();const r=await window.nostr?.signEvent(t);if(!r)throw new Error("Failed to sign event");return r.sig}async relays(t){await this.waitForExtension();const r=await window.nostr?.getRelays?.()||{},s=[];for(const o of Object.keys(r))r[o].read&&r[o].write&&s.push(o);return s.map(o=>new NDKRelay(o,t?.relayAuthDefaultPolicy,t))}async encryptionEnabled(t){const r=[];return(!t||t==="nip04")&&window.nostr?.nip04&&r.push("nip04"),(!t||t==="nip44")&&window.nostr?.nip44&&r.push("nip44"),r}async encrypt(t,r,s="nip04"){if(!await this.encryptionEnabled(s))throw new Error(`${s}encryption is not available from your browser extension`);await this.waitForExtension();const o=t.pubkey;return this.queueEncryption(s,"encrypt",o,r)}async decrypt(t,r,s="nip04"){if(!await this.encryptionEnabled(s))throw new Error(`${s}encryption is not available from your browser extension`);await this.waitForExtension();const o=t.pubkey;return this.queueEncryption(s,"decrypt",o,r)}async queueEncryption(t,r,s,o){return new Promise((a,c)=>{this.encryptionQueue.push({scheme:t,method:r,counterpartyHexpubkey:s,value:o,resolve:a,reject:c}),this.encryptionProcessing||this.processEncryptionQueue()})}async processEncryptionQueue(t,r=0){if(!t&&this.encryptionQueue.length===0){this.encryptionProcessing=!1;return}this.encryptionProcessing=!0;const s=t||this.encryptionQueue.shift();if(!s){this.encryptionProcessing=!1;return}const{scheme:o,method:a,counterpartyHexpubkey:c,value:f,resolve:g,reject:m}=s;this.debug("Processing encryption queue item",{method:a,counterpartyHexpubkey:c,value:f});try{const b=await window.nostr?.[o]?.[a](c,f);if(!b)throw new Error("Failed to encrypt/decrypt");g(b)}catch(b){const k=b instanceof Error?b.message:String(b);if(k.includes("call already executing")&&r<5){this.debug("Retrying encryption queue item",{method:a,counterpartyHexpubkey:c,value:f,retries:r}),setTimeout(()=>{this.processEncryptionQueue(s,r+1)},50*r);return}m(b instanceof Error?b:new Error(k))}this.processEncryptionQueue()}waitForExtension(){return new Promise((t,r)=>{if(window.nostr){t();return}let s;const o=setInterval(()=>{window.nostr&&(clearTimeout(s),clearInterval(o),t())},100);s=setTimeout(()=>{clearInterval(o),r(new Error("NIP-07 extension not available"))},this.waitTimeout)})}toPayload(){return JSON.stringify({type:"nip07",payload:""})}static async fromPayload(t,r){const s=JSON.parse(t);if(s.type!=="nip07")throw new Error(`Invalid payload type: expected 'nip07', got ${s.type}`);return new ts(void 0,r)}};registerSigner("nip07",NDKNip07Signer);var NDKNostrRpc=class extends libExports.EventEmitter{ndk;signer;relaySet;debug;encryptionType="nip44";pool;constructor(n,t,r,s){if(super(),this.ndk=n,this.signer=t,s){this.pool=new NDKPool(s,n,{debug:r.extend("rpc-pool"),name:"Nostr RPC"}),this.relaySet=new NDKRelaySet(new Set,n,this.pool);for(const o of s){const a=this.pool.getRelay(o,!1,!1);a.authPolicy=NDKRelayAuthPolicies.signIn({ndk:n,signer:t,debug:r}),this.relaySet.addRelay(a),a.connect()}}this.debug=r.extend("rpc")}subscribe(n){return new Promise(t=>{const r=this.ndk.subscribe(n,{closeOnEose:!1,groupable:!1,cacheUsage:"ONLY_RELAY",pool:this.pool,relaySet:this.relaySet,onEvent:async s=>{try{const o=await this.parseEvent(s);o.method?this.emit("request",o):(this.emit(`response-${o.id}`,o),this.emit("response",o))}catch(o){this.debug("error parsing event",o,s.rawEvent())}},onEose:()=>{this.debug("eosed"),t(r)}})})}async parseEvent(n){this.encryptionType==="nip44"&&n.content.includes("?iv=")?this.encryptionType="nip04":this.encryptionType==="nip04"&&!n.content.includes("?iv=")&&(this.encryptionType="nip44");const t=this.ndk.getUser({pubkey:n.pubkey});t.ndk=this.ndk;let r;try{r=await this.signer.decrypt(t,n.content,this.encryptionType)}catch{const b=this.encryptionType==="nip04"?"nip44":"nip04";r=await this.signer.decrypt(t,n.content,b),this.encryptionType=b}const s=JSON.parse(r),{id:o,method:a,params:c,result:f,error:g}=s;return a?{id:o,pubkey:n.pubkey,method:a,params:c,event:n}:{id:o,result:f,error:g,event:n}}async sendResponse(n,t,r,s=24133,o){const a={id:n,result:r};o&&(a.error=o);const c=await this.signer.user(),f=this.ndk.getUser({pubkey:t}),g=new NDKEvent(this.ndk,{kind:s,content:JSON.stringify(a),tags:[["p",t]],pubkey:c.pubkey});g.content=await this.signer.encrypt(f,g.content,this.encryptionType),await g.sign(this.signer),await g.publish(this.relaySet)}async sendRequest(n,t,r=[],s=24133,o){const a=Math.random().toString(36).substring(7),c=await this.signer.user(),f=this.ndk.getUser({pubkey:n}),g={id:a,method:t,params:r},m=new Promise(()=>{const k=_=>{_.result==="auth_url"?(this.once(`response-${a}`,k),this.emit("authUrl",_.error)):o&&o(_)};this.once(`response-${a}`,k)}),b=new NDKEvent(this.ndk,{kind:s,content:JSON.stringify(g),tags:[["p",n]],pubkey:c.pubkey});return b.content=await this.signer.encrypt(f,b.content,this.encryptionType),await b.sign(this.signer),await b.publish(this.relaySet),m}};function nostrConnectGenerateSecret(){return Math.random().toString(36).substring(2,15)}function generateNostrConnectUri(n,t,r,s){const o={name:s?.name?encodeURIComponent(s.name):"",url:s?.url?encodeURIComponent(s.url):"",image:s?.image?encodeURIComponent(s.image):"",perms:s?.perms?encodeURIComponent(s.perms):""};let a=`nostrconnect://${n}?image=${o.image}&url=${o.url}&name=${o.name}&perms=${o.perms}&secret=${encodeURIComponent(t)}`;return r&&(a+=`&relay=${encodeURIComponent(r)}`),a}var NDKNip46Signer=class gn extends libExports.EventEmitter{ndk;_user;bunkerPubkey;userPubkey;get pubkey(){if(!this.userPubkey)throw new Error("Not ready");return this.userPubkey}secret;localSigner;nip05;rpc;debug;relayUrls;subscription;nostrConnectUri;nostrConnectSecret;constructor(t,r,s,o,a){super(),this.ndk=t,this.debug=t.debug.extend("nip46:signer"),this.relayUrls=o,s?typeof s=="string"?this.localSigner=new NDKPrivateKeySigner(s):this.localSigner=s:this.localSigner=NDKPrivateKeySigner.generate(),r===!1||(r?r.startsWith("bunker://")?this.bunkerFlowInit(r):this.nip05Init(r):this.nostrconnectFlowInit(a)),this.rpc=new NDKNostrRpc(this.ndk,this.localSigner,this.debug,this.relayUrls)}static bunker(t,r,s){return new gn(t,r,s)}static nostrconnect(t,r,s,o){return new gn(t,void 0,s,[r],o)}nostrconnectFlowInit(t){this.nostrConnectSecret=nostrConnectGenerateSecret();const r=this.localSigner.pubkey;this.nostrConnectUri=generateNostrConnectUri(r,this.nostrConnectSecret,this.relayUrls?.[0],t)}bunkerFlowInit(t){const r=new URL(t),s=r.hostname||r.pathname.replace(/^\/\//,""),o=r.searchParams.get("pubkey"),a=r.searchParams.getAll("relay"),c=r.searchParams.get("secret");this.bunkerPubkey=s,this.userPubkey=o,this.relayUrls=a,this.secret=c}nip05Init(t){this.nip05=t}async startListening(){if(this.subscription)return;const t=await this.localSigner.user();if(!t)throw new Error("Local signer not ready");this.subscription=await this.rpc.subscribe({kinds:[24133],"#p":[t.pubkey]})}async user(){return this._user?this._user:this.blockUntilReady()}get userSync(){if(!this._user)throw new Error("Remote user not ready synchronously");return this._user}async blockUntilReadyNostrConnect(){return new Promise((t,r)=>{const s=o=>{o.result===this.nostrConnectSecret&&(this._user=o.event.author,this.userPubkey=o.event.pubkey,this.bunkerPubkey=o.event.pubkey,this.rpc.off("response",s),t(this._user))};this.startListening(),this.rpc.on("response",s)})}async blockUntilReady(){if(!this.bunkerPubkey&&!this.nostrConnectSecret&&!this.nip05)throw new Error("Bunker pubkey not set");if(this.nostrConnectSecret)return this.blockUntilReadyNostrConnect();if(this.nip05&&!this.userPubkey){const t=await NDKUser.fromNip05(this.nip05,this.ndk);t&&(this._user=t,this.userPubkey=t.pubkey,this.relayUrls=t.nip46Urls,this.rpc=new NDKNostrRpc(this.ndk,this.localSigner,this.debug,this.relayUrls))}if(!this.bunkerPubkey&&this.userPubkey)this.bunkerPubkey=this.userPubkey;else if(!this.bunkerPubkey)throw new Error("Bunker pubkey not set");return await this.startListening(),this.rpc.on("authUrl",(...t)=>{this.emit("authUrl",...t)}),new Promise((t,r)=>{const s=[this.userPubkey??""];if(this.secret&&s.push(this.secret),!this.bunkerPubkey)throw new Error("Bunker pubkey not set");this.rpc.sendRequest(this.bunkerPubkey,"connect",s,24133,o=>{o.result==="ack"?this.getPublicKey().then(a=>{this.userPubkey=a,this._user=this.ndk.getUser({pubkey:a}),t(this._user)}):r(o.error)})})}stop(){this.subscription?.stop(),this.subscription=void 0}async getPublicKey(){return this.userPubkey?this.userPubkey:new Promise((t,r)=>{if(!this.bunkerPubkey)throw new Error("Bunker pubkey not set");this.rpc.sendRequest(this.bunkerPubkey,"get_public_key",[],24133,s=>{t(s.result)})})}async encryptionEnabled(t){return t?[t]:Promise.resolve(["nip04","nip44"])}async encrypt(t,r,s="nip04"){return this.encryption(t,r,s,"encrypt")}async decrypt(t,r,s="nip04"){return this.encryption(t,r,s,"decrypt")}async encryption(t,r,s,o){return new Promise((c,f)=>{if(!this.bunkerPubkey)throw new Error("Bunker pubkey not set");this.rpc.sendRequest(this.bunkerPubkey,`${s}_${o}`,[t.pubkey,r],24133,g=>{g.error?f(g.error):c(g.result)})})}async sign(t){return new Promise((s,o)=>{if(!this.bunkerPubkey)throw new Error("Bunker pubkey not set");this.rpc.sendRequest(this.bunkerPubkey,"sign_event",[JSON.stringify(t)],24133,a=>{if(a.error)o(a.error);else{const c=JSON.parse(a.result);s(c.sig)}})})}async createAccount(t,r,s){await this.startListening();const o=[];return t&&o.push(t),r&&o.push(r),s&&o.push(s),new Promise((a,c)=>{if(!this.bunkerPubkey)throw new Error("Bunker pubkey not set");this.rpc.sendRequest(this.bunkerPubkey,"create_account",o,24133,f=>{if(f.error)c(f.error);else{const g=f.result;a(g)}})})}toPayload(){if(!this.bunkerPubkey||!this.userPubkey)throw new Error("NIP-46 signer is not fully initialized for serialization");const t={type:"nip46",payload:{bunkerPubkey:this.bunkerPubkey,userPubkey:this.userPubkey,relayUrls:this.relayUrls,secret:this.secret,localSignerPayload:this.localSigner.toPayload(),nip05:this.nip05||null}};return JSON.stringify(t)}static async fromPayload(t,r){if(!r)throw new Error("NDK instance is required to deserialize NIP-46 signer");const s=JSON.parse(t);if(s.type!=="nip46")throw new Error(`Invalid payload type: expected 'nip46', got ${s.type}`);const o=s.payload;if(!o||typeof o!="object"||!o.localSignerPayload)throw new Error("Invalid payload content for nip46 signer");const a=await ndkSignerFromPayload(o.localSignerPayload,r);if(!a)throw new Error("Failed to deserialize local signer for NIP-46");if(!(a instanceof NDKPrivateKeySigner))throw new Error("Local signer must be an instance of NDKPrivateKeySigner");let c;return c=new gn(r,!1,a,o.relayUrls),c.userPubkey=o.userPubkey,c.bunkerPubkey=o.bunkerPubkey,c.relayUrls=o.relayUrls,c.secret=o.secret,o.userPubkey&&(c._user=new NDKUser({pubkey:o.userPubkey}),c._user&&(c._user.ndk=r)),c}};registerSigner("nip46",NDKNip46Signer);var d2$2=debug$1("ndk:zapper:ln");async function getNip57ZapSpecFromLud({lud06:n,lud16:t},r){let s;if(t&&!t.startsWith("LNURL")){const[o,a]=t.split("@");s=`https://${a}/.well-known/lnurlp/${o}`}else if(n){const{words:o}=bech32.decode(n,1e3),a=bech32.fromWords(o);s=new TextDecoder("utf-8").decode(a)}if(!s)throw d2$2("No zap endpoint found %o",{lud06:n,lud16:t}),new Error("No zap endpoint found");try{const a=await(r.httpFetch||fetch)(s);if(a.status!==200){const c=await a.text();throw new Error(`Unable to fetch zap endpoint ${s}: ${c}`)}return await a.json()}catch(o){throw new Error(`Unable to fetch zap endpoint ${s}: ${o}`)}}async function generateZapRequest(n,t,r,s,o,a,c,f,g){const m=r.callback,b=new NDKEvent(t);if(b.kind=9734,b.content=c||"",b.tags=[["relays",...a.slice(0,4)],["amount",o.toString()],["lnurl",m],["p",s]],n instanceof NDKEvent){const B=n.referenceTags().filter(L=>L[0]!=="p");b.tags.push(...B),n.kind!==void 0&&b.tags.push(["k",n.kind.toString()])}f&&(b.tags=b.tags.concat(f));const k=new Set,_=new Set;for(const A of b.tags)A[0]==="e"?k.add(A[1]):A[0]==="a"&&_.add(A[1]);if(k.size>1)throw new Error("Only one e-tag is allowed");if(_.size>1)throw new Error("Only one a-tag is allowed");return b.tags=b.tags.filter(A=>A[0]!=="p"),b.tags.push(["p",s]),await b.sign(g),b}var d3=debug$1("ndk:zapper"),NDKZapper=class extends libExports.EventEmitter{target;ndk;comment;amount;unit;tags;signer;zapMethod;nutzapAsFallback;lnPay;cashuPay;onComplete;maxRelays=3;constructor(n,t,r="msat",s={}){if(super(),this.target=n,this.ndk=s.ndk||n.ndk,!this.ndk)throw new Error("No NDK instance provided");this.amount=t,this.comment=s.comment,this.unit=r,this.tags=s.tags,this.signer=s.signer,this.nutzapAsFallback=s.nutzapAsFallback??!1,this.lnPay=s.lnPay||this.ndk.walletConfig?.lnPay,this.cashuPay=s.cashuPay||this.ndk.walletConfig?.cashuPay,this.onComplete=s.onComplete||this.ndk.walletConfig?.onPaymentComplete}async zap(n){d3("Starting zap process",{target:this.target,amount:this.amount,unit:this.unit,methods:n,nutzapAsFallback:this.nutzapAsFallback});const t=this.getZapSplits();d3("Calculated zap splits",t);const r=new Map;await Promise.all(t.map(async a=>{let c;d3("Processing split",a);try{c=await this.zapSplit(a,n),d3("Split completed successfully",{split:a,result:c})}catch(f){d3("Split failed",{split:a,error:f.message}),c=new Error(f.message)}this.emit("split:complete",a,c),r.set(a,c)})),d3("All splits completed",r);const s=Array.from(r.values()).every(a=>a===void 0||a instanceof Error),o=Array.from(r.values()).some(a=>a instanceof Error);if(this.emit("complete",r),this.onComplete&&this.onComplete(r),s){const c=Array.from(r.values()).filter(f=>f instanceof Error).map(f=>f.message).join(", ")||"All zap attempts failed";throw d3("All splits failed",c),new Error(c)}return o&&d3("Some splits failed, but at least one succeeded"),r}async zapNip57(n,t){if(!this.lnPay)throw new Error("No lnPay function available");const r=await getNip57ZapSpecFromLud(t,this.ndk);if(!r)throw new Error("No zap spec available for recipient");const s=await this.relays(n.pubkey),o=await generateZapRequest(this.target,this.ndk,r,n.pubkey,n.amount,s,this.comment,this.tags,this.signer);if(!o)throw d3("Unable to generate zap request"),new Error("Unable to generate zap request");const a=await this.getLnInvoice(o,n.amount,r);if(!a)throw d3("Unable to get payment request"),new Error("Unable to get payment request");this.emit("ln_invoice",{amount:n.amount,recipientPubkey:n.pubkey,unit:this.unit,nip57ZapRequest:o,pr:a,type:"nip57"});const c=await this.lnPay({target:this.target,recipientPubkey:n.pubkey,paymentDescription:"NIP-57 Zap",pr:a,amount:n.amount,unit:this.unit,nip57ZapRequest:o});return c?.preimage&&this.emit("ln_payment",{preimage:c.preimage,amount:n.amount,recipientPubkey:n.pubkey,pr:a,unit:this.unit,nip57ZapRequest:o,type:"nip57"}),c}async zapNip61(n,t){if(d3("Starting NIP-61 zap",{split:n,data:t}),!this.cashuPay)throw d3("No cashuPay function available"),new Error("No cashuPay function available");const r=[];this.target instanceof NDKEvent&&r.push(["e",this.target.id]);const s=this.signer||this.ndk.signer;if(s){const a=await s.user();r.push(["P",a.pubkey])}d3("Calling cashuPay function",{target:this.target,recipientPubkey:n.pubkey,amount:n.amount,unit:this.unit,proofTags:r,data:t});let o;if(o=await this.cashuPay({target:this.target,recipientPubkey:n.pubkey,paymentDescription:"NIP-61 Zap",amount:n.amount,unit:this.unit,proofTags:r,...t??{}},a=>{d3("LN invoice generated for NIP-61",a),this.emit("ln_invoice",{pr:a,amount:n.amount,recipientPubkey:n.pubkey,unit:this.unit,type:"nip61"})}),d3("NIP-61 Zap result: %o",o),o instanceof Error)return d3("cashuPay returned error",o),o;if(o){const{proofs:a,mint:c}=o;if(!a||!c)throw d3("Invalid zap confirmation: missing proofs or mint",o),new Error(`Invalid zap confirmation: missing proofs or mint: ${o}`);d3("Creating nutzap event",{proofsCount:a.length,mint:c});const f=await this.relays(n.pubkey);d3("Publishing to relays",f);const g=NDKRelaySet.fromRelayUrls(f,this.ndk),m=new NDKNutzap(this.ndk);return m.tags=[...m.tags,...this.tags||[]],m.proofs=a,m.mint=c,m.target=this.target,m.comment=this.comment,m.unit="sat",m.recipientPubkey=n.pubkey,await m.sign(this.signer),d3("Nutzap signed, publishing",m.id),m.publish(g),m}d3("cashuPay returned undefined")}async zapSplit(n,t){d3("Starting zapSplit",{split:n,methods:t});const r=this.ndk.getUser({pubkey:n.pubkey});d3("Fetching zap info for recipient",r.pubkey);const s=await r.getZapInfo(2500);d3("Recipient zap methods",{methods:Array.from(s.keys()),nip61Data:s.get("nip61"),nip57Data:s.get("nip57")});let o;const a=this.nutzapAsFallback&&this.cashuPay;if(d3("Fallback configuration",{canFallbackToNip61:a,nutzapAsFallback:this.nutzapAsFallback,hasCashuPay:!!this.cashuPay}),s.size===0&&!a)throw d3("No zap methods available and fallback disabled"),new Error("No zap method available for recipient and NIP-61 fallback is disabled");const c=async()=>{if(d3("Executing NIP-61 fallback"),!this.nutzapAsFallback)return;let _=(await getRelayListForUsers([n.pubkey],this.ndk)).get(n.pubkey)?.readRelayUrls;return _=this.ndk.pool.connectedRelays().map(A=>A.url),d3("NIP-61 fallback relay URLs",_),await this.zapNip61(n,{relays:_,p2pk:n.pubkey,allowIntramintFallback:!!a})},f=!t||t.includes("nip61"),g=!t||t.includes("nip57");d3("Method filters",{canUseNip61:f,canUseNip57:g});const m=s.get("nip61");if(m&&f){d3("Attempting NIP-61 zap",m);try{if(o=await this.zapNip61(n,m),o instanceof NDKNutzap)return d3("NIP-61 zap succeeded",o),o}catch(k){d3("NIP-61 attempt failed",k),this.emit("notice",`NIP-61 attempt failed: ${k.message}`)}}const b=s.get("nip57");if(b&&g){d3("Attempting NIP-57 zap",b);try{if(o=await this.zapNip57(n,b),!(o instanceof Error))return d3("NIP-57 zap succeeded",o),o}catch(k){d3("NIP-57 attempt failed",k),this.emit("notice",`NIP-57 attempt failed: ${k.message}`)}}if(a){if(d3("Attempting NIP-61 fallback"),o=await c(),o instanceof Error)throw d3("NIP-61 fallback failed",o),o;return d3("NIP-61 fallback succeeded",o),o}if(d3("All zap methods exhausted"),this.emit("notice","Zap methods exhausted and there was no fallback to NIP-61"),o instanceof Error)throw o;return o}async getLnInvoice(n,t,r){const s=r.callback,o=JSON.stringify(n.rawEvent());d3(`Fetching invoice from ${s}?${new URLSearchParams({amount:t.toString(),nostr:o})}`);const a=new URL(s);a.searchParams.append("amount",t.toString()),a.searchParams.append("nostr",o),d3(`Fetching invoice from ${a.toString()}`);const c=await fetch(a.toString());if(d3(`Got response from zap endpoint: ${s}`,{status:c.status}),c.status!==200){d3(`Received non-200 status from zap endpoint: ${s}`,{status:c.status,amount:t,nostr:o});const g=await c.text();throw new Error(`Unable to fetch zap endpoint ${s}: ${g}`)}return(await c.json()).pr}getZapSplits(){if(this.target instanceof NDKUser)return[{pubkey:this.target.pubkey,amount:this.amount}];const n=this.target.getMatchingTags("zap");if(n.length===0)return[{pubkey:this.target.pubkey,amount:this.amount}];const t=[],r=n.reduce((s,o)=>s+Number.parseInt(o[2]),0);for(const s of n){const o=s[1],a=Math.floor(Number.parseInt(s[2])/r*this.amount);t.push({pubkey:o,amount:a})}return t}async getRecipientZapMethods(n=2500){const t=this.getZapSplits(),r=new Map;return await Promise.all(t.map(async s=>{const a=await this.ndk.getUser({pubkey:s.pubkey}).getZapInfo(n);r.set(s.pubkey,a)})),r}async getZapMethods(n,t,r=2500){return await n.getUser({pubkey:t}).getZapInfo(r)}async relays(n){let t=[];if(this.ndk?.activeUser){const r=await getRelayListForUsers([this.ndk.activeUser.pubkey,n],this.ndk),s=new Map;for(const o of r.values())for(const a of o.readRelayUrls){const c=s.get(a)||0;s.set(a,c+1)}t=Array.from(s.entries()).sort((o,a)=>a[1]-o[1]).map(([o])=>o).slice(0,this.maxRelays)}return this.ndk?.pool?.permanentAndConnectedRelays().length&&(t=this.ndk.pool.permanentAndConnectedRelays().map(r=>r.url)),t.length||(t=[]),t}};const index$1=Object.freeze(Object.defineProperty({__proto__:null,BECH32_REGEX,NDKAppHandlerEvent,NDKArticle,NDKBlossomList,NDKCashuMintAnnouncement,NDKCashuMintList,NDKCashuToken,NDKCashuWalletTx,NDKClassified,NDKDVMJobFeedback,NDKDraft,NDKEvent,NDKFedimintMint,NDKFollowPack,NDKHighlight,NDKImage,NDKInterestList,NDKKind,NDKList,NDKMintRecommendation,NDKNip07Signer,NDKNip46Signer,NDKNostrRpc,NDKNutzap,NDKPool,NDKPrivateKeySigner,NDKProject,NDKProjectTemplate,NDKPublishError,NDKRelay,NDKRelayAuthPolicies,NDKRelayFeedList,NDKRelayList,NDKRelaySet,NDKRelayStatus,NDKRepost,NDKSimpleGroupMemberList,NDKSimpleGroupMetadata,NDKStory,NDKStorySticker,NDKSubscription,NDKSubscriptionCacheUsage,NDKSubscriptionReceipt,NDKSubscriptionStart,NDKSubscriptionTier,NDKTask,NDKThread,NDKUser,NDKVideo,NDKWiki,NDKWikiMergeRequest,NDKZapper,NIP33_A_REGEX,calculateRelaySetFromEvent,createValidationIssue,default:NDK,defaultOpts,deserialize,eventHasETagMarkers,fetchRelayInformation,filterFingerprint,filterFromId,generateContentTags,generateHashtags,generateZapRequest,getNip57ZapSpecFromLud,getRelayListForUser,getRelayListForUsers,getReplyTag,getRootTag,giftUnwrap,giftWrap,imetaTagToTag,isNip33AValue,isValidHex64,isValidNip05,isValidPubkey,mapImetaTag,mergeFilters,mergeTags,ndkSignerFromPayload,newAmount,nip19:nip19_exports,nip49:nip49_exports,normalize,normalizeRelayUrl,normalizeUrl,parseTagToSubscriptionAmount,possibleIntervalFrequencies,processFilters,profileFromEvent,proofsTotalBalance,queryFullyFilled,registerSigner,relayListFromKind3,relaysFromBech32,serialize,serializeProfile,strToDimension,strToPosition,tryNormalizeRelayUrl,wrapEvent,zapInvoiceFromEvent},Symbol.toStringTag,{value:"Module"})),createStoreImpl=n=>{let t;const r=new Set,s=(m,b)=>{const k=typeof m=="function"?m(t):m;if(!Object.is(k,t)){const _=t;t=b??(typeof k!="object"||k===null)?k:Object.assign({},t,k),r.forEach(A=>A(t,_))}},o=()=>t,f={setState:s,getState:o,getInitialState:()=>g,subscribe:m=>(r.add(m),()=>r.delete(m))},g=t=n(s,o,f);return f},createStore=(n=>n?createStoreImpl(n):createStoreImpl),bytesToHex=bytesToHex$1,hexToBytes=hexToBytes$1;var fr={},G$1={};G$1.byteLength=Dr;G$1.toByteArray=Pr;G$1.fromByteArray=Wr;var S$1=[],R$1=[],br=typeof Uint8Array<"u"?Uint8Array:Array,z$1="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(var D$1=0,kr=z$1.length;D$1<kr;++D$1)S$1[D$1]=z$1[D$1],R$1[z$1.charCodeAt(D$1)]=D$1;R$1[45]=62;R$1[95]=63;function pr(n){var t=n.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var r=n.indexOf("=");r===-1&&(r=t);var s=r===t?0:4-r%4;return[r,s]}function Dr(n){var t=pr(n),r=t[0],s=t[1];return(r+s)*3/4-s}function $r(n,t,r){return(t+r)*3/4-r}function Pr(n){var t,r=pr(n),s=r[0],o=r[1],a=new br($r(n,s,o)),c=0,f=o>0?s-4:s,g;for(g=0;g<f;g+=4)t=R$1[n.charCodeAt(g)]<<18|R$1[n.charCodeAt(g+1)]<<12|R$1[n.charCodeAt(g+2)]<<6|R$1[n.charCodeAt(g+3)],a[c++]=t>>16&255,a[c++]=t>>8&255,a[c++]=t&255;return o===2&&(t=R$1[n.charCodeAt(g)]<<2|R$1[n.charCodeAt(g+1)]>>4,a[c++]=t&255),o===1&&(t=R$1[n.charCodeAt(g)]<<10|R$1[n.charCodeAt(g+1)]<<4|R$1[n.charCodeAt(g+2)]>>2,a[c++]=t>>8&255,a[c++]=t&255),a}function Or(n){return S$1[n>>18&63]+S$1[n>>12&63]+S$1[n>>6&63]+S$1[n&63]}function Gr(n,t,r){for(var s,o=[],a=t;a<r;a+=3)s=(n[a]<<16&16711680)+(n[a+1]<<8&65280)+(n[a+2]&255),o.push(Or(s));return o.join("")}function Wr(n){for(var t,r=n.length,s=r%3,o=[],a=16383,c=0,f=r-s;c<f;c+=a)o.push(Gr(n,c,c+a>f?f:c+a));return s===1?(t=n[r-1],o.push(S$1[t>>2]+S$1[t<<4&63]+"==")):s===2&&(t=(n[r-2]<<8)+n[r-1],o.push(S$1[t>>10]+S$1[t>>4&63]+S$1[t<<2&63]+"=")),o.join("")}var J={};J.read=function(n,t,r,s,o){var a,c,f=o*8-s-1,g=(1<<f)-1,m=g>>1,b=-7,k=r?o-1:0,_=r?-1:1,A=n[t+k];for(k+=_,a=A&(1<<-b)-1,A>>=-b,b+=f;b>0;a=a*256+n[t+k],k+=_,b-=8);for(c=a&(1<<-b)-1,a>>=-b,b+=s;b>0;c=c*256+n[t+k],k+=_,b-=8);if(a===0)a=1-m;else{if(a===g)return c?NaN:(A?-1:1)*(1/0);c=c+Math.pow(2,s),a=a-m}return(A?-1:1)*c*Math.pow(2,a-s)};J.write=function(n,t,r,s,o,a){var c,f,g,m=a*8-o-1,b=(1<<m)-1,k=b>>1,_=o===23?Math.pow(2,-24)-Math.pow(2,-77):0,A=s?0:a-1,B=s?1:-1,L=t<0||t===0&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(f=isNaN(t)?1:0,c=b):(c=Math.floor(Math.log(t)/Math.LN2),t*(g=Math.pow(2,-c))<1&&(c--,g*=2),c+k>=1?t+=_/g:t+=_*Math.pow(2,1-k),t*g>=2&&(c++,g/=2),c+k>=b?(f=0,c=b):c+k>=1?(f=(t*g-1)*Math.pow(2,o),c=c+k):(f=t*Math.pow(2,k-1)*Math.pow(2,o),c=0));o>=8;n[r+A]=f&255,A+=B,f/=256,o-=8);for(c=c<<o|f,m+=o;m>0;n[r+A]=c&255,A+=B,c/=256,m-=8);n[r+A-B]|=L*128};(function(n){const t=G$1,r=J,s=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;n.Buffer=b,n.SlowBuffer=se,n.INSPECT_MAX_BYTES=50;const o=2147483647;n.kMaxLength=o;const{Uint8Array:a,ArrayBuffer:c,SharedArrayBuffer:f}=globalThis;b.TYPED_ARRAY_SUPPORT=g(),!b.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function g(){try{const q=new a(1),te={foo:function(){return 42}};return Object.setPrototypeOf(te,a.prototype),Object.setPrototypeOf(q,te),q.foo()===42}catch{return!1}}Object.defineProperty(b.prototype,"parent",{enumerable:!0,get:function(){if(b.isBuffer(this))return this.buffer}}),Object.defineProperty(b.prototype,"offset",{enumerable:!0,get:function(){if(b.isBuffer(this))return this.byteOffset}});function m(q){if(q>o)throw new RangeError('The value "'+q+'" is invalid for option "size"');const te=new a(q);return Object.setPrototypeOf(te,b.prototype),te}function b(q,te,Ue){if(typeof q=="number"){if(typeof te=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return B(q)}return k(q,te,Ue)}b.poolSize=8192;function k(q,te,Ue){if(typeof q=="string")return L(q,te);if(c.isView(q))return ve(q);if(q==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof q);if(sn(q,c)||q&&sn(q.buffer,c)||typeof f<"u"&&(sn(q,f)||q&&sn(q.buffer,f)))return We(q,te,Ue);if(typeof q=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const nt=q.valueOf&&q.valueOf();if(nt!=null&&nt!==q)return b.from(nt,te,Ue);const st=re(q);if(st)return st;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof q[Symbol.toPrimitive]=="function")return b.from(q[Symbol.toPrimitive]("string"),te,Ue);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof q)}b.from=function(q,te,Ue){return k(q,te,Ue)},Object.setPrototypeOf(b.prototype,a.prototype),Object.setPrototypeOf(b,a);function _(q){if(typeof q!="number")throw new TypeError('"size" argument must be of type number');if(q<0)throw new RangeError('The value "'+q+'" is invalid for option "size"')}function A(q,te,Ue){return _(q),q<=0?m(q):te!==void 0?typeof Ue=="string"?m(q).fill(te,Ue):m(q).fill(te):m(q)}b.alloc=function(q,te,Ue){return A(q,te,Ue)};function B(q){return _(q),m(q<0?0:ze(q)|0)}b.allocUnsafe=function(q){return B(q)},b.allocUnsafeSlow=function(q){return B(q)};function L(q,te){if((typeof te!="string"||te==="")&&(te="utf8"),!b.isEncoding(te))throw new TypeError("Unknown encoding: "+te);const Ue=ne(q,te)|0;let nt=m(Ue);const st=nt.write(q,te);return st!==Ue&&(nt=nt.slice(0,st)),nt}function Z(q){const te=q.length<0?0:ze(q.length)|0,Ue=m(te);for(let nt=0;nt<te;nt+=1)Ue[nt]=q[nt]&255;return Ue}function ve(q){if(sn(q,a)){const te=new a(q);return We(te.buffer,te.byteOffset,te.byteLength)}return Z(q)}function We(q,te,Ue){if(te<0||q.byteLength<te)throw new RangeError('"offset" is outside of buffer bounds');if(q.byteLength<te+(Ue||0))throw new RangeError('"length" is outside of buffer bounds');let nt;return te===void 0&&Ue===void 0?nt=new a(q):Ue===void 0?nt=new a(q,te):nt=new a(q,te,Ue),Object.setPrototypeOf(nt,b.prototype),nt}function re(q){if(b.isBuffer(q)){const te=ze(q.length)|0,Ue=m(te);return Ue.length===0||q.copy(Ue,0,0,te),Ue}if(q.length!==void 0)return typeof q.length!="number"||mn(q.length)?m(0):Z(q);if(q.type==="Buffer"&&Array.isArray(q.data))return Z(q.data)}function ze(q){if(q>=o)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+o.toString(16)+" bytes");return q|0}function se(q){return+q!=q&&(q=0),b.alloc(+q)}b.isBuffer=function(q){return q!=null&&q._isBuffer===!0&&q!==b.prototype},b.compare=function(q,te){if(sn(q,a)&&(q=b.from(q,q.offset,q.byteLength)),sn(te,a)&&(te=b.from(te,te.offset,te.byteLength)),!b.isBuffer(q)||!b.isBuffer(te))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(q===te)return 0;let Ue=q.length,nt=te.length;for(let st=0,lt=Math.min(Ue,nt);st<lt;++st)if(q[st]!==te[st]){Ue=q[st],nt=te[st];break}return Ue<nt?-1:nt<Ue?1:0},b.isEncoding=function(q){switch(String(q).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},b.concat=function(q,te){if(!Array.isArray(q))throw new TypeError('"list" argument must be an Array of Buffers');if(q.length===0)return b.alloc(0);let Ue;if(te===void 0)for(te=0,Ue=0;Ue<q.length;++Ue)te+=q[Ue].length;const nt=b.allocUnsafe(te);let st=0;for(Ue=0;Ue<q.length;++Ue){let lt=q[Ue];if(sn(lt,a))st+lt.length>nt.length?(b.isBuffer(lt)||(lt=b.from(lt)),lt.copy(nt,st)):a.prototype.set.call(nt,lt,st);else if(b.isBuffer(lt))lt.copy(nt,st);else throw new TypeError('"list" argument must be an Array of Buffers');st+=lt.length}return nt};function ne(q,te){if(b.isBuffer(q))return q.length;if(c.isView(q)||sn(q,c))return q.byteLength;if(typeof q!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof q);const Ue=q.length,nt=arguments.length>2&&arguments[2]===!0;if(!nt&&Ue===0)return 0;let st=!1;for(;;)switch(te){case"ascii":case"latin1":case"binary":return Ue;case"utf8":case"utf-8":return yn(q).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Ue*2;case"hex":return Ue>>>1;case"base64":return $n(q).length;default:if(st)return nt?-1:yn(q).length;te=(""+te).toLowerCase(),st=!0}}b.byteLength=ne;function X(q,te,Ue){let nt=!1;if((te===void 0||te<0)&&(te=0),te>this.length||((Ue===void 0||Ue>this.length)&&(Ue=this.length),Ue<=0)||(Ue>>>=0,te>>>=0,Ue<=te))return"";for(q||(q="utf8");;)switch(q){case"hex":return rt(this,te,Ue);case"utf8":case"utf-8":return je(this,te,Ue);case"ascii":return Xe(this,te,Ue);case"latin1":case"binary":return Qe(this,te,Ue);case"base64":return Ce(this,te,Ue);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return _t(this,te,Ue);default:if(nt)throw new TypeError("Unknown encoding: "+q);q=(q+"").toLowerCase(),nt=!0}}b.prototype._isBuffer=!0;function $e(q,te,Ue){const nt=q[te];q[te]=q[Ue],q[Ue]=nt}b.prototype.swap16=function(){const q=this.length;if(q%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let te=0;te<q;te+=2)$e(this,te,te+1);return this},b.prototype.swap32=function(){const q=this.length;if(q%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let te=0;te<q;te+=4)$e(this,te,te+3),$e(this,te+1,te+2);return this},b.prototype.swap64=function(){const q=this.length;if(q%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let te=0;te<q;te+=8)$e(this,te,te+7),$e(this,te+1,te+6),$e(this,te+2,te+5),$e(this,te+3,te+4);return this},b.prototype.toString=function(){const q=this.length;return q===0?"":arguments.length===0?je(this,0,q):X.apply(this,arguments)},b.prototype.toLocaleString=b.prototype.toString,b.prototype.equals=function(q){if(!b.isBuffer(q))throw new TypeError("Argument must be a Buffer");return this===q?!0:b.compare(this,q)===0},b.prototype.inspect=function(){let q="";const te=n.INSPECT_MAX_BYTES;return q=this.toString("hex",0,te).replace(/(.{2})/g,"$1 ").trim(),this.length>te&&(q+=" ... "),"<Buffer "+q+">"},s&&(b.prototype[s]=b.prototype.inspect),b.prototype.compare=function(q,te,Ue,nt,st){if(sn(q,a)&&(q=b.from(q,q.offset,q.byteLength)),!b.isBuffer(q))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof q);if(te===void 0&&(te=0),Ue===void 0&&(Ue=q?q.length:0),nt===void 0&&(nt=0),st===void 0&&(st=this.length),te<0||Ue>q.length||nt<0||st>this.length)throw new RangeError("out of range index");if(nt>=st&&te>=Ue)return 0;if(nt>=st)return-1;if(te>=Ue)return 1;if(te>>>=0,Ue>>>=0,nt>>>=0,st>>>=0,this===q)return 0;let lt=st-nt,It=Ue-te;const Zt=Math.min(lt,It),tn=this.slice(nt,st),Yt=q.slice(te,Ue);for(let qt=0;qt<Zt;++qt)if(tn[qt]!==Yt[qt]){lt=tn[qt],It=Yt[qt];break}return lt<It?-1:It<lt?1:0};function Ve(q,te,Ue,nt,st){if(q.length===0)return-1;if(typeof Ue=="string"?(nt=Ue,Ue=0):Ue>2147483647?Ue=2147483647:Ue<-2147483648&&(Ue=-2147483648),Ue=+Ue,mn(Ue)&&(Ue=st?0:q.length-1),Ue<0&&(Ue=q.length+Ue),Ue>=q.length){if(st)return-1;Ue=q.length-1}else if(Ue<0)if(st)Ue=0;else return-1;if(typeof te=="string"&&(te=b.from(te,nt)),b.isBuffer(te))return te.length===0?-1:Ze(q,te,Ue,nt,st);if(typeof te=="number")return te=te&255,typeof a.prototype.indexOf=="function"?st?a.prototype.indexOf.call(q,te,Ue):a.prototype.lastIndexOf.call(q,te,Ue):Ze(q,[te],Ue,nt,st);throw new TypeError("val must be string, number or Buffer")}function Ze(q,te,Ue,nt,st){let lt=1,It=q.length,Zt=te.length;if(nt!==void 0&&(nt=String(nt).toLowerCase(),nt==="ucs2"||nt==="ucs-2"||nt==="utf16le"||nt==="utf-16le")){if(q.length<2||te.length<2)return-1;lt=2,It/=2,Zt/=2,Ue/=2}function tn(qt,en){return lt===1?qt[en]:qt.readUInt16BE(en*lt)}let Yt;if(st){let qt=-1;for(Yt=Ue;Yt<It;Yt++)if(tn(q,Yt)===tn(te,qt===-1?0:Yt-qt)){if(qt===-1&&(qt=Yt),Yt-qt+1===Zt)return qt*lt}else qt!==-1&&(Yt-=Yt-qt),qt=-1}else for(Ue+Zt>It&&(Ue=It-Zt),Yt=Ue;Yt>=0;Yt--){let qt=!0;for(let en=0;en<Zt;en++)if(tn(q,Yt+en)!==tn(te,en)){qt=!1;break}if(qt)return Yt}return-1}b.prototype.includes=function(q,te,Ue){return this.indexOf(q,te,Ue)!==-1},b.prototype.indexOf=function(q,te,Ue){return Ve(this,q,te,Ue,!0)},b.prototype.lastIndexOf=function(q,te,Ue){return Ve(this,q,te,Ue,!1)};function He(q,te,Ue,nt){Ue=Number(Ue)||0;const st=q.length-Ue;nt?(nt=Number(nt),nt>st&&(nt=st)):nt=st;const lt=te.length;nt>lt/2&&(nt=lt/2);let It;for(It=0;It<nt;++It){const Zt=parseInt(te.substr(It*2,2),16);if(mn(Zt))return It;q[Ue+It]=Zt}return It}function Le(q,te,Ue,nt){return hn(yn(te,q.length-Ue),q,Ue,nt)}function Q(q,te,Ue,nt){return hn(hs(te),q,Ue,nt)}function oe(q,te,Ue,nt){return hn($n(te),q,Ue,nt)}function Y(q,te,Ue,nt){return hn(ds(te,q.length-Ue),q,Ue,nt)}b.prototype.write=function(q,te,Ue,nt){if(te===void 0)nt="utf8",Ue=this.length,te=0;else if(Ue===void 0&&typeof te=="string")nt=te,Ue=this.length,te=0;else if(isFinite(te))te=te>>>0,isFinite(Ue)?(Ue=Ue>>>0,nt===void 0&&(nt="utf8")):(nt=Ue,Ue=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");const st=this.length-te;if((Ue===void 0||Ue>st)&&(Ue=st),q.length>0&&(Ue<0||te<0)||te>this.length)throw new RangeError("Attempt to write outside buffer bounds");nt||(nt="utf8");let lt=!1;for(;;)switch(nt){case"hex":return He(this,q,te,Ue);case"utf8":case"utf-8":return Le(this,q,te,Ue);case"ascii":case"latin1":case"binary":return Q(this,q,te,Ue);case"base64":return oe(this,q,te,Ue);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Y(this,q,te,Ue);default:if(lt)throw new TypeError("Unknown encoding: "+nt);nt=(""+nt).toLowerCase(),lt=!0}},b.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function Ce(q,te,Ue){return te===0&&Ue===q.length?t.fromByteArray(q):t.fromByteArray(q.slice(te,Ue))}function je(q,te,Ue){Ue=Math.min(q.length,Ue);const nt=[];let st=te;for(;st<Ue;){const lt=q[st];let It=null,Zt=lt>239?4:lt>223?3:lt>191?2:1;if(st+Zt<=Ue){let tn,Yt,qt,en;switch(Zt){case 1:lt<128&&(It=lt);break;case 2:tn=q[st+1],(tn&192)===128&&(en=(lt&31)<<6|tn&63,en>127&&(It=en));break;case 3:tn=q[st+1],Yt=q[st+2],(tn&192)===128&&(Yt&192)===128&&(en=(lt&15)<<12|(tn&63)<<6|Yt&63,en>2047&&(en<55296||en>57343)&&(It=en));break;case 4:tn=q[st+1],Yt=q[st+2],qt=q[st+3],(tn&192)===128&&(Yt&192)===128&&(qt&192)===128&&(en=(lt&15)<<18|(tn&63)<<12|(Yt&63)<<6|qt&63,en>65535&&en<1114112&&(It=en))}}It===null?(It=65533,Zt=1):It>65535&&(It-=65536,nt.push(It>>>10&1023|55296),It=56320|It&1023),nt.push(It),st+=Zt}return Ge(nt)}const Je=4096;function Ge(q){const te=q.length;if(te<=Je)return String.fromCharCode.apply(String,q);let Ue="",nt=0;for(;nt<te;)Ue+=String.fromCharCode.apply(String,q.slice(nt,nt+=Je));return Ue}function Xe(q,te,Ue){let nt="";Ue=Math.min(q.length,Ue);for(let st=te;st<Ue;++st)nt+=String.fromCharCode(q[st]&127);return nt}function Qe(q,te,Ue){let nt="";Ue=Math.min(q.length,Ue);for(let st=te;st<Ue;++st)nt+=String.fromCharCode(q[st]);return nt}function rt(q,te,Ue){const nt=q.length;(!te||te<0)&&(te=0),(!Ue||Ue<0||Ue>nt)&&(Ue=nt);let st="";for(let lt=te;lt<Ue;++lt)st+=fs[q[lt]];return st}function _t(q,te,Ue){const nt=q.slice(te,Ue);let st="";for(let lt=0;lt<nt.length-1;lt+=2)st+=String.fromCharCode(nt[lt]+nt[lt+1]*256);return st}b.prototype.slice=function(q,te){const Ue=this.length;q=~~q,te=te===void 0?Ue:~~te,q<0?(q+=Ue,q<0&&(q=0)):q>Ue&&(q=Ue),te<0?(te+=Ue,te<0&&(te=0)):te>Ue&&(te=Ue),te<q&&(te=q);const nt=this.subarray(q,te);return Object.setPrototypeOf(nt,b.prototype),nt};function ht(q,te,Ue){if(q%1!==0||q<0)throw new RangeError("offset is not uint");if(q+te>Ue)throw new RangeError("Trying to access beyond buffer length")}b.prototype.readUintLE=b.prototype.readUIntLE=function(q,te,Ue){q=q>>>0,te=te>>>0,Ue||ht(q,te,this.length);let nt=this[q],st=1,lt=0;for(;++lt<te&&(st*=256);)nt+=this[q+lt]*st;return nt},b.prototype.readUintBE=b.prototype.readUIntBE=function(q,te,Ue){q=q>>>0,te=te>>>0,Ue||ht(q,te,this.length);let nt=this[q+--te],st=1;for(;te>0&&(st*=256);)nt+=this[q+--te]*st;return nt},b.prototype.readUint8=b.prototype.readUInt8=function(q,te){return q=q>>>0,te||ht(q,1,this.length),this[q]},b.prototype.readUint16LE=b.prototype.readUInt16LE=function(q,te){return q=q>>>0,te||ht(q,2,this.length),this[q]|this[q+1]<<8},b.prototype.readUint16BE=b.prototype.readUInt16BE=function(q,te){return q=q>>>0,te||ht(q,2,this.length),this[q]<<8|this[q+1]},b.prototype.readUint32LE=b.prototype.readUInt32LE=function(q,te){return q=q>>>0,te||ht(q,4,this.length),(this[q]|this[q+1]<<8|this[q+2]<<16)+this[q+3]*16777216},b.prototype.readUint32BE=b.prototype.readUInt32BE=function(q,te){return q=q>>>0,te||ht(q,4,this.length),this[q]*16777216+(this[q+1]<<16|this[q+2]<<8|this[q+3])},b.prototype.readBigUInt64LE=an(function(q){q=q>>>0,nn(q,"offset");const te=this[q],Ue=this[q+7];(te===void 0||Ue===void 0)&&un(q,this.length-8);const nt=te+this[++q]*2**8+this[++q]*2**16+this[++q]*2**24,st=this[++q]+this[++q]*2**8+this[++q]*2**16+Ue*2**24;return BigInt(nt)+(BigInt(st)<<BigInt(32))}),b.prototype.readBigUInt64BE=an(function(q){q=q>>>0,nn(q,"offset");const te=this[q],Ue=this[q+7];(te===void 0||Ue===void 0)&&un(q,this.length-8);const nt=te*2**24+this[++q]*2**16+this[++q]*2**8+this[++q],st=this[++q]*2**24+this[++q]*2**16+this[++q]*2**8+Ue;return(BigInt(nt)<<BigInt(32))+BigInt(st)}),b.prototype.readIntLE=function(q,te,Ue){q=q>>>0,te=te>>>0,Ue||ht(q,te,this.length);let nt=this[q],st=1,lt=0;for(;++lt<te&&(st*=256);)nt+=this[q+lt]*st;return st*=128,nt>=st&&(nt-=Math.pow(2,8*te)),nt},b.prototype.readIntBE=function(q,te,Ue){q=q>>>0,te=te>>>0,Ue||ht(q,te,this.length);let nt=te,st=1,lt=this[q+--nt];for(;nt>0&&(st*=256);)lt+=this[q+--nt]*st;return st*=128,lt>=st&&(lt-=Math.pow(2,8*te)),lt},b.prototype.readInt8=function(q,te){return q=q>>>0,te||ht(q,1,this.length),this[q]&128?(255-this[q]+1)*-1:this[q]},b.prototype.readInt16LE=function(q,te){q=q>>>0,te||ht(q,2,this.length);const Ue=this[q]|this[q+1]<<8;return Ue&32768?Ue|4294901760:Ue},b.prototype.readInt16BE=function(q,te){q=q>>>0,te||ht(q,2,this.length);const Ue=this[q+1]|this[q]<<8;return Ue&32768?Ue|4294901760:Ue},b.prototype.readInt32LE=function(q,te){return q=q>>>0,te||ht(q,4,this.length),this[q]|this[q+1]<<8|this[q+2]<<16|this[q+3]<<24},b.prototype.readInt32BE=function(q,te){return q=q>>>0,te||ht(q,4,this.length),this[q]<<24|this[q+1]<<16|this[q+2]<<8|this[q+3]},b.prototype.readBigInt64LE=an(function(q){q=q>>>0,nn(q,"offset");const te=this[q],Ue=this[q+7];(te===void 0||Ue===void 0)&&un(q,this.length-8);const nt=this[q+4]+this[q+5]*2**8+this[q+6]*2**16+(Ue<<24);return(BigInt(nt)<<BigInt(32))+BigInt(te+this[++q]*2**8+this[++q]*2**16+this[++q]*2**24)}),b.prototype.readBigInt64BE=an(function(q){q=q>>>0,nn(q,"offset");const te=this[q],Ue=this[q+7];(te===void 0||Ue===void 0)&&un(q,this.length-8);const nt=(te<<24)+this[++q]*2**16+this[++q]*2**8+this[++q];return(BigInt(nt)<<BigInt(32))+BigInt(this[++q]*2**24+this[++q]*2**16+this[++q]*2**8+Ue)}),b.prototype.readFloatLE=function(q,te){return q=q>>>0,te||ht(q,4,this.length),r.read(this,q,!0,23,4)},b.prototype.readFloatBE=function(q,te){return q=q>>>0,te||ht(q,4,this.length),r.read(this,q,!1,23,4)},b.prototype.readDoubleLE=function(q,te){return q=q>>>0,te||ht(q,8,this.length),r.read(this,q,!0,52,8)},b.prototype.readDoubleBE=function(q,te){return q=q>>>0,te||ht(q,8,this.length),r.read(this,q,!1,52,8)};function ot(q,te,Ue,nt,st,lt){if(!b.isBuffer(q))throw new TypeError('"buffer" argument must be a Buffer instance');if(te>st||te<lt)throw new RangeError('"value" argument is out of bounds');if(Ue+nt>q.length)throw new RangeError("Index out of range")}b.prototype.writeUintLE=b.prototype.writeUIntLE=function(q,te,Ue,nt){if(q=+q,te=te>>>0,Ue=Ue>>>0,!nt){const It=Math.pow(2,8*Ue)-1;ot(this,q,te,Ue,It,0)}let st=1,lt=0;for(this[te]=q&255;++lt<Ue&&(st*=256);)this[te+lt]=q/st&255;return te+Ue},b.prototype.writeUintBE=b.prototype.writeUIntBE=function(q,te,Ue,nt){if(q=+q,te=te>>>0,Ue=Ue>>>0,!nt){const It=Math.pow(2,8*Ue)-1;ot(this,q,te,Ue,It,0)}let st=Ue-1,lt=1;for(this[te+st]=q&255;--st>=0&&(lt*=256);)this[te+st]=q/lt&255;return te+Ue},b.prototype.writeUint8=b.prototype.writeUInt8=function(q,te,Ue){return q=+q,te=te>>>0,Ue||ot(this,q,te,1,255,0),this[te]=q&255,te+1},b.prototype.writeUint16LE=b.prototype.writeUInt16LE=function(q,te,Ue){return q=+q,te=te>>>0,Ue||ot(this,q,te,2,65535,0),this[te]=q&255,this[te+1]=q>>>8,te+2},b.prototype.writeUint16BE=b.prototype.writeUInt16BE=function(q,te,Ue){return q=+q,te=te>>>0,Ue||ot(this,q,te,2,65535,0),this[te]=q>>>8,this[te+1]=q&255,te+2},b.prototype.writeUint32LE=b.prototype.writeUInt32LE=function(q,te,Ue){return q=+q,te=te>>>0,Ue||ot(this,q,te,4,4294967295,0),this[te+3]=q>>>24,this[te+2]=q>>>16,this[te+1]=q>>>8,this[te]=q&255,te+4},b.prototype.writeUint32BE=b.prototype.writeUInt32BE=function(q,te,Ue){return q=+q,te=te>>>0,Ue||ot(this,q,te,4,4294967295,0),this[te]=q>>>24,this[te+1]=q>>>16,this[te+2]=q>>>8,this[te+3]=q&255,te+4};function xt(q,te,Ue,nt,st){on(te,nt,st,q,Ue,7);let lt=Number(te&BigInt(4294967295));q[Ue++]=lt,lt=lt>>8,q[Ue++]=lt,lt=lt>>8,q[Ue++]=lt,lt=lt>>8,q[Ue++]=lt;let It=Number(te>>BigInt(32)&BigInt(4294967295));return q[Ue++]=It,It=It>>8,q[Ue++]=It,It=It>>8,q[Ue++]=It,It=It>>8,q[Ue++]=It,Ue}function St(q,te,Ue,nt,st){on(te,nt,st,q,Ue,7);let lt=Number(te&BigInt(4294967295));q[Ue+7]=lt,lt=lt>>8,q[Ue+6]=lt,lt=lt>>8,q[Ue+5]=lt,lt=lt>>8,q[Ue+4]=lt;let It=Number(te>>BigInt(32)&BigInt(4294967295));return q[Ue+3]=It,It=It>>8,q[Ue+2]=It,It=It>>8,q[Ue+1]=It,It=It>>8,q[Ue]=It,Ue+8}b.prototype.writeBigUInt64LE=an(function(q,te=0){return xt(this,q,te,BigInt(0),BigInt("0xffffffffffffffff"))}),b.prototype.writeBigUInt64BE=an(function(q,te=0){return St(this,q,te,BigInt(0),BigInt("0xffffffffffffffff"))}),b.prototype.writeIntLE=function(q,te,Ue,nt){if(q=+q,te=te>>>0,!nt){const Zt=Math.pow(2,8*Ue-1);ot(this,q,te,Ue,Zt-1,-Zt)}let st=0,lt=1,It=0;for(this[te]=q&255;++st<Ue&&(lt*=256);)q<0&&It===0&&this[te+st-1]!==0&&(It=1),this[te+st]=(q/lt>>0)-It&255;return te+Ue},b.prototype.writeIntBE=function(q,te,Ue,nt){if(q=+q,te=te>>>0,!nt){const Zt=Math.pow(2,8*Ue-1);ot(this,q,te,Ue,Zt-1,-Zt)}let st=Ue-1,lt=1,It=0;for(this[te+st]=q&255;--st>=0&&(lt*=256);)q<0&&It===0&&this[te+st+1]!==0&&(It=1),this[te+st]=(q/lt>>0)-It&255;return te+Ue},b.prototype.writeInt8=function(q,te,Ue){return q=+q,te=te>>>0,Ue||ot(this,q,te,1,127,-128),q<0&&(q=255+q+1),this[te]=q&255,te+1},b.prototype.writeInt16LE=function(q,te,Ue){return q=+q,te=te>>>0,Ue||ot(this,q,te,2,32767,-32768),this[te]=q&255,this[te+1]=q>>>8,te+2},b.prototype.writeInt16BE=function(q,te,Ue){return q=+q,te=te>>>0,Ue||ot(this,q,te,2,32767,-32768),this[te]=q>>>8,this[te+1]=q&255,te+2},b.prototype.writeInt32LE=function(q,te,Ue){return q=+q,te=te>>>0,Ue||ot(this,q,te,4,2147483647,-2147483648),this[te]=q&255,this[te+1]=q>>>8,this[te+2]=q>>>16,this[te+3]=q>>>24,te+4},b.prototype.writeInt32BE=function(q,te,Ue){return q=+q,te=te>>>0,Ue||ot(this,q,te,4,2147483647,-2147483648),q<0&&(q=4294967295+q+1),this[te]=q>>>24,this[te+1]=q>>>16,this[te+2]=q>>>8,this[te+3]=q&255,te+4},b.prototype.writeBigInt64LE=an(function(q,te=0){return xt(this,q,te,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),b.prototype.writeBigInt64BE=an(function(q,te=0){return St(this,q,te,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function Mt(q,te,Ue,nt,st,lt){if(Ue+nt>q.length)throw new RangeError("Index out of range");if(Ue<0)throw new RangeError("Index out of range")}function Bt(q,te,Ue,nt,st){return te=+te,Ue=Ue>>>0,st||Mt(q,te,Ue,4),r.write(q,te,Ue,nt,23,4),Ue+4}b.prototype.writeFloatLE=function(q,te,Ue){return Bt(this,q,te,!0,Ue)},b.prototype.writeFloatBE=function(q,te,Ue){return Bt(this,q,te,!1,Ue)};function Ut(q,te,Ue,nt,st){return te=+te,Ue=Ue>>>0,st||Mt(q,te,Ue,8),r.write(q,te,Ue,nt,52,8),Ue+8}b.prototype.writeDoubleLE=function(q,te,Ue){return Ut(this,q,te,!0,Ue)},b.prototype.writeDoubleBE=function(q,te,Ue){return Ut(this,q,te,!1,Ue)},b.prototype.copy=function(q,te,Ue,nt){if(!b.isBuffer(q))throw new TypeError("argument should be a Buffer");if(Ue||(Ue=0),!nt&&nt!==0&&(nt=this.length),te>=q.length&&(te=q.length),te||(te=0),nt>0&&nt<Ue&&(nt=Ue),nt===Ue||q.length===0||this.length===0)return 0;if(te<0)throw new RangeError("targetStart out of bounds");if(Ue<0||Ue>=this.length)throw new RangeError("Index out of range");if(nt<0)throw new RangeError("sourceEnd out of bounds");nt>this.length&&(nt=this.length),q.length-te<nt-Ue&&(nt=q.length-te+Ue);const st=nt-Ue;return this===q&&typeof a.prototype.copyWithin=="function"?this.copyWithin(te,Ue,nt):a.prototype.set.call(q,this.subarray(Ue,nt),te),st},b.prototype.fill=function(q,te,Ue,nt){if(typeof q=="string"){if(typeof te=="string"?(nt=te,te=0,Ue=this.length):typeof Ue=="string"&&(nt=Ue,Ue=this.length),nt!==void 0&&typeof nt!="string")throw new TypeError("encoding must be a string");if(typeof nt=="string"&&!b.isEncoding(nt))throw new TypeError("Unknown encoding: "+nt);if(q.length===1){const lt=q.charCodeAt(0);(nt==="utf8"&&lt<128||nt==="latin1")&&(q=lt)}}else typeof q=="number"?q=q&255:typeof q=="boolean"&&(q=Number(q));if(te<0||this.length<te||this.length<Ue)throw new RangeError("Out of range index");if(Ue<=te)return this;te=te>>>0,Ue=Ue===void 0?this.length:Ue>>>0,q||(q=0);let st;if(typeof q=="number")for(st=te;st<Ue;++st)this[st]=q;else{const lt=b.isBuffer(q)?q:b.from(q,nt),It=lt.length;if(It===0)throw new TypeError('The value "'+q+'" is invalid for argument "value"');for(st=0;st<Ue-te;++st)this[st+te]=lt[st%It]}return this};const Jt={};function Ft(q,te,Ue){Jt[q]=class extends Ue{constructor(){super(),Object.defineProperty(this,"message",{value:te.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${q}]`,this.stack,delete this.name}get code(){return q}set code(nt){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:nt,writable:!0})}toString(){return`${this.name} [${q}]: ${this.message}`}}}Ft("ERR_BUFFER_OUT_OF_BOUNDS",function(q){return q?`${q} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),Ft("ERR_INVALID_ARG_TYPE",function(q,te){return`The "${q}" argument must be of type number. Received type ${typeof te}`},TypeError),Ft("ERR_OUT_OF_RANGE",function(q,te,Ue){let nt=`The value of "${q}" is out of range.`,st=Ue;return Number.isInteger(Ue)&&Math.abs(Ue)>2**32?st=Xt(String(Ue)):typeof Ue=="bigint"&&(st=String(Ue),(Ue>BigInt(2)**BigInt(32)||Ue<-(BigInt(2)**BigInt(32)))&&(st=Xt(st)),st+="n"),nt+=` It must be ${te}. Received ${st}`,nt},RangeError);function Xt(q){let te="",Ue=q.length;const nt=q[0]==="-"?1:0;for(;Ue>=nt+4;Ue-=3)te=`_${q.slice(Ue-3,Ue)}${te}`;return`${q.slice(0,Ue)}${te}`}function rn(q,te,Ue){nn(te,"offset"),(q[te]===void 0||q[te+Ue]===void 0)&&un(te,q.length-(Ue+1))}function on(q,te,Ue,nt,st,lt){if(q>Ue||q<te){const It=typeof te=="bigint"?"n":"";let Zt;throw te===0||te===BigInt(0)?Zt=`>= 0${It} and < 2${It} ** ${(lt+1)*8}${It}`:Zt=`>= -(2${It} ** ${(lt+1)*8-1}${It}) and < 2 ** ${(lt+1)*8-1}${It}`,new Jt.ERR_OUT_OF_RANGE("value",Zt,q)}rn(nt,st,lt)}function nn(q,te){if(typeof q!="number")throw new Jt.ERR_INVALID_ARG_TYPE(te,"number",q)}function un(q,te,Ue){throw Math.floor(q)!==q?(nn(q,Ue),new Jt.ERR_OUT_OF_RANGE("offset","an integer",q)):te<0?new Jt.ERR_BUFFER_OUT_OF_BOUNDS:new Jt.ERR_OUT_OF_RANGE("offset",`>= 0 and <= ${te}`,q)}const ls=/[^+/0-9A-Za-z-_]/g;function us(q){if(q=q.split("=")[0],q=q.trim().replace(ls,""),q.length<2)return"";for(;q.length%4!==0;)q=q+"=";return q}function yn(q,te){te=te||1/0;let Ue;const nt=q.length;let st=null;const lt=[];for(let It=0;It<nt;++It){if(Ue=q.charCodeAt(It),Ue>55295&&Ue<57344){if(!st){if(Ue>56319){(te-=3)>-1&&lt.push(239,191,189);continue}else if(It+1===nt){(te-=3)>-1&&lt.push(239,191,189);continue}st=Ue;continue}if(Ue<56320){(te-=3)>-1&&lt.push(239,191,189),st=Ue;continue}Ue=(st-55296<<10|Ue-56320)+65536}else st&&(te-=3)>-1&&lt.push(239,191,189);if(st=null,Ue<128){if((te-=1)<0)break;lt.push(Ue)}else if(Ue<2048){if((te-=2)<0)break;lt.push(Ue>>6|192,Ue&63|128)}else if(Ue<65536){if((te-=3)<0)break;lt.push(Ue>>12|224,Ue>>6&63|128,Ue&63|128)}else if(Ue<1114112){if((te-=4)<0)break;lt.push(Ue>>18|240,Ue>>12&63|128,Ue>>6&63|128,Ue&63|128)}else throw new Error("Invalid code point")}return lt}function hs(q){const te=[];for(let Ue=0;Ue<q.length;++Ue)te.push(q.charCodeAt(Ue)&255);return te}function ds(q,te){let Ue,nt,st;const lt=[];for(let It=0;It<q.length&&!((te-=2)<0);++It)Ue=q.charCodeAt(It),nt=Ue>>8,st=Ue%256,lt.push(st),lt.push(nt);return lt}function $n(q){return t.toByteArray(us(q))}function hn(q,te,Ue,nt){let st;for(st=0;st<nt&&!(st+Ue>=te.length||st>=q.length);++st)te[st+Ue]=q[st];return st}function sn(q,te){return q instanceof te||q!=null&&q.constructor!=null&&q.constructor.name!=null&&q.constructor.name===te.name}function mn(q){return q!==q}const fs=(function(){const q="0123456789abcdef",te=new Array(256);for(let Ue=0;Ue<16;++Ue){const nt=Ue*16;for(let st=0;st<16;++st)te[nt+st]=q[Ue]+q[st]}return te})();function an(q){return typeof BigInt>"u"?ps:q}function ps(){throw new Error("BigInt not supported")}})(fr);const O=fr.Buffer;class Yr{static fromHex(t){if(t=t.trim(),t.length===0)return new Uint8Array(0);if(t.length<2||t.length&1)throw new Error("Invalid hex string: odd length.");if((t.startsWith("0x")||t.startsWith("0X"))&&(t=t.slice(2)),!t.match(/^[0-9a-fA-F]*$/))throw new Error("Invalid hex string: contains non-hex characters");const r=t.match(/.{1,2}/g);if(!r)throw new Error("Invalid hex string");return new Uint8Array(r.map(s=>parseInt(s,16)))}static toHex(t){return Array.from(t,r=>r.toString(16).padStart(2,"0")).join("")}static fromString(t){return t=t.trim(),new TextEncoder().encode(t)}static toString(t){return new TextDecoder("utf-8").decode(t)}static concat(...t){const r=t.reduce((a,c)=>a+c.length,0),s=new Uint8Array(r);let o=0;for(const a of t)s.set(a,o),o+=a.length;return s}static alloc(t){return new Uint8Array(t)}static writeBigUint64BE(t){const r=new ArrayBuffer(8);return new DataView(r).setBigUint64(0,t,!1),new Uint8Array(r)}static toBase64(t){if(typeof O<"u")return O.from(t).toString("base64");if(t.length>32768){let r="";for(let s=0;s<t.length;s+=32768){const o=t.slice(s,s+32768);r+=btoa(String.fromCharCode(...o))}return r}return btoa(String.fromCharCode(...t))}static fromBase64(t){if(t=t.trim(),typeof O<"u")return new Uint8Array(O.from(t,"base64"));let r=t.replace(/-/g,"+").replace(/_/g,"/");for(;r.length%4;)r+="=";return new Uint8Array([...atob(r)].map(s=>s.charCodeAt(0)))}static equals(t,r){if(t.length!==r.length)return!1;let s=0;for(let o=0;o<t.length;o++)s|=t[o]^r[o];return s===0}static compare(t,r){const s=Math.min(t.length,r.length);for(let o=0;o<s;o++){if(t[o]<r[o])return-1;if(t[o]>r[o])return 1}return t.length-r.length}}function Vr(n){return Hr(bytesToHex(n))}function Hr(n){return BigInt(`0x${n}`)}function Xr(n){return Yr.fromBase64(n)}const d$3=hexToBytes("536563703235366b315f48617368546f43757276655f43617368755f");function T$2(n){const t=sha256(Yr.concat(d$3,n)),r=new Uint32Array(1),s=2**16;for(let o=0;o<s;o++){const a=new Uint8Array(r.buffer),c=sha256(Yr.concat(t,a));try{return l$1(bytesToHex(Yr.concat(new Uint8Array([2]),c)))}catch{r[0]++}}throw new Error("No valid point found")}function H(n){const t=n.map(r=>r.toHex(!1)).join("");return sha256(new TextEncoder().encode(t))}function l$1(n){return secp256k1.ProjectivePoint.fromHex(n)}const K$1=n=>{let t;return/^[a-fA-F0-9]+$/.test(n)?t=Hr(n)%BigInt(2**31-1):t=Vr(Xr(n))%BigInt(2**31-1),t};function p$3(n,t){if(n.length!==t.length)return!1;for(let r=0;r<n.length;r++)if(n[r]!==t[r])return!1;return!0}const v$2=(n,t,r,s)=>{const o=secp256k1.ProjectivePoint.fromPrivateKey(bytesToHex(n.s)),a=s.multiply(Vr(n.e)),c=t.multiply(Vr(n.s)),f=r.multiply(Vr(n.e)),g=o.subtract(a),m=c.subtract(f),b=H([g,m,s,r]);return p$3(b,n.e)},d$2=(n,t,r,s)=>{if(t.r===void 0)throw new Error("verifyDLEQProof_reblind: Undefined blinding factor");const o=T$2(n),a=r.add(s.multiply(t.r)),c=secp256k1.ProjectivePoint.fromPrivateKey(t.r),f=o.add(c);return v$2(t,f,a,s)},Rho160=Uint8Array.from([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),Id160=Uint8Array.from(new Array(16).fill(0).map((n,t)=>t)),Pi160=Id160.map(n=>(9*n+5)%16),idxLR=(()=>{const r=[[Id160],[Pi160]];for(let s=0;s<4;s++)for(let o of r)o.push(o[s].map(a=>Rho160[a]));return r})(),idxL=idxLR[0],idxR=idxLR[1],shifts160=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(n=>Uint8Array.from(n)),shiftsL160=idxL.map((n,t)=>n.map(r=>shifts160[t][r])),shiftsR160=idxR.map((n,t)=>n.map(r=>shifts160[t][r])),Kl160=Uint32Array.from([0,1518500249,1859775393,2400959708,2840853838]),Kr160=Uint32Array.from([1352829926,1548603684,1836072691,2053994217,0]);function ripemd_f(n,t,r,s){return n===0?t^r^s:n===1?t&r|~t&s:n===2?(t|~r)^s:n===3?t&s|r&~s:t^(r|~s)}const BUF_160=new Uint32Array(16);class RIPEMD160 extends HashMD{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:t,h1:r,h2:s,h3:o,h4:a}=this;return[t,r,s,o,a]}set(t,r,s,o,a){this.h0=t|0,this.h1=r|0,this.h2=s|0,this.h3=o|0,this.h4=a|0}process(t,r){for(let A=0;A<16;A++,r+=4)BUF_160[A]=t.getUint32(r,!0);let s=this.h0|0,o=s,a=this.h1|0,c=a,f=this.h2|0,g=f,m=this.h3|0,b=m,k=this.h4|0,_=k;for(let A=0;A<5;A++){const B=4-A,L=Kl160[A],Z=Kr160[A],ve=idxL[A],We=idxR[A],re=shiftsL160[A],ze=shiftsR160[A];for(let se=0;se<16;se++){const ne=rotl$1(s+ripemd_f(A,a,f,m)+BUF_160[ve[se]]+L,re[se])+k|0;s=k,k=m,m=rotl$1(f,10)|0,f=a,a=ne}for(let se=0;se<16;se++){const ne=rotl$1(o+ripemd_f(B,c,g,b)+BUF_160[We[se]]+Z,ze[se])+_|0;o=_,_=b,b=rotl$1(g,10)|0,g=c,c=ne}}this.set(this.h1+f+b|0,this.h2+m+_|0,this.h3+k+o|0,this.h4+s+c|0,this.h0+a+g|0)}roundClean(){clean(BUF_160)}destroy(){this.destroyed=!0,clean(this.buffer),this.set(0,0,0,0,0)}}const ripemd160=createHasher(()=>new RIPEMD160);const Point=secp256k1.ProjectivePoint,base58check=createBase58check(sha256$1);function bytesToNumber(n){abytes(n);const t=n.length===0?"0":bytesToHex$1(n);return BigInt("0x"+t)}function numberToBytes(n){if(typeof n!="bigint")throw new Error("bigint expected");return hexToBytes$1(n.toString(16).padStart(64,"0"))}const MASTER_SECRET=utf8ToBytes("Bitcoin seed"),BITCOIN_VERSIONS={private:76066276,public:76067358},HARDENED_OFFSET=2147483648,hash160=n=>ripemd160(sha256$1(n)),fromU32=n=>createView(n).getUint32(0,!1),toU32=n=>{if(!Number.isSafeInteger(n)||n<0||n>2**32-1)throw new Error("invalid number, should be from 0 to 2**32-1, got "+n);const t=new Uint8Array(4);return createView(t).setUint32(0,n,!1),t};class HDKey{get fingerprint(){if(!this.pubHash)throw new Error("No publicKey set!");return fromU32(this.pubHash)}get identifier(){return this.pubHash}get pubKeyHash(){return this.pubHash}get privateKey(){return this.privKeyBytes||null}get publicKey(){return this.pubKey||null}get privateExtendedKey(){const t=this.privateKey;if(!t)throw new Error("No private key");return base58check.encode(this.serialize(this.versions.private,concatBytes(new Uint8Array([0]),t)))}get publicExtendedKey(){if(!this.pubKey)throw new Error("No public key");return base58check.encode(this.serialize(this.versions.public,this.pubKey))}static fromMasterSeed(t,r=BITCOIN_VERSIONS){if(abytes(t),8*t.length<128||8*t.length>512)throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got "+t.length);const s=hmac(sha512,MASTER_SECRET,t);return new HDKey({versions:r,chainCode:s.slice(32),privateKey:s.slice(0,32)})}static fromExtendedKey(t,r=BITCOIN_VERSIONS){const s=base58check.decode(t),o=createView(s),a=o.getUint32(0,!1),c={versions:r,depth:s[4],parentFingerprint:o.getUint32(5,!1),index:o.getUint32(9,!1),chainCode:s.slice(13,45)},f=s.slice(45),g=f[0]===0;if(a!==r[g?"private":"public"])throw new Error("Version mismatch");return g?new HDKey({...c,privateKey:f.slice(1)}):new HDKey({...c,publicKey:f})}static fromJSON(t){return HDKey.fromExtendedKey(t.xpriv)}constructor(t){if(this.depth=0,this.index=0,this.chainCode=null,this.parentFingerprint=0,!t||typeof t!="object")throw new Error("HDKey.constructor must not be called directly");if(this.versions=t.versions||BITCOIN_VERSIONS,this.depth=t.depth||0,this.chainCode=t.chainCode||null,this.index=t.index||0,this.parentFingerprint=t.parentFingerprint||0,!this.depth&&(this.parentFingerprint||this.index))throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");if(t.publicKey&&t.privateKey)throw new Error("HDKey: publicKey and privateKey at same time.");if(t.privateKey){if(!secp256k1.utils.isValidPrivateKey(t.privateKey))throw new Error("Invalid private key");this.privKey=typeof t.privateKey=="bigint"?t.privateKey:bytesToNumber(t.privateKey),this.privKeyBytes=numberToBytes(this.privKey),this.pubKey=secp256k1.getPublicKey(t.privateKey,!0)}else if(t.publicKey)this.pubKey=Point.fromHex(t.publicKey).toRawBytes(!0);else throw new Error("HDKey: no public or private key provided");this.pubHash=hash160(this.pubKey)}derive(t){if(!/^[mM]'?/.test(t))throw new Error('Path must start with "m" or "M"');if(/^[mM]'?$/.test(t))return this;const r=t.replace(/^[mM]'?\//,"").split("/");let s=this;for(const o of r){const a=/^(\d+)('?)$/.exec(o),c=a&&a[1];if(!a||a.length!==3||typeof c!="string")throw new Error("invalid child index: "+o);let f=+c;if(!Number.isSafeInteger(f)||f>=HARDENED_OFFSET)throw new Error("Invalid index");a[2]==="'"&&(f+=HARDENED_OFFSET),s=s.deriveChild(f)}return s}deriveChild(t){if(!this.pubKey||!this.chainCode)throw new Error("No publicKey or chainCode set");let r=toU32(t);if(t>=HARDENED_OFFSET){const f=this.privateKey;if(!f)throw new Error("Could not derive hardened child key");r=concatBytes(new Uint8Array([0]),f,r)}else r=concatBytes(this.pubKey,r);const s=hmac(sha512,this.chainCode,r),o=bytesToNumber(s.slice(0,32)),a=s.slice(32);if(!secp256k1.utils.isValidPrivateKey(o))throw new Error("Tweak bigger than curve order");const c={versions:this.versions,chainCode:a,depth:this.depth+1,parentFingerprint:this.fingerprint,index:t};try{if(this.privateKey){const f=mod(this.privKey+o,secp256k1.CURVE.n);if(!secp256k1.utils.isValidPrivateKey(f))throw new Error("The tweak was out of range or the resulted private key is invalid");c.privateKey=f}else{const f=Point.fromHex(this.pubKey).add(Point.fromPrivateKey(o));if(f.equals(Point.ZERO))throw new Error("The tweak was equal to negative P, which made the result key invalid");c.publicKey=f.toRawBytes(!0)}return new HDKey(c)}catch{return this.deriveChild(t+1)}}sign(t){if(!this.privateKey)throw new Error("No privateKey set!");return abytes(t,32),secp256k1.sign(t,this.privKey).toCompactRawBytes()}verify(t,r){if(abytes(t,32),abytes(r,64),!this.publicKey)throw new Error("No publicKey set!");let s;try{s=secp256k1.Signature.fromCompact(r)}catch{return!1}return secp256k1.verify(s,t,this.publicKey)}wipePrivateData(){return this.privKey=void 0,this.privKeyBytes&&(this.privKeyBytes.fill(0),this.privKeyBytes=void 0),this}toJSON(){return{xpriv:this.privateExtendedKey,xpub:this.publicExtendedKey}}serialize(t,r){if(!this.chainCode)throw new Error("No chainCode set");return abytes(r,33),concatBytes(toU32(t),new Uint8Array([this.depth]),toU32(this.parentFingerprint),toU32(this.index),this.chainCode,r)}}function D(n){return Yr.toBase64(n).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}function U(n){return Yr.fromBase64(n)}function j(n){const t=JSON.stringify(n);return v$1(Yr.toBase64(Yr.fromString(t)))}function x$1(n){const t=Yr.toString(Yr.fromBase64($(n)));return JSON.parse(t)}function $(n){return n.replace(/-/g,"+").replace(/_/g,"/").split("=")[0]}function v$1(n){return n.replace(/\+/g,"-").replace(/\//g,"_").split("=")[0]}function u$1(n){if(typeof n!="string"||n.length===0)return!1;const t=/^[A-Za-z0-9\-_]+={0,2}$/,r=/^[A-Za-z0-9+/]+={0,2}$/;if(!t.test(n)&&!r.test(n))return!1;const s=n.replace(/-/g,"+").replace(/_/g,"/"),o=(4-s.length%4)%4;if(o>2)return!1;const a=s+"=".repeat(o);try{const c=Yr.fromBase64(a),f=Yr.toBase64(c),g=f.replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,""),m=s.replace(/=+$/,"");return f.replace(/=+$/,"")===m||g===m}catch{return!1}}const S="m/129372'/0'",T$1=(n,t,r)=>{const s=/^[a-fA-F0-9]+$/.test(t);if(!s&&u$1(t)||s&&t.startsWith("00"))return i(n,t,r,0);if(s&&t.startsWith("01"))return p$2(n,t,r,0);throw new Error(`Unrecognized keyset ID version ${t.slice(0,2)}`)},z=(n,t,r)=>{const s=/^[a-fA-F0-9]+$/.test(t);if(!s&&u$1(t)||s&&t.startsWith("00"))return i(n,t,r,1);if(s&&t.startsWith("01"))return p$2(n,t,r,1);throw new Error(`Unrecognized keyset ID version ${t.slice(0,2)}`)},p$2=(n,t,r,s)=>{let o=Yr.concat(Yr.fromString("Cashu_KDF_HMAC_SHA256"),Yr.fromHex(t),Yr.writeBigUint64BE(BigInt(r)));switch(s){case 0:o=Yr.concat(o,Yr.fromHex("00"));break;case 1:o=Yr.concat(o,Yr.fromHex("01"))}return hmac(sha256$1,n,o)},i=(n,t,r,s)=>{const o=HDKey.fromMasterSeed(n),a=K$1(t),c=`${S}/${a}'/${r}'/${s}`,f=o.derive(c);if(f.privateKey===null)throw new Error("Could not derive private key");return f.privateKey},e=n=>{try{return n instanceof Uint8Array&&(n=new TextDecoder().decode(n)),JSON.parse(n)}catch{throw new Error("can't parse secret")}},p$1=(n,t)=>{const r=sha256(n),s=schnorr.sign(r,t);return bytesToHex(s)},h=(n,t,r)=>{try{const s=sha256(t),o=r.length===66?r.slice(2):r;if(schnorr.verify(n,s,hexToBytes(o)))return!0}catch(s){console.error("verifyP2PKsecret error:",s)}return!1};function d$1(n){try{const t=typeof n=="string"?e(n):n;if(t[0]!=="P2PK")throw new Error('Invalid P2PK secret: must start with "P2PK"');const r=Math.floor(Date.now()/1e3);return w(t)>r?E(t):I$1(t)}catch{}return[]}function E(n){const t=typeof n=="string"?e(n):n;if(t[0]!=="P2PK")throw new Error('Invalid P2PK secret: must start with "P2PK"');const{data:r,tags:s}=t[1],o=s&&s.find(c=>c[0]==="pubkeys"),a=o&&o.length>1?o.slice(1):[];return[r,...a].filter(Boolean)}function I$1(n){const t=typeof n=="string"?e(n):n;if(t[0]!=="P2PK")throw new Error('Invalid P2PK secret: must start with "P2PK"');const{tags:r}=t[1],s=r&&r.find(o=>o[0]==="refund");return s&&s.length>1?s.slice(1).filter(Boolean):[]}function w(n){const t=typeof n=="string"?e(n):n;if(t[0]!=="P2PK")throw new Error('Invalid P2PK secret: must start with "P2PK"');const{tags:r}=t[1],s=r&&r.find(o=>o[0]==="locktime");return s&&s.length>1?parseInt(s[1],10):1/0}const K=n=>{if(!n)return[];if(typeof n=="string")try{return JSON.parse(n).signatures||[]}catch(t){return console.error("Failed to parse witness string:",t),[]}return n.signatures||[]},W$1=(n,t,r=!1)=>{const s=Array.isArray(t)?t:[t];return n.map((o,a)=>{let c=o;for(const f of s)try{c=T(c,f)}catch(g){const m=g instanceof Error?g.message:"Unknown error";if(r)throw new Error(`Failed signing proof #${a+1}: ${m}`);console.warn(`Proof #${a+1}: ${m}`)}return c})},T=(n,t)=>{const r=e(n.secret);if(r[0]!=="P2PK")throw new Error("not a P2PK secret");const s=bytesToHex(schnorr.getPublicKey(t)),o=d$1(r);if(!o.length||!o.some(f=>f.includes(s)))throw new Error(`Signature not required from [02|03]${s}`);const a=K(n.witness);if(a.some(f=>{try{return h(f,n.secret,s)}catch{return!1}}))throw new Error(`Proof already signed by [02|03]${s}`);const c=p$1(n.secret,t);return a.push(c),{...n,witness:{signatures:a}}};function u(n,t){let r=n;for(const o of t)r+=o.B_;const s=new TextEncoder().encode(r);return sha256(s)}function p(n,t,r){const s=u(t,r),o=hexToBytes$1(n),a=schnorr.sign(s,o);return bytesToHex$1(a)}function l(n,t,r){const s=T$2(n);t||(t=Vr(secp256k1.utils.randomPrivateKey()));const o=secp256k1.ProjectivePoint.BASE.multiply(t);return{B_:s.add(o),r:t,secret:n}}function C(n,t,r){return n.subtract(r.multiply(t))}function y(n,t,r,s){const o=s,a=C(n.C_,t,o);return{id:n.id,amount:n.amount,secret:r,C:a}}const v=n=>({amount:n.amount,C:n.C.toHex(!0),id:n.id,secret:new TextDecoder().decode(n.secret),witness:JSON.stringify(n.witness)});function ie(n){return typeof n=="number"||typeof n=="string"}function wt(n){const t=[];return kt(n,t),new Uint8Array(t)}function kt(n,t){if(n===null)t.push(246);else if(n===void 0)t.push(247);else if(typeof n=="boolean")t.push(n?245:244);else if(typeof n=="number")Ot(n,t);else if(typeof n=="string")Nt(n,t);else if(Array.isArray(n))ce(n,t);else if(n instanceof Uint8Array)ae(n,t);else if(typeof n=="object"&&n!==null&&!Array.isArray(n))ue(n,t);else throw new Error("Unsupported type")}function Ot(n,t){if(n<24)t.push(n);else if(n<256)t.push(24,n);else if(n<65536)t.push(25,n>>8,n&255);else if(n<4294967296)t.push(26,n>>24,n>>16&255,n>>8&255,n&255);else throw new Error("Unsupported integer size")}function ae(n,t){const r=n.length;if(r<24)t.push(64+r);else if(r<256)t.push(88,r);else if(r<65536)t.push(89,r>>8&255,r&255);else if(r<4294967296)t.push(90,r>>24&255,r>>16&255,r>>8&255,r&255);else throw new Error("Byte string too long to encode");for(let s=0;s<n.length;s++)t.push(n[s])}function Nt(n,t){const r=new TextEncoder().encode(n),s=r.length;if(s<24)t.push(96+s);else if(s<256)t.push(120,s);else if(s<65536)t.push(121,s>>8&255,s&255);else if(s<4294967296)t.push(122,s>>24&255,s>>16&255,s>>8&255,s&255);else throw new Error("String too long to encode");for(let o=0;o<r.length;o++)t.push(r[o])}function ce(n,t){const r=n.length;if(r<24)t.push(128|r);else if(r<256)t.push(152,r);else if(r<65536)t.push(153,r>>8,r&255);else throw new Error("Unsupported array length");for(const s of n)kt(s,t)}function ue(n,t){const r=Object.keys(n);Ot(r.length,t),t[t.length-1]|=160;for(const s of r)Nt(s,t),kt(n[s],t)}function bt(n){const t=new DataView(n.buffer,n.byteOffset,n.byteLength);return it(t,0).value}function it(n,t){if(t>=n.byteLength)throw new Error("Unexpected end of data");const r=n.getUint8(t++),s=r>>5,o=r&31;switch(s){case 0:return he(n,t,o);case 1:return le(n,t,o);case 2:return de(n,t,o);case 3:return fe(n,t,o);case 4:return me(n,t,o);case 5:return pe(n,t,o);case 7:return ge(n,t,o);default:throw new Error(`Unsupported major type: ${s}`)}}function V(n,t,r){if(r<24)return{value:r,offset:t};if(r===24)return{value:n.getUint8(t++),offset:t};if(r===25){const s=n.getUint16(t,!1);return t+=2,{value:s,offset:t}}if(r===26){const s=n.getUint32(t,!1);return t+=4,{value:s,offset:t}}if(r===27){const s=n.getUint32(t,!1),o=n.getUint32(t+4,!1);return t+=8,{value:s*2**32+o,offset:t}}throw new Error(`Unsupported length: ${r}`)}function he(n,t,r){const{value:s,offset:o}=V(n,t,r);return{value:s,offset:o}}function le(n,t,r){const{value:s,offset:o}=V(n,t,r);return{value:-1-s,offset:o}}function de(n,t,r){const{value:s,offset:o}=V(n,t,r);if(o+s>n.byteLength)throw new Error("Byte string length exceeds data length");return{value:new Uint8Array(n.buffer,n.byteOffset+o,s),offset:o+s}}function fe(n,t,r){const{value:s,offset:o}=V(n,t,r);if(o+s>n.byteLength)throw new Error("String length exceeds data length");const a=new Uint8Array(n.buffer,n.byteOffset+o,s);return{value:new TextDecoder().decode(a),offset:o+s}}function me(n,t,r){const{value:s,offset:o}=V(n,t,r),a=[];let c=o;for(let f=0;f<s;f++){const g=it(n,c);a.push(g.value),c=g.offset}return{value:a,offset:c}}function pe(n,t,r){const{value:s,offset:o}=V(n,t,r),a={};let c=o;for(let f=0;f<s;f++){const g=it(n,c);if(!ie(g.value))throw new Error("Invalid key type");const m=it(n,g.offset);a[g.value]=m.value,c=m.offset}return{value:a,offset:c}}function ye(n){const t=(n&31744)>>10,r=n&1023,s=n&32768?-1:1;return t===0?s*2**-14*(r/1024):t===31?r?NaN:s*(1/0):s*2**(t-15)*(1+r/1024)}function ge(n,t,r){if(r<24)switch(r){case 20:return{value:!1,offset:t};case 21:return{value:!0,offset:t};case 22:return{value:null,offset:t};case 23:return{value:void 0,offset:t};default:throw new Error(`Unknown simple value: ${r}`)}if(r===24)return{value:n.getUint8(t++),offset:t};if(r===25){const s=ye(n.getUint16(t,!1));return t+=2,{value:s,offset:t}}if(r===26){const s=n.getFloat32(t,!1);return t+=4,{value:s,offset:t}}if(r===27){const s=n.getFloat64(t,!1);return t+=8,{value:s,offset:t}}throw new Error(`Unknown simple or float value: ${r}`)}const we="A",ke="cashu";function R(n,t,r,s){if(r){const a=Rt(r);if(n===0&&a===0)return r;const c=r.filter(g=>g>0),f=Rt(c);if(f>n)throw new Error(`Split is greater than total amount: ${f} > ${n}`);if(c.some(g=>!Lt(g,t)))throw new Error("Provided amount preferences do not match the amounts of the mint keyset.");if(f===n)return c;r=c,n-=f}else r=[];const o=Qt(t,"desc");if(!o||o.length===0)throw new Error("Cannot split amount, keyset is inactive or contains no keys");if(o.forEach(a=>{if(n<=0||a<=0)return;const c=Math.floor(n/a);for(let f=0;f<c;++f)r.push(a);n%=a}),n!==0)throw new Error(`Unable to split remaining amount: ${n}`);return r.sort((a,c)=>a-c)}function vt(n,t,r,s){const o=[],a=n.map(f=>f.amount);Qt(r,"asc").forEach(f=>{const g=a.filter(b=>b===f).length,m=Math.max(s-g,0);for(let b=0;b<m&&!(o.reduce((k,_)=>k+_,0)+f>t);++b)o.push(f)});const c=t-o.reduce((f,g)=>f+g,0);return c&&R(c,r).forEach(f=>{o.push(f)}),o.sort((f,g)=>f-g)}function Qt(n,t="desc"){return t=="desc"?Object.keys(n).map(r=>parseInt(r)).sort((r,s)=>s-r):Object.keys(n).map(r=>parseInt(r)).sort((r,s)=>r-s)}function Lt(n,t){return n in t}function be(n){return Ct(bytesToHex(n))}function Ct(n){return BigInt(`0x${n}`)}function _e(n){return n.toString(16).padStart(64,"0")}function Tt(n){return/^[a-f0-9]*$/i.test(n)}function Et(n){return Array.isArray(n)?n.some(t=>!Tt(t.id)):!Tt(n.id)}function Ee(n,t){Et(n.proofs)||(n.proofs=Wt(n.proofs));const r={token:[{mint:n.mint,proofs:n.proofs}]};return n.unit&&(r.unit=n.unit),n.memo&&(r.memo=n.memo),ke+we+j(r)}function Wt(n){return n.map(t=>{const r={...t};return r.id=r.id.slice(0,16),r})}function Ye(n,t){return Et(n.proofs)||t?.version===3?Ee(n):Ae(n)}function Ae(n,t){if(n.proofs.forEach(f=>{if(f.dleq&&f.dleq.r==null)throw new Error("Missing blinding factor in included DLEQ proof")}),Et(n.proofs))throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");n.proofs=Wt(n.proofs);const r=jt(n),s=wt(r),o="cashu",a="B",c=D(s);return o+a+c}function jt(n){const t={},r=n.mint;for(let o=0;o<n.proofs.length;o++){const a=n.proofs[o];t[a.id]?t[a.id].push(a):t[a.id]=[a]}const s={m:r,u:n.unit||"sat",t:Object.keys(t).map(o=>({i:hexToBytes(o),p:t[o].map(a=>({a:a.amount,s:a.secret,c:hexToBytes(a.C),...a.dleq&&{d:{e:hexToBytes(a.dleq.e),s:hexToBytes(a.dleq.s),r:hexToBytes(a.dleq.r??"00")}},...a.witness&&{w:JSON.stringify(a.witness)}}))}))};return n.memo&&(s.d=n.memo),s}function $t(n){const t=[];n.t.forEach(s=>s.p.forEach(o=>{t.push({secret:o.s,C:bytesToHex(o.c),amount:o.a,id:bytesToHex(s.i),...o.d&&{dleq:{r:bytesToHex(o.d.r),s:bytesToHex(o.d.s),e:bytesToHex(o.d.e)}},...o.w&&{witness:o.w}})}));const r={mint:n.m,proofs:t,unit:n.u||"sat"};return n.d&&(r.memo=n.d),r}function Pe(n,t){["web+cashu://","cashu://","cashu:","cashu"].forEach(s=>{n.startsWith(s)&&(n=n.slice(s.length))});const r=Ie(n);return r.proofs=qe(r.proofs,t),r}function Ie(n){const t=n.slice(0,1),r=n.slice(1);if(t==="A"){const s=x$1(r);if(s.token.length>1)throw new Error("Multi entry token are not supported");const o=s.token[0],a={mint:o.mint,proofs:o.proofs,unit:s.unit||"sat"};return s.memo&&(a.memo=s.memo),a}else if(t==="B"){const s=U(r),o=bt(s);return $t(o)}throw new Error("Token version is not supported")}function Se(n,t,r,s=0,o=!1){if(o){const g=Object.entries(n).sort((b,k)=>+b[0]-+k[0]).map(([,b])=>b).reduce((b,k)=>b+k,""),m=sha256$1(g);return Yr.toBase64(m).slice(0,12)}let a=Object.entries(n).sort((g,m)=>+g[0]-+m[0]).map(([,g])=>hexToBytes(g)).reduce((g,m)=>dt(g,m),new Uint8Array),c,f;switch(s){case 0:return c=sha256$1(a),f=Yr.toHex(c).slice(0,14),"00"+f;case 1:if(!t)throw new Error("Cannot compute keyset ID version 01: unit is required.");return a=dt(a,Yr.fromString("unit:"+t)),r&&(a=dt(a,Yr.fromString("final_expiry:"+r.toString()))),c=sha256$1(a),f=Yr.toHex(c),"01"+f;default:throw new Error(`Unrecognized keyset ID version: ${s}`)}}function dt(n,t){const r=new Uint8Array(n.length+t.length);return r.set(n),r.set(t,n.length),r}function x(n){return typeof n=="object"}function P(...n){return n.map(t=>t.replace(/(^\/+|\/+$)/g,"")).join("/")}function zt(n){return n.replace(/\/$/,"")}function W(n){return n.reduce((t,r)=>t+r.amount,0)}class Me{get value(){return this._value}set value(t){this._value=t}get next(){return this._next}set next(t){this._next=t}constructor(t){this._value=t,this._next=null}}class Be{get first(){return this._first}set first(t){this._first=t}get last(){return this._last}set last(t){this._last=t}get size(){return this._size}set size(t){this._size=t}constructor(){this._first=null,this._last=null,this._size=0}enqueue(t){const r=new Me(t);return this._size===0||!this._last?(this._first=r,this._last=r):(this._last.next=r,this._last=r),this._size++,!0}dequeue(){if(this._size===0||!this._first)return null;const t=this._first;return this._first=t.next,t.next=null,this._size--,t.value}}function at(n){return n.map(t=>{const r={...t};return delete r.dleq,r})}function Dt(n){const t=u$1(n.id),r=/^[a-fA-F0-9]+$/.test(n.id),s=r?hexToBytes(n.id)[0]:0;return Se(n.keys,n.unit,n.final_expiry,s,t&&!r)===n.id}function qe(n,t){const r=[];for(const s of n){let o;try{o=hexToBytes(s.id)}catch{r.push(s);continue}if(o[0]===0)r.push(s);else if(o[0]===1){if(!t)throw new Error("A short keyset ID v2 was encountered, but got no keysets to map it to.");let a=!1;for(const c of t)if(s.id===c.id.slice(0,s.id.length)){s.id=c.id,r.push(s),a=!0;break}if(!a)throw new Error(`Couldn't map short keyset ID ${s.id} to any known keysets of the current Mint`)}else throw new Error(`Unknown keyset ID version: ${o[0]}`)}return r}function Ht(n,t){if(n.dleq==null)return!1;const r={e:hexToBytes(n.dleq.e),s:hexToBytes(n.dleq.s),r:Ct(n.dleq.r??"00")};if(!Lt(n.amount,t.keys))throw new Error(`undefined key for amount ${n.amount}`);const s=t.keys[n.amount];return d$2(new TextEncoder().encode(n.secret),r,l$1(n.C),l$1(s))}function Rt(n){return n.reduce((t,r)=>t+r,0)}let ct;typeof WebSocket<"u"&&(ct=WebSocket);function Te(){if(ct===void 0)throw new Error("WebSocket implementation not initialized");return ct}const F={fatal(){},error(){},warn(){},info(){},debug(){},trace(){},log(){}};function De(){const n=Date.now();return{elapsed:()=>Date.now()-n}}class G{constructor(){this.connectionMap=new Map}static getInstance(){return G.instance||(G.instance=new G),G.instance}getConnection(t,r){if(this.connectionMap.has(t))return this.connectionMap.get(t);const s=new Re(t,r);return this.connectionMap.set(t,s),s}}class Re{constructor(t,r){this.subListeners={},this.rpcListeners={},this.rpcId=0,this.onCloseCallbacks=[],this._WS=Te(),this.url=new URL(t),this.messageQueue=new Be,this._logger=r??F}connect(){return this.connectionPromise||(this.connectionPromise=new Promise((t,r)=>{try{this.ws=new this._WS(this.url.toString()),this.onCloseCallbacks=[]}catch(s){r(s instanceof Error?s:new Error(String(s)));return}this.ws.onopen=()=>{t()},this.ws.onerror=()=>{r(new Error("Failed to open WebSocket"))},this.ws.onmessage=s=>{this.messageQueue.enqueue(s.data),this.handlingInterval||(this.handlingInterval=setInterval(this.handleNextMessage.bind(this),0))},this.ws.onclose=s=>{this.connectionPromise=void 0,this.onCloseCallbacks.forEach(o=>o(s))}})),this.connectionPromise}sendRequest(t,r){if(this.ws?.readyState!==1){if(t==="unsubscribe")return;throw this._logger.error("Attempted sendRequest, but socket was not open"),new Error("Socket not open")}const s=this.rpcId;this.rpcId++;const o=JSON.stringify({jsonrpc:"2.0",method:t,params:r,id:s});this.ws?.send(o)}closeSubscription(t){this.ws?.send(JSON.stringify(["CLOSE",t]))}addSubListener(t,r){(this.subListeners[t]=this.subListeners[t]||[]).push(r)}addRpcListener(t,r,s){this.rpcListeners[s]={callback:t,errorCallback:r}}removeRpcListener(t){delete this.rpcListeners[t]}removeListener(t,r){if(this.subListeners[t]){if(this.subListeners[t].length===1){delete this.subListeners[t];return}this.subListeners[t]=this.subListeners[t].filter(s=>s!==r)}}async ensureConnection(){this.ws?.readyState!==1&&await this.connect()}handleNextMessage(){if(this.messageQueue.size===0){clearInterval(this.handlingInterval),this.handlingInterval=void 0;return}const t=this.messageQueue.dequeue();let r;try{if(r=JSON.parse(t),"result"in r&&r.id!=null)this.rpcListeners[r.id]&&(this.rpcListeners[r.id].callback(),this.removeRpcListener(r.id));else if("error"in r&&r.id!=null)this.rpcListeners[r.id]&&(this.rpcListeners[r.id].errorCallback(new Error(r.error.message)),this.removeRpcListener(r.id));else if("method"in r&&!("id"in r)){const s=r.params?.subId;if(!s)return;if(this.subListeners[s]?.length>0){const o=r;this.subListeners[s].forEach(a=>a(o.params?.payload))}}}catch(s){this._logger.error("Error doing handleNextMessage",{e:s});return}}createSubscription(t,r,s){if(this.ws?.readyState!==1)throw this._logger.error("Attempted createSubscription, but socket was not open"),new Error("Socket is not open");const o=(Math.random()+1).toString(36).substring(7);return this.addRpcListener(()=>{this.addSubListener(o,r)},s,this.rpcId),this.sendRequest("subscribe",{...t,subId:o}),this.rpcId++,o}cancelSubscription(t,r,s){this.removeListener(t,r),this.addRpcListener(()=>{this._logger.info("Unsubscribed {subId}",{subId:t})},s||(o=>this._logger.error("Unsubscribe failed",{e:o})),this.rpcId),this.sendRequest("unsubscribe",{subId:t})}get activeSubscriptions(){return Object.keys(this.subListeners)}close(){this.ws&&this.ws?.close()}onClose(t){this.onCloseCallbacks.push(t)}}const ns={UNSPENT:"UNSPENT",SPENT:"SPENT"},tt={UNPAID:"UNPAID",PENDING:"PENDING",PAID:"PAID"},yt={UNPAID:"UNPAID",PAID:"PAID"};class et extends Error{constructor(t,r){super(t),this.status=r,this.name="HttpResponseError",Object.setPrototypeOf(this,et.prototype)}}class At extends Error{constructor(t){super(t),this.name="NetworkError",Object.setPrototypeOf(this,At.prototype)}}class Pt extends et{constructor(t,r){super(r||"Unknown mint operation error",400),this.code=t,this.name="MintOperationError",Object.setPrototypeOf(this,Pt.prototype)}}let Gt={},Vt=F;function Ke(n){Vt=n}async function xe({endpoint:n,requestBody:t,headers:r,...s}){const o=t?JSON.stringify(t):void 0,a={Accept:"application/json, text/plain, */*",...o?{"Content-Type":"application/json"}:void 0,...r};let c;try{c=await fetch(n,{body:o,headers:a,...s})}catch(f){throw new At(f instanceof Error?f.message:"Network request failed")}if(!c.ok){let f;try{f=await c.json()}catch{f={error:"bad response"}}if(c.status===400&&"code"in f&&typeof f.code=="number"&&"detail"in f&&typeof f.detail=="string")throw new Pt(f.code,f.detail);let g="HTTP request failed";throw"error"in f&&typeof f.error=="string"?g=f.error:"detail"in f&&typeof f.detail=="string"&&(g=f.detail),new et(g,c.status)}try{return await c.json()}catch(f){throw Vt.error("Failed to parse HTTP response",{err:f}),new et("bad response",c.status)}}async function I(n){return await xe({...n,...Gt})}function ft(n,t){return n.state||(t.warn("Field 'state' not found in MeltQuoteResponse. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)"),typeof n.paid=="boolean"&&(n.state=n.paid?tt.PAID:tt.UNPAID)),n}function Kt(n,t){return n.state||(t.warn("Field 'state' not found in MintQuoteResponse. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)"),typeof n.paid=="boolean"&&(n.state=n.paid?yt.PAID:yt.UNPAID)),n}function Fe(n,t){return Array.isArray(n?.contact)&&n?.contact.length>0&&(n.contact=n.contact.map(r=>Array.isArray(r)&&r.length===2&&typeof r[0]=="string"&&typeof r[1]=="string"?(t.warn("Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117"),{method:r[0],info:r[1]}):r)),n}class gt{constructor(t){this._mintInfo=t,t.nuts[22]&&(this._protectedEnpoints={cache:{},apiReturn:t.nuts[22].protected_endpoints.map(r=>({method:r.method,regex:new RegExp(r.path)}))})}isSupported(t){switch(t){case 4:case 5:return this.checkMintMelt(t);case 7:case 8:case 9:case 10:case 11:case 12:case 14:case 20:return this.checkGenericNut(t);case 17:return this.checkNut17();case 15:return this.checkNut15();default:throw new Error("nut is not supported by cashu-ts")}}requiresBlindAuthToken(t){if(!this._protectedEnpoints)return!1;if(typeof this._protectedEnpoints.cache[t]=="boolean")return this._protectedEnpoints.cache[t];const r=this._protectedEnpoints.apiReturn.some(s=>s.regex.test(t));return this._protectedEnpoints.cache[t]=r,r}checkGenericNut(t){return this._mintInfo.nuts[t]?.supported?{supported:!0}:{supported:!1}}checkMintMelt(t){const r=this._mintInfo.nuts[t];return r&&r.methods.length>0&&!r.disabled?{disabled:!1,params:r.methods}:{disabled:!0,params:r.methods}}checkNut17(){return this._mintInfo.nuts[17]&&this._mintInfo.nuts[17].supported.length>0?{supported:!0,params:this._mintInfo.nuts[17].supported}:{supported:!1}}checkNut15(){return this._mintInfo.nuts[15]&&this._mintInfo.nuts[15].methods.length>0?{supported:!0,params:this._mintInfo.nuts[15].methods}:{supported:!1}}get contact(){return this._mintInfo.contact}get description(){return this._mintInfo.description}get description_long(){return this._mintInfo.description_long}get name(){return this._mintInfo.name}get pubkey(){return this._mintInfo.pubkey}get nuts(){return this._mintInfo.nuts}get version(){return this._mintInfo.version}get motd(){return this._mintInfo.motd}get supportsBolt12Description(){return this._mintInfo.nuts[4]?.methods.some(t=>t.method==="bolt12"&&t.options?.description===!0)}}class M{constructor(t,r,s,o){this._mintUrl=t,this._customRequest=r,this._checkNut22=!1,this._mintUrl=zt(t),this._customRequest=r,s&&(this._checkNut22=!0,this._authTokenGetter=s),this._logger=o?.logger??F,Ke(this._logger)}get mintUrl(){return this._mintUrl}static async getInfo(t,r,s){const o=s??F,a=await(r||I)({endpoint:P(t,"/v1/info")});return Fe(a,o)}async getInfo(){return M.getInfo(this._mintUrl,this._customRequest,this._logger)}async getLazyMintInfo(){if(this._mintInfo)return this._mintInfo;const t=await M.getInfo(this._mintUrl,this._customRequest);return this._mintInfo=new gt(t),this._mintInfo}static async swap(t,r,s,o){const a=s||I,c=o?{"Blind-auth":o}:{},f=await a({endpoint:P(t,"/v1/swap"),method:"POST",requestBody:r,headers:c});if(!x(f)||!Array.isArray(f?.signatures))throw new Error(f.detail??"bad response");return f}async swap(t){const r=await this.handleBlindAuth("/v1/swap");return M.swap(this._mintUrl,t,this._customRequest,r)}static async createMintQuote(t,r,s,o,a){const c=a??F,f=s||I,g=o?{"Blind-auth":o}:{},m=await f({endpoint:P(t,"/v1/mint/quote/bolt11"),method:"POST",requestBody:r,headers:g});return Kt(m,c)}async createMintQuote(t){const r=await this.handleBlindAuth("/v1/mint/quote/bolt11");return M.createMintQuote(this._mintUrl,t,this._customRequest,r)}static async createMintQuoteBolt12(t,r,s,o){const a=s||I,c=o?{"Blind-auth":o}:{};return await a({endpoint:P(t,"/v1/mint/quote/bolt12"),method:"POST",requestBody:r,headers:c})}async createMintQuoteBolt12(t){const r=await this.handleBlindAuth("/v1/mint/quote/bolt12");return M.createMintQuoteBolt12(this._mintUrl,t,this._customRequest,r)}static async checkMintQuote(t,r,s,o,a){const c=a??F,f=s||I,g=o?{"Blind-auth":o}:{},m=await f({endpoint:P(t,"/v1/mint/quote/bolt11",r),method:"GET",headers:g});return Kt(m,c)}async checkMintQuote(t){const r=await this.handleBlindAuth(`/v1/mint/quote/bolt11/${t}`);return M.checkMintQuote(this._mintUrl,t,this._customRequest,r)}static async checkMintQuoteBolt12(t,r,s,o){const a=s||I,c=o?{"Blind-auth":o}:{};return await a({endpoint:P(t,"/v1/mint/quote/bolt12",r),method:"GET",headers:c})}async checkMintQuoteBolt12(t){const r=await this.handleBlindAuth(`/v1/mint/quote/bolt12/${t}`);return M.checkMintQuoteBolt12(this._mintUrl,t,this._customRequest,r)}static async mint(t,r,s,o){const a=s||I,c=o?{"Blind-auth":o}:{},f=await a({endpoint:P(t,"/v1/mint/bolt11"),method:"POST",requestBody:r,headers:c});if(!x(f)||!Array.isArray(f?.signatures))throw new Error("bad response");return f}async mint(t){const r=await this.handleBlindAuth("/v1/mint/bolt11");return M.mint(this._mintUrl,t,this._customRequest,r)}static async mintBolt12(t,r,s,o){const a=s||I,c=o?{"Blind-auth":o}:{},f=await a({endpoint:P(t,"/v1/mint/bolt12"),method:"POST",requestBody:r,headers:c});if(!x(f)||!Array.isArray(f?.signatures))throw new Error("bad response");return f}async mintBolt12(t){const r=await this.handleBlindAuth("/v1/mint/bolt12");return M.mintBolt12(this._mintUrl,t,this._customRequest,r)}static async createMeltQuote(t,r,s,o,a){const c=a??F,f=s||I,g=o?{"Blind-auth":o}:{},m=await f({endpoint:P(t,"/v1/melt/quote/bolt11"),method:"POST",requestBody:r,headers:g}),b=ft(m,c);if(!x(b)||typeof b?.amount!="number"||typeof b?.fee_reserve!="number"||typeof b?.quote!="string")throw new Error("bad response");return b}async createMeltQuote(t){const r=await this.handleBlindAuth("/v1/melt/quote/bolt11");return M.createMeltQuote(this._mintUrl,t,this._customRequest,r)}static async createMeltQuoteBolt12(t,r,s,o){const a=s||I,c=o?{"Blind-auth":o}:{};return await a({endpoint:P(t,"/v1/melt/quote/bolt12"),method:"POST",requestBody:r,headers:c})}async createMeltQuoteBolt12(t){const r=await this.handleBlindAuth("/v1/melt/quote/bolt12");return M.createMeltQuoteBolt12(this._mintUrl,t,this._customRequest,r)}static async checkMeltQuote(t,r,s,o,a){const c=a??F,f=s||I,g=o?{"Blind-auth":o}:{},m=await f({endpoint:P(t,"/v1/melt/quote/bolt11",r),method:"GET",headers:g}),b=ft(m,c);if(!x(b)||typeof b?.amount!="number"||typeof b?.fee_reserve!="number"||typeof b?.quote!="string"||typeof b?.state!="string"||!Object.values(tt).includes(b.state))throw new Error("bad response");return b}async checkMeltQuote(t){const r=await this.handleBlindAuth(`/v1/melt/quote/bolt11/${t}`);return M.checkMeltQuote(this._mintUrl,t,this._customRequest,r)}static async checkMeltQuoteBolt12(t,r,s,o){const a=s||I,c=o?{"Blind-auth":o}:{};return await a({endpoint:P(t,"/v1/melt/quote/bolt12",r),method:"GET",headers:c})}async checkMeltQuoteBolt12(t){const r=await this.handleBlindAuth(`/v1/melt/quote/bolt12/${t}`);return M.checkMeltQuoteBolt12(this._mintUrl,t,this._customRequest,r)}static async melt(t,r,s,o,a){const c=a??F,f=s||I,g=o?{"Blind-auth":o}:{},m=await f({endpoint:P(t,"/v1/melt/bolt11"),method:"POST",requestBody:r,headers:g}),b=ft(m,c);if(!x(b)||typeof b?.state!="string"||!Object.values(tt).includes(b.state))throw new Error("bad response");return b}async melt(t){const r=await this.handleBlindAuth("/v1/melt/bolt11");return M.melt(this._mintUrl,t,this._customRequest,r)}static async meltBolt12(t,r,s,o){const a=s||I,c=o?{"Blind-auth":o}:{};return await a({endpoint:P(t,"/v1/melt/bolt12"),method:"POST",requestBody:r,headers:c})}async meltBolt12(t){const r=await this.handleBlindAuth("/v1/melt/bolt12");return M.meltBolt12(this._mintUrl,t,this._customRequest,r)}static async check(t,r,s){const o=await(s||I)({endpoint:P(t,"/v1/checkstate"),method:"POST",requestBody:r});if(!x(o)||!Array.isArray(o?.states))throw new Error("bad response");return o}static async getKeys(t,r,s){r&&(r=r.replace(/\//g,"_").replace(/\+/g,"-"));const o=await(s||I)({endpoint:r?P(t,"/v1/keys",r):P(t,"/v1/keys")});if(!x(o)||!Array.isArray(o.keysets))throw new Error("bad response");return o}async getKeys(t,r){return await M.getKeys(r||this._mintUrl,t,this._customRequest)}static async getKeySets(t,r){return(r||I)({endpoint:P(t,"/v1/keysets")})}async getKeySets(){return M.getKeySets(this._mintUrl,this._customRequest)}async check(t){return M.check(this._mintUrl,t,this._customRequest)}static async restore(t,r,s){const o=await(s||I)({endpoint:P(t,"/v1/restore"),method:"POST",requestBody:r});if(!x(o)||!Array.isArray(o?.outputs)||!Array.isArray(o?.signatures))throw new Error("bad response");return o}async restore(t){return M.restore(this._mintUrl,t,this._customRequest)}async connectWebSocket(){if(this.ws)await this.ws.ensureConnection();else{const t=new URL(this._mintUrl),r="v1/ws";t.pathname&&(t.pathname.endsWith("/")?t.pathname+=r:t.pathname+="/"+r),this.ws=G.getInstance().getConnection(`${t.protocol==="https:"?"wss":"ws"}://${t.host}${t.pathname}`);try{await this.ws.connect()}catch(s){throw this._logger.error("Failed to connect to WebSocket...",{e:s}),new Error("Failed to connect to WebSocket...")}}}disconnectWebSocket(){this.ws&&this.ws.close()}get webSocketConnection(){return this.ws}async handleBlindAuth(t){if(this._checkNut22&&(await this.getLazyMintInfo()).requiresBlindAuthToken(t)){if(!this._authTokenGetter)throw new Error("Can not call a protected endpoint without authProofGetter");return this._authTokenGetter()}}}class mt{constructor(t,r,s){this.amount=t,this.B_=r,this.id=s}getSerializedBlindedMessage(){return{amount:this.amount,B_:this.B_.toHex(!0),id:this.id}}}function pt(n){return typeof n=="function"}class N{constructor(t,r,s){this.secret=s,this.blindingFactor=r,this.blindedMessage=t}toProof(t,r){let s;t.dleq&&(s={s:hexToBytes$1(t.dleq.s),e:hexToBytes$1(t.dleq.e),r:this.blindingFactor});const o={id:t.id,amount:t.amount,C_:l$1(t.C_)},a=l$1(r.keys[t.amount]),c=y(o,this.blindingFactor,this.secret,a);return{...v(c),...s&&{dleq:{s:bytesToHex$1(s.s),e:bytesToHex$1(s.e),r:_e(s.r??BigInt(0))}}}}static createP2PKData(t,r,s,o){return R(r,s.keys,o).map(a=>this.createSingleP2PKData(t,a,s.id))}static createSingleP2PKData(t,r,s){const o=Array.isArray(t.pubkey)?t.pubkey:[t.pubkey],a=Math.max(1,Math.min(t.requiredSignatures||1,o.length)),c=Math.max(1,Math.min(t.requiredRefundSignatures||1,t.refundKeys?t.refundKeys.length:1)),f=["P2PK",{nonce:bytesToHex$1(randomBytes(32)),data:o[0],tags:[]}];t.locktime&&f[1].tags.push(["locktime",String(t.locktime)]),o.length>1&&(f[1].tags.push(["pubkeys",...o.slice(1)]),a>1&&f[1].tags.push(["n_sigs",String(a)])),t.refundKeys&&(f[1].tags.push(["refund",...t.refundKeys]),c>1&&f[1].tags.push(["n_sigs_refund",String(c)]));const g=JSON.stringify(f),m=new TextEncoder().encode(g),{r:b,B_:k}=l(m);return new N(new mt(r,k,s).getSerializedBlindedMessage(),b,m)}static createRandomData(t,r,s){return R(t,r.keys,s).map(o=>this.createSingleRandomData(o,r.id))}static createSingleRandomData(t,r){const s=bytesToHex$1(randomBytes(32)),o=new TextEncoder().encode(s),{r:a,B_:c}=l(o);return new N(new mt(t,c,r).getSerializedBlindedMessage(),a,o)}static createDeterministicData(t,r,s,o,a){return R(t,o.keys,a).map((c,f)=>this.createSingleDeterministicData(c,r,s+f,o.id))}static createSingleDeterministicData(t,r,s,o){const a=T$1(r,o,s),c=bytesToHex$1(a),f=new TextEncoder().encode(c),g=be(z(r,o,s)),{r:m,B_:b}=l(f,g);return new N(new mt(t,b,o).getSerializedBlindedMessage(),m,f)}}const Oe=3,Ne="sat";class rs{constructor(t,r){this._keys=new Map,this._keysets=[],this._seed=void 0,this._unit=Ne,this._mintInfo=void 0,this._denominationTarget=Oe,this.mint=t,this._logger=r?.logger??F;let s=[];if(r?.keys&&!Array.isArray(r.keys)?s=[r.keys]:r?.keys&&Array.isArray(r?.keys)&&(s=r?.keys),s&&s.forEach(o=>this._keys.set(o.id,o)),r?.unit&&(this._unit=r?.unit),r?.keysets&&(this._keysets=r.keysets),r?.mintInfo&&(this._mintInfo=new gt(r.mintInfo)),r?.denominationTarget&&(this._denominationTarget=r.denominationTarget),r?.bip39seed){if(r.bip39seed instanceof Uint8Array){this._seed=r.bip39seed;return}throw new Error("bip39seed must be a valid UInt8Array")}r?.keepFactory&&(this._keepFactory=r.keepFactory)}get unit(){return this._unit}get keys(){return this._keys}get keysetId(){if(!this._keysetId)throw new Error("No keysetId set");return this._keysetId}set keysetId(t){this._keysetId=t}get keysets(){return this._keysets}get mintInfo(){if(!this._mintInfo)throw new Error("Mint info not loaded");return this._mintInfo}async getMintInfo(){const t=await this.mint.getInfo();return this._mintInfo=new gt(t),this._mintInfo}async lazyGetMintInfo(){return this._mintInfo?this._mintInfo:await this.getMintInfo()}async loadMint(){await Promise.all([this.getMintInfo(),this.getKeys()])}getActiveKeyset(t){let r=t.filter(o=>o.active&&o.unit===this._unit);r=r.filter(o=>o.id.startsWith("00"));const s=r.sort((o,a)=>(o.input_fee_ppk??0)-(a.input_fee_ppk??0))[0];if(!s)throw new Error("No active keyset found");return s}async getKeySets(){const t=(await this.mint.getKeySets()).keysets.filter(r=>r.unit===this._unit);return this._keysets=t,this._keysets}async getAllKeys(){const t=await this.mint.getKeys();return t.keysets.forEach(r=>{if(!Dt(r))throw new Error(`Couldn't verify keyset ID ${r.id}`)}),this._keys=new Map(t.keysets.map(r=>[r.id,r])),this.keysetId=this.getActiveKeyset(this._keysets).id,t.keysets}async getKeys(t,r){if((!(this._keysets.length>0)||r)&&await this.getKeySets(),t||(t=this.getActiveKeyset(this._keysets).id),!this._keysets.find(s=>s.id===t)&&(await this.getKeySets(),!this._keysets.find(s=>s.id===t)))throw new Error(`could not initialize keys. No keyset with id '${t}' found`);if(!this._keys.get(t)){const s=await this.mint.getKeys(t);if(!Dt(s.keysets[0]))throw new Error(`Couldn't verify keyset ID ${s.keysets[0].id}`);this._keys.set(t,s.keysets[0])}return this.keysetId=t,this._keys.get(t)}async receive(t,r){const{requireDleq:s,keysetId:o,outputAmounts:a,counter:c,pubkey:f,privkey:g,outputData:m,p2pk:b}=r||{};this._keysets.length===0&&await this.getKeySets(),typeof t=="string"&&(t=Pe(t,this._keysets));const k=await this.getKeys(o);if(s&&t.proofs.some(We=>!Ht(We,k)))throw new Error("Token contains proofs with invalid DLEQ");const _=W(t.proofs)-this.getFeesForProofs(t.proofs);let A;m?A={send:m}:this._keepFactory&&(A={send:this._keepFactory});const B=this.createSwapPayload(_,t.proofs,k,a,c,f,g,A,b),{signatures:L}=await this.mint.swap(B.payload),Z=B.outputData.map((We,re)=>We.toProof(L[re],k)),ve=[];return B.sortedIndices.forEach((We,re)=>{ve[We]=Z[re]}),ve}async send(t,r,s){const{offline:o,includeFees:a,includeDleq:c,keysetId:f,outputAmounts:g,pubkey:m,privkey:b,outputData:k}=s||{};if(c&&(r=r.filter(L=>L.dleq!=null)),W(r)<t)throw new Error("Not enough funds available to send");const{keep:_,send:A}=this.selectProofsToSend(r,t,s?.includeFees),B=a?this.getFeesForProofs(A):0;if(!o&&(W(A)!=t+B||g||m||b||f||k)){const L=await this.swap(t,r,s),{keep:Z,send:ve}=L,We=L.serialized;return{keep:Z,send:ve,serialized:We}}if(W(A)<t+B)throw new Error("Not enough funds available to send");return{keep:_,send:A}}selectProofsToSend(t,r,s=!1){const o=De();let a=null,c=1/0,f=0,g=0;const m=(ze,se)=>ze-(s?Math.ceil(se/1e3):0),b=ze=>{const se=[...ze];for(let ne=se.length-1;ne>0;ne--){const X=Math.floor(Math.random()*(ne+1));[se[ne],se[X]]=[se[X],se[ne]]}return se},k=(ze,se,ne)=>{let X=0,$e=ze.length-1,Ve=null;for(;X<=$e;){const Ze=Math.floor((X+$e)/2),He=ze[Ze].exFee;(ne?He<=se:He>=se)?(Ve=Ze,ne?X=Ze+1:$e=Ze-1):ne?$e=Ze-1:X=Ze+1}return ne?Ve:X<ze.length?X:null},_=(ze,se)=>{const ne=se.exFee;let X=0,$e=ze.length;for(;X<$e;){const Ve=Math.floor((X+$e)/2);ze[Ve].exFee<ne?X=Ve+1:$e=Ve}ze.splice(X,0,se)},A=(ze,se)=>m(ze,se)<r?1/0:ze+se/1e3-r;let B=0,L=0;const Z=t.map(ze=>{const se=this.getProofFeePPK(ze),ne=s?ze.amount-se/1e3:ze.amount,X={proof:ze,exFee:ne,ppkfee:se};return(!s||ne>0)&&(B+=ze.amount,L+=se),X});let ve=s?Z.filter(ze=>ze.exFee>0):Z;if(ve.sort((ze,se)=>ze.exFee-se.exFee),ve.length>0){let ze;{const se=k(ve,r,!1);if(se!==null){const ne=ve[se].exFee,X=k(ve,ne,!0);if(X===null)throw new Error("Unexpected null rightIndex in binary search");ze=X+1}else ze=ve.length}for(let se=ze;se<ve.length;se++)B-=ve[se].proof.amount,L-=ve[se].ppkfee;ve=ve.slice(0,ze)}const We=m(B,L);if(r<=0||r>We)return{keep:t,send:[]};const re=Math.min(Math.ceil(r*(1+0/100)),r+0,We);for(let ze=0;ze<60;ze++){const se=[];let ne=0,X=0;for(const Le of b(ve)){const Q=ne+Le.proof.amount,oe=X+Le.ppkfee,Y=m(Q,oe);if(se.push(Le),ne=Q,X=oe,Y>=r)break}const $e=new Set(se),Ve=ve.filter(Le=>!$e.has(Le)),Ze=b(Array.from({length:se.length},(Le,Q)=>Q)).slice(0,5e3);for(const Le of Ze){const Q=m(ne,X);if(Q===r||Q>=r&&Q<=re)break;const oe=se[Le],Y=ne-oe.proof.amount,Ce=X-oe.ppkfee,je=m(Y,Ce),Je=r-je,Ge=k(Ve,Je,!1);if(Ge!==null){const Xe=Ve[Ge];(Je>=0||Xe.exFee<=oe.exFee)&&(se[Le]=Xe,ne=Y+Xe.proof.amount,X=Ce+Xe.ppkfee,Ve.splice(Ge,1),_(Ve,oe))}}const He=A(ne,X);if(He<c){this._logger.debug("selectProofsToSend: best solution found in trial #{trial} - amount: {amount}, delta: {delta}",{trial:ze,amount:ne,delta:He}),a=[...se].sort((Q,oe)=>oe.exFee-Q.exFee),c=He,f=ne,g=X;const Le=[...a];for(;Le.length>1&&c>0;){const Q=Le.pop(),oe=ne-Q.proof.amount,Y=X-Q.ppkfee,Ce=A(oe,Y);if(Ce==1/0)break;Ce<c&&(a=[...Le],c=Ce,f=oe,g=Y,ne=oe,X=Y)}}if(a&&c<1/0){const Le=m(f,g);if(Le===r||Le>=r&&Le<=re)break}if(o.elapsed()>1e3){this._logger.warn("Proof selection took too long. Returning best selection so far.");break}}if(a&&c<1/0){const ze=a.map(X=>X.proof),se=new Set(ze),ne=t.filter(X=>!se.has(X));return this._logger.info("Proof selection took {time}ms",{time:o.elapsed()}),{keep:ne,send:ze}}return{keep:t,send:[]}}getFeesForProofs(t){const r=t.reduce((s,o)=>s+this.getProofFeePPK(o),0);return Math.ceil(r/1e3)}getProofFeePPK(t){const r=this._keysets.find(s=>s.id===t.id);if(!r)throw new Error(`Could not get fee. No keyset found for keyset id: ${t.id}`);return r?.input_fee_ppk||0}getFeesForKeyset(t,r){return Math.floor(Math.max((t*(this._keysets.find(s=>s.id===r)?.input_fee_ppk||0)+999)/1e3,0))}async swap(t,r,s){let{outputAmounts:o}=s||{};const{includeFees:a,keysetId:c,counter:f,pubkey:g,privkey:m,proofsWeHave:b,outputData:k,p2pk:_}=s||{},A=await this.getKeys(c);let B=t;const L=W(r);let Z=o?.sendAmounts||R(B,A.keys);if(a){let oe=this.getFeesForKeyset(Z.length,A.id),Y=R(oe,A.keys);for(;this.getFeesForKeyset(Z.concat(Y).length,A.id)>oe;)oe++,Y=R(oe,A.keys);Z=Z.concat(Y),B+=oe}const{keep:ve,send:We}=this.selectProofsToSend(r,B,!0),re=W(We)-this.getFeesForProofs(We)-B;if(re<0)throw new Error("Not enough balance to send");let ze;if(!o?.keepAmounts&&!b)ze=R(re,A.keys);else if(!o?.keepAmounts&&b)ze=vt(b,re,A.keys,this._denominationTarget);else if(o){if(o.keepAmounts?.reduce((oe,Y)=>oe+Y,0)!=re)throw new Error("Keep amounts do not match amount to keep");ze=o.keepAmounts}if(B+this.getFeesForProofs(We)>L)throw this._logger.error(`Not enough funds available (${L}) for swap amountToSend: ${B} + fee: ${this.getFeesForProofs(We)} | length: ${We.length}`),new Error("Not enough funds available for swap");o={keepAmounts:ze,sendAmounts:Z};const se=k?.keep||this._keepFactory,ne=k?.send,X=this.createSwapPayload(B,We,A,o,f,g,m,{keep:se,send:ne},_),{signatures:$e}=await this.mint.swap(X.payload),Ve=X.outputData.map((oe,Y)=>oe.toProof($e[Y],A)),Ze=[],He=[],Le=Array(X.keepVector.length),Q=Array(Ve.length);return X.sortedIndices.forEach((oe,Y)=>{Le[oe]=X.keepVector[Y],Q[oe]=Ve[Y]}),Q.forEach((oe,Y)=>{Le[Y]?Ze.push(oe):He.push(oe)}),{keep:[...Ze,...ve],send:He}}async batchRestore(t=300,r=100,s=0,o){const a=Math.ceil(t/r),c=[];let f,g=0;for(;g<a;){const m=await this.restore(s,r,{keysetId:o});m.proofs.length>0?(g=0,c.push(...m.proofs),f=m.lastCounterWithSignature):g++,s+=r}return{proofs:c,lastCounterWithSignature:f}}async restore(t,r,s){const{keysetId:o}=s||{},a=await this.getKeys(o);if(!this._seed)throw new Error("CashuWallet must be initialized with a seed to use restore");const c=Array(r).fill(0),f=N.createDeterministicData(0,this._seed,t,a,c),{outputs:g,signatures:m}=await this.mint.restore({outputs:f.map(A=>A.blindedMessage)}),b={};g.forEach((A,B)=>b[A.B_]=m[B]);const k=[];let _;for(let A=0;A<f.length;A++){const B=b[f[A].blindedMessage.B_];B&&(_=t+A,f[A].blindedMessage.amount=B.amount,k.push(f[A].toProof(B,a)))}return{proofs:k,lastCounterWithSignature:_}}async createMintQuote(t,r){const s={unit:this._unit,amount:t,description:r},o=await this.mint.createMintQuote(s);return{...o,amount:o.amount||t,unit:o.unit||this.unit}}async createLockedMintQuote(t,r,s){const{supported:o}=(await this.lazyGetMintInfo()).isSupported(20);if(!o)throw new Error("Mint does not support NUT-20");const a={unit:this._unit,amount:t,description:s,pubkey:r},c=await this.mint.createMintQuote(a);if(typeof c.pubkey!="string")throw new Error("Mint returned unlocked mint quote");{const f=c.pubkey;return{...c,pubkey:f,amount:c.amount||t,unit:c.unit||this.unit}}}async createMintQuoteBolt12(t,r){const s=await this.lazyGetMintInfo();if(r?.description&&!s.supportsBolt12Description)throw new Error("Mint does not support description for bolt12");const o={pubkey:t,unit:this._unit,amount:r?.amount,description:r?.description};return this.mint.createMintQuoteBolt12(o)}async checkMintQuote(t){const r=typeof t=="string"?t:t.quote,s=await this.mint.checkMintQuote(r);return typeof t=="string"?s:{...s,amount:s.amount||t.amount,unit:s.unit||t.unit}}async checkMintQuoteBolt12(t){return this.mint.checkMintQuoteBolt12(t)}async mintProofs(t,r,s){return this._mintProofs("bolt11",t,r,s)}async mintProofsBolt12(t,r,s,o){return this._mintProofs("bolt12",t,r,{...o,privateKey:s})}async createMeltQuote(t){const r={unit:this._unit,request:t},s=await this.mint.createMeltQuote(r);return{...s,unit:s.unit||this.unit,request:s.request||t}}async createMeltQuoteBolt12(t,r){return this.mint.createMeltQuoteBolt12({unit:this._unit,request:t,options:r?{amountless:{amount_msat:r}}:void 0})}async createMultiPathMeltQuote(t,r){const{supported:s,params:o}=(await this.lazyGetMintInfo()).isSupported(15);if(!s)throw new Error("Mint does not support NUT-15");if(!o?.some(f=>f.method==="bolt11"&&f.unit===this.unit))throw new Error(`Mint does not support MPP for bolt11 and ${this.unit}`);const a={mpp:{amount:r}},c={unit:this._unit,request:t,options:a};return{...await this.mint.createMeltQuote(c),request:t,unit:this._unit}}async checkMeltQuote(t){const r=typeof t=="string"?t:t.quote,s=await this.mint.checkMeltQuote(r);return typeof t=="string"?s:{...s,request:t.request,unit:t.unit}}async checkMeltQuoteBolt12(t){return this.mint.checkMeltQuoteBolt12(t)}async meltProofs(t,r,s){return this._meltProofs("bolt11",t,r,s)}async meltProofsBolt12(t,r,s){return this._meltProofs("bolt12",t,r,s)}createSwapPayload(t,r,s,o,a,c,f,g,m){const b=r.reduce((re,ze)=>re+ze.amount,0);o&&o.sendAmounts&&!o.keepAmounts&&(o.keepAmounts=R(b-t-this.getFeesForProofs(r),s.keys));const k=b-t-this.getFeesForProofs(r);let _=[],A=[];if(g?.keep)if(pt(g.keep)){const re=g.keep;R(k,s.keys).forEach(ze=>{_.push(re(ze,s))})}else _=g.keep;else _=this.createOutputData(k,s,a,void 0,o?.keepAmounts,void 0,this._keepFactory);if(g?.send)if(pt(g.send)){const re=g.send;R(t,s.keys).forEach(ze=>{A.push(re(ze,s))})}else A=g.send;else A=this.createOutputData(t,s,a?a+_.length:void 0,c,o?.sendAmounts,m);f&&(r=W$1(r,f)),r=at(r),r=r.map(re=>{const ze=re.witness&&typeof re.witness!="string"?JSON.stringify(re.witness):re.witness;return{...re,witness:ze}});const B=[..._,...A],L=B.map((re,ze)=>ze).sort((re,ze)=>B[re].blindedMessage.amount-B[ze].blindedMessage.amount),Z=[...Array.from({length:_.length},()=>!0),...Array.from({length:A.length},()=>!1)],ve=L.map(re=>B[re]),We=L.map(re=>Z[re]);return{payload:{inputs:r,outputs:ve.map(re=>re.blindedMessage)},outputData:ve,keepVector:We,sortedIndices:L}}async checkProofsStates(t){const r=new TextEncoder,s=t.map(c=>T$2(r.encode(c.secret)).toHex(!0)),o=100,a=[];for(let c=0;c<s.length;c+=o){const f=s.slice(c,c+o),{states:g}=await this.mint.check({Ys:f}),m={};g.forEach(b=>{m[b.Y]=b});for(let b=0;b<f.length;b++){const k=m[f[b]];if(!k)throw new Error("Could not find state for proof with Y: "+f[b]);a.push(k)}}return a}async onMintQuoteUpdates(t,r,s){if(await this.mint.connectWebSocket(),!this.mint.webSocketConnection)throw new Error("failed to establish WebSocket connection.");const o=this.mint.webSocketConnection.createSubscription({kind:"bolt11_mint_quote",filters:t},r,s);return()=>{this.mint.webSocketConnection?.cancelSubscription(o,r)}}async onMeltQuotePaid(t,r,s){return this.onMeltQuoteUpdates([t],o=>{o.state===tt.PAID&&r(o)},s)}async onMintQuotePaid(t,r,s){return this.onMintQuoteUpdates([t],o=>{o.state===yt.PAID&&r(o)},s)}async onMeltQuoteUpdates(t,r,s){if(await this.mint.connectWebSocket(),!this.mint.webSocketConnection)throw new Error("failed to establish WebSocket connection.");const o=this.mint.webSocketConnection.createSubscription({kind:"bolt11_melt_quote",filters:t},r,s);return()=>{this.mint.webSocketConnection?.cancelSubscription(o,r)}}async onProofStateUpdates(t,r,s){if(await this.mint.connectWebSocket(),!this.mint.webSocketConnection)throw new Error("failed to establish WebSocket connection.");const o=new TextEncoder,a={};for(let g=0;g<t.length;g++){const m=T$2(o.encode(t[g].secret)).toHex(!0);a[m]=t[g]}const c=Object.keys(a),f=this.mint.webSocketConnection.createSubscription({kind:"proof_state",filters:c},g=>{r({...g,proof:a[g.Y]})},s);return()=>{this.mint.webSocketConnection?.cancelSubscription(f,r)}}createOutputData(t,r,s,o,a,c,f){let g;if(o)g=N.createP2PKData({pubkey:o},t,r,a);else if(s||s===0){if(!this._seed)throw new Error("cannot create deterministic messages without seed");g=N.createDeterministicData(t,this._seed,s,r,a)}else c?g=N.createP2PKData(c,t,r,a):f?g=R(t,r.keys).map(m=>f(m,r)):g=N.createRandomData(t,r,a);return g}createBlankOutputs(t,r,s,o){let a=Math.ceil(Math.log2(t))||1;a<0&&(a=0);const c=a?Array(a).fill(0):[];return this.createOutputData(0,r,s,void 0,c,void 0,o)}async _mintProofs(t,r,s,o){let{outputAmounts:a}=o||{};const{counter:c,pubkey:f,p2pk:g,keysetId:m,proofsWeHave:b,outputData:k,privateKey:_}=o||{},A=await this.getKeys(m);!a&&b&&(a={keepAmounts:vt(b,r,A.keys,this._denominationTarget),sendAmounts:[]});let B=[];if(k)if(pt(k)){const We=R(r,A.keys,a?.keepAmounts);for(let re=0;re<We.length;re++)B.push(k(We[re],A))}else B=k;else if(this._keepFactory){const We=R(r,A.keys,a?.keepAmounts);for(let re=0;re<We.length;re++)B.push(this._keepFactory(We[re],A))}else B=this.createOutputData(r,A,c,f,a?.keepAmounts,g);const L=B.map(We=>We.blindedMessage),Z={outputs:L,quote:typeof s=="string"?s:s.quote};if(typeof s!="string"&&s.pubkey){if(!_)throw new Error("Can not sign locked quote without private key");Z.signature=p(_,s.quote,L)}if(t==="bolt12"){const{signatures:We}=await this.mint.mintBolt12(Z);return B.map((re,ze)=>re.toProof(We[ze],A))}const{signatures:ve}=await this.mint.mint(Z);return B.map((We,re)=>We.toProof(ve[re],A))}async _meltProofs(t,r,s,o){const{keysetId:a,counter:c,privkey:f}=o||{},g=await this.getKeys(a),m=this.createBlankOutputs(W(s)-r.amount,g,c,this._keepFactory);f!=null&&(s=W$1(s,f)),s=at(s),s=s.map(_=>{const A=_.witness&&typeof _.witness!="string"?JSON.stringify(_.witness):_.witness;return{..._,witness:A}});const b={quote:r.quote,inputs:s,outputs:m.map(_=>_.blindedMessage)};if(t==="bolt12"){const _=await this.mint.meltBolt12(b);return{quote:{..._,unit:r.unit,request:r.request},change:_.change?.map((A,B)=>m[B].toProof(A,g))??[]}}const k=await this.mint.melt(b);return{quote:{...k,unit:r.unit,request:r.request},change:k.change?.map((_,A)=>m[A].toProof(_,g))??[]}}}var FRAME_SIZE_LIMITS={MINIMUM:4096,DEFAULT:5e4},TIMEOUTS={SYNC_SESSION:5e3,CACHE_QUERY:5e3,EVENT_FETCH:1e4,RELAY_CONNECTION:3e4},RANGE_SPLITTING={BUCKET_COUNT:16,MIN_ELEMENTS_FOR_BUCKETS:32},BUFFER_SIZES={DEFAULT_WRAPPED_BUFFER_SIZE:512,FRAME_SIZE_SAFETY_MARGIN:200};function isWrappedBuffer(n){return n instanceof WrappedBuffer}function isUint8Array(n){return n instanceof Uint8Array&&!isWrappedBuffer(n)}var PROTOCOL_VERSION=97,ID_SIZE=32,FINGERPRINT_SIZE=16;function encodeVarInt(n){if(n===0)return new Uint8Array([0]);const t=[];for(;n!==0;)t.push(n&127),n>>>=7;t.reverse();for(let r=0;r<t.length-1;r++)t[r]|=128;return new Uint8Array(t)}function decodeVarInt(n){if(!isWrappedBuffer(n)&&!isUint8Array(n))throw new Error("Invalid buffer type: expected Uint8Array or WrappedBuffer");let t=0;for(;;){if(n.length===0)throw new Error("VarInt decoding: unexpected end of buffer");const r=shiftByte(n);if(t=t<<7|r&127,(r&128)===0)break}return t}function getByte(n){return getBytes(n,1)[0]}function getBytes(n,t){if(!isWrappedBuffer(n)&&!isUint8Array(n))throw new Error("Invalid buffer type: expected Uint8Array or WrappedBuffer");if(n.length<t)throw new Error("getBytes: unexpected end of buffer");return isWrappedBuffer(n)?n.shiftN(t):n.slice(0,t)}function shiftByte(n){if(!isWrappedBuffer(n)&&!isUint8Array(n))throw new Error("Invalid buffer type: expected Uint8Array or WrappedBuffer");return isWrappedBuffer(n)?n.shift():n[0]}function compareUint8Array(n,t){const r=Math.min(n.length,t.length);for(let s=0;s<r;s++){if(n[s]<t[s])return-1;if(n[s]>t[s])return 1}return n.length<t.length?-1:n.length>t.length?1:0}function hexToUint8Array(n){if(n.startsWith("0x")&&(n=n.slice(2)),n.length%2!==0)throw new Error("Hex string has odd length");const t=new Uint8Array(n.length/2);for(let r=0;r<t.length;r++)t[r]=Number.parseInt(n.slice(r*2,r*2+2),16);return t}var hexLookupTable=new Array(256);{const n=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"];for(let t=0;t<256;t++)hexLookupTable[t]=n[t>>>4&15]+n[t&15]}function uint8ArrayToHex(n){let t="";for(let r=0;r<n.length;r++)t+=hexLookupTable[n[r]];return t}var WrappedBuffer=class ss{constructor(t){typeof t=="number"?(this._raw=new Uint8Array(t),this.length=0):t?(this._raw=new Uint8Array(t),this.length=t.length):(this._raw=new Uint8Array(BUFFER_SIZES.DEFAULT_WRAPPED_BUFFER_SIZE),this.length=0)}unwrap(){return this._raw.subarray(0,this.length)}get capacity(){return this._raw.byteLength}append(t){const r=t instanceof ss?t.unwrap():t,s=r.length+this.length;if(this.capacity<s){const o=this._raw,a=Math.max(this.capacity*2,s);this._raw=new Uint8Array(a),this._raw.set(o)}this._raw.set(r,this.length),this.length+=r.length}set(t){const r=t instanceof Uint8Array?t:new Uint8Array(t);this.capacity<r.length&&(this._raw=new Uint8Array(Math.max(this.capacity*2,r.length))),this._raw.set(r),this.length=r.length}shift(){if(this.length===0)throw new Error("Cannot shift from empty buffer");const t=this._raw[0];return this._raw=this._raw.subarray(1),this.length--,t}shiftN(t){if(this.length<t)throw new Error("Cannot shift more bytes than available");const r=this._raw.subarray(0,t);return this._raw=this._raw.subarray(t),this.length-=t,r}clear(){this.length=0}},Accumulator=class{constructor(){this.buf=new Uint8Array(ID_SIZE),this.setToZero()}setToZero(){this.buf=new Uint8Array(ID_SIZE)}add(n){let t=0,r=0;const s=new DataView(this.buf.buffer),o=new DataView(n.buffer);for(let a=0;a<8;a++){const c=a*4,f=s.getUint32(c,!0),g=o.getUint32(c,!0);let m=f;m+=t,m+=g,m>4294967295&&(r=1),s.setUint32(c,m&4294967295,!0),t=r,r=0}}negate(){const n=new DataView(this.buf.buffer);for(let r=0;r<8;r++){const s=r*4;n.setUint32(s,~n.getUint32(s,!0),!0)}const t=new Uint8Array(ID_SIZE);t[0]=1,this.add(t)}async getFingerprint(n){const t=new Uint8Array(this.buf.length+encodeVarInt(n).length);return t.set(this.buf),t.set(encodeVarInt(n),this.buf.length),(await this.sha256(t)).subarray(0,FINGERPRINT_SIZE)}async sha256(n){if(crypto?.subtle){const t=await crypto.subtle.digest("SHA-256",n.buffer);return new Uint8Array(t)}try{const t=await __vitePreload(()=>import("./BIHI7g3E.js"),[],import.meta.url);return new Uint8Array(t.createHash("sha256").update(n).digest())}catch{throw new Error("No SHA256 implementation available")}}};function itemCompare(n,t){return n.timestamp!==t.timestamp?n.timestamp-t.timestamp:compareUint8Array(n.id,t.id)}var NegentropyStorage=class is{constructor(){this.items=[],this.sealed=!1}static fromEvents(t){const r=new is;for(const s of t)r.insert(s.created_at||0,s.id);return r.seal(),r}insert(t,r){if(this.sealed)throw new Error("Storage is sealed, cannot insert");const s=typeof r=="string"?hexToUint8Array(r):r;if(s.length!==ID_SIZE)throw new Error(`Invalid ID size: expected ${ID_SIZE}, got ${s.length}`);this.items.push({timestamp:t,id:s})}seal(){if(this.sealed)throw new Error("Storage is already sealed");this.sealed=!0,this.items.sort(itemCompare);for(let t=1;t<this.items.length;t++)if(itemCompare(this.items[t-1],this.items[t])===0)throw new Error("Duplicate item in storage")}unseal(){this.sealed=!1}size(){return this.checkSealed(),this.items.length}getItem(t){if(this.checkSealed(),t>=this.items.length)throw new Error("Index out of range");return this.items[t]}iterate(t,r,s){this.checkSealed(),this.checkBounds(t,r);for(let o=t;o<r&&s(this.items[o],o);o++);}findLowerBound(t,r,s){return this.checkSealed(),this.checkBounds(t,r),this.binarySearch(this.items,t,r,o=>itemCompare(o,s)<0)}async fingerprint(t,r){const s=new Accumulator;return s.setToZero(),this.iterate(t,r,o=>(s.add(o.id),!0)),await s.getFingerprint(r-t)}checkSealed(){if(!this.sealed)throw new Error("Storage is not sealed")}checkBounds(t,r){if(t>r||r>this.items.length)throw new Error("Invalid range")}binarySearch(t,r,s,o){let a=s-r;for(;a>0;){let c=r;const f=Math.floor(a/2);c+=f,o(t[c])?(r=++c,a-=f+1):a=f}return r}},Negentropy=class{constructor(n,t=0){if(this.lastTimestampIn=0,this.lastTimestampOut=0,this.isInitiator=!1,t!==0&&t<FRAME_SIZE_LIMITS.MINIMUM)throw new Error(`frameSizeLimit too small (minimum ${FRAME_SIZE_LIMITS.MINIMUM} bytes)`);this.storage=n,this.frameSizeLimit=t}bound(n,t){return{timestamp:n,id:t||new Uint8Array(0)}}async initiate(){if(this.isInitiator)throw new Error("Already initiated");this.isInitiator=!0;const n=new WrappedBuffer;return n.set([PROTOCOL_VERSION]),await this.splitRange(0,this.storage.size(),this.bound(Number.MAX_VALUE),n),n.unwrap()}setInitiator(){this.isInitiator=!0}async reconcile(n){const t=[],r=[],s=new WrappedBuffer(n);this.lastTimestampIn=this.lastTimestampOut=0;const o=new WrappedBuffer;o.set([PROTOCOL_VERSION]);const a=this.validateProtocolVersion(s);if(!a.isValid)return{nextMessage:a.output.unwrap(),have:t,need:r};const c=this.storage.size();let f=this.bound(0),g=0,m=!1;for(;s.length!==0;){const b=new WrappedBuffer,k=()=>{m&&(m=!1,b.append(this.encodeBound(f)),b.append(encodeVarInt(0)))},_=this.decodeBound(s),A=s.length===0?0:decodeVarInt(s),B=g,L=this.storage.findLowerBound(g,c,_),Z=await this.processByMode(A,B,L,_,s,b,o,k,t,r);if(Z.shouldSkip&&(m=!0),this.exceededFrameSizeLimit(o.length+b.length)){const ve=await this.storage.fingerprint(L,c);o.append(this.encodeBound(this.bound(Number.MAX_VALUE))),o.append(encodeVarInt(1)),o.append(ve);break}Z.outputAlreadyAppended||o.append(b.unwrap()),g=L,f=_}return{nextMessage:o.length===1&&this.isInitiator?void 0:o.unwrap(),have:t,need:r}}validateProtocolVersion(n){const t=new WrappedBuffer;t.set([PROTOCOL_VERSION]);const r=getByte(n);if(r<96||r>111)throw new Error("Invalid negentropy protocol version byte");if(r!==PROTOCOL_VERSION){if(this.isInitiator)throw new Error(`Unsupported negentropy protocol version requested: ${r-96}`);return{isValid:!1,output:t}}return{isValid:!0,output:t}}async processByMode(n,t,r,s,o,a,c,f,g,m){if(n===0)return this.handleModeSkip();if(n===1)return await this.handleModeFingerprint(t,r,s,o,a,f);if(n===2)return await this.handleModeIdList(t,r,s,o,a,c,f,g,m);throw new Error("Unexpected mode")}handleModeSkip(){return{shouldSkip:!0,outputAlreadyAppended:!1}}async handleModeFingerprint(n,t,r,s,o,a){const c=getBytes(s,FINGERPRINT_SIZE),f=await this.storage.fingerprint(n,t);return compareUint8Array(c,f)!==0?(a(),await this.splitRange(n,t,r,o),{shouldSkip:!1,outputAlreadyAppended:!1}):{shouldSkip:!0,outputAlreadyAppended:!1}}async handleModeIdList(n,t,r,s,o,a,c,f,g){const m=decodeVarInt(s),b=new Map;for(let k=0;k<m;k++){const _=getBytes(s,ID_SIZE),A=Array.from(_).join(",");b.set(A,_)}return this.isInitiator?this.handleIdListAsInitiator(n,t,b,f,g):await this.handleIdListAsResponder(n,t,r,o,a,c)}handleIdListAsInitiator(n,t,r,s,o){this.storage.iterate(n,t,a=>{const c=Array.from(a.id).join(",");return r.has(c)?r.delete(c):s.push(a.id),!0});for(const a of r.values())o.push(a);return{shouldSkip:!0,outputAlreadyAppended:!1}}async handleIdListAsResponder(n,t,r,s,o,a){a();const c=new WrappedBuffer;let f=0,g=r;return this.storage.iterate(n,t,(m,b)=>this.exceededFrameSizeLimit(o.length+c.length)?(g=m,!1):(c.append(m.id),f++,!0)),s.append(this.encodeBound(g)),s.append(encodeVarInt(2)),s.append(encodeVarInt(f)),s.append(c.unwrap()),o.append(s.unwrap()),s.clear(),{shouldSkip:!1,outputAlreadyAppended:!0}}async splitRange(n,t,r,s){const o=t-n,a=RANGE_SPLITTING.BUCKET_COUNT;if(o<RANGE_SPLITTING.MIN_ELEMENTS_FOR_BUCKETS)s.append(this.encodeBound(r)),s.append(encodeVarInt(2)),s.append(encodeVarInt(o)),this.storage.iterate(n,t,c=>(s.append(c.id),!0));else{const c=Math.floor(o/a),f=o%a;let g=n;for(let m=0;m<a;m++){const b=c+(m<f?1:0),k=await this.storage.fingerprint(g,g+b);g+=b;let _;if(g===t)_=r;else{let A,B;if(this.storage.iterate(g-1,g+1,(L,Z)=>(Z===g-1?A=L:B=L,!0)),!A||!B)throw new Error(`Failed to get items at index ${g-1} and ${g} for bound calculation`);_=this.getMinimalBound(A,B)}s.append(this.encodeBound(_)),s.append(encodeVarInt(1)),s.append(k)}}}exceededFrameSizeLimit(n){return this.frameSizeLimit>0&&n>this.frameSizeLimit-BUFFER_SIZES.FRAME_SIZE_SAFETY_MARGIN}decodeTimestampIn(n){let t=decodeVarInt(n);return t=t===0?Number.MAX_VALUE:t-1,this.lastTimestampIn===Number.MAX_VALUE||t===Number.MAX_VALUE?(this.lastTimestampIn=Number.MAX_VALUE,Number.MAX_VALUE):(t+=this.lastTimestampIn,this.lastTimestampIn=t,t)}decodeBound(n){const t=this.decodeTimestampIn(n),r=decodeVarInt(n);if(r>ID_SIZE)throw new Error("Bound key too long");const s=new Uint8Array(ID_SIZE),o=getBytes(n,Math.min(r,n.length));return s.set(o),{timestamp:t,id:s}}encodeTimestampOut(n){if(n===Number.MAX_VALUE)return this.lastTimestampOut=Number.MAX_VALUE,encodeVarInt(0);const t=n;return n-=this.lastTimestampOut,this.lastTimestampOut=t,encodeVarInt(n+1)}encodeBound(n){const t=this.encodeTimestampOut(n.timestamp),r=encodeVarInt(n.id.length),s=new Uint8Array(t.length+r.length+n.id.length);return s.set(t),s.set(r,t.length),s.set(n.id,t.length+r.length),s}getMinimalBound(n,t){if(t.timestamp!==n.timestamp)return this.bound(t.timestamp);let r=0;for(let s=0;s<ID_SIZE&&t.id[s]===n.id[s];s++)r++;return this.bound(t.timestamp,t.id.subarray(0,r+1))}};function isNegMessage(n){return Array.isArray(n)&&n.length>=2&&typeof n[0]=="string"&&typeof n[1]=="string"}function isNegMsgWithPayload(n){return isNegMessage(n)&&n.length===3&&typeof n[2]=="string"}function hasWebSocketConnectivity(n){return"connectivity"in n&&n.connectivity&&typeof n.connectivity.send=="function"}var SyncSession=class extends libExports.EventEmitter{constructor(n,t,r,s){super(),this.need=new Set,this.have=new Set,this.active=!1,this.roundNumber=0,this.relay=n,this.filters=t,this.sessionId=this.generateSessionId(),this.opts=s,this.negentropy=new Negentropy(r,s.frameSizeLimit||FRAME_SIZE_LIMITS.DEFAULT),this.setupRelayMonitoring()}async start(){if(this.active)throw new Error("Sync session already active");this.active=!0,this.relay.registerProtocolHandler("NEG-MSG",this.handleNegMsg.bind(this)),this.relay.registerProtocolHandler("NEG-ERR",this.handleNegErr.bind(this)),this.relay.registerProtocolHandler("NEG-CLOSE",this.handleNegClose.bind(this)),this.relay.on("notice",this.handleNotice.bind(this));try{this.emitProgress("initiating",0);const n=await this.negentropy.initiate(),t=JSON.stringify(["NEG-OPEN",this.sessionId,this.filters,uint8ArrayToHex(n)]);return await this.sendRaw(t),this.roundNumber++,await new Promise((r,s)=>{this.once("complete",r),this.once("error",s),setTimeout(()=>{this.active&&(this.cleanup(),s(new Error("Sync session timeout")))},this.opts.timeout||TIMEOUTS.SYNC_SESSION)})}catch(n){throw this.cleanup(),n}}async handleNegMsg(n,t){try{if(!isNegMsgWithPayload(t))throw new Error("Invalid NEG-MSG format: expected [string, string, string]");const[,r,s]=t;if(r!==this.sessionId)return;const o=hexToUint8Array(s),a=o.length,c=await this.negentropy.reconcile(o);for(const f of c.need)this.need.add(uint8ArrayToHex(f));for(const f of c.have)this.have.add(uint8ArrayToHex(f));if(this.emitProgress("reconciling",a),c.nextMessage){this.roundNumber++;const f=JSON.stringify(["NEG-MSG",this.sessionId,uint8ArrayToHex(c.nextMessage)]);await this.sendRaw(f)}else{this.emitProgress("closing",0);const f=JSON.stringify(["NEG-CLOSE",this.sessionId]);await this.sendRaw(f),this.complete()}}catch(r){this.error(r instanceof Error?r:new Error(String(r)))}}handleNegErr(n,t){if(!isNegMsgWithPayload(t)){this.error(new Error("Invalid NEG-ERR format: expected [string, string, string]"));return}const[,r,s]=t;r===this.sessionId&&this.error(new Error(`Relay sync error: ${s}`))}handleNegClose(n,t){if(!isNegMessage(t)){this.error(new Error("Invalid NEG-CLOSE format: expected [string, string]"));return}const[,r]=t;r===this.sessionId&&this.complete()}handleNotice(n){if(typeof n!="string")return;const t=n.toLowerCase();(t.includes("negentropy")||t.includes("bad msg")||t.includes("bad message")||t.includes("unknown")&&t.includes("msg")||t.includes("unsupported")&&t.includes("protocol"))&&this.error(new Error(`Relay does not support negentropy: ${n}`))}complete(){this.active&&(this.cleanup(),this.emit("complete",{need:this.need,have:this.have}))}error(n){this.active&&(this.cleanup(),this.emit("error",n))}cleanup(){this.active=!1,this.relay.unregisterProtocolHandler("NEG-MSG"),this.relay.unregisterProtocolHandler("NEG-ERR"),this.relay.unregisterProtocolHandler("NEG-CLOSE"),this.relay.off("notice",this.handleNotice),this.relay.off("disconnect",this.handleRelayDisconnect)}setupRelayMonitoring(){this.relay.once("disconnect",this.handleRelayDisconnect.bind(this))}handleRelayDisconnect(){this.active&&this.error(new Error("Relay disconnected during sync session"))}async sendRaw(n){const t=this.relay.url;if(!this.relay.connected)throw new Error(`Relay ${t} is not connected`);if(!hasWebSocketConnectivity(this.relay))throw new Error(`Relay ${t} does not support direct message sending`);try{await this.relay.connectivity.send(n)}catch(r){throw new Error(`Failed to send message to relay ${t}: ${r instanceof Error?r.message:String(r)}`)}}generateSessionId(){return`neg-${Math.random().toString(36).substring(2,15)}`}emitProgress(n,t){const r={phase:n,round:this.roundNumber,needCount:this.need.size,haveCount:this.have.size,messageSize:t,timestamp:Date.now()};this.emit("progress",r)}};async function ndkSync(n,t={}){if(!this.cacheAdapter)throw new Error("NDK sync requires a cache adapter. Configure NDK with cacheAdapter option.");const r=Array.isArray(n)?n:[n],s=getRelaySet.call(this,t),o=Array.from(s.relays),a={events:[],need:new Set,have:new Set},c=o.map(async f=>{if(f.connected||await new Promise(g=>{const m=()=>{f.off("ready",m),g()};f.once("ready",m),setTimeout(()=>{f.off("ready",m),g()},TIMEOUTS.RELAY_CONNECTION)}),!f.connected){console.warn(`[NDK Sync] Relay ${f.url} did not connect in time, skipping`);return}try{await syncWithRelay.call(this,f,r,t,a)}catch(g){const m=g instanceof Error?g.message:String(g);console.error(`[NDK Sync] Failed to sync with relay ${f.url}: ${m}`),t.onRelayError&&await t.onRelayError(f,g instanceof Error?g:new Error(String(g)))}});return await Promise.all(c),a}function getRelaySet(n){if(n.relaySet)return n.relaySet;if(n.relayUrls)return NDKRelaySet.fromRelayUrls(n.relayUrls,this);const t=this.pool?.relays;if(!t||t.size===0)throw new Error("No relays available for sync");const r=new Set(t.values());return new NDKRelaySet(r,this)}async function syncWithRelay(n,t,r,s){try{const o=await queryCache.call(this,t),a=NegentropyStorage.fromEvents(o),c=new SyncSession(n,t,a,r);r.onNegotiationProgress&&c.on("progress",m=>{r.onNegotiationProgress?.(n,m)});const{need:f,have:g}=await c.start();for(const m of f)s.need.add(m);for(const m of g)s.have.add(m);if(r.autoFetch!==!1&&f.size>0){r.onNegotiationProgress&&r.onNegotiationProgress(n,{phase:"fetching",round:0,needCount:f.size,haveCount:g.size,messageSize:0,timestamp:Date.now()});const m=await fetchNeededEvents.call(this,n,f);s.events.push(...m),this.cacheAdapter&&await saveFetchedEventsToCache.call(this,m,t,n)}}catch(o){const a=o instanceof Error?o.message:String(o);throw new Error(`Sync failed with relay ${n.url}: ${a}`)}}async function saveFetchedEventsToCache(n,t,r){if(this.cacheAdapter)for(const s of n)await this.cacheAdapter.setEvent(s,t,r)}async function queryCache(n){if(!this.cacheAdapter)return[];const t=[];return new Promise(r=>{const s=this.subscribe(n,{cacheUsage:NDKSubscriptionCacheUsage.ONLY_CACHE,closeOnEose:!0,onEvents:o=>{t.push(...o)},onEvent:o=>{t.push(o)},onEose:()=>{r(t)}});setTimeout(()=>{s.stop(),r(t)},TIMEOUTS.CACHE_QUERY)})}async function fetchNeededEvents(n,t){const r=[],s=new NDKRelaySet(new Set([n]),this);return new Promise(o=>{const a=this.subscribe({ids:Array.from(t)},{closeOnEose:!0,relaySet:s,exclusiveRelay:!0,groupable:!1,onEvent:c=>{r.push(c)},onEose:()=>{o(r)}});setTimeout(()=>{a.stop(),o(r)},TIMEOUTS.EVENT_FETCH)})}async function supportsNegentropy(n){try{return(typeof n=="string"?await fetchRelayInformation(n):await n.fetchInfo()).supported_nips?.includes(77)??!1}catch{return!1}}var NDKSync=class vn{constructor(t){this.CAPABILITY_CACHE_TTL=36e5,this.ndk=t}async checkRelaySupport(t){const s=(await this.ndk.cacheAdapter?.getRelayStatus?.(t.url))?.metadata?.sync,o=Date.now();if(s?.lastChecked&&o-s.lastChecked<this.CAPABILITY_CACHE_TTL)return s.supportsNegentropy??!1;try{const a=await supportsNegentropy(t);return await this.ndk.cacheAdapter?.updateRelayStatus?.(t.url,{metadata:{sync:{supportsNegentropy:a,lastChecked:o}}}),a}catch(a){return await this.ndk.cacheAdapter?.updateRelayStatus?.(t.url,{metadata:{sync:{supportsNegentropy:!1,lastChecked:o,lastError:a instanceof Error?a.message:"Unknown error"}}}),!1}}async getNegentropyRelays(t){const r=t||Array.from(this.ndk.pool?.relays?.values()||[]);return(await Promise.all(r.map(async o=>({relay:o,supports:await this.checkRelaySupport(o)})))).filter(o=>o.supports).map(o=>o.relay)}async getRelayCapability(t){return(await this.ndk.cacheAdapter?.getRelayStatus?.(t))?.metadata?.sync}async clearCapabilityCache(t){t?await this.ndk.cacheAdapter?.updateRelayStatus?.(t,{metadata:{sync:void 0}}):console.warn("clearCapabilityCache() without relayUrl is not supported with persistent cache")}async markRelayAsNotSupporting(t,r){await this.ndk.cacheAdapter?.updateRelayStatus?.(t,{metadata:{sync:{supportsNegentropy:!1,lastChecked:Date.now(),lastError:r.message}}})}createErrorHandler(t){return async(r,s)=>{await t?.(r,s),await this.markRelayAsNotSupporting(r.url,s)}}async syncSingleRelay(t,r,s={}){if(await this.checkRelaySupport(t))return await ndkSync.call(this.ndk,r,{...s,relaySet:new NDKRelaySet(new Set([t]),this.ndk),onNegotiationProgress:s.onNegotiationProgress});const a=await this.ndk.guardrailOff("fetch-events-usage").fetchEvents(r,{relaySet:new NDKRelaySet(new Set([t]),this.ndk),subId:"sync-fetch-fallback",groupable:!1});return{events:Array.from(a),need:new Set,have:new Set}}async sync(t,r){const s=Array.isArray(t)?t:[t],o=r?.relaySet||(r?.relayUrls?NDKRelaySet.fromRelayUrls(r.relayUrls,this.ndk):void 0),a=Array.from(o?o.relays:this.ndk.pool?.relays?.values()||[]);if(a.length===0)return console.warn("[NDK Sync] No relays available for sync"),{events:[],need:new Set,have:new Set};const c={events:[],need:new Set,have:new Set},f={...r,onRelayError:this.createErrorHandler(r?.onRelayError)};return await Promise.all(a.map(async g=>{try{const m=await this.syncSingleRelay(g,s,f);c.events.push(...m.events);for(const b of m.need)c.need.add(b);for(const b of m.have)c.have.add(b)}catch(m){console.error(`[NDK Sync] Failed to sync with relay ${g.url}:`,m)}})),c}async syncAndSubscribe(t,r={}){this.ndk.cacheAdapter||console.warn("[NDKSync] No cache adapter - sync will not work, using subscription only");const s=Array.isArray(t)?t:[t],o=r.relaySet||(r.relayUrls?NDKRelaySet.fromRelayUrls(r.relayUrls,this.ndk):void 0),a=Array.from(o?o.relays:this.ndk.pool?.relays?.values()||[]);if(a.length===0)throw new Error("No relays available for syncAndSubscribe");const c=s.map(g=>({...g,limit:0})),f=this.ndk.subscribe(c,{...r,relaySet:o,closeOnEose:!1});if(this.ndk.cacheAdapter){let g=0;const m=a.length,b=async k=>{try{const _=await this.syncSingleRelay(k,s,{autoFetch:!0,onRelayError:this.createErrorHandler(r.onRelayError),onNegotiationProgress:r.onNegotiationProgress});r.onRelaySynced?.(k,_.events.length)}catch(_){console.error(`[NDKSync] Failed to sync from ${k.url}:`,_)}finally{g++,g===m&&r.onSyncComplete?.()}};for(const k of a)if(k.connected)b(k);else{let _=!1;const A=()=>{_||(_=!0,k.off("ready",A),b(k))};k.once("ready",A),setTimeout(()=>{_||(_=!0,k.off("ready",A),g++,g===m&&r.onSyncComplete?.())},TIMEOUTS.RELAY_CONNECTION)}}else setTimeout(()=>r.onSyncComplete?.(),0);return f}static sync(t,r,s){return new vn(t).sync(r,s)}static syncAndSubscribe(t,r,s){return new vn(t).syncAndSubscribe(r,s)}};async function fetchMintInfo(n,t){if(t.cacheAdapter?.getCacheData)try{const r=await t.cacheAdapter.getCacheData("wallet:mint:info",n);if(r)return{isOnline:!0,info:r}}catch(r){console.error("Error reading mint info from cache:",r)}try{const r=await fetch(`${n}/v1/info`);if(r.ok){const s=await r.json();if(t.cacheAdapter?.setCacheData)try{await t.cacheAdapter.setCacheData("wallet:mint:info",n,s)}catch(o){console.error("Error caching mint info:",o)}return{isOnline:!0,info:s}}return{isOnline:!1}}catch{return{isOnline:!1}}}function createMintDiscoveryStore(n,t={}){const{network:r="mainnet",timeout:s=1e4,followUsers:o}=t;let a,c,f;const g=new Map,m=createStore()((k,_)=>({mints:[],progress:{announcementsFound:0,recommendationsFound:0},getMint:A=>g.get(A),getTopMints:(A=10,B=0)=>{let L=_().mints;return B>0&&(L=L.filter(Z=>Z.recommendations.length>=B)),L.sort((Z,ve)=>ve.score-Z.score).slice(0,A)},searchMints:A=>{const B=A.toLowerCase();return _().mints.filter(L=>L.url.toLowerCase().includes(B)||L.name?.toLowerCase().includes(B)||L.description?.toLowerCase().includes(B))},recommendMint:async(A,B)=>{const L=new NDKMintRecommendation(n);L.recommendedKind=NDKKind.CashuMintAnnouncement,L.urls=[A],L.review=B,await L.sign(),await L.publish()},stop:()=>{a?.stop(),c?.stop(),f&&clearTimeout(f)}}));a=n.subscribe({kinds:[NDKKind.CashuMintAnnouncement],limit:100},{closeOnEose:!1,onEvent:async k=>{const _=await NDKCashuMintAnnouncement.from(k);if(!_||r&&_.network!==r)return;const A=_.url;if(!A)return;const B=g.get(A),L={url:A,identifier:_.identifier,network:_.network,nuts:_.nuts||[],name:_.metadata?.name,description:_.metadata?.description,icon:_.metadata?.icon,longDescription:_.metadata?.longDescription,contact:_.metadata?.contact,motd:_.metadata?.motd,recommendations:B?.recommendations||[],score:B?.score||0,lastUpdated:Date.now()};g.set(A,L),m.setState(Z=>({mints:Array.from(g.values()),progress:{...Z.progress,announcementsFound:Z.progress.announcementsFound+1}})),fetchMintInfo(A,n).then(({isOnline:Z,info:ve})=>{const We=g.get(A);We&&(g.set(A,{...We,isOnline:Z,name:ve?.name||We.name,description:ve?.description||We.description,icon:ve?.icon||We.icon,longDescription:ve?.longDescription||We.longDescription,contact:ve?.contact||We.contact,motd:ve?.motd||We.motd,lastUpdated:Date.now()}),m.setState({mints:Array.from(g.values())}))})}});const b={kinds:[NDKKind.EcashMintRecommendation],"#k":[NDKKind.CashuMintAnnouncement.toString()],limit:500};return o&&o.length>0&&(b.authors=o),c=n.subscribe(b,{closeOnEose:!1,onEvent:async k=>{const _=await NDKMintRecommendation.from(k);if(!_)return;const A=_.urls;for(const B of A){const L=g.get(B);L?(L.recommendations.push(_),L.score=L.recommendations.length,g.set(B,{...L})):g.set(B,{url:B,nuts:[],recommendations:[_],score:1,lastUpdated:Date.now()}),m.setState(Z=>({mints:Array.from(g.values()),progress:{...Z.progress,recommendationsFound:Z.progress.recommendationsFound+1}}))}}}),s>0&&(f=setTimeout(()=>{m.getState().stop()},s)),m}var mintWallets=new Map,mintWalletPromises=new Map;function mintKey(n,t,r){if(r){const s=new TextDecoder().decode(r);return`${n}-${t}-${s}`}return`${n}-${t}`}async function walletForMint(n,{pk:t,timeout:r=5e3,mintInfo:s,mintKeys:o,onMintInfoNeeded:a,onMintInfoLoaded:c,onMintKeysNeeded:f,onMintKeysLoaded:g}={}){const m=Date.now(),b=()=>`+${Date.now()-m}ms`;if(a){console.log(`[MINT-CACHE ${b()}] Querying cache for mint info: ${n}`);const L=Date.now();s??=await a(n);const Z=Date.now()-L;s?console.log(`[MINT-CACHE ${b()}]  Cache HIT for mint info: ${n} (${Z}ms)`,{name:s.name}):console.log(`[MINT-CACHE ${b()}]  Cache MISS for mint info: ${n} (${Z}ms)`)}if(f){console.log(`[MINT-CACHE ${b()}] Querying cache for mint keys: ${n}`);const L=Date.now();o??=await f(n);const Z=Date.now()-L;o?console.log(`[MINT-CACHE ${b()}]  Cache HIT for mint keys: ${n} (${Z}ms)`,{count:o.length}):console.log(`[MINT-CACHE ${b()}]  Cache MISS for mint keys: ${n} (${Z}ms)`)}if(!s&&c){console.log(`[MINT-CACHE ${b()}] Fetching mint info from ${n}/v1/info`);const L=Date.now();s=await M.getInfo(n);const Z=Date.now()-L;console.log(`[MINT-CACHE ${b()}] Caching mint info: ${n} (fetched in ${Z}ms)`,{name:s.name}),c?.(n,s)}const k="sat",_=mintKey(n,k,t);if(mintWallets.has(_))return console.log(`[MINT-CACHE ${b()}] Returning cached wallet instance: ${n}`),mintWallets.get(_);if(mintWalletPromises.has(_))return console.log(`[MINT-CACHE ${b()}] Wallet loading in progress, returning existing promise: ${n}`),mintWalletPromises.get(_);if(!s){if(a){console.log(`[MINT-CACHE ${b()}] Querying cache for mint info (second check): ${n}`);const L=Date.now();s=await a(n);const Z=Date.now()-L;s?console.log(`[MINT-CACHE ${b()}]  Cache HIT for mint info (second check): ${n} (${Z}ms)`,{name:s.name}):console.log(`[MINT-CACHE ${b()}]  Cache MISS for mint info (second check): ${n} (${Z}ms)`)}if(!s&&c){console.log(`[MINT-CACHE ${b()}] Fetching mint info from ${n}/v1/info (second check)`);const L=Date.now();s=await M.getInfo(n);const Z=Date.now()-L;console.log(`[MINT-CACHE ${b()}] Caching mint info (second check): ${n} (fetched in ${Z}ms)`,{name:s.name}),c(n,s)}}if(!o&&f){console.log(`[MINT-CACHE ${b()}] Querying cache for mint keys (second check): ${n}`);const L=Date.now();o=await f(n);const Z=Date.now()-L;o?console.log(`[MINT-CACHE ${b()}]  Cache HIT for mint keys (second check): ${n} (${Z}ms)`,{count:o.length}):console.log(`[MINT-CACHE ${b()}]  Cache MISS for mint keys (second check): ${n} (${Z}ms)`)}const A=new rs(new M(n),{unit:k,bip39seed:t,mintInfo:s,keys:o}),B=new Promise(async L=>{try{console.log(`[MINT-CACHE ${b()}] Loading mint wallet: ${n}`);const Z=Date.now(),ve=new Promise((re,ze)=>{setTimeout(()=>{ze(new Error("timeout loading mint"))},r)});await Promise.race([A.loadMint(),ve]);const We=Date.now()-Z;console.log(`[MINT-CACHE ${b()}] Mint wallet loaded: ${n} (${We}ms)`),mintWallets.set(_,A),mintWalletPromises.delete(_),A.keys&&(console.log(`[MINT-CACHE ${b()}] Caching mint keys after loadMint: ${n}`,{count:A.keys.size}),g?.(n,A.keys)),L(A)}catch(Z){console.error(`[WALLET ${b()}] error loading mint`,n,Z.message),mintWalletPromises.delete(_),L(null)}});return mintWalletPromises.set(_,B),B}function createMintCacheCallbacks(n){return{onMintInfoNeeded:async t=>{if(n.getCacheData)return n.getCacheData("wallet:mint:info",t)},onMintInfoLoaded:async(t,r)=>{n.setCacheData&&await n.setCacheData("wallet:mint:info",t,r)},onMintKeysNeeded:async t=>{if(n.getCacheData)return n.getCacheData("wallet:mint:keys",t)},onMintKeysLoaded:async(t,r)=>{if(!n.setCacheData)return;const s=Array.from(r.values());await n.setCacheData("wallet:mint:keys",t,s)}}}async function getCashuWallet(n){if(this.cashuWallets.has(n))return this.cashuWallets.get(n);const t=await walletForMint(n,{onMintInfoNeeded:this.onMintInfoNeeded,onMintInfoLoaded:this.onMintInfoLoaded,onMintKeysNeeded:this.onMintKeysNeeded,onMintKeysLoaded:this.onMintKeysLoaded});if(!t)throw new Error(`unable to load wallet for mint ${n}`);return this.cashuWallets.set(n,t),t}var NDKWalletStatus=(n=>(n.INITIAL="initial",n.LOADING="loading",n.READY="ready",n.FAILED="failed",n))(NDKWalletStatus||{}),NDKWallet=class extends libExports.EventEmitter{cashuWallets=new Map;onMintInfoNeeded;onMintInfoLoaded;onMintKeysNeeded;onMintKeysLoaded;getCashuWallet=getCashuWallet.bind(this);ndk;constructor(n){super(),this.ndk=n}status="initial";get type(){throw new Error("Not implemented")}walletId="unknown";get balance(){throw new Error("Not implemented")}redeemNutzaps(n,t,r){throw new Error("Not implemented")}};function getBolt11ExpiresAt(n){const t=bolt11Exports.decode(n),r=t.expiry,s=t.sections.find(o=>o.name==="timestamp").value;if(typeof r=="number"&&typeof s=="number")return r+s}function getBolt11Amount(n){const s=bolt11Exports.decode(n).sections.find(o=>o.name==="amount")?.value;return Number(s)}function getBolt11Description(n){return bolt11Exports.decode(n).sections.find(o=>o.name==="description")?.value}var NDKCashuQuote=class os extends NDKEvent{quoteId;mint;amount;unit;_wallet;static kind=NDKKind.CashuQuote;constructor(t,r){super(t,r),this.kind??=NDKKind.CashuQuote}static async from(t){const r=new os(t.ndk,t),s=t;try{await r.decrypt()}catch{r.content=s.content}try{const o=JSON.parse(r.content);r.quoteId=o.quoteId,r.mint=o.mint,r.amount=o.amount,r.unit=o.unit}catch{return}return r}set wallet(t){this._wallet=t}set invoice(t){const r=getBolt11ExpiresAt(t);r&&this.tags.push(["expiration",r.toString()])}async save(){if(!this.ndk)throw new Error("NDK is required");this.content=JSON.stringify({quoteId:this.quoteId,mint:this.mint,amount:this.amount,unit:this.unit}),await this.encrypt(this.ndk.activeUser,void 0,"nip44"),await this.sign(),await this.publish(this._wallet?.relaySet)}};async function createOutTxEvent(n,t,r,s,{nutzaps:o}={}){let a=t.paymentDescription,c;t.pr?(c=getBolt11Amount(t.pr),a??=getBolt11Description(t.pr),c&&(c/=1e3)):c=t.amount,c||console.error("BUG: Unable to find amount for paymentRequest",t);const f=new NDKCashuWalletTx(n);if(f.direction="out",f.amount=c??0,f.mint=r.mint,f.description=a,r.fee&&(f.fee=r.fee),t.target&&(f.tags.push(t.target.tagReference()),t.target instanceof NDKUser||f.tags.push(["p",t.target.pubkey])),o){f.description??="nutzap redeem";for(const g of o)f.addRedeemedNutzap(g)}return r.stateUpdate?.created&&(f.createdTokens=[r.stateUpdate.created]),r.stateUpdate?.deleted&&(f.destroyedTokenIds=r.stateUpdate.deleted),r.stateUpdate?.reserved&&(f.reservedTokens=[r.stateUpdate.reserved]),await f.sign(),f.publish(s),f}async function createInTxEvent(n,t,r,s,{nutzaps:o,fee:a,description:c},f){const g=new NDKCashuWalletTx(n),m=proofsTotalBalance(t);if(g.direction="in",g.amount=m,g.mint=r,g.description=c,s.created&&(g.createdTokens=[s.created]),s.deleted&&(g.destroyedTokenIds=s.deleted),s.reserved&&(g.reservedTokens=[s.reserved]),o)for(const b of o)g.addRedeemedNutzap(b);return a&&(g.fee=a),await g.sign(),g.publish(f),g}var d=debug$1("ndk-wallet:cashu:deposit");function randomMint(n){const t=n.mints;return t[Math.floor(Math.random()*t.length)]}var NDKCashuDeposit=class as extends libExports.EventEmitter{mint;amount;quoteId;wallet;checkTimeout;checkIntervalLength=2500;finalized=!1;quoteEvent;constructor(t,r,s){super(),this.wallet=t,this.mint=s||randomMint(t),this.amount=r}static fromQuoteEvent(t,r){if(!r.amount)throw new Error("quote has no amount");if(!r.mint)throw new Error("quote has no mint");const s=new as(t,r.amount,r.mint);return s.quoteId=r.quoteId,s}async start(t=2500){const s=await(await this.wallet.getCashuWallet(this.mint)).createMintQuote(this.amount);return d("created quote %s for %d %s",s.quote,this.amount,this.mint),this.quoteId=s.quote,this.wallet.depositMonitor.addDeposit(this),setTimeout(this.check.bind(this,t),t),this.createQuoteEvent(s.quote,s.request).then(o=>this.quoteEvent=o),s.request}async createQuoteEvent(t,r){const{ndk:s}=this.wallet,o=new NDKCashuQuote(s);o.quoteId=t,o.mint=this.mint,o.amount=this.amount,o.wallet=this.wallet,o.invoice=r;try{await o.save(),d("saved quote on event %s",o.rawEvent())}catch(a){d("error saving quote on event %s",a.relayErrors)}return o}async runCheck(){this.finalized||await this.finalize(),this.finalized||this.delayCheck()}delayCheck(){setTimeout(()=>{this.runCheck(),this.checkIntervalLength+=500},this.checkIntervalLength)}async check(t){this.runCheck(),t&&setTimeout(()=>{clearTimeout(this.checkTimeout)},t)}async finalize(){if(!this.quoteId)throw new Error("No quoteId set.");let t;try{d("Checking for minting status of %s",this.quoteId);const r=await this.wallet.getCashuWallet(this.mint),s=await this.wallet.state.getProofs({mint:this.mint});if(t=await r.mintProofs(this.amount,this.quoteId,{proofsWeHave:s}),t.length===0)return}catch(r){if(r.message.match(/not paid/i))return;if(r.message.match(/already issued/i)){d("Mint is saying the quote has already been issued, destroying quote event: %s",r.message),this.destroyQuoteEvent(),this.finalized=!0;return}if(r.message.match(/rate limit/i)){d("Mint seems to be rate limiting, lowering check interval"),this.checkIntervalLength+=5e3;return}d(r.message);return}try{this.finalized=!0;const r=await this.wallet.state.update({store:t,mint:this.mint},"Deposit"),s=r.created;if(!s)throw new Error("no token event created");createInTxEvent(this.wallet.ndk,t,this.mint,r,{description:"Deposit"},this.wallet.relaySet),this.emit("success",s),this.destroyQuoteEvent()}catch(r){this.emit("error",r.message),console.error(r)}}async destroyQuoteEvent(){if(!this.quoteEvent)return;(await this.quoteEvent.delete(void 0,!1)).publish(this.wallet.relaySet)}},NDKCashuDepositMonitor=class extends libExports.EventEmitter{deposits=new Map;addDeposit(n){const{quoteId:t}=n;if(!t)throw new Error("deposit has no quote ID");return this.deposits.has(t)?!1:(n.once("success",r=>{this.removeDeposit(t)}),this.deposits.set(t,n),this.emit("change"),!0)}removeDeposit(n){this.deposits.delete(n),this.emit("change")}};async function handleEventDeletion(n){const t=n.getMatchingTags("e").map(r=>r[1]);for(const r of t)this.state.removeTokenId(r)}async function handleQuote(n){const t=await NDKCashuQuote.from(n);if(!t)return;const r=Date.now()/1e3-3600;if(n.created_at&&n.created_at<r)return;const s=NDKCashuDeposit.fromQuoteEvent(this,t);this.depositMonitor.addDeposit(s)&&s.finalize()}async function handleToken(n){if(this.state.tokens.has(n.id))return;const t=await NDKCashuToken.from(n);if(t){for(const r of t.deletedTokens)this.state.removeTokenId(r);this.state.addToken(t)}}setInterval(()=>{},5e3);var handlers={[NDKKind.CashuToken]:handleToken,[NDKKind.CashuQuote]:handleQuote,[NDKKind.EventDeletion]:handleEventDeletion},balanceUpdateTimer=null;async function eventHandler(n){const t=handlers[n.kind];t&&(balanceUpdateTimer&&clearTimeout(balanceUpdateTimer),await t.call(this,n),balanceUpdateTimer=setTimeout(()=>{this.emit("balance_updated")},100))}async function eventDupHandler(n,t,r,s,o){}var d2$1=debug$1("ndk-wallet:cashu:validate");async function consolidateTokens(){d2$1("checking %d tokens for spent proofs",this.state.tokens.size);const n=new Set(this.state.getMintsProofs({validStates:new Set(["available","reserved","deleted"])}).keys());d2$1("found %d mints",n.size),n.forEach(t=>{consolidateMintTokens(t,this)})}async function consolidateMintTokens(n,t,r,s,o){r??=t.state.getProofs({mint:n,includeDeleted:!0,onlyAvailable:!1});const a=await walletForMint(n);if(!a)return;let c=[];try{c=await a.checkProofsStates(r)}catch{return}const f=[],g=[],m=[];r.forEach((_,A)=>{const{state:B}=c[A];B===ns.SPENT?f.push(_):B===ns.UNSPENT?g.push(_):m.push(_)});const b={mint:n,store:g,destroy:f};if(f.reduce((_,A)=>_+A.amount,0),b.destroy?.length===0)return;b.store?.push(...m);const k=m.reduce((_,A)=>_+A.amount,0);return t.state.reserveProofs(m,k),t.state.update(b,"Consolidate")}function calculateFee(n,t,r){const s=t.reduce((c,f)=>c+f.amount,0),o=r.reduce((c,f)=>c+f.amount,0),a=s-n-o;if(a<0)throw new Error("Invalid fee calculation: received more proofs than sent to mint");return a}async function withProofReserve(n,t,r,s,o,a){t??=await n.getCashuWallet(r);const c=n.state.getProofs({mint:r,onlyAvailable:!0}),f=t.selectProofsToSend(c,s);if(f.send.reduce((_,A)=>_+A.amount,0)<s)return null;n.state.reserveProofs(f.send,s);let m=null,b=null,k=null;try{if(m=await a(f.send,c),!m)return null;b={mint:r,store:m.change,destroy:f.send},k=await n.state.update(b)}catch(_){throw n.state.unreserveProofs(f.send,s,"available"),_}return m?{result:m.result,proofsChange:b,stateUpdate:k,mint:r,fee:calculateFee(o,f.send,m.change)}:null}async function payLn(n,t,{amount:r,unit:s}={}){let o=getBolt11Amount(t);if(!o)throw new Error("invoice amount is required");o=o/1e3,r&&s&&s==="msat"&&(r=r/1e3);const a=n.getMintsWithBalance(o+3);if(!a.length)return null;for(const c of a)try{const f=await executePayment(c,t,r??o,n);if(f)return r&&(f.fee=calculateFee(r,f.proofsChange?.destroy??[],f.proofsChange?.store??[])),f}catch(f){n.warn(`Failed to execute payment with min ${c}: ${f}`)}return null}async function executePayment(n,t,r,s){const o=await s.getCashuWallet(n);try{const a=await o.createMeltQuote(t),c=a.amount+a.fee_reserve;return await withProofReserve(s,o,n,c,r,async(g,m)=>{const b=await o.meltProofs(a,g);return b.quote.state===tt.PAID?{result:{preimage:b.quote.payment_preimage??""},change:b.change}:null})}catch(a){if(a instanceof Error)if(a.message.match(/already spent/i))setTimeout(()=>{consolidateMintTokens(n,s)},2500);else throw a;return null}}function ensureIsCashuPubkey(n){if(!n)return;let t=n;if(t.length===64&&(t=`02${t}`),t.length!==66)throw new Error("Invalid pubkey");return t}async function mintProofs(n,t,r,s,o,a){const c=(f,g,m)=>{const b=ensureIsCashuPubkey(o);n.mintProofs(r,t.quote,{pubkey:b,...a&&a.length>0?{tags:a}:{}}).then(k=>{console.debug("minted tokens",k),f({proofs:k,mint:s})}).catch(k=>{m++,m<=3?(console.error("error minting tokens",k),setTimeout(()=>c(f,g,m),m*1500)):g(k)})};return new Promise((f,g)=>{c(f,g,0)})}async function createToken(n,t,r,s,o){console.log("[createToken] Starting token creation",{amount:t,recipientMints:r,p2pk:s}),s=ensureIsCashuPubkey(s);const a=n.getMintsWithBalance(t);console.log("[createToken] My mints with enough balance",a);const c=r&&r.length>0,f=c?findMintsInCommon([r,a]):a;console.log("[createToken] Mints in common",{hasRecipientMints:c,mintsInCommon:f});for(const g of f){console.log("[createToken] Attempting to create token in mint",g);try{const m=await createTokenInMint(n,g,t,s,o);if(m)return console.log("[createToken] Successfully created token in mint",g),m;console.log("[createToken] Failed to create token in mint",g)}catch(m){console.error("[createToken] Error creating token in mint",g,m)}}return c?(console.log("[createToken] Attempting cross-mint transfer"),await createTokenWithMintTransfer(n,t,r,s,o)):(console.error("[createToken] All token creation attempts failed"),null)}async function createTokenInMint(n,t,r,s,o){console.log("[createTokenInMint] Starting",{mint:t,amount:r,p2pk:s});const a=await n.getCashuWallet(t);console.log("[createTokenInMint] Got cashu wallet for mint",t);try{const c=await withProofReserve(n,a,t,r,r,async(f,g)=>{console.log("[createTokenInMint] Inside withProofReserve callback",{proofsToUseCount:f.length,allOurProofsCount:g.length});const m=await a.send(r,f,{pubkey:s,proofsWeHave:g,...o&&o.length>0?{tags:o}:{}});return console.log("[createTokenInMint] Send result",{sendCount:m.send.length,keepCount:m.keep.length}),{result:{proofs:m.send,mint:t},change:m.keep,mint:t}});return console.log("[createTokenInMint] Success",c),c}catch(c){console.error("[createTokenInMint] Error",{mint:t,error:c.message,stack:c.stack})}return null}async function createTokenWithMintTransfer(n,t,r,s,o){const a=async()=>{const B=async re=>{const ze=await walletForMint(re);if(!ze)throw new Error(`unable to load wallet for mint ${re}`);return{quote:await ze.createMintQuote(t),mint:re,targetMintWallet:ze}},L=r.map(B),{quote:Z,mint:ve,targetMintWallet:We}=await Promise.any(L);if(!Z)throw new Error("failed to get quote from any mint");return{quote:Z,mint:ve,targetMintWallet:We}},{quote:c,mint:f,targetMintWallet:g}=await a();if(!c)return null;const m=getBolt11Amount(c.request);if(!m)throw new Error("invoice amount is required");const b=m/1e3;if(b>t)throw new Error(`invoice amount is more than the amount passed in (${b} vs ${t})`);const k=await payLn(n,c.request,{amount:t});if(!k)return null;const{proofs:_,mint:A}=await mintProofs(g,c,t,f,s,o);return{...k,result:{proofs:_,mint:A},fee:k.fee}}function findMintsInCommon(n){const t=new Map;for(const s of n)for(const o of s){const a=normalizeUrl(o);t.has(a)?t.set(a,t.get(a)+1):t.set(a,1)}const r=[];for(const[s,o]of t.entries())o===n.length&&r.push(s);return r}var PaymentHandler=class{wallet;constructor(n){this.wallet=n}async lnPay(n,t=!0){if(!n.pr)throw new Error("pr is required");const r=getBolt11Amount(n.pr);if(!r)throw new Error("invoice amount is required");if(n.amount&&r>n.amount)throw new Error("invoice amount is more than the amount passed in");const s=await payLn(this.wallet,n.pr,{amount:n.amount,unit:n.unit});if(s?.result?.preimage)return t&&createOutTxEvent(this.wallet.ndk,n,s,this.wallet.relaySet),s.result}async cashuPay(n){console.log("[PaymentHandler.cashuPay] Starting cashu payment",{originalAmount:n.amount,unit:n.unit,mints:n.mints,p2pk:n.p2pk,allowIntramintFallback:n.allowIntramintFallback});const t={...n};t.unit?.startsWith("msat")&&(t.amount=t.amount/1e3,t.unit="sat",console.log("[PaymentHandler.cashuPay] Converted msat to sat",{newAmount:t.amount,newUnit:t.unit})),console.log("[PaymentHandler.cashuPay] Creating token with mints",n.mints);let r=await createToken(this.wallet,t.amount,n.mints,n.p2pk,n.proofTags);if(!r?.result&&(console.log("[PaymentHandler.cashuPay] Token creation failed with specified mints"),n.allowIntramintFallback&&(console.log("[PaymentHandler.cashuPay] Attempting intramint fallback"),r=await createToken(this.wallet,t.amount,void 0,n.p2pk,n.proofTags)),!r?.result)){console.error("[PaymentHandler.cashuPay] Token creation failed completely");return}return console.log("[PaymentHandler.cashuPay] Token created successfully",{proofsCount:r.result.proofs.length,mint:r.result.mint}),createOutTxEvent(this.wallet.ndk,t,r,this.wallet.relaySet),r.result}};function getBalance(n){return this.getProofEntries(n).reduce((r,s)=>r+s.proof.amount,0)}function getMintsBalances({onlyAvailable:n}={onlyAvailable:!0}){const t={},r=this.getProofEntries({onlyAvailable:n});for(const s of r)s.mint&&(t[s.mint]??=0,t[s.mint]+=s.proof.amount);return t}function addProof(n){this.proofs.set(n.proof.C,n),this.journal.push({memo:"Added proof",timestamp:Date.now(),metadata:{type:"proof",id:n.proof.C,amount:n.proof.amount,mint:n.mint}})}function reserveProofs(n,t){for(const r of n)this.updateProof(r,{state:"reserved"});this.reserveAmounts.push(t)}function unreserveProofs(n,t,r){for(const o of n)this.updateProof(o,{state:r});const s=this.reserveAmounts.indexOf(t);if(s!==-1)this.reserveAmounts.splice(s,1);else throw new Error(`BUG: Amount ${t} not found in reserveAmounts`)}function getProofEntries(n={}){const t=new Map,r=new Set(["available"]);let{mint:s,onlyAvailable:o,includeDeleted:a}=n;o??=!0,o||r.add("reserved"),a&&r.add("deleted");for(const c of this.proofs.values())s&&c.mint!==s||r.has(c.state)&&c.proof&&t.set(c.proof.C,c);return Array.from(t.values())}function updateProof(n,t){const r=n.C,s=this.proofs.get(r);if(!s)throw new Error("Proof not found");const o={...s,...t};this.proofs.set(r,o),this.journal.push({memo:`Updated proof state: ${JSON.stringify(t)}`,timestamp:Date.now(),metadata:{type:"proof",id:r,amount:n.amount,mint:s.mint}})}function addToken(n){if(!n.mint)throw new Error("BUG: Token has no mint");const r=this.tokens.get(n.id)?.state??"available";this.tokens.set(n.id,{token:n,state:r});for(const s of n.proofs)maybeAssociateProofWithToken(this,s,n,r)}function maybeAssociateProofWithToken(n,t,r,s){const o=t.C,a=n.proofs.get(o);if(!a)return n.addProof({mint:r.mint,state:s,tokenId:r.id,timestamp:r.created_at,proof:t}),!0;if(a.tokenId){if(a.tokenId===r.id)return null;const c=n.tokens.get(a.tokenId);if(!c)throw new Error(`BUG: Token id ${a.tokenId} not found, was expected to be associated with proof ${o}`);const f=c.token;return f&&f.created_at&&(!r.created_at||r.created_at<f.created_at)?!1:(n.updateProof(t,{tokenId:r.id,state:s}),!0)}return n.updateProof(t,{tokenId:r.id,state:s}),!0}function removeTokenId(n){const t=this.tokens.get(n)||{};this.tokens.set(n,{...t,state:"deleted"});for(const r of this.proofs.values()){const{proof:s}=r;if(r.tokenId===n){if(!s)throw new Error("BUG: Proof entry has no proof");this.updateProof(s,{state:"deleted"})}}}async function update(n,t){return updateInternalState(this,n),this.wallet.emit("balance_updated"),updateExternalState(this,n)}function updateInternalState(n,t){if(t.store&&t.store.length>0)for(const r of t.store)n.addProof({mint:t.mint,state:"available",proof:r,timestamp:Date.now()});if(t.destroy&&t.destroy.length>0)for(const r of t.destroy)n.updateProof(r,{state:"deleted"});if(t.reserve&&t.reserve.length>0)throw new Error("BUG: Proofs should not be reserved via update")}async function updateExternalState(n,t){const r=calculateNewState(n,t);if(r.deletedTokenIds.size>0){const o=new NDKEvent(n.wallet.ndk,{kind:NDKKind.EventDeletion,tags:[["k",NDKKind.CashuToken.toString()],...Array.from(r.deletedTokenIds).map(a=>["e",a])]});await o.sign(),publishWithRetry(n,o,n.wallet.relaySet);for(const a of r.deletedTokenIds)n.removeTokenId(a)}const s={};if(r.saveProofs.length>0){const o=await createTokenEvent(n,t.mint,r);s.created=o}return s}async function publishWithRetry(n,t,r,s=10*1e3){let o;o=await t.publish(r);let a;t.kind===NDKKind.EventDeletion&&(a="deletion"),t.kind===NDKKind.CashuToken&&(a="token"),t.kind===NDKKind.CashuWallet&&(a="wallet");const c={type:a,id:t.id,relayUrl:r?.relayUrls.join(",")};if(o)return n.journal.push({memo:`Publish kind:${t.kind} succeesfully`,timestamp:Date.now(),metadata:c}),o;n.journal.push({memo:"Publish failed",timestamp:Date.now(),metadata:c}),setTimeout(()=>{publishWithRetry(n,t,r,s)},s)}async function createTokenEvent(n,t,r){const s=new NDKCashuToken(n.wallet.ndk);return s.mint=t,s.proofs=r.saveProofs,await s.toNostrEvent(),n.addToken(s),s.deletedTokens=Array.from(r.deletedTokenIds),await s.sign(),n.addToken(s),publishWithRetry(n,s,n.wallet.relaySet),s}function calculateNewState(n,t){const r=new Set;for(const a of t.destroy||[])r.add(a.C);const s=new Map;let o;for(const a of t.store||[])s.set(a.C,a);o=getAffectedTokens(n,t);for(const a of o.values())for(const c of a.proofs)r.has(c.C)||s.set(c.C,c);return{deletedTokenIds:new Set(o.keys()),deletedProofs:r,reserveProofs:[],saveProofs:Array.from(s.values())}}function getAffectedTokens(n,t){const r=new Map;for(const s of t.destroy||[]){const o=n.proofs.get(s.C);if(!o)continue;const a=o.tokenId;if(!a)continue;const c=n.tokens.get(a);c?.token&&r.set(a,c.token)}return r}var WalletState=class{constructor(n,t=new Set){this.wallet=n,this.reservedProofCs=t}reserveAmounts=[];proofs=new Map;tokens=new Map;journal=[];dump(){return{proofs:Array.from(this.proofs.values()),balances:this.getMintsBalance(),totalBalance:this.getBalance(),tokens:Array.from(this.tokens.values())}}addToken=addToken.bind(this);removeTokenId=removeTokenId.bind(this);addProof=addProof.bind(this);reserveProofs=reserveProofs.bind(this);unreserveProofs=unreserveProofs.bind(this);getProofEntries=getProofEntries.bind(this);updateProof=updateProof.bind(this);getProofs(n){return this.getProofEntries(n).map(t=>t.proof)}getTokens(n={onlyAvailable:!0}){const t=this.getProofEntries(n),r=new Map;for(const s of t){const o=s.tokenId??null,a=r.get(o)??{tokenId:o,mint:s.mint,proofEntries:[]};a.token??=o?this.tokens.get(o)?.token:void 0,a.proofEntries.push(s),r.set(o,a)}return r}getMintsProofs({validStates:n=new Set(["available"])}={}){const t=new Map;for(const r of this.proofs.values()){if(!r.mint||!r.proof||!n.has(r.state))continue;const s=t.get(r.mint)||[];s.push(r.proof),t.set(r.mint,s)}return t}getBalance=getBalance.bind(this);getMintsBalance=getMintsBalances.bind(this);update=update.bind(this)},NDKCashuWallet=class En extends NDKWallet{get type(){return"nip-60"}_p2pk;sub;status="initial";static kind=NDKKind.CashuWallet;static kinds=[NDKKind.CashuWallet];mints=[];privkeys=new Map;signer;walletId="nip-60";depositMonitor=new NDKCashuDepositMonitor;warnings=[];paymentHandler;state;relaySet;_walletRelays=[];constructor(t){if(super(t),this.ndk=t,this.paymentHandler=new PaymentHandler(this),this.state=new WalletState(this),t.cacheAdapter?.getCacheData&&t.cacheAdapter?.setCacheData){const r=createMintCacheCallbacks(t.cacheAdapter);this.onMintInfoNeeded=r.onMintInfoNeeded,this.onMintInfoLoaded=r.onMintInfoLoaded,this.onMintKeysNeeded=r.onMintKeysNeeded,this.onMintKeysLoaded=r.onMintKeysLoaded}}async backup(t=!0){if(this.privkeys.size===0)throw new Error("no privkey to backup");const r=new NDKCashuWalletBackup(this.ndk),s=[];for(const[o,a]of this.privkeys.entries())s.push(a.privateKey);return r.privkeys=s,r.mints=this.mints,t&&r.save(this.relaySet),r}consolidateTokens=consolidateTokens.bind(this);async mintNuts(t){let r;const s=t.reduce((o,a)=>o+a,0);for(const o of this.mints){const a=await this.getCashuWallet(o),c=await this.state.getProofs({mint:o});if(r=await a.send(s,c,{proofsWeHave:c,includeFees:!0,outputAmounts:{sendAmounts:t}}),r.send.length>0){const f={store:r?.keep??[],destroy:r.send,mint:o},g=await this.state.update(f);return createOutTxEvent(this.ndk,{paymentDescription:"minted nuts",amount:t.reduce((m,b)=>m+b,0)},{result:{proofs:r.send},stateUpdate:g,mint:o,fee:0},this.relaySet),this.emit("balance_updated"),r}}}async send(t,r){if(this.mints.length===0)throw new Error("No mints configured");const s=await this.mintNuts([t]);if(!s)throw new Error("Failed to create token");return Ye({mint:this.mints[0],proofs:s.send,memo:r})}async loadFromEvent(t){const r=new NDKEvent(t.ndk,t.rawEvent());await r.decrypt();const s=JSON.parse(r.content);for(const o of s)o[0]==="mint"?this.mints.push(o[1]):o[0]==="privkey"?await this.addPrivkey(o[1]):o[0]==="relay"&&this._walletRelays.push(o[1]);await this.getP2pk()}static async from(t){if(!t.ndk)throw new Error("no ndk instance on event");const r=new En(t.ndk);return await r.loadFromEvent(t),r}static async create(t,r,s){const o=new En(t),a=NDKPrivateKeySigner.generate();return await o.addPrivkey(a.privateKey),o.mints=r,s&&s.length>0&&(o.relaySet=NDKRelaySet.fromRelayUrls(s,t)),await o.publish(),await o.backup(!0),o}async fetchWalletRelays(t){if(this._walletRelays.length>0)return NDKRelaySet.fromRelayUrls(this._walletRelays,this.ndk);const r=await this.ndk.fetchEvent({kinds:[NDKKind.RelayList],authors:[t]},{cacheUsage:NDKSubscriptionCacheUsage.PARALLEL});if(r)return NDKRelayList.from(r).relaySet}async start(t){const r=this.ndk?.activeUser;if(this.status==="ready")return Promise.resolve();this.setStatus("loading");const s=t?.pubkey??r?.pubkey;if(!s)throw new Error("no pubkey");this.relaySet||(this.relaySet=await this.fetchWalletRelays(s));const o=[{kinds:[NDKKind.CashuToken],authors:[s]},{kinds:[NDKKind.CashuQuote],authors:[s]},{kinds:[NDKKind.EventDeletion],authors:[s],"#k":[NDKKind.CashuToken.toString()]}];if(t?.since&&(o[0].since=t.since,o[1].since=t.since,o[2].since=t.since),this.ndk.cacheAdapter){const a=[],c=await this.ndk.fetchEvents([{kinds:[NDKKind.CashuToken],authors:[s]}],{cacheUsage:NDKSubscriptionCacheUsage.ONLY_CACHE});a.push(...c);for(const f of a)eventHandler.call(this,f);this.emit("balance_updated")}if(this.ndk.cacheAdapter)try{const a=await NDKSync.sync(this.ndk,o,{relaySet:this.relaySet,autoFetch:!0});for(const g of a.events)eventHandler.call(this,g);const c=t??{};c.subId??="cashu-wallet-state";const f=o.map(g=>({...g,since:Math.floor(Date.now()/1e3)-60}));this.sub=this.ndk.subscribe(f,{...c,relaySet:this.relaySet,closeOnEose:!1,onEvent:g=>{eventHandler.call(this,g)},onEventDup:eventDupHandler.bind(this)}),this.emit("ready"),this.setStatus("ready")}catch(a){console.error("[NDKCashuWallet] Sync failed, falling back to subscription:",a),await this.startWithSubscription(o,t)}else await this.startWithSubscription(o,t)}async startWithSubscription(t,r){const s=r??{};return s.subId??="cashu-wallet-state",new Promise(o=>{this.sub=this.ndk.subscribe(t,{...s,relaySet:this.relaySet,onEvent:a=>{eventHandler.call(this,a)},onEose:async()=>{this.emit("ready"),this.setStatus("ready"),o()},onEventDup:eventDupHandler.bind(this)})})}stop(){this.sub?.stop(),this.setStatus("initial")}setStatus(t){this.status!==t&&(this.status=t,this.emit("status_changed",t))}async getP2pk(){if(this._p2pk)return this._p2pk;if(this.privkeys.size===0){const t=NDKPrivateKeySigner.generate();await this.addPrivkey(t.privateKey)}return this.p2pk}get p2pks(){return Array.from(this.privkeys.keys())}async addPrivkey(t){const r=new NDKPrivateKeySigner(t),s=await r.user();return this.privkeys.set(s.pubkey,r),this._p2pk??=s.pubkey,this._p2pk}get p2pk(){if(!this._p2pk)throw new Error("p2pk not set");return this._p2pk}set p2pk(t){if(this.privkeys.has(t))this.signer=this.privkeys.get(t),this.p2pk=t;else throw new Error(`privkey for ${t} not found`)}walletPayload(){const t=Array.from(this.privkeys.values()).map(s=>s.privateKey),r=payloadForEvent(t,this.mints);return this._walletRelays.length>0&&r.push(...this._walletRelays.map(s=>["relay",s])),r}async publish(){this.relaySet&&(this._walletRelays=Array.from(this.relaySet.relays).map(s=>s.url));const t=new NDKEvent(this.ndk,{content:JSON.stringify(this.walletPayload()),kind:NDKKind.CashuWallet}),r=await this.ndk?.signer?.user();return await t.encrypt(r,void 0,"nip44"),t.publish(this.relaySet)}async publishMintList(){const t=new NDKCashuMintList(this.ndk);return t.mints=this.mints,this.relaySet&&(t.relays=Array.from(this.relaySet.relays).map(r=>r.url)),t.p2pk=this.p2pk,t.publishReplaceable(this.relaySet)}async update(t){this.mints=t.mints,t.relays&&t.relays.length>0?(this.relaySet=NDKRelaySet.fromRelayUrls(t.relays,this.ndk),this._walletRelays=t.relays):(this.relaySet=void 0,this._walletRelays=[]);const r=new NDKEvent(this.ndk,{content:JSON.stringify(this.walletPayload()),kind:NDKKind.CashuWallet}),s=await this.ndk?.signer?.user();return await r.encrypt(s,void 0,"nip44"),r.publishReplaceable(this.relaySet)}deposit(t,r){const s=new NDKCashuDeposit(this,t,r);return s.on("success",o=>{this.state.addToken(o)}),s}async receiveToken(t,r){const{mint:s}=Pe(t),a=await(await this.getCashuWallet(s)).receive(t),c=await this.state.update({store:a,mint:s}),f=c.created;return createInTxEvent(this.ndk,a,s,c,{description:r},this.relaySet),f}async lnPay(t,r=!0){return this.paymentHandler.lnPay(t,r)}async cashuPay(t){return this.paymentHandler.cashuPay(t)}wallets=new Map;async redeemNutzaps(t,r,{mint:s,proofs:o,cashuWallet:a}){if(a)s??=a.mint.mintUrl;else{if(!s)throw new Error("mint not set");a=await this.getCashuWallet(s)}if(!s)throw new Error("mint not set");if(!o)throw new Error("proofs not set");try{const c=this.state.getProofs({mint:s}),f=await a.receive({proofs:o,mint:s},{proofsWeHave:c,privkey:r}),g=o.reduce((_,A)=>_+A.amount,0),m=f.reduce((_,A)=>_+A.amount,0),b=g-m,k=await this.state.update({store:f,mint:s});return createInTxEvent(this.ndk,f,s,k,{nutzaps:t,fee:b},this.relaySet),g}catch(c){throw console.error("error redeeming nutzaps",t.map(f=>f.encode()),c),c}}warn(t,r,s){s??=r?.onRelays,this.warnings.push({msg:t,event:r,relays:s}),this.emit("warning",{msg:t,event:r,relays:s})}get balance(){return{amount:this.state.getBalance({onlyAvailable:!0})}}mintBalance(t){return this.mintBalances[t]||0}get mintBalances(){return this.state.getMintsBalance({onlyAvailable:!0})}getMintsWithBalance(t){const r=this.state.getMintsBalance({onlyAvailable:!0});return Object.entries(r).filter(([s,o])=>o>=t).map(([s])=>s)}async getMintInfo(t){return await(await this.getCashuWallet(t)).mint.getInfo()}},NDKCashuWalletBackup=class cs extends NDKEvent{privkeys=[];mints=[];constructor(t,r){super(t,r),this.kind??=NDKKind.CashuWalletBackup}static async from(t){if(!t.ndk)throw new Error("no ndk instance on event");const r=new cs(t.ndk,t);try{await r.decrypt();const s=JSON.parse(r.content);for(const o of s)o[0]==="mint"?r.mints.push(o[1]):o[0]==="privkey"&&r.privkeys.push(o[1])}catch(s){console.error("error decrypting backup event",r.encode(),s);return}return r}async save(t){if(!this.ndk)throw new Error("no ndk instance");if(!this.privkeys.length)throw new Error("no privkeys");return this.content=JSON.stringify(payloadForEvent(this.privkeys,this.mints)),await this.encrypt(this.ndk.activeUser,void 0,"nip44"),this.publish(t)}};function payloadForEvent(n,t){if(n.length===0)throw new Error("privkey not set");return[...t.map(s=>["mint",s]),...n.map(s=>["privkey",s])]}debug$1("ndk-wallet:nwc");const index=Object.freeze(Object.defineProperty({__proto__:null,NDKCashuDeposit,NDKCashuWallet,NDKCashuWalletBackup,NDKWallet,NDKWalletStatus,WalletState,calculateNewState,consolidateMintTokens,consolidateTokens,createMintCacheCallbacks,createMintDiscoveryStore,getBolt11Amount,getBolt11Description,getBolt11ExpiresAt,update},Symbol.toStringTag,{value:"Module"}));debug$1("ndk-wot:filter");function rankByWoT(n,t,r={}){const{algorithm:s="distance",unknownsLast:o=!1,comparator:a}=r;return a?[...t].sort(a):[...t].sort((c,f)=>{const g=c.pubkey,m=f.pubkey,b=n.includes(g),k=n.includes(m);if(o){if(!b&&k)return 1;if(b&&!k)return-1;if(!b&&!k)return 0}switch(s){case"distance":{const _=n.getDistance(g)??1/0,A=n.getDistance(m)??1/0;return _-A}case"score":{const _=n.getScore(g);return n.getScore(m)-_}case"followers":{const _=n.getNode(g),A=n.getNode(m),B=_?.followedBy.size??0;return(A?.followedBy.size??0)-B}default:return 0}})}var d2=debug$1("ndk-wot"),NDKWoT=class{ndk;rootPubkey;nodes=new Map;loaded=!1;constructor(n,t){if(!this.isValidPubkey(t))throw new Error(`Invalid root pubkey: ${t}`);this.ndk=n,this.rootPubkey=t,this.nodes.set(t,{pubkey:t,depth:0,followedBy:new Set})}async load(n){const{depth:t,maxFollows:r=1e3,timeout:s,useNegentropy:o=!0,negentropyMinAuthors:a=5,relayUrls:c}=n;d2("Building WOT graph for %s with depth %d (negentropy: %s, minAuthors: %d)",this.rootPubkey,t,o,a);const f=Date.now(),g=new Set;for(let m=0;m<t;m++){if(s&&Date.now()-f>s){d2("Timeout reached while building WOT graph");break}const b=Array.from(this.nodes.values()).filter(_=>_.depth===m).map(_=>_.pubkey);if(b.length===0)break;d2("Processing %d users at depth %d",b.length,m);const k=await this.fetchContactLists({authors:b,useNegentropy:o&&b.length>=a,relayUrls:c});for(const _ of k){if(g.has(_.pubkey))continue;g.add(_.pubkey);const B=this.extractFollows(_).slice(0,r);for(const L of B){let Z=this.nodes.get(L);Z?(m+1<Z.depth&&(Z.depth=m+1),Z.followedBy.add(_.pubkey)):(Z={pubkey:L,depth:m+1,followedBy:new Set([_.pubkey])},this.nodes.set(L,Z))}}}this.loaded=!0,d2("WOT graph built with %d nodes in %dms",this.nodes.size,Date.now()-f)}async fetchContactLists(n){const{authors:t,useNegentropy:r,relayUrls:s}=n;if(!r)return d2("Fetching %d contact lists using subscription",t.length),await this.fetchViaSubscription(t);d2("Attempting negentropy sync for %d contact lists",t.length);try{const o={autoFetch:!0,subId:"wot-sync"};s&&(o.relayUrls=s);const a=await NDKSync.sync(this.ndk,{kinds:[NDKKind.Contacts],authors:t},o);return d2("Negentropy sync completed: %d events, %d needed, %d we have",a.events.length,a.need.size,a.have.size),new Set(a.events)}catch(o){return d2("Negentropy sync failed, falling back to subscription: %s",o),await this.fetchViaSubscription(t)}}async fetchViaSubscription(n){return new Promise((t,r)=>{const s=new Set,o=setTimeout(()=>{a.stop(),r(new Error(`Timeout fetching contact lists for ${n.length} authors`))},3e4),a=this.ndk.subscribe({kinds:[NDKKind.Contacts],authors:n},{closeOnEose:!0,subId:"wot-fetch",addSinceFromCache:!0,onEvent:c=>{s.add(c)},onEose:()=>{clearTimeout(o),a.stop(),d2("Subscription fetch completed: %d events",s.size),t(s)}})})}isValidPubkey(n){return/^[0-9a-f]{64}$/i.test(n)}extractFollows(n){const t=[];for(const r of n.tags)if(r[0]==="p"){const s=r[1];s&&typeof s=="string"&&this.isValidPubkey(s)?t.push(s):s&&d2("Skipping invalid p-tag pubkey: %s",s)}return t}getScore(n){const t=this.nodes.get(n);return t?1/(t.depth+1):0}getDistance(n){const t=this.nodes.get(n);return t?t.depth:null}includes(n,t){const r=this.nodes.get(n);return r?t?.maxDepth!==void 0?r.depth<=t.maxDepth:!0:!1}getAllPubkeys(n){let t=Array.from(this.nodes.values());if(n?.maxDepth!==void 0){const r=n.maxDepth;t=t.filter(s=>s.depth<=r)}return t.map(r=>r.pubkey)}getScores(n){const t=new Map;for(const r of n)t.set(r,this.getScore(r));return t}getNode(n){return this.nodes.get(n)||null}isLoaded(){return this.loaded}get size(){return this.nodes.size}},SessionError=class extends Error{constructor(n){super(n),this.name="SessionError"}},SignerDeserializationError=class extends SessionError{constructor(n){super(n),this.name="SignerDeserializationError"}},StorageError=class extends SessionError{constructor(n){super(n),this.name="StorageError"}},SessionNotFoundError=class extends SessionError{constructor(n){super(`Session not found for pubkey: ${n}`),this.name="SessionNotFoundError"}},NoActiveSessionError=class extends SessionError{constructor(){super("No active session"),this.name="NoActiveSessionError"}},NDKNotInitializedError=class extends SessionError{constructor(){super("NDK not initialized. Call init() first."),this.name="NDKNotInitializedError"}},AuthManager=class{constructor(n,t){this.store=n,this.getStore=t}async login(n,t={}){const{setActive:r=!0,...s}=t,o=await this.store.addSession(n,r);return this.store.startSession(o,s),o}logout(n){const t=n??this.getStore().activePubkey;if(!t)throw new NoActiveSessionError;this.store.removeSession(t)}async switchTo(n){await this.store.switchToUser(n)}};async function serializeSigner(n){try{return n.toPayload()}catch{return}}async function deserializeSigner(n,t){try{const r=await ndkSignerFromPayload(n,t);if(!r)throw new Error("NDK returned undefined signer");return r}catch(r){const s=r instanceof Error?r.message:"Unknown error";throw new SignerDeserializationError(`Failed to deserialize signer: ${s}`)}}async function serializeSession(n,t){return{pubkey:n.pubkey,signerPayload:t?await serializeSigner(t):void 0,lastActive:n.lastActive,preferences:n.preferences}}var PersistenceManager=class{constructor(n,t){this.storage=n,this.getStore=t}async restore(){if(!this.storage)throw new StorageError("No storage configured");const{sessions:n,activePubkey:t}=await this.storage.load();for(const[r,s]of n)await this.restoreSession(r,s);t&&this.getStore().sessions.has(t)&&this.getStore().switchToUser(t)}async persist(){if(!this.storage)throw new StorageError("No storage configured");const n=await this.serializeAllSessions();await this.storage.save(n,this.getStore().activePubkey)}async clear(){if(!this.storage)throw new StorageError("No storage configured");await this.storage.clear()}async restoreSession(n,t){const r=this.getStore();let s;if(t.signerPayload)try{s=await deserializeSigner(t.signerPayload,r.ndk)}catch(a){a instanceof SignerDeserializationError&&console.warn(`Failed to restore signer for ${n}: ${a.message}`)}const o=s?await s.user():r.ndk?.getUser({pubkey:n})??new NDKUser({pubkey:n});await r.addSession(s||o,!1),r.updateSession(n,{lastActive:t.lastActive,preferences:t.preferences})}async serializeAllSessions(){const n=this.getStore(),t=new Map;for(const[r,s]of n.sessions){const o=n.signers.get(r),a=await serializeSession(s,o);t.set(r,a)}return t}};function normalizeMonitor(n){const t=[],r=new Map;if(!n||n.length===0)return{kinds:t,constructorMap:r};for(const s of n)if(typeof s=="number")t.push(s);else if(s.kinds&&Array.isArray(s.kinds))for(const o of s.kinds)t.push(o),r.set(o,s);return{kinds:t,constructorMap:r}}function createSessionStore(){return createStore((n,t)=>({sessions:new Map,signers:new Map,activePubkey:void 0,init:r=>{n({ndk:r})},addSession:async(r,s)=>{const o=t();let a,c;"user"in r&&typeof r.user=="function"?(c=r,a=await c.user()):a=r;const f=a.pubkey,m=o.sessions.get(f)||{pubkey:f,events:new Map,subscriptions:[],lastActive:s?Math.floor(Date.now()/1e3):0},b=new Map(o.sessions);b.set(f,m);const k={sessions:b};if(c){const _=new Map(o.signers);_.set(f,c),k.signers=_}return s&&(k.activePubkey=f,o.ndk&&c&&(o.ndk.signer=c,a.ndk=o.ndk,o.ndk.activeUser=a)),n(k),f},startSession:(r,s)=>{const o=t(),{ndk:a,sessions:c}=o;if(!a)throw new NDKNotInitializedError;const f=c.get(r);if(!f)throw new SessionNotFoundError(r);for(const _ of f.subscriptions)_.stop();const{kinds:g,constructorMap:m}=normalizeMonitor(s.monitor),b=buildSubscriptionKinds(s,g);if(b.length===0)return;const k=a.subscribe({kinds:b,authors:[r]},{closeOnEose:!1,subId:"session"},{onEvent:_=>handleIncomingEvent(_,r,m,t)});t().updateSession(r,{subscriptions:[k]})},stopSession:r=>{const o=t().sessions.get(r);if(o?.subscriptions){for(const a of o.subscriptions)a.stop();t().updateSession(r,{subscriptions:[]})}},addMonitor:r=>{const s=t(),{ndk:o,activePubkey:a}=s;if(!o)throw new NDKNotInitializedError;if(!a){console.warn("No active session to add monitor to");return}const c=s.sessions.get(a);if(!c)throw new SessionNotFoundError(a);const{kinds:f,constructorMap:g}=normalizeMonitor(r);if(f.length===0)return;const m=o.subscribe({kinds:f,authors:[a]},{closeOnEose:!1},{onEvent:k=>handleIncomingEvent(k,a,g,t)}),b=[...c.subscriptions,m];t().updateSession(a,{subscriptions:b})},switchToUser:async r=>{const s=t();if(r===null){s.ndk&&(s.ndk.signer=void 0,s.ndk.activeUser=void 0,s.ndk.muteFilter=void 0,s.ndk.relayConnectionFilter=void 0),n({activePubkey:void 0});return}const o=s.sessions.get(r);if(!o)throw new SessionNotFoundError(r);const a=s.signers.get(r);if(t().updateSession(r,{lastActive:Math.floor(Date.now()/1e3)}),s.ndk)if(s.ndk.signer=a,o.muteSet||o.mutedWords?s.ndk.muteFilter=c=>{if(o.muteSet?.has(c.pubkey)||c.id&&o.muteSet?.has(c.id))return!0;if(c.content&&o.mutedWords&&o.mutedWords.size>0){const f=c.content.toLowerCase();for(const g of o.mutedWords)if(f.includes(g))return!0}return!1}:s.ndk.muteFilter=void 0,o.blockedRelays&&o.blockedRelays.size>0){const c=o.blockedRelays;s.ndk.relayConnectionFilter=f=>!c.has(f)}else s.ndk.relayConnectionFilter=void 0;if(n({activePubkey:r}),s.ndk&&a){const c=await a.user();c.ndk=s.ndk,s.ndk.activeUser=c}},removeSession:r=>{const s=t(),o=new Map(s.sessions),a=new Map(s.signers);o.delete(r),a.delete(r);const c={sessions:o,signers:a};if(s.activePubkey===r&&Array.from(o.keys()).length===0&&(c.activePubkey=void 0,s.ndk&&(s.ndk.signer=void 0,s.ndk.activeUser=void 0,s.ndk.muteFilter=void 0,s.ndk.relayConnectionFilter=void 0)),n(c),t().stopSession(r),s.activePubkey===r){const f=Array.from(o.keys());f.length>0&&t().switchToUser(f[0]).catch(g=>{console.error("Failed to switch session after removal:",g)})}},updateSession:(r,s)=>{const o=t(),a=o.sessions.get(r);if(!a)return;const c={...a,...s},f=new Map(o.sessions);f.set(r,c),n({sessions:f})},updatePreferences:(r,s)=>{const a=t().sessions.get(r);if(!a)return;const c={...a.preferences,...s};t().updateSession(r,{preferences:c})}}))}function buildSubscriptionKinds(n,t){const r=[];return n.follows&&r.push(NDKKind.Contacts),n.mutes&&r.push(NDKKind.MuteList),n.blockedRelays&&r.push(NDKKind.BlockRelayList),n.relayList&&r.push(NDKKind.RelayList),n.wallet&&r.push(NDKKind.CashuWallet,NDKKind.CashuMintList),r.push(...t),r}function handleIncomingEvent(n,t,r,s){const o=s().sessions.get(t);if(o){if(n.kind===NDKKind.Contacts){handleContactListEvent(n,t,s);return}if(n.kind===NDKKind.MuteList){handleMuteListEvent(n,t,s);return}if(n.kind===NDKKind.BlockRelayList){handleBlockRelayListEvent(n,t,s);return}if(n.kind===NDKKind.RelayList){handleRelayListEvent(n,t,s);return}handleReplaceableEvent(n,o,t,r,s)}}function handleContactListEvent(n,t,r){const s=r().sessions.get(t);if(!s||n.kind===void 0)return;const o=s.events.get(n.kind);if(o&&(o.id===n.id||(o.created_at??0)>(n.created_at??0)))return;const a=new Set;for(const c of n.tags)c[0]==="p"&&c[1]&&isValidPubkey(c[1])&&a.add(c[1]);s.events.set(n.kind,n),r().updateSession(t,{followSet:a,events:new Map(s.events)})}function handleMuteListEvent(n,t,r){const s=r().sessions.get(t);if(!s||n.kind===void 0)return;const o=s.events.get(n.kind);if(o&&(o.id===n.id||(o.created_at??0)>(n.created_at??0)))return;const a=new Map,c=new Set;for(const f of n.tags)(f[0]==="p"||f[0]==="e")&&f[1]&&a.set(f[1],f[0]),f[0]==="word"&&f[1]&&c.add(f[1].toLowerCase());s.events.set(n.kind,n),r().updateSession(t,{muteSet:a,mutedWords:c,events:new Map(s.events)})}function handleBlockRelayListEvent(n,t,r){const s=r().sessions.get(t);if(!s||n.kind===void 0)return;const o=s.events.get(n.kind);if(o&&(o.id===n.id||(o.created_at??0)>(n.created_at??0)))return;const a=new Set;for(const c of n.tags)c[0]==="relay"&&c[1]&&a.add(c[1]);s.events.set(n.kind,n),r().updateSession(t,{blockedRelays:a,events:new Map(s.events)})}function handleRelayListEvent(n,t,r){const s=r().sessions.get(t);if(!s||n.kind===void 0)return;const o=s.events.get(n.kind);if(o&&(o.id===n.id||(o.created_at??0)>(n.created_at??0)))return;const a=NDKRelayList.from(n),c=new Map;for(const f of a.readRelayUrls)c.set(f,{read:!0,write:!1});for(const f of a.writeRelayUrls){const g=c.get(f);g?g.write=!0:c.set(f,{read:!1,write:!0})}for(const f of a.bothRelayUrls)c.set(f,{read:!0,write:!0});s.events.set(n.kind,n),r().updateSession(t,{relayList:c,events:new Map(s.events)})}function handleReplaceableEvent(n,t,r,s,o){if(n.kind===void 0)return;const a=t.events.get(n.kind);if(a&&(a.id===n.id||(a.created_at??0)>(n.created_at??0)))return;const c=s.get(n.kind),f=c&&typeof c.from=="function"?c.from(n):n;t.events.set(n.kind,f),o().updateSession(r,{events:new Map(t.events)})}function debounce(n,t){let r=null;return(...s)=>{r&&clearTimeout(r),r=setTimeout(()=>{n(...s)},t)}}function serializeSessionData(n){const t={sessions:Array.from(n.sessions.entries()),activePubkey:n.activePubkey,version:1,updatedAt:Date.now()};return JSON.stringify(t,null,2)}function deserializeSessionData(n){const t=JSON.parse(n);return{sessions:new Map(t.sessions||[]),activePubkey:t.activePubkey}}var NDKSessionManager=class{constructor(n,t={}){this.store=createSessionStore(),this.options={autoSave:t.autoSave??!0,saveDebounceMs:t.saveDebounceMs??500,...t},this.store.getState().init(n),this.authManager=new AuthManager(this.store.getState(),()=>this.store.getState()),this.persistenceManager=new PersistenceManager(this.options.storage,()=>this.store.getState()),this.options.autoSave&&this.options.storage&&this.setupAutoSave()}getCurrentState(){return this.store.getState()}getSessions(){return this.getCurrentState().sessions}getSession(n){return this.getCurrentState().sessions.get(n)}get activeSession(){const{activePubkey:n,sessions:t}=this.getCurrentState();return n?t.get(n):void 0}get activeUser(){const n=this.activeSession,t=this.getCurrentState();if(!(!n||!t.ndk))return t.ndk.getUser({pubkey:n.pubkey})}get activePubkey(){return this.getCurrentState().activePubkey}isReadOnly(n){const t=n??this.getCurrentState().activePubkey;return t?!this.getCurrentState().signers.has(t):!0}async login(n,t={}){const r={...this.options.fetches,setActive:t.setActive};return this.authManager.login(n,r)}async createAccount(n,t){const s=this.getCurrentState().ndk;if(!s)throw new Error("NDK not initialized");const o=t?.signer??NDKPrivateKeySigner.generate();t?.signer||await this.login(o,{setActive:!0});const a=t?.publish!==!1,c=[];if(n?.profile){const f=new NDKEvent(s,{kind:NDKKind.Metadata,content:JSON.stringify(n.profile)});await f.sign(o),a?await f.publish():c.push(f)}if(n?.relays&&n.relays.length>0){const f=new NDKRelayList(s);f.bothRelayUrls=n.relays,await f.sign(o),a?await f.publish():c.push(f)}if(n?.wallet){const{NDKCashuWallet:f}=await __vitePreload(async()=>{const{NDKCashuWallet:g}=await Promise.resolve().then(()=>index);return{NDKCashuWallet:g}},void 0,import.meta.url);await f.create(s,n.wallet.mints,n.wallet.relays)}if(n?.follows&&n.follows.length>0){const f=new NDKEvent(s,{kind:NDKKind.Contacts,tags:n.follows.map(g=>["p",g]),content:""});await f.sign(o),a?await f.publish():c.push(f)}return{signer:o,events:c}}logout(n){this.authManager.logout(n)}async switchTo(n){await this.authManager.switchTo(n)}startSession(n,t){this.getCurrentState().startSession(n,t)}stopSession(n){this.getCurrentState().stopSession(n)}addMonitor(n){this.getCurrentState().addMonitor(n)}enableWallet(n){const t=n??this.getCurrentState().activePubkey;if(!t)return;const r=this.getCurrentState(),s=r.sessions.get(t);if(!s)return;r.updatePreferences(t,{walletEnabled:!0});const o=s.subscriptions;o&&o.length>0&&(r.stopSession(t),r.startSession(t,{...this.options.fetches,wallet:!0}))}disableWallet(n){const t=n??this.getCurrentState().activePubkey;if(!t)return;const r=this.getCurrentState(),s=r.sessions.get(t);if(!s)return;r.updatePreferences(t,{walletEnabled:!1});const o=s.subscriptions;o&&o.length>0&&(r.stopSession(t),r.startSession(t,{...this.options.fetches,wallet:!1}))}isWalletEnabled(n){const t=n??this.getCurrentState().activePubkey;return t?this.getCurrentState().sessions.get(t)?.preferences?.walletEnabled??!1:!1}subscribe(n){return this.store.subscribe(n)}async restore(){if(await this.persistenceManager.restore(),this.options.fetches){const n=this.getCurrentState();for(const t of n.sessions.keys()){const r=n.sessions.get(t);if(!r)continue;const s=r.preferences?.walletEnabled??this.options.fetches.wallet??!1,o={...this.options.fetches,wallet:s};n.startSession(t,o)}}}async persist(){return this.persistenceManager.persist()}async clear(){return this.persistenceManager.clear()}destroy(){const n=this.getCurrentState();for(const t of n.sessions.keys())n.stopSession(t);this.unsubscribe&&this.unsubscribe()}setupAutoSave(){const n=debounce(()=>{this.persistenceManager.persist().catch(t=>{console.error("Failed to auto-save sessions:",t)})},this.options.saveDebounceMs);this.unsubscribe=this.store.subscribe(()=>{n()})}},LocalStorage=class{constructor(n="ndk-sessions"){this.key=n}async save(n,t){if(typeof window>"u"||!window.localStorage)throw new StorageError("localStorage is not available");try{const s=serializeSessionData({sessions:n,activePubkey:t});localStorage.setItem(this.key,s)}catch(r){const s=r instanceof Error?r.message:"Unknown error";throw new StorageError(`Failed to save sessions to localStorage: ${s}`)}}async load(){if(typeof window>"u"||!window.localStorage)return{sessions:new Map};const n=localStorage.getItem(this.key);if(!n)return{sessions:new Map};try{return deserializeSessionData(n)}catch(t){const r=t instanceof Error?t.message:"Unknown error";throw new StorageError(`Failed to parse sessions from localStorage: ${r}`)}}async clear(){if(typeof window>"u"||!window.localStorage)throw new StorageError("localStorage is not available");try{localStorage.removeItem(this.key)}catch(n){const t=n instanceof Error?n.message:"Unknown error";throw new StorageError(`Failed to clear sessions from localStorage: ${t}`)}}};function constructing(n,t,r){n.session||r("ndksvelte-no-session",`NDKSvelte instantiated without 'session' parameter.

Session support is disabled. This means:
   No login/logout functionality
   No wallet integration ($wallet store unavailable)
   No automatic session persistence
   No follows/mutes management

Most interactive apps need session support.`,`Enable sessions: createNDK({ session: true })
Or with custom options: createNDK({ session: { follows: true, wallet: true } })`)}function subscribing(n,t,r){typeof n!="function"&&typeof n=="object"&&n!==null&&t("ndksvelte-subscribe-wrong-api",`$subscribe() requires a CALLBACK FUNCTION, not direct config.

You're trying to use an API that doesn't exist.

WRONG:
  const notes = ndk.$subscribe({ kinds: [1] });
  const notes = ndk.$subscribe([{ kinds: [1] }]);

CORRECT:
  const notes = ndk.$subscribe(() => ({
    filters: [{ kinds: [1], limit: 50 }]
  }));

The callback enables reactive filters and conditional subscriptions.`,"Always wrap your config in a callback function: () => ({ ... })")}function validateCallback(n,t,r){if(typeof n!="function")throw new TypeError(`${t} expects ${r} to be a function, but received ${typeof n}. Example: ndk.${t}(() => value) instead of ndk.${t}(value)`)}const inFlightEventRequests=new Map;function createFetchEvents(n,t){validateCallback(t,"$fetchEvents","config");const r=proxy([]),s=user_derived(()=>{const c=t();return!c||"filters"in c?c:Array.isArray(c)?{filters:c}:["kinds","authors","ids","since","until","limit","#e","#p","#a","#d","#t","search"].some(m=>m in c)?{filters:c}:c}),o=user_derived(()=>{const c=get(s);if(!(!c||!("filters"in c)))return Array.isArray(c.filters)?c.filters:[c.filters]}),a=user_derived(()=>{const c=get(s);if(!c||!("filters"in c))return{};const{filters:f,...g}=c;return g});return user_effect(()=>{const c=get(o),f=get(a);if(!c){untrack(()=>{r.length=0});return}const g=JSON.stringify({filters:c,...f});let m=inFlightEventRequests.get(g);m||(m=n.fetchEvents(c,f).then(k=>k).finally(()=>{inFlightEventRequests.delete(g)}),inFlightEventRequests.set(g,m)),untrack(()=>{r.length=0});const b=g;m.then(k=>{untrack(()=>{JSON.stringify({filters:get(o),...get(a)})===b&&(r.length=0,r.push(...Array.from(k)))})}).catch(()=>{untrack(()=>{JSON.stringify({filters:get(o),...get(a)})===b&&(r.length=0)})})}),r}function targetToId(n){return"pubkey"in n&&typeof n.pubkey=="string"?n.pubkey:n.tagId()}function randomId(){return Math.random().toString(36).substring(2,15)}function getZapperTarget(n){const{target:t}=n;return"pubkey"in t&&typeof t.pubkey=="string"?{id:t.pubkey,type:"user"}:{id:t.tagId(),type:"event"}}class ReactivePaymentsStore{#t=state(proxy([]));get pending(){return get(this.#t)}set pending(t){set(this.#t,t,!0)}#e=state(proxy([]));get history(){return get(this.#e)}set history(t){set(this.#e,t,!0)}#n=state(proxy(new Map));get byTarget(){return get(this.#n)}set byTarget(t){set(this.#n,t,!0)}getZapAmount(t){const r=targetToId(t);return(this.byTarget.get(r)||[]).filter(o=>o.type==="zap_sent"&&o.status==="complete").reduce((o,a)=>o+a.amount,0)}isZapped(t){const r=targetToId(t);return(this.byTarget.get(r)||[]).some(o=>o.type==="zap_sent"&&(o.status==="complete"||o.status==="pending"))}addPending(t,r){const{id:s,type:o}=getZapperTarget(t),a=t.amount,c=t.unit,f={internalId:randomId(),targetId:s,targetType:o,target:t.target,recipient:o==="user"?s:t.target.pubkey,sender:r,amount:a,unit:c,status:"pending",comment:t.comment,timestamp:Date.now(),zapper:t};this.pending=[...this.pending,f]}completePending(t,r){const s=this.pending.find(c=>c.internalId===t);if(!s)return;const o={id:r.id,type:"zap_sent",direction:"out",status:"complete",amount:s.amount,unit:s.unit,timestamp:r.created_at||s.timestamp,target:s.target,targetId:s.targetId,targetType:s.targetType,recipient:s.recipient,sender:s.sender,comment:s.comment,event:r};this.pending=this.pending.filter(c=>c.internalId!==t),this.history=[...this.history,o];const a=this.byTarget.get(s.targetId)||[];this.byTarget.set(s.targetId,[...a,o])}failPending(t,r){const s=this.pending.find(o=>o.internalId===t);s&&(s.status="failed",s.error=r,this.pending=[...this.pending])}}function createReactivePayments(){return new ReactivePaymentsStore}class ReactivePoolStore{#t;#e=state(proxy(new Map));get relays(){return get(this.#e)}set relays(t){set(this.#e,t,!0)}#n=state(0);get connectedCount(){return get(this.#n)}set connectedCount(t){set(this.#n,t,!0)}#r=state(0);get connectingCount(){return get(this.#r)}set connectingCount(t){set(this.#r,t,!0)}constructor(t){this.#t=t,this.#o()}#o(){const t=this.#t.pool;if(!t){console.error("[svelte] Pool not initialized, skipping event listeners");return}for(const r of t.relays.values())this.#s(r);t.on("relay:connect",this.#a),t.on("relay:disconnect",this.#l),t.on("relay:connecting",this.#u)}#s(t){const r=t.connectivity.status;let s;r>=NDKRelayStatus.CONNECTED?s="connected":r===NDKRelayStatus.CONNECTING?s="connecting":r===NDKRelayStatus.RECONNECTING?s="reconnecting":s="disconnected",this.#i(t,s)}#a=t=>{this.#i(t,"connected"),this.#c()};#l=t=>{this.#i(t,"disconnected"),this.#c()};#u=t=>{this.#i(t,"connecting"),this.#c()};#i(t,r){const s=this.relays.get(t.url),o={url:t.url,status:r,connectionStats:s?.connectionStats||{attempts:0,success:0}};r==="connecting"?o.connectionStats.attempts++:r==="connected"&&(o.connectionStats.success++,o.connectionStats.connectedAt=Date.now()),this.relays.set(t.url,o),this.relays=new Map(this.relays)}#c(){let t=0,r=0;for(const s of this.relays.values())s.status==="connected"&&t++,s.status==="connecting"&&r++;this.connectedCount=t,this.connectingCount=r}getRelay(t){return this.relays.get(t)}getConnectedRelays(){return Array.from(this.relays.values()).filter(t=>t.status==="connected")}}function createReactivePool(n){return new ReactivePoolStore(n)}class FollowsProxy{#t;#e;constructor(t,r){this.#t=t,this.#e=r}async add(t){const r=this.#t.currentUser;if(!r)throw new Error("No active user");return await r.follow(t,this.#e)}async remove(t){const r=this.#t.currentUser;if(!r)throw new Error("No active user");return await r.unfollow(t,this.#e)}async toggle(t){this.#e.has(t)?await this.remove(t):await this.add(t)}has(t){return this.#e.has(t)}get size(){return this.#e.size}[Symbol.iterator](){return this.#e[Symbol.iterator]()}values(){return this.#e.values()}keys(){return this.#e.keys()}entries(){return this.#e.entries()}forEach(t,r){return this.#e.forEach(t,r)}}class MutesProxy{#t;#e;constructor(t,r){this.#t=t,this.#e=r}async mute(t){const r=this.#t.currentUser;if(!r)throw new Error("No active user");if(!r.ndk)throw new Error("No NDK instance found");if(r.ndk.assertSigner(),this.#e.has(t))return;this.#e.add(t);const s=new NDKEvent(r.ndk,{kind:NDKKind.MuteList,content:"",tags:[]});for(const o of this.#e)s.tags.push(["p",o]);await s.publishReplaceable()}async unmute(t){const r=this.#t.currentUser;if(!r)throw new Error("No active user");if(!r.ndk)throw new Error("No NDK instance found");if(r.ndk.assertSigner(),!this.#e.has(t))return;this.#e.delete(t);const s=new NDKEvent(r.ndk,{kind:NDKKind.MuteList,content:"",tags:[]});for(const o of this.#e)s.tags.push(["p",o]);await s.publishReplaceable()}async toggle(t){this.#e.has(t)?await this.unmute(t):await this.mute(t)}has(t){return this.#e.has(t)}get size(){return this.#e.size}[Symbol.iterator](){return this.#e[Symbol.iterator]()}values(){return this.#e.values()}keys(){return this.#e.keys()}entries(){return this.#e.entries()}forEach(t,r){return this.#e.forEach(t,r)}}class ReactiveSessionsStore{#t;#e=state(proxy({}));get sessions(){return get(this.#e)}set sessions(t){set(this.#e,t,!0)}#n=state(void 0);get activePubkey(){return get(this.#n)}set activePubkey(t){set(this.#n,t,!0)}constructor(t){this.#t=t,this.#t.subscribe(r=>{const s={};if(r.sessions.forEach((o,a)=>{s[a]=o}),this.sessions=s,r.activePubkey){const o=r.signers.get(r.activePubkey);o&&r.ndk&&(r.ndk.signer=o)}else r.ndk&&(r.ndk.signer=void 0,r.ndk.activeUser=void 0);this.activePubkey=r.activePubkey}),this.#t.restore().catch(r=>{console.error("[svelte] Failed to restore sessions:",r)})}get current(){if(this.activePubkey)return this.sessions[this.activePubkey]}get currentUser(){return this.#t.activeUser}get follows(){const t=this.current?.followSet??new Set;return new FollowsProxy(this,t)}get mutes(){const t=this.current?.muteSet??new Map,r=new Set(t.keys());return new MutesProxy(this,r)}get mutedWords(){return this.current?.mutedWords??new Set}get blockedRelays(){return this.current?.blockedRelays??new Set}get relayList(){return this.current?.relayList??new Map}getSessionEvent(t){return this.current?.events.get(t)}get walletEvent(){return this.getSessionEvent(NDKKind.CashuWallet)}get all(){return Object.values(this.sessions)}async login(t,r){return await this.#t.login(t,r)}async add(t){return await this.#t.login(t,{setActive:!1})}logout(t){const r=t??this.activePubkey;r&&this.#t.logout(r)}logoutAll(){const t=Object.keys(this.sessions);for(const r of t)this.#t.logout(r)}async switch(t){await this.#t.switchTo(t)}async switchTo(t){await this.#t.switchTo(t)}get(t){return this.sessions[t]}start(t,r){this.#t.startSession(t,r)}stop(t){this.#t.stopSession(t)}addMonitor(t){this.#t.addMonitor(t)}isReadOnly(t){return this.#t.isReadOnly(t)}async createAccount(t,r){return await this.#t.createAccount(t,r)}}function createReactiveSessions(n){return new ReactiveSessionsStore(n)}class ReactiveWalletStore{#t=state(0);get balance(){return get(this.#t)}set balance(t){set(this.#t,t,!0)}#e=state(void 0);#n=state(proxy(NDKWalletStatus.INITIAL));get status(){return get(this.#n)}set status(t){set(this.#n,t,!0)}#r;#o;#s;#a;#l=!1;constructor(t,r){this.#r=t,this.#o=r,r.subscribe(s=>{const o=s.activePubkey;if(!o){this.clear();return}const c=s.sessions.get(o)?.events.get(NDKKind.CashuWallet),f=this.#a&&this.#a!==o;if(!c){get(this.#e)&&!f&&this.clear();return}c.id===this.#s&&o===this.#a||this.#l||this.#u(c,o)})}async#u(t,r){this.#l=!0;try{const s=await NDKCashuWallet.from(t);s&&(this.#s=t.id,this.#a=r,this.set(s),await s.start({pubkey:r}))}catch{}finally{this.#l=!1}}set(t){get(this.#e)&&(get(this.#e).off("balance_updated",this.#i),get(this.#e).off("status_changed",this.#c)),set(this.#e,t,!0),this.status=t.status,this.#r.wallet=t,t.on("balance_updated",this.#i),t.on("status_changed",this.#c),this.refreshBalance()}#i=t=>{t?this.balance=t.amount||0:this.refreshBalance()};#c=t=>{this.status=t};async refreshBalance(){if(get(this.#e))try{const t=get(this.#e).balance;this.balance=t?.amount||0}catch{}}clear(){get(this.#e)&&(get(this.#e).off("balance_updated",this.#i),get(this.#e).off("status_changed",this.#c)),set(this.#e,void 0),this.balance=0,this.status=NDKWalletStatus.INITIAL,this.#s=void 0,this.#a=void 0,this.#r.wallet=void 0}get mints(){const t=get(this.#e);return!t||!(t instanceof NDKCashuWallet)?[]:t.mints}get mintBalances(){const t=get(this.#e);if(!t||!(t instanceof NDKCashuWallet))return[];const r=t.state.getMintsBalance(),s=t.mints,o=new Map;for(const a of s)o.set(a,0);for(const[a,c]of Object.entries(r))typeof c=="number"&&o.set(a,c);return Array.from(o.entries()).map(([a,c])=>({url:a,balance:c})).sort((a,c)=>c.balance-a.balance)}get relays(){const t=get(this.#e);return!t||!(t instanceof NDKCashuWallet)?[]:t.relaySet?Array.from(t.relaySet.relays).map(r=>r.url):[]}get transactions(){return[]}get needsOnboarding(){const t=get(this.#e);return!t||t instanceof NDKCashuWallet&&t.mints.length===0}get privkey(){const t=get(this.#e);if(!(t instanceof NDKCashuWallet))return;const r=Array.from(t.privkeys),s=r.length>0?r[0]:void 0;return s?s[0]:void 0}get relaySet(){const t=get(this.#e);if(t instanceof NDKCashuWallet)return t.relaySet}deposit(t,r){const s=get(this.#e);if(s instanceof NDKCashuWallet)return s.deposit(t,r)}async send(t,r){const s=get(this.#e);if(!(s instanceof NDKCashuWallet))throw new Error("No wallet");return s.send(t,r)}async receiveToken(t,r){const s=get(this.#e);if(!(s instanceof NDKCashuWallet))throw new Error("No wallet");await s.receiveToken(t,r)}async getP2PKPubkey(){const t=get(this.#e);if(!(t instanceof NDKCashuWallet))throw new Error("No wallet");return await t.getP2pk()}async lnPay(t){const r=get(this.#e);if(!(r instanceof NDKCashuWallet))throw new Error("No wallet");return r.lnPay(t)}async save(t){let r=get(this.#e);if(r instanceof NDKCashuWallet)await r.update(t);else{const s=this.#o.activePubkey;if(!s)throw new Error("No active session");const o=await NDKCashuWallet.create(this.#r,t.mints,t.relays);await o.start({pubkey:s}),this.set(o),r=o}r instanceof NDKCashuWallet&&await r.publishMintList()}}function createReactiveWallet(n,t){return new ReactiveWalletStore(n,t)}class ReactiveWoTStore{#t;#e;#n=null;#r=state(!1);get loaded(){return get(this.#r)}set loaded(t){set(this.#r,t,!0)}#o=state(!1);get autoFilterEnabled(){return get(this.#o)}set autoFilterEnabled(t){set(this.#o,t,!0)}#s=state(void 0);constructor(t,r){this.#t=t,this.#e=r}async load(t={}){const r=this.#e.currentUser?.pubkey;if(!r)throw new Error("Cannot load WoT: no user logged in");this.#n=new NDKWoT(this.#t,r);const s={depth:t.maxDepth||3,maxFollows:t.maxFollows,timeout:t.timeout};await this.#n.load(s),this.loaded=!0}enableAutoFilter(t){this.autoFilterEnabled=!0,set(this.#s,t,!0)}disableAutoFilter(){this.autoFilterEnabled=!1,set(this.#s,void 0)}getScore(t){return this.#n?this.#n.getScore(t):0}getDistance(t){return this.#n?this.#n.getDistance(t):null}includes(t,r){return this.#n?this.#n.includes(t,r):!1}shouldFilterEvent(t){if(!this.#n||!this.autoFilterEnabled)return!1;const{maxDepth:r,minScore:s,includeUnknown:o=!1}=get(this.#s)||{};return this.includes(t.pubkey,{maxDepth:r})?s!==void 0?this.getScore(t.pubkey)<s:!1:!o}rankEvents(t,r){return this.#n?rankByWoT(this.#n,t,r):t}}function createReactiveWoT(n,t){return new ReactiveWoTStore(n,t)}function createSubscriptionInternal(n,t,r){let s=state(proxy([])),o=state(!1);const a=new Map;let c,f,g;const m=user_derived(()=>{const X=t();return!X||"filters"in X?X:Array.isArray(X)?{filters:X}:["kinds","authors","ids","since","until","limit","#e","#p","#a","#d","#t","search"].some(Ze=>Ze in X)?{filters:X}:X}),b=user_derived(()=>{const X=get(m);return X?"filters"in X?Array.isArray(X.filters)?X.filters:[X.filters]:[]:[]}),k=user_derived(()=>{const X=get(m);if(!X||!("filters"in X))return{};const{filters:$e,noDedupe:Ve,dedupeKey:Ze,wot:He,wotRank:Le,...Q}=X;return Q}),_=user_derived(()=>{const X=get(m);return!X||!("filters"in X)?{noDedupe:void 0,dedupeKey:void 0,wot:void 0,wotRank:void 0}:{noDedupe:X.noDedupe,dedupeKey:X.dedupeKey,wot:X.wot,wotRank:X.wotRank}}),A=user_derived(()=>get(_).dedupeKey??(X=>X.deduplicationKey()));user_effect(()=>{const X=get(b),$e=get(k);if(X.length===0){re();return}f=X,g=$e,se()}),user_effect(()=>{get(_),ve()});let B,L=0;function Z(X){const $e=get(_),Ve=get(A)(X);if(!$e.noDedupe&&a.has(Ve)){const Le=a.get(Ve);if(Le){const Q=Le.created_at||0,oe=X.created_at||0;if(Q>=oe)return}}a.set(Ve,X);const Ze=Date.now(),He=Ze-L;if(He>=16)L=Ze,ve();else if(B===void 0){const Le=16-He;B=setTimeout(()=>{B=void 0,L=Date.now(),ve()},Le)}}function ve(){const X=get(_);let $e=Array.from(a.values()),Ve=!1;n.$wot&&n.$wot.loaded&&(X.wot!==!1&&(X.wot||n.$wot.autoFilterEnabled)&&($e=$e.filter(He=>{if(X.wot&&typeof X.wot=="object"){const{maxDepth:Le,minScore:Q,includeUnknown:oe=!1}=X.wot;return n.$wot.includes(He.pubkey,{maxDepth:Le})?Q!==void 0?n.$wot.getScore(He.pubkey)>=Q:!0:oe}else return!n.$wot.shouldFilterEvent(He)})),X.wotRank&&($e=n.$wot.rankEvents($e,X.wotRank),Ve=!0)),Ve||$e.sort((Ze,He)=>(He.created_at||0)-(Ze.created_at||0)),set(s,$e,!0)}function We(){if(c)return;const X=r(f,{...g,closeOnEose:!1,onEvents:$e=>{for(const Ve of $e){const Ze=get(_),He=get(A)(Ve);if(!Ze.noDedupe&&a.has(He)){const Le=a.get(He);if(Le){const Q=Le.created_at||0,oe=Ve.created_at||0;if(Q>=oe)continue}}a.set(He,Ve)}ve()},onEvent:Z,onEose:()=>{set(o,!0)}});X instanceof Promise?X.then($e=>{c=$e}).catch(()=>{}):c=X}function re(){c?.stop(),c=void 0,B!==void 0&&(clearTimeout(B),B=void 0)}let ze=!1;function se(){ze||(ze=!0,re(),a.clear(),set(s,[],!0),set(o,!1),L=0,We(),queueMicrotask(()=>{ze=!1}))}function ne(){B!==void 0&&(clearTimeout(B),B=void 0),a.clear(),set(s,[],!0),set(o,!1),L=0}return{get events(){return get(s)},get count(){return get(s).length},get eosed(){return get(o)},start:We,stop:re,clear:ne}}function createSubscription(n,t){return validateCallback(t,"$subscribe","config"),createSubscriptionInternal(n,t,(r,s)=>n.subscribe(r,s))}function createMetaSubscription(n,t){validateCallback(t,"$metaSubscribe","config");let r=state(proxy([])),s=state(!1),o=state(proxy(new Map));const a=new Map,c=new Map;let f,g,m,b;const k=user_derived(()=>{const $e=t();return!$e||"filters"in $e?$e:Array.isArray($e)?{filters:$e}:["kinds","authors","ids","since","until","limit","#e","#p","#a","#d","#t","search"].some(He=>He in $e)?{filters:$e}:$e}),_=user_derived(()=>{const $e=get(k);return!$e||!("filters"in $e)?[]:Array.isArray($e.filters)?$e.filters:[$e.filters]}),A=user_derived(()=>{const $e=get(k);if(!$e||!("filters"in $e))return{};const{filters:Ve,sort:Ze,...He}=$e;return He}),B=user_derived(()=>{const $e=get(k);return $e&&"sort"in $e?$e.sort??"time":"time"});user_effect(()=>{const $e=get(_),Ve=get(A);if($e.length===0){ze();return}const Ze=JSON.stringify(g)!==JSON.stringify($e),He=JSON.stringify(m)!==JSON.stringify(Ve);(Ze||He||!f)&&(g=$e,m=Ve,ne())}),user_effect(()=>{const $e=get(B);b!==$e&&f?(b=$e,We()):f||(b=$e)});async function L($e){const Ve=new Set,Ze=new Map;for(const oe of $e){const Y=oe.getMatchingTags("e"),Ce=oe.getMatchingTags("a");for(const je of Y)if(je[1]){Ve.add(je[1]);const Je=Ze.get(je[1])||[];Je.push(oe),Ze.set(je[1],Je)}for(const je of Ce)if(je[1]){Ve.add(je[1]);const Je=Ze.get(je[1])||[];Je.push(oe),Ze.set(je[1],Je)}}if(Ve.size===0)return;const He=[],Le=[],Q=[];for(const oe of Ve)oe.includes(":")?Q.push(oe):Le.push(oe);if(Le.length>0&&He.push({ids:Le}),Q.length>0){const oe=new Map;for(const Y of Q){const[Ce,je,Je]=Y.split(":"),Ge=parseInt(Ce);if(!isNaN(Ge)&&je&&Je){oe.has(je)||oe.set(je,{kinds:new Set,dTags:new Set});const Xe=oe.get(je);Xe.kinds.add(Ge),Xe.dTags.add(Je)}}for(const[Y,{kinds:Ce,dTags:je}]of oe)He.push({kinds:Array.from(Ce),authors:[Y],"#d":Array.from(je)})}try{const oe=await n.guardrailOff().fetchEvents(He);for(const Y of oe){const Ce=Y.tagId(),je=Ze.get(Ce);je&&ve(Y,je)}We()}catch{}}async function Z($e){await L([$e])}function ve($e,Ve){const Ze=$e.tagId();a.set(Ze,$e);const He=c.get(Ze)||[],Le=new Set(He.map(oe=>oe.id)),Q=Ve.filter(oe=>!Le.has(oe.id));Q.length>0&&c.set(Ze,[...He,...Q])}function We(){let $e=Array.from(a.values());switch(b){case"time":$e.sort((Ve,Ze)=>(Ze.created_at||0)-(Ve.created_at||0));break;case"count":$e.sort((Ve,Ze)=>{const He=c.get(Ve.tagId())?.length||0;return(c.get(Ze.tagId())?.length||0)-He});break;case"tag-time":$e.sort((Ve,Ze)=>{const He=c.get(Ve.tagId())||[],Le=c.get(Ze.tagId())||[],Q=Math.max(...He.map(Y=>Y.created_at||0),0);return Math.max(...Le.map(Y=>Y.created_at||0),0)-Q});break;case"unique-authors":$e.sort((Ve,Ze)=>{const He=c.get(Ve.tagId())||[],Le=c.get(Ze.tagId())||[],Q=new Set(He.map(Y=>Y.pubkey)).size;return new Set(Le.map(Y=>Y.pubkey)).size-Q});break}set(r,$e,!0),set(o,new Map(c),!0)}function re(){f||(f=n.subscribe(g,{...m,closeOnEose:!1,onEvents:$e=>{L($e)},onEvent:$e=>{Z($e)},onEose:()=>{set(s,!0)}}))}function ze(){f?.stop(),f=void 0}let se=!1;function ne(){se||(se=!0,ze(),a.clear(),c.clear(),set(r,[],!0),set(o,new Map,!0),set(s,!1),re(),queueMicrotask(()=>{se=!1}))}function X(){a.clear(),c.clear(),set(r,[],!0),set(o,new Map,!0),set(s,!1)}return{get events(){return get(r)},get count(){return get(r).length},get eosed(){return get(s)},get pointedBy(){return get(o)},eventsTagging($e){return get(o).get($e.tagId())||[]},start:re,stop:ze,clear:X}}function validateNip57Zap(n,t){if(n.kind!==NDKKind.Zap)return!1;const r=zapInvoiceFromEvent(n);if(!r)return!1;if(t){if(t instanceof NDKEvent){if(r.zappedEvent!==t.id&&r.zappedEvent!==t.tagId())return!1}else if(r.zapped!==t.pubkey)return!1}return!0}function validateNip61Zap(n,t){if(n.kind!==NDKKind.Nutzap)return!1;const r=NDKNutzap.from(n);if(!r||!r.isValid)return!1;if(t){if(t instanceof NDKEvent){const s=r.tagValue("e"),o=r.tagValue("a");if(s!==t.id&&o!==t.tagId())return!1}else if(r.recipientPubkey!==t.pubkey)return!1}return!0}function validateZap(n,t){return n.kind===NDKKind.Zap?validateNip57Zap(n,t):n.kind===NDKKind.Nutzap?validateNip61Zap(n,t):!1}function getZapAmount(n){if(n.kind===NDKKind.Zap){const t=zapInvoiceFromEvent(n);return t?Math.floor(t.amount/1e3):0}else if(n.kind===NDKKind.Nutzap){const t=NDKNutzap.from(n);return t?t.amount:0}return 0}function getZapSender(n){if(n.ndk){if(n.kind===NDKKind.Zap){const t=zapInvoiceFromEvent(n);return t?n.ndk.getUser({pubkey:t.zappee}):void 0}else if(n.kind===NDKKind.Nutzap){const t=NDKNutzap.from(n);return t?t.sender:void 0}}}function hasZappedBy(n,t){return n.some(r=>getZapSender(r)?.pubkey===t)}function createZapSubscription(n,t){validateCallback(t,"$zaps","config");let r=state(proxy([])),s=state(!1);const o=new Map;let a;const c=user_derived(t),f=user_derived(()=>{const re=get(c);if(!re)return;const{target:ze,method:se,limit:ne}=re;let X;return se==="nip57"?X=[NDKKind.Zap]:se==="nip61"?X=[NDKKind.Nutzap]:X=[NDKKind.Zap,NDKKind.Nutzap],{...ze.filter(),kinds:X,limit:ne}});function g(re){const ze=re.deduplicationKey();if(o.has(ze)){const se=o.get(ze);if(se){const ne=se.created_at||0,X=re.created_at||0;if(ne>=X)return}}o.set(ze,re),b()}function m(re){for(const ze of re){const se=ze.deduplicationKey();if(!o.has(se))o.set(se,ze);else{const ne=o.get(se);if(ne){const X=ne.created_at||0;(ze.created_at||0)>X&&o.set(se,ze)}}}b()}function b(){let re=Array.from(o.values());re.sort((ze,se)=>(se.created_at||0)-(ze.created_at||0)),set(r,re,!0)}function k(){a||!get(f)||(a=n.subscribe(get(f),{closeOnEose:!1,onEvent:g,onEvents:m,onEose:()=>{set(s,!0)}}))}function _(){a?.stop(),a=void 0}function A(){_(),o.clear(),set(r,[],!0),set(s,!1),k()}function B(){o.clear(),set(r,[],!0),set(s,!1)}user_effect(()=>{if(!get(f)){_();return}A()});const L=user_derived(()=>{const re=get(c);if(!re)return[];let ze=get(r);return re.validated&&(ze=ze.filter(se=>validateZap(se,re.target))),ze}),Z=user_derived(()=>get(L).filter(re=>re.kind===NDKKind.Zap)),ve=user_derived(()=>get(L).filter(re=>re.kind===NDKKind.Nutzap).map(re=>NDKNutzap.from(re)).filter(re=>re!==void 0)),We=user_derived(()=>get(L).reduce((re,ze)=>re+getZapAmount(ze),0));return{get events(){return get(L)},get count(){return get(L).length},get totalAmount(){return get(We)},get eosed(){return get(s)},get lightningZaps(){return get(Z)},get nutzaps(){return get(ve)},stop:_,start:k,clear:B}}class ReactiveFollows extends Array{#t;constructor(t,r){super(...t),this.#t=r}async add(t){const r=this.#t?.currentUser;if(!r)throw new Error("No active user");const s=this.#t?.current?.followSet??new Set;return await r.follow(t,s)}async remove(t){const r=this.#t?.currentUser;if(!r)throw new Error("No active user");const s=this.#t?.current?.followSet??new Set;return await r.unfollow(t,s)}has(t){return this.#t?.follows?.has(t)??!1}}class NDKSvelte extends NDK{$sessions;$wot;$wallet;$payments;$pool;#t=state(void 0);constructor(t={}){if(super(t),this.aiGuardrails?.register("ndkSvelte",{constructing}),this.aiGuardrails?.register("ndkSvelteSubscribe",{subscribing}),this.aiGuardrails?.ndkSvelte?.constructing(t),t.session){const r=t.session===!0?{storage:new LocalStorage,autoSave:!0,fetches:{follows:!0,mutes:!0,wallet:!0}}:{storage:new LocalStorage,autoSave:!0,...t.session},s=new NDKSessionManager(this,r);this.$wallet=createReactiveWallet(this,s),this.$sessions=createReactiveSessions(s),this.$wot=createReactiveWoT(this,this.$sessions)}this.$payments=createReactivePayments(),this.$pool=createReactivePool(this),this.on("activeUser:change",r=>{set(this.#t,r,!0)}),set(this.#t,this.activeUser,!0)}$subscribe(t){return this.aiGuardrails?.ndkSvelteSubscribe?.subscribing(t),createSubscription(this,t)}$metaSubscribe(t){return createMetaSubscription(this,t)}$fetchEvents(t){return createFetchEvents(this,t)}get $currentUser(){return get(this.#t)}get $activeUser(){return get(this.#t)}get $currentPubkey(){return get(this.#t)?.pubkey}get $currentSession(){return this.$sessions?.current}get $follows(){const t=Array.from(this.$sessions?.follows??[]);return new ReactiveFollows(t,this.$sessions)}get $mutes(){return this.$sessions?.mutes}$zaps(t){return createZapSubscription(this,t)}$sessionEvent(t,r){if(!this.$sessions)return;const s=t.kinds[0],o=this.$sessions.getSessionEvent(s);if(o)return o;if(r?.create){const a=new t(this);return this.$currentUser&&(a.pubkey=this.$currentUser.pubkey),a}}}function createNDK(n={}){return new NDKSvelte(n)}const NDK_CONTEXT_KEY="ndk";function resolveNDK(n){if(n)return n;try{if(hasContext(NDK_CONTEXT_KEY)){const t=getContext(NDK_CONTEXT_KEY);if(t)return t}}catch{}throw new Error(`NDK not found. Either:
1. Provide as second parameter: createBuilder(() => config, ndk)
2. Set in Svelte context: setContext('${NDK_CONTEXT_KEY}', ndk)`)}const inFlightRequests=new SvelteMap;function createProfileFetcher(n,t){const r=resolveNDK(t),s=proxy({profile:null,user:null,loading:!0});async function o(a){s.loading=!0;try{const c=typeof a=="string"?await r.fetchUser(a):a;if(!c){s.profile=null,s.user=null,s.loading=!1;return}const f=c.pubkey;if(c.profile){s.profile=c.profile,s.user=c,s.loading=!1;return}let g=inFlightRequests.get(f);g||(g=c.fetchProfile({closeOnEose:!0,groupable:!0,groupableDelay:250}).finally(()=>{inFlightRequests.delete(f)}),inFlightRequests.set(f,g));const m=await g;s.profile=m||null,s.user=c}catch(c){console.error("Failed to fetch profile:",c),s.profile=null,s.user=null}s.loading=!1}return user_effect(()=>{const{user:a}=n();a&&o(a)}),{get profile(){return s.profile},get user(){return s.user},get loading(){return s.loading}}}new SvelteMap;function createModalStore(){let n=state(!1),t=state(null);return{get show(){return get(n)},set show(r){set(n,r,!0)},get data(){return get(t)},set data(r){set(t,r,!0)},open(r){set(t,r??null,!0),set(n,!0)},close(){set(n,!1),set(t,null)}}}const baseModal=createModalStore(),relayAuthModal={get show(){return baseModal.show},get request(){return baseModal.data},open(n){baseModal.open(n)},confirm(){baseModal.data&&(baseModal.data.onConfirm(),baseModal.close())},reject(){baseModal.data&&(baseModal.data.onReject(),baseModal.close())},close(){baseModal.close()}},AGORA_RELAYS=["wss://ve.agorawlc.com/","wss://ni.agorawlc.com/","wss://zw.agorawlc.com/"],WALLET_DEFAULT_RELAYS=["wss://relay.primal.net/","wss://relay.nostr.band/"],AGORA_LANGUAGE_MAP={"wss://ve.agorawlc.com/":"es","wss://ni.agorawlc.com/":"es","wss://zw.agorawlc.com/":"en"};function isAgoraRelay(n){return n?n.includes("agorawlc.com"):!1}function getRelaysToUse(n,t){return n?[n]:[]}function getAgoraLanguage(n){return n?AGORA_LANGUAGE_MAP[n]??null:null}function applyThemeColor(n){typeof window>"u"||document.documentElement.setAttribute("data-theme",n)}const DEFAULT_RELAYS$1=[...AGORA_RELAYS.map(n=>({url:n,read:!0,write:!0,enabled:!0})),{url:"wss://relay.damus.io",read:!0,write:!0,enabled:!0},{url:"wss://nos.lol",read:!0,write:!0,enabled:!0},{url:"wss://relay.primal.net",read:!0,write:!0,enabled:!0}],DEFAULT_SETTINGS={relays:DEFAULT_RELAYS$1,selectedRelay:AGORA_RELAYS[0],theme:"system",themeColor:"orange",language:"en",notifications:{enabled:!0,mentions:!0,replies:!0,zaps:!0},privacy:{hideReadReceipts:!1,hideTypingIndicator:!1},zap:{defaultAmount:21},wallet:{npubCashEnabled:!1},relayAuth:{mode:"always"}};function loadSettings(){if(typeof window>"u")return DEFAULT_SETTINGS;try{const n=localStorage.getItem("voces-settings");if(n){const t=JSON.parse(n);return t.relays&&(t.relays=t.relays.map(r=>({...r,url:r.url.replace(/^wss:\/\/ws:\/\//,"ws://").replace(/^wss:\/\/wss:\/\//,"wss://")}))),{...DEFAULT_SETTINGS,...t}}}catch(n){console.error("Failed to load settings:",n)}return DEFAULT_SETTINGS}function saveSettings(n){if(!(typeof window>"u"))try{localStorage.setItem("voces-settings",JSON.stringify(n))}catch(t){console.error("Failed to save settings:",t)}}class SettingsStore{#t=state(proxy(loadSettings()));get state(){return get(this.#t)}set state(t){set(this.#t,t,!0)}get relays(){return this.state.relays}get selectedRelay(){return this.state.selectedRelay}get theme(){return this.state.theme}get themeColor(){return this.state.themeColor}get language(){return this.state.language}get notifications(){return this.state.notifications}get privacy(){return this.state.privacy}get zap(){return this.state.zap}get wallet(){return this.state.wallet}get relayAuth(){return this.state.relayAuth}addRelay(t){this.state.relays=[...this.state.relays,t],saveSettings(this.state)}removeRelay(t){this.state.relays=this.state.relays.filter(r=>r.url!==t),saveSettings(this.state)}updateRelay(t,r){this.state.relays=this.state.relays.map(s=>s.url===t?{...s,...r}:s),saveSettings(this.state)}toggleRelay(t){this.state.relays=this.state.relays.map(r=>r.url===t?{...r,enabled:!r.enabled}:r),saveSettings(this.state)}setRelays(t){this.state.relays=t,saveSettings(this.state)}setSelectedRelay(t){this.state.selectedRelay=t,saveSettings(this.state)}setTheme(t){this.state.theme=t,saveSettings(this.state),typeof window<"u"&&(t==="dark"||t==="system"&&window.matchMedia("(prefers-color-scheme: dark)").matches?(document.documentElement.classList.remove("light"),document.documentElement.classList.add("dark")):(document.documentElement.classList.remove("dark"),document.documentElement.classList.add("light")))}setThemeColor(t){this.state.themeColor=t,saveSettings(this.state),applyThemeColor(t)}setLanguage(t){this.state.language=t,saveSettings(this.state)}updateNotifications(t){this.state.notifications={...this.state.notifications,...t},saveSettings(this.state)}updatePrivacy(t){this.state.privacy={...this.state.privacy,...t},saveSettings(this.state)}updateZap(t){this.state.zap={...this.state.zap,...t},saveSettings(this.state)}updateWallet(t){this.state.wallet={...this.state.wallet,...t},saveSettings(this.state)}updateRelayAuth(t){this.state.relayAuth={...this.state.relayAuth,...t},saveSettings(this.state)}save(){saveSettings(this.state)}resetToDefaults(){this.state={...DEFAULT_SETTINGS},saveSettings(this.state)}}const settings=new SettingsStore,debug=debug$1("agora:relay:auth"),AUTH_DECISIONS_KEY="agora:relay-auth-decisions",authDecisionsCache=new Map;function loadAuthDecisions(){try{const n=localStorage.getItem(AUTH_DECISIONS_KEY);if(n){const t=JSON.parse(n),r=new Map;return t.forEach(s=>r.set(s.relay,s.accepted)),r}}catch(n){debug("Failed to load auth decisions:",n)}return new Map}function saveAuthDecisions(n){try{const t=Array.from(n.entries()).map(([r,s])=>({relay:r,accepted:s,timestamp:Date.now()}));localStorage.setItem(AUTH_DECISIONS_KEY,JSON.stringify(t))}catch(t){debug("Failed to save auth decisions:",t)}}typeof window<"u"&&loadAuthDecisions().forEach((t,r)=>authDecisionsCache.set(r,t));async function promptUserForAuth(n){return new Promise(t=>{relayAuthModal.open({relayUrl:n.url,onConfirm:()=>{authDecisionsCache.set(n.url,!0),saveAuthDecisions(authDecisionsCache),t(!0)},onReject:()=>{authDecisionsCache.set(n.url,!1),saveAuthDecisions(authDecisionsCache),t(!1)}})})}function getStoredDecision(n){return authDecisionsCache.get(n)}async function createAndSignAuthEvent(n,t,r){const s=new NDKEvent(n);s.kind=NDKKind.ClientAuth,s.tags=[["relay",t.url],["challenge",r]];const o=n?.signer;if(o)try{return await s.sign(o),debug(`Successfully signed auth event for ${t.url}`),s}catch(a){return debug("Failed to sign auth event:",a),!1}else return debug(`No signer available for ${t.url}, waiting for signer...`),new Promise(a=>{const c=setTimeout(()=>{debug(`Signer timeout for ${t.url}, authentication failed`),a(!1)},5e3),f=async g=>{clearTimeout(c);try{await s.sign(g),debug(`Successfully signed auth event for ${t.url} after waiting`),a(s)}catch(m){debug("Failed to sign auth event after waiting:",m),a(!1)}};n?.once("signer:ready",f)})}function createAuthPolicyWithConfirmation({ndk:n}={}){return debug("Creating auth policy with user confirmation"),async(t,r)=>{if(debug(`Relay ${t.url} requested authentication`),settings.relayAuth.mode==="always")return debug(`Auto-authenticating to ${t.url} (mode: always)`),createAndSignAuthEvent(n,t,r);if(isAgoraRelay(t.url))return debug(`Auto-authenticating to Agora relay: ${t.url}`),createAndSignAuthEvent(n,t,r);const o=getStoredDecision(t.url);return o!==void 0?(debug(`Using stored decision for ${t.url}: ${o?"accepted":"rejected"}`),o?createAndSignAuthEvent(n,t,r):!1):(debug(`Prompting user for auth decision for ${t.url}`),await promptUserForAuth(t)?(debug(`User accepted authentication for ${t.url}`),createAndSignAuthEvent(n,t,r)):(debug(`User rejected authentication for ${t.url}`),!1))}}function createHashtagInterestsStore(n){const t=user_derived(()=>n.$sessions?.getSessionEvent(10015)),r=user_derived(()=>get(t)?get(t).tags.filter(c=>c[0]==="t"&&c[1]).map(c=>c[1].toLowerCase()):[]);async function s(c){if(!n.$currentUser)throw new Error("No user logged in");const f=c.toLowerCase();if(get(r).includes(f))return;const g=get(t),m=new NDKEvent(n);m.kind=NDKKind.InterestList,g?m.tags=[...g.tags.filter(b=>b[0]==="t"),["t",f]]:m.tags=[["t",f]],m.content=g?.content||"",await m.publish()}async function o(c){if(!n.$currentUser)throw new Error("No user logged in");const f=c.toLowerCase();if(!get(r).includes(f))return;const g=get(t);if(!g)return;const m=new NDKEvent(n);m.kind=NDKKind.InterestList,m.tags=g.tags.filter(b=>!(b[0]==="t"&&b[1]?.toLowerCase()===f)),m.content=g.content||"",await m.publish()}async function a(c){const f=c.toLowerCase();get(r).includes(f)?await o(f):await s(f)}return{get interests(){return get(r)},addHashtag:s,removeHashtag:o,toggleHashtag:a}}class RelayFeedsStore{constructor(t){this.ndk=t}get list(){const t=this.ndk.$sessions;return t&&t.relayFeedList||null}get relays(){if(!this.list)return[];const t=[];for(const r of this.list.tags)r[0]==="relay"&&r[1]&&t.push(r[1]);return t}get relaySets(){if(!this.list)return[];const t=[];for(const r of this.list.tags)r[0]==="a"&&r[1]&&t.push(r[1]);return t}isFavorite(t){return this.relays.includes(t)}async addRelay(t){let r=this.list;if(r||(r=new NDKRelayFeedList(this.ndk)),this.isFavorite(t))return;r.tags.push(["relay",t]),await r.publish();const s=this.ndk.$sessions;s&&(s.relayFeedList=r)}async removeRelay(t){const r=this.list;r&&(r.tags=r.tags.filter(s=>!(s[0]==="relay"&&s[1]===t)),await r.publish())}async addRelaySet(t){let r=this.list;if(r||(r=new NDKRelayFeedList(this.ndk)),this.relaySets.includes(t))return;r.tags.push(["a",t]),await r.publish();const o=this.ndk.$sessions;o&&(o.relayFeedList=r)}async removeRelaySet(t){const r=this.list;r&&(r.tags=r.tags.filter(s=>!(s[0]==="a"&&s[1]===t)),await r.publish())}}function createRelayFeedsStore(n){return new RelayFeedsStore(n)}const CACHE_WORKER_VERSION="1.0.0-beta.42",DEFAULT_RELAYS=["wss://relay.primal.net","wss://relay.nostr.band"],cacheAdapter=new src_default({dbName:"agora",workerUrl:`/worker-${CACHE_WORKER_VERSION}.js`,wasmUrl:"/sql-wasm.wasm"}),cacheInitialized=cacheAdapter.initializeAsync();let sigVerifyWorker;const ndk=createNDK({explicitRelayUrls:DEFAULT_RELAYS,autoConnectUserRelays:!0,cacheAdapter,signatureVerificationWorker:sigVerifyWorker,initialValidationRatio:1,lowestValidationRatio:.1,aiGuardrails:!1,futureTimestampGrace:30,clientName:"Agora",session:{storage:new LocalStorage,autoSave:!0,fetches:{follows:!0,mutes:!0,wallet:!0,relayList:!0,monitor:[NDKBlossomList,NDKInterestList,NDKRelayFeedList]}}});ndk.relayAuthDefaultPolicy=createAuthPolicyWithConfirmation({ndk});const ndkReady=(async()=>{try{console.log(" Initializing cache..."),await cacheInitialized,console.log(" Cache initialized.");const n=(await __vitePreload(async()=>{const{default:t}=await import("./zNmMpKrZ.js");return{default:t}},[],import.meta.url)).default;sigVerifyWorker=new n,ndk.signatureVerificationWorker=sigVerifyWorker,ndk.connect()}catch(n){console.error(" Failed to initialize cache:",n)}})(),hashtagInterests=createHashtagInterestsStore(ndk),relayFeeds=createRelayFeedsStore(ndk);export{AGORA_RELAYS as A,giftUnwrap as B,nip19_exports as C,createProfileFetcher as D,NDKList as E,debug$1 as F,wrapEvent as G,NDKBlossomList as H,NDKNip07Signer as I,NDKPrivateKeySigner as J,relayAuthModal as K,applyThemeColor as L,ndkReady as M,NDKKind as N,bolt11Exports as O,getRelaysToUse as P,hashtagInterests as Q,filterFromId as R,NDKZapper as S,hasZappedBy as T,createMintDiscoveryStore as U,index$1 as V,WALLET_DEFAULT_RELAYS as W,NDKFollowPack as a,nip19_exports$1 as b,createModalStore as c,NDKArticle as d,NDKSubscriptionCacheUsage as e,NDKEvent as f,getAgoraLanguage as g,NDKRelaySet as h,isValidPubkey as i,NDKCashuMintList as j,isAgoraRelay as k,NDKClassified as l,normalizeRelayUrl as m,ndk as n,NDKRelayFeedList as o,mapImetaTag as p,NDKInterestList as q,relayFeeds as r,settings as s,resolveNDK as t,getDefaultExportFromCjs as u,sha256$2 as v,bytesToHex$2 as w,schnorr$1 as x,NDKUser as y,giftWrap as z};
