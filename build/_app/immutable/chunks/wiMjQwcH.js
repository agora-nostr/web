import{b as A,g as p,s as w}from"./Bq750rDx.js";import{_ as z}from"./PPVm8Dsz.js";import{E as K,f as j,p as J,N as F,F as I,G}from"./CdRP5_sk.js";class q{blossom;#e=A("idle");#t=A(null);#r=A(null);#s=A(null);constructor(t){this.blossom=t}get status(){return p(this.#e)}get progress(){return p(this.#t)}get result(){return p(this.#r)}get error(){return p(this.#s)}get state(){return{status:p(this.#e),progress:p(this.#t),result:p(this.#r),error:p(this.#s)}}async upload(t,e){w(this.#e,"uploading"),w(this.#t,{loaded:0,total:t.size,percentage:0},!0),w(this.#r,null),w(this.#s,null);try{const r={...e,onProgress:i=>{const a=Math.round(i.loaded/i.total*100);return w(this.#t,{loaded:i.loaded,total:i.total,percentage:a},!0),"continue"}},s=await this.blossom.upload(t,r);return w(this.#e,"success"),w(this.#r,s,!0),s}catch(r){throw w(this.#e,"error"),w(this.#s,r instanceof Error?r:new Error(String(r)),!0),r}}reset(){w(this.#e,"idle"),w(this.#t,null),w(this.#r,null),w(this.#s,null)}}function we(o){return new q(o)}const d={SERVER_UNAVAILABLE:"SERVER_UNAVAILABLE",SERVER_ERROR:"SERVER_ERROR",SERVER_REJECTED:"SERVER_REJECTED",SERVER_TIMEOUT:"SERVER_TIMEOUT",SERVER_LIST_EMPTY:"SERVER_LIST_EMPTY",SERVER_INVALID_RESPONSE:"SERVER_INVALID_RESPONSE",NO_SIGNER:"NO_SIGNER",AUTH_REQUIRED:"AUTH_REQUIRED",AUTH_INVALID:"AUTH_INVALID",AUTH_EXPIRED:"AUTH_EXPIRED",AUTH_REJECTED:"AUTH_REJECTED",UPLOAD_TOO_LARGE:"UPLOAD_TOO_LARGE",UPLOAD_INVALID_TYPE:"UPLOAD_INVALID_TYPE",UPLOAD_FAILED:"UPLOAD_FAILED",ALL_SERVERS_FAILED:"ALL_SERVERS_FAILED",BLOB_NOT_FOUND:"BLOB_NOT_FOUND",USER_SERVER_LIST_NOT_FOUND:"USER_SERVER_LIST_NOT_FOUND",SERVER_UNSUPPORTED:"SERVER_UNSUPPORTED",FORMAT_UNSUPPORTED:"FORMAT_UNSUPPORTED",NO_SHA256_CALCULATOR:"NO_SHA256_CALCULATOR"},W=24242,P={maxRetries:3,retryDelay:1e3,backoffFactor:1.5,retryableStatusCodes:[408,429,500,502,503,504]},Y={Accept:"application/json"},Q="ndk:blossom",X=[500,501,502,503,504,505];class v extends Error{constructor(t,e,r,s){super(t),this.name="NDKBlossomError",this.code=e,this.serverUrl=r,this.cause=s}}class S extends v{constructor(t,e,r,s){super(t,e,r,s),this.name="NDKBlossomUploadError"}}class b extends v{constructor(t,e,r,s,i){super(t,e,r,i),this.name="NDKBlossomServerError",this.status=s}}class m extends v{constructor(t,e,r,s){super(t,e,r,s),this.name="NDKBlossomAuthError"}}class y extends v{constructor(t,e,r,s){super(t,e,r,s),this.name="NDKBlossomNotFoundError"}}class _ extends v{constructor(t,e,r,s){super(t,e,r,s),this.name="NDKBlossomOptimizationError"}}class L{constructor(t=Q){this.debugger=K(t)}error(t,e){this.log("error",t,e)}warn(t,e){this.log("warn",t,e)}info(t,e){this.log("info",t,e)}debug(t,e){this.log("debug",t,e)}log(t,e,r){const s=`[${t.toUpperCase()}] ${e}`;r!==void 0?this.debugger(s,r):this.debugger(s)}}class Z{constructor(t){this.logFunction=t}error(t,e){this.logFunction("error",t,e)}warn(t,e){this.logFunction("warn",t,e)}info(t,e){this.logFunction("info",t,e)}debug(t,e){this.logFunction("debug",t,e)}}const ee=new L("ndk:blossom:auth");async function B(o,t,e={}){if(!o.signer)throw new m("No signer available to create authentication event",d.NO_SIGNER);try{const r=new j(o);r.kind=W,r.created_at=Math.floor(Date.now()/1e3),r.content=e.content||`${t.charAt(0).toUpperCase()+t.slice(1)} blob`;const s=[["t",t]];e.sha256&&(Array.isArray(e.sha256)?e.sha256:[e.sha256]).forEach(n=>{s.push(["x",n])});const i=e.expirationSeconds||3600,a=Math.floor(Date.now()/1e3)+i;return s.push(["expiration",a.toString()]),r.tags=s,await r.sign(),ee.debug(`Created Blossom auth event for action: ${t}`),r}catch(r){throw r instanceof m?r:new m(`Failed to create auth event: ${r.message}`,d.AUTH_REQUIRED,void 0,r)}}function x(o,t){const e=JSON.stringify(t.rawEvent()),r=btoa(e);return{...o,Authorization:`Nostr ${r}`}}async function V(o,t,e={}){const r=await B(o,t,e),s=x(e.fetchOptions?.headers||{},r);return{...e.fetchOptions||{},headers:s}}const te=Object.freeze(Object.defineProperty({__proto__:null,addAuthHeaders:x,createAuthEvent:B,createAuthenticatedFetchOptions:V},Symbol.toStringTag,{value:"Module"})),re=new L;async function U(o,t={},e={},r=re){const s={...P,...e},i={...Y,...t.headers||{}};let a=0;const l=()=>s.retryDelay*s.backoffFactor**a;for(;a<=s.maxRetries;)try{const n=await fetch(o,{...t,headers:i});if(!n.ok&&s.retryableStatusCodes.includes(n.status)&&a<s.maxRetries){a++;const c=l();r.warn(`Request failed with status ${n.status}, retrying in ${c}ms (attempt ${a}/${s.maxRetries})`,{url:o}),await new Promise(u=>setTimeout(u,c));continue}return n}catch(n){if(a<s.maxRetries){a++;const c=l();r.warn(`Network error, retrying in ${c}ms (attempt ${a}/${s.maxRetries})`,{url:o,error:n}),await new Promise(u=>setTimeout(u,c))}else throw new b(`Network request failed after ${s.maxRetries} retries: ${n.message}`,d.SERVER_UNAVAILABLE,o,void 0,n)}throw new b(`Request failed after ${s.maxRetries} retries`,d.SERVER_UNAVAILABLE,o)}async function se(o,t={},e={}){try{return(await U(o,{...t,method:"HEAD"},e)).ok}catch{return!1}}async function $(o,t,e={}){const s=`${o.endsWith("/")?o.slice(0,-1):o}/${t}`;return se(s,{method:"HEAD"},e)}async function oe(o,t){if(!o.ok)throw X.includes(o.status)?new b(`Server error: ${o.status} ${o.statusText}`,d.SERVER_ERROR,t,o.status):new b(`Request rejected: ${o.status} ${o.statusText}`,d.SERVER_REJECTED,t,o.status);try{return await o.json()}catch(e){throw new b(`Invalid JSON response: ${e.message}`,d.SERVER_INVALID_RESPONSE,t,o.status,e)}}const f=new L("ndk:blossom:uploader");async function N(o,t,e,r={}){if(f.debug(`Uploading file to ${e}`,{fileName:t.name,fileType:t.type,fileSize:t.size}),!r.sha256Calculator)throw new S("SHA256Calculator is required for upload. Please provide one in options.","NO_SHA256_CALCULATOR",e);const i=await r.sha256Calculator.calculateSha256(t);f.debug(`File hash: ${i}`);try{const a=e.endsWith("/")?e.slice(0,-1):e,l=`${a}/upload`,n=await V(o,"upload",{sha256:i,content:`Upload ${t.name}`,fetchOptions:{method:"PUT",body:t,headers:{"Content-Type":t.type||"application/octet-stream",...r.headers}}});if(r.onProgress){const g=n.body;if(g instanceof File||g instanceof Blob){const E=new XMLHttpRequest;return await new Promise((H,O)=>{E.upload.addEventListener("progress",R=>{R.lengthComputable&&r.onProgress?.({loaded:R.loaded,total:R.total})}),E.addEventListener("load",()=>{if(E.status>=200&&E.status<300)try{const R=JSON.parse(E.responseText);H(R)}catch(R){O(new b(`Invalid response from server: ${R.message}`,d.SERVER_INVALID_RESPONSE,e,E.status,R))}else O(new b(`Upload failed with status ${E.status}`,d.SERVER_REJECTED,e,E.status))}),E.addEventListener("error",()=>{O(new b("Network error during upload",d.SERVER_UNAVAILABLE,e))}),E.addEventListener("abort",()=>{O(new b("Upload aborted",d.UPLOAD_FAILED,e))}),E.open("PUT",l);for(const[R,M]of Object.entries(n.headers||{}))E.setRequestHeader(R,M);E.send(g)})}}const c=await U(l,n,{maxRetries:r.maxRetries,retryDelay:r.retryDelay});return await oe(c,e),{url:`${a}/${i}`,size:t.size.toString(),m:t.type,x:i}}catch(a){throw a instanceof b||a instanceof m?a:new S(`Upload failed: ${a.message}`,d.UPLOAD_FAILED,e,a)}}async function ae(o,t,e={}){if(f.debug("Starting file upload",{fileName:t.name,fileType:t.type,fileSize:t.size}),f.debug("Upload options:",{hasServer:!!e.server,hasFallbackServer:!!e.fallbackServer,fallbackServer:e.fallbackServer,allOptions:e}),e.server)try{const n=await N(o.ndk,t,e.server,e);return f.debug(`Upload successful to specified server ${e.server}`),n}catch(n){throw f.error(`Upload to specified server ${e.server} failed:`,n),new S(`Upload failed on specified server: ${e.server}: ${n.message}`,d.UPLOAD_FAILED)}const r=await o.getServerList();let s=[];r&&Array.isArray(r.servers)&&(s=r.servers);const i=[];for(const n of s)try{const c=await N(o.ndk,t,n,e);return f.debug(`Upload successful to ${n}`),c}catch(c){if(f.error(`Upload to ${n} failed:`,c),i.push({serverUrl:n,error:c}),e.onServerError&&c instanceof b&&e.onServerError(c,n)==="retry")try{const g=await N(o.ndk,t,n,e);return f.debug(`Retry upload successful to ${n}`),g}catch(g){f.error(`Retry upload to ${n} failed:`,g),i.push({serverUrl:n,error:g})}}if(e.fallbackServer)try{const n=await N(o.ndk,t,e.fallbackServer,e);return f.debug(`Upload successful to fallback server ${e.fallbackServer}`),n}catch(n){f.error(`Upload to fallback server ${e.fallbackServer} failed:`,n),i.push({serverUrl:e.fallbackServer,error:n})}const a=i.map(n=>{const c=n.error;let u=`${n.serverUrl}: ${c.message}`;return c instanceof b?(u+=` (status: ${c.status}, code: ${c.code})`,c.cause&&(u+=` - ${c.cause.message}`)):c instanceof m?u+=` (auth error, code: ${c.code})`:c instanceof S&&(u+=` (code: ${c.code})`,c.cause&&(u+=` - cause: ${c.cause.message}`)),u}),l=s.length===0?`No blossom servers configured. Please add servers to your profile or provide a fallbackServer. ${e.fallbackServer?`Fallback server also failed: ${a[0]||"unknown error"}`:""}`:`Upload failed on all ${s.length} configured server(s)${e.fallbackServer?" and fallback server":""}:
${a.join(`
`)}`;throw f.error(l),new S(l,d.ALL_SERVERS_FAILED)}async function D(o,t){f.debug(`Searching for hash ${t} in nostr events`);const e={"#x":[t],limit:10};try{const r=await o.fetchEvents(e);if(r.size===0)return[];const s=new Set;for(const i of r)for(const a of i.tags){if(a[0]==="imeta"){const l=J(a);l.url&&l.x===t&&s.add(l.url)}a[0]==="url"&&a[1]&&C(a[1])===t&&s.add(a[1])}return Array.from(s)}catch(r){return f.error("Error searching for hash in nostr:",r),[]}}const h=new L("ndk:blossom:url-healing");function C(o){try{const r=new URL(o).pathname.split("/"),s=r[r.length-1],i=s.includes(".")?s.split(".")[0]:s;return/^[a-f0-9]{64}$/i.test(i)?i:void 0}catch(t){h.error(`Error extracting hash from URL ${o}:`,t);return}}async function T(o,t){if(o.length===0)return;const e=t?o.filter(r=>r!==t):o;if(e.length!==0){for(const r of e)try{if(await $(r,""))return h.debug(`Found working URL: ${r}`),r}catch(s){h.debug(`URL check failed for ${r}:`,s)}return h.debug(`No working URLs found, returning first URL: ${e[0]}`),e[0]}}async function ne(o,t,e){h.debug(`Fixing URL: ${e}`);const r=C(e);if(!r)return h.debug(`Invalid URL, no hash found: ${e}`),e;try{if(await $(e,""))return h.debug(`Original URL works, no need to fix: ${e}`),e}catch(s){h.debug(`Original URL check failed: ${s}`)}try{const s={kinds:[F.BlossomList],authors:[t.pubkey]},i=await o.fetchEvent(s);let a=[];if(i&&(a=I(i).servers),a.length===0){h.debug(`No servers found for user ${t.pubkey}`);const c=await D(o,r),u=await T(c,e);return u||e}for(const c of a)try{const g=`${c.endsWith("/")?c.slice(0,-1):c}/${r}`;if(await $(c,r))return h.debug(`Found alternative server: ${g}`),g}catch(u){h.debug(`Server check failed for ${c}:`,u)}const l=await D(o,r),n=await T(l,e);return n||(h.debug(`Could not fix URL: ${e}`),e)}catch(s){return h.debug(`Error fixing URL: ${s}`),e}}async function ie(o,t,e){h.debug(`Getting blob URL for hash: ${e}`);try{const r={kinds:[F.BlossomList],authors:[t.pubkey]},s=await o.fetchEvent(r);let i=[];if(s&&(i=s.tags.filter(a=>a[0]==="server"&&a[1]).map(a=>a[1])),i.length===0){h.debug(`No servers found for user ${t.pubkey}`);const a=await D(o,e),l=await T(a);if(l)return l;throw new y(`No servers found for user ${t.pubkey}`,d.USER_SERVER_LIST_NOT_FOUND)}for(const a of i)try{const n=`${a.endsWith("/")?a.slice(0,-1):a}/${e}`;if(await $(a,e))return h.debug(`Found blob on server: ${n}`),n}catch(l){h.debug(`Server check failed for ${a}:`,l)}throw new y(`Blob with hash ${e} not found on any of user's servers`,d.BLOB_NOT_FOUND)}catch(r){if(r instanceof y)throw r;const s=await D(o,e),i=await T(s);if(i)return i;throw new y(`Failed to get blob URL: ${r.message}`,d.BLOB_NOT_FOUND,void 0,r)}}class ce{async calculateSha256(t){const e=await t.arrayBuffer(),r=await crypto.subtle.digest("SHA-256",e);return Array.from(new Uint8Array(r)).map(s=>s.toString(16).padStart(2,"0")).join("")}}let k;function le(){return k||(k=new ce),k}const ue={calculateSha256:async o=>le().calculateSha256(o)};class be{constructor(t){this.serverConfigs=new Map,this.debugMode=!1,this.ndk=t,this.retryOptions=P,this.logger=new L,this.sha256Calculator=ue}set debug(t){this.debugMode=t}get debug(){return this.debugMode}set loggerFunction(t){this.logger=new Z(t)}setSHA256Calculator(t){this.sha256Calculator=t}getSHA256Calculator(){return this.sha256Calculator}set serverList(t){this._serverList=t}async getServerList(t){if(this._serverList)return this.logger.debug(`Using cached server list with ${this._serverList.servers.length} servers`),this._serverList;if(t??(t=this.ndk.activeUser),!t)throw this.logger.error("No user available to fetch server list"),new v("No user available to fetch server list","NO_SIGNER");this.logger.debug(`Fetching server list for user ${t.pubkey}`);const e={kinds:G.kinds,authors:[t.pubkey]},r=await this.ndk.fetchEvent(e);if(!r){this.logger.warn(`No blossom server list event found for user ${t.pubkey}`);return}return this._serverList=I(r),this.logger.debug(`Found server list with ${this._serverList.servers.length} servers: ${this._serverList.servers.join(", ")}`),this._serverList}async upload(t,e={}){try{return this.onUploadProgress&&(e.onProgress=s=>this.onUploadProgress?this.onUploadProgress(s,t,"unknown"):"continue"),e.sha256Calculator||(e.sha256Calculator=this.getSHA256Calculator()),await ae(this,t,e)}catch(r){throw this.onUploadFailed&&r instanceof Error&&this.onUploadFailed(r.message,r instanceof S?r.serverUrl:void 0,t),r}}async fixUrl(t,e){return ne(this.ndk,t,e)}async getBlob(t){try{return await U(t,{},this.retryOptions)}catch(e){throw new y(`Failed to fetch blob: ${e.message}`,"BLOB_NOT_FOUND",t,e)}}async getBlobByHash(t,e){const r=await ie(this.ndk,t,e);return this.getBlob(r)}async listBlobs(t){const e=await this.getServerList();let r=[];if(e&&(r=e.servers),r.length===0)return this.logger.error(`No servers found for user ${t.pubkey}`),[];const s=new Map;for(const i of r)try{const l=`${i.endsWith("/")?i.slice(0,-1):i}/list/${t.pubkey}`,n=await U(l,{},this.retryOptions);if(!n.ok)continue;const c=await n.json();if(Array.isArray(c))for(const u of c){const g={url:u.url,size:u.size?.toString(),m:u.mime_type,x:u.sha256,dim:u.width&&u.height?`${u.width}x${u.height}`:void 0,blurhash:u.blurhash,alt:u.alt};u.sha256&&s.set(u.sha256,g)}}catch(a){this.logger.error(`Error listing blobs on server ${i}:`,a)}return Array.from(s.values())}async deleteBlob(t){if(!this.ndk.signer)throw new m("No signer available to delete blob","NO_SIGNER");const e=(await this.ndk.signer.user()).pubkey,r={kinds:[F.BlossomList],authors:[e]},s=await this.ndk.fetchEvent(r);let i=[];if(s&&(i=s.tags.filter(l=>l[0]==="server"&&l[1]).map(l=>l[1])),i.length===0)return this.logger.error(`No servers found for user ${e}`),!1;let a=!1;for(const l of i)try{const c=`${l.endsWith("/")?l.slice(0,-1):l}/${t}`,u=await he(this.ndk,"delete",{sha256:t,content:`Delete blob ${t}`,fetchOptions:{method:"DELETE"}});(await U(c,u,this.retryOptions)).ok&&(a=!0)}catch(n){this.logger.error(`Error deleting blob on server ${l}:`,n)}return a}async checkServerForBlob(t,e){return $(t,e)}setRetryOptions(t){this.retryOptions={...this.retryOptions,...t}}setServerConfig(t,e){this.serverConfigs.set(t,e)}async getOptimizedBlob(t,e={}){try{const r=new URL(t),s=`${r.protocol}//${r.host}`,i=r.pathname.split("/").pop();if(!i)throw new _("Invalid URL, no hash found","BLOB_NOT_FOUND",t);let a=`${s}/media/${i}`;const l=new URLSearchParams;for(const[c,u]of Object.entries(e))u!==void 0&&l.append(c,u.toString());l.toString()&&(a+=`?${l.toString()}`);const n=await U(a,{},this.retryOptions);if(!n.ok)throw new _(`Failed to get optimized blob: ${n.status} ${n.statusText}`,"SERVER_REJECTED",t);return n}catch(r){throw r instanceof _?r:new _(`Failed to get optimized blob: ${r.message}`,"SERVER_UNSUPPORTED",t,r)}}async getOptimizedUrl(t,e={}){const r=new URL(t),s=`${r.protocol}//${r.host}`,i=r.pathname.split("/").pop();if(!i)throw new _("Invalid URL, no hash found","BLOB_NOT_FOUND",t);let a=`${s}/media/${i}`;const l=new URLSearchParams;for(const[n,c]of Object.entries(e))c!==void 0&&l.append(n,c.toString());return l.toString()&&(a+=`?${l.toString()}`),a}generateSrcset(t,e){const r=[],s=new URL(t),i=`${s.protocol}//${s.host}`,a=s.pathname.split("/").pop();if(!a)return"";for(const l of e){const n=new URLSearchParams;n.append("width",l.width.toString()),l.format&&n.append("format",l.format);const c=`${i}/media/${a}?${n.toString()}`;r.push(`${c} ${l.width}w`)}return r.join(", ")}}async function he(o,t,e={}){const{createAuthenticatedFetchOptions:r}=await z(async()=>{const{createAuthenticatedFetchOptions:s}=await Promise.resolve().then(()=>te);return{createAuthenticatedFetchOptions:s}},void 0,import.meta.url);return r(o,t,e)}export{be as N,we as c};
